<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marigo1d.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Spring相关学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-learning-record">
<meta property="og:url" content="https://marigo1d.github.io/2024/10/01/Spring-learning-record/index.html">
<meta property="og:site_name" content="Marigold">
<meta property="og:description" content="Spring相关学习记录">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-10-01T10:30:43.000Z">
<meta property="article:modified_time" content="2025-02-20T10:01:00.006Z">
<meta property="article:author" content="marigo1d">
<meta property="article:tag" content="java, Spring">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://marigo1d.github.io/2024/10/01/Spring-learning-record/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Spring-learning-record | Marigold</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Marigold</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Salt, Pepper and Birds~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://marigo1d.github.io/2024/10/01/Spring-learning-record/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="marigo1d">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marigold">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring-learning-record
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-01 18:30:43" itemprop="dateCreated datePublished" datetime="2024-10-01T18:30:43+08:00">2024-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-20 18:01:00" itemprop="dateModified" datetime="2025-02-20T18:01:00+08:00">2025-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>59k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:47</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Spring相关学习记录</p>
<span id="more"></span>





<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p>案例</p>
<p><strong>处理 GET 请求的流程举例 (以一个简单的 Java Web 应用为例):</strong></p>
<p>假设用户在浏览器中访问 <a target="_blank" rel="noopener" href="http://www.example.com/products/123%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96%E4%BA%A7%E5%93%81">http://www.example.com/products/123，这是一个获取产品</a> ID 为 123 的产品的 GET 请求。</p>
<ol>
<li><p><strong>客户端 (浏览器) 发起请求:</strong> 浏览器将 GET 请求发送到 <a target="_blank" rel="noopener" href="http://www.example.com./">www.example.com。</a></p>
</li>
<li><p><strong>反向代理服务器 (如果存在):</strong> 反向代理服务器接收请求。它可能执行一些操作，例如检查缓存，如果缓存命中则直接返回结果。如果没有缓存，则将请求转发到 Web 服务器。</p>
</li>
<li><p><strong>Web 服务器 (例如 Apache&#x2F;Nginx):</strong> Web 服务器接收请求，根据配置将请求转发到相应的应用服务器。</p>
<p>对于静态内容（如 HTML 文件、图片、CSS 和 JavaScript 文件），Web 服务器可以直接从文件系统中读取并返回给客户端，无需涉及应用服务器，从而显著提升性能。Web 服务器通过配置文件中的规则（例如，Nginx 中的 location 指令）来识别静态文件请求，通常根据 URL 路径或文件扩展名进行匹配。例如，请求 &#x2F;images&#x2F;logo.png 或 &#x2F;styles.css，Web 服务器会直接返回对应的文件。 此外，Web服务器还可以设置缓存过期时间，例如通过expires指令，进一步优化对静态资源的访问速度。</p>
<p>对于动态内容，Web 服务器则充当反向代理的角色，将请求转发到后端的应用服务器。例如，URL 路径 &#x2F;products 可能对应一个需要数据库交互的产品列表页面，Web 服务器会将该请求转发到专门处理产品相关请求的应用服务器。转发规则同样在配置文件中定义，可以基于 URL 路径、请求方法等进行匹配。例如，所有 &#x2F;api&#x2F; 开头的请求都可能被转发到特定的应用服务器。</p>
</li>
<li><p><strong>应用服务器 (例如 Tomcat):</strong> 应用服务器接收请求。</p>
<ul>
<li><strong>路由:</strong> 应用服务器根据 URL 路径 &#x2F;products&#x2F;123 确定哪个控制器 (Controller) 和方法 (Method) 应该处理这个请求。例如，它可能将请求路由到 ProductController 的 getProduct 方法。</li>
<li><strong>控制器:</strong> ProductController 的 getProduct 方法被调用。该方法从 URL 中提取产品 ID (123)。</li>
<li><strong>服务层 (可选):</strong> 控制器调用服务层 (Service Layer) 的方法来获取产品数据。服务层封装了业务逻辑，例如从数据库中检索产品信息。</li>
<li><strong>数据访问层 (DAO):</strong> 服务层调用数据访问层 (Data Access Object) 的方法来与数据库交互。DAO 负责执行数据库查询。</li>
<li><strong>数据库:</strong> 数据库服务器接收查询请求，返回产品 ID 为 123 的产品数据。</li>
<li><strong>返回数据:</strong> DAO 将数据返回给服务层，服务层将数据返回给控制器。</li>
<li><strong>视图渲染 (可选):</strong> 控制器将数据传递给视图渲染引擎 (例如 JSP, Thymeleaf)，生成 HTML 响应。如果返回的是 JSON 数据，则跳过此步骤。</li>
</ul>
</li>
<li><p><strong>应用服务器返回响应:</strong> 应用服务器将生成的 HTML 响应或 JSON 数据返回给 Web 服务器。</p>
</li>
<li><p><strong>Web 服务器返回响应:</strong> Web 服务器将响应返回给反向代理服务器 (如果存在)。</p>
</li>
<li><p><strong>反向代理服务器返回响应:</strong> 反向代理服务器将响应返回给客户端 (浏览器)。</p>
</li>
<li><p><strong>浏览器渲染:</strong> 浏览器接收 HTML 响应并渲染页面，或者处理 JSON 数据。</p>
</li>
</ol>
<h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebServlet注解表示这是一个Servlet，并映射到地址/:</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置响应类型:</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取输出流:</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        <span class="comment">// 写入响应:</span></span><br><span class="line">        pw.write(<span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 最后不要忘记flush强制输出:</span></span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignInServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span>  <span class="comment">// 会接收所有未匹配的路径，相当于 /*</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程</p>
<ol>
<li><strong>客户端发送GET请求:</strong> 客户端浏览器向服务器发送一个HTTP GET请求到指定的URL（例如&#x2F;）。</li>
<li><strong>服务器接收请求:</strong> 服务器（例如Tomcat）接收到请求。</li>
<li><strong>Servlet容器匹配Servlet:</strong> Servlet容器根据URL找到对应的Servlet（本例中是HelloServlet）。</li>
<li><strong>Servlet容器创建request和response对象:</strong> Servlet容器创建HttpServletRequest和HttpServletResponse对象。HttpServletRequest封装了客户端请求的信息（例如请求头、参数等），HttpServletResponse用于构建服务器的响应。</li>
<li><strong>Servlet容器调用doGet方法:</strong> Servlet容器调用HelloServlet的doGet方法，并将创建的HttpServletRequest和HttpServletResponse对象作为参数传入。</li>
<li><strong>Servlet处理请求:</strong> 在doGet方法中，使用req对象获取客户端请求的信息，并使用resp对象构建响应。例如，设置响应的内容类型、写入响应内容等。</li>
<li><strong>Servlet容器发送响应:</strong> doGet方法执行完毕后，Servlet容器将resp对象中封装的响应信息发送回客户端。</li>
</ol>
<blockquote>
<p>一个Servlet类在服务器中只有一个实例，但对于每个HTTP请求，Web服务器会使用多线程执行请求。因此，一个Servlet的<code>doGet()</code>、<code>doPost()</code>等处理请求的方法是多线程并发执行的。如果Servlet中定义了字段，要注意多线程并发访问的问题.</p>
</blockquote>
<h2 id="Redirect-与-Forward"><a href="#Redirect-与-Forward" class="headerlink" title="Redirect 与 Forward"></a>Redirect 与 Forward</h2><p>Redirect透过HTTP 301 和 302实现</p>
<p>浏览器收到302响应后，它会立刻根据<code>Location</code>的指示发送一个新的<code>GET /hello</code>请求，这个过程就是重定向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 302 临时重定向</span></span><br><span class="line"><span class="type">String</span> <span class="variable">redirectToUrl</span> <span class="operator">=</span> <span class="string">&quot;/hello&quot;</span> + (name == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;?name=&quot;</span> + name);</span><br><span class="line">resp.sendRedirect(redirectToUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 301 永久重定向，浏览器会缓存/hi到/hello这个重定向的关联，下次请求/hi的时候，浏览器就直接发送/hello请求了</span></span><br><span class="line">resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); <span class="comment">// 301</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;/hello&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/morning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForwardServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/hello&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, name);</span><br></pre></td></tr></table></figure>

<p>流程: </p>
<ol>
<li><p>HttpSession session &#x3D; req.getSession();: 这一行代码获取或创建一个与当前请求关联的 HttpSession 对象。如果<strong>请求报文</strong>中包含的会话 ID（<code>Cookie: JSESSIONID=ABCDEF1234567890</code>），服务器会尝试检索与该 ID 关联的现有会话。如果找不到或会话 ID 无效，服务器会创建一个新的会话，并生成一个新的会话 ID。</p>
</li>
<li><p>session.setAttribute(“user”, name);: 这一行代码将名为 “user” 的属性及其值 name 存储到会话对象中。此数据存储在服务器端，而不是直接发送到客户端。</p>
<blockquote>
<p>HttpSession 对象保存在服务器端。存储在 Session 中的值代表了与特定客户端会话相关的数据。例如，在用户登录后，可以将用户名存储在 Session 中，以便在后续请求中识别用户身份，而无需用户每次都重新登录。其他常见的例子包括：</p>
<ul>
<li>购物车中的商品</li>
<li>用户的偏好设置</li>
<li>用户的浏览历史</li>
<li>游戏中的分数</li>
</ul>
</blockquote>
</li>
<li><p><strong>设置 Cookie：</strong> 当服务器处理完请求并准备发送响应时，如果创建了新的会话或现有会话被修改，服务器会将 Set-Cookie 头添加到响应中。这个头包含新创建的或更新的会话 ID。客户端（通常是浏览器）收到此头后，会将会话 ID 存储在一个 cookie 中。</p>
<blockquote>
<p>只有当以下几种情况发生时，服务器才会更新或发送新的 Cookie：</p>
<ol>
<li><strong>创建新的会话：</strong> 当客户端第一次访问需要会话的资源时，服务器会创建一个新的 HttpSession 对象，并生成一个新的会话 ID，然后通过 Set-Cookie 头将新的会话 ID 发送给客户端。</li>
<li><strong>会话 ID 重新生成（较少见）：</strong> 出于安全考虑，服务器可能会在某些情况下重新生成会话 ID，例如用户登录后。这时服务器会发送一个新的 Set-Cookie 头，其中包含新的会话 ID。</li>
<li><strong>会话过期时间更新（如果配置了）：</strong> 如果服务器配置了会话的过期时间，并且在会话过程中更新了过期时间，服务器可能会发送一个新的 Set-Cookie 头来更新 Cookie 中的过期时间信息。</li>
<li><strong>其他与会话相关的 Cookie 属性更改：</strong> 例如，如果服务器更改了 Cookie 的 HttpOnly、Secure、Path 或 Domain 属性，则需要发送新的 Set-Cookie 头来更新客户端的 Cookie。</li>
</ol>
</blockquote>
</li>
<li><p><strong>后续请求：</strong> 客户端在后续请求中会自动将这个 cookie 发送回服务器。服务器根据 cookie 中的会话 ID 检索相应的 HttpSession 对象，从而维护会话状态。</p>
</li>
</ol>
<p>除了使用Cookie机制可以实现Session外，还可以通过隐藏表单、URL末尾附加ID来追踪Session。</p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP（JavaServer Pages）是一种用于创建动态 Web 页面的技术。它允许您在 HTML 页面中嵌入 Java 代码，从而生成动态内容。Tomcat 在处理 JSP 页面时扮演着关键角色，其过程如下：</p>
<ol>
<li><p><strong>翻译阶段 (Translation):</strong> 当浏览器第一次请求 JSP 页面时，Tomcat 的 JSP 引擎会将 JSP 页面翻译成一个 Java Servlet 源文件。这个源文件包含了 JSP 页面中的所有 HTML、Java 代码以及 JSP 指令。  这个转换过程主要包括以下步骤：</p>
<ul>
<li><strong>解析 JSP 指令:</strong>  JSP 指令（例如 <code>&lt;%@ page ... %&gt;</code>, <code>&lt;%@ include ... %&gt;</code>, <code>&lt;%@ taglib ... %&gt;</code>）会被解析并用于配置生成的 Servlet。</li>
<li><strong>将 HTML 转换为 Java 代码:</strong> JSP 页面中的 HTML 代码会被转换为 <code>out.write()</code> 语句，其中 <code>out</code> 是 <code>JspWriter</code> 对象，用于将内容输出到客户端。</li>
<li><strong>嵌入 Java 代码:</strong>  JSP 页面中的 Java 代码片段（例如 <code>&lt;% ... %&gt;</code> 和 <code>&lt;%= ... %&gt;</code>）会被直接嵌入到生成的 Servlet 的 <code>_jspService()</code> 方法中。</li>
</ul>
</li>
<li><p><strong>编译阶段 (Compilation):</strong> 翻译生成的 Java Servlet 源文件会被 Java 编译器编译成一个 Java Servlet class 文件 (<code>.class</code> 文件)。</p>
</li>
<li><p><strong>加载阶段 (Loading):</strong> Tomcat 的类加载器会将编译好的 Servlet class 文件加载到内存中。</p>
</li>
<li><p><strong>实例化阶段 (Instantiation):</strong> Tomcat 创建 Servlet 的一个实例。</p>
</li>
<li><p><strong>初始化阶段 (Initialization):</strong> Tomcat 调用 Servlet 的 <code>init()</code> 方法，对 Servlet 进行初始化。 这通常只发生一次，在 Servlet 第一次被请求时。</p>
</li>
<li><p><strong>请求处理阶段 (Request Processing):</strong>  当浏览器请求 JSP 页面时，Tomcat 会调用 Servlet 的 <code>_jspService()</code> 方法。这个方法包含了 JSP 页面中的所有逻辑，并负责生成动态内容。  <code>_jspService()</code> 方法会根据 HTTP 请求的类型 (GET, POST 等) 执行相应的逻辑。</p>
</li>
<li><p><strong>销毁阶段 (Destruction):</strong> 当 Tomcat 关闭或需要卸载 Servlet 时，会调用 Servlet 的 <code>destroy()</code> 方法，释放资源。</p>
</li>
</ol>
<p><strong>简而言之，Tomcat 将 JSP 页面转换为 Servlet，然后像对待其他 Servlet 一样处理它。 这意味着 JSP 页面最终会被转换成 Java 代码，并在服务器端执行。</strong></p>
<p><strong>示例：</strong></p>
<p>假设有一个简单的 JSP 页面 <code>hello.jsp</code>：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello, &lt;%= <span class="keyword">new</span> <span class="title class_">java</span>.util.Date() %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>Tomcat 会将其转换为类似以下的 Servlet 代码 (简化版)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello_jsp</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">JspWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">    out.write(<span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;html&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;head&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;title&gt;Hello JSP&lt;/title&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/head&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;body&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;h1&gt;Hello, &quot;</span>);</span><br><span class="line">    out.print(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date());</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/h1&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/body&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/html&gt;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，HTML 代码被转换为 <code>out.write()</code> 语句，而 Java 代码 <code>&lt;%= new java.util.Date() %&gt;</code> 被嵌入到 <code>_jspService()</code> 方法中。  最终，这个 Servlet 会被编译并执行，生成动态的 HTML 页面并返回给浏览器。</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p><strong>过滤器链 (FilterChain):</strong> Servlet 容器会根据 web.xml 或注解中的配置，将匹配 URL 模式的过滤器组成一个链条。当请求到达时，容器会依次调用链上的过滤器。</p>
<p><strong>chain.doFilter():</strong> 这个方法是将控制权交给过滤器链中的下一个实体。</p>
<ul>
<li><strong>如果有下一个过滤器:</strong> 控制权会转移到下一个过滤器，执行其 doFilter() 方法。</li>
<li><strong>如果没有下一个过滤器:</strong> 控制权会转移到目标 servlet，执行其 service() 方法 (进而调用 doGet(), doPost() 等)。</li>
</ul>
<p><strong>过滤器执行顺序:</strong> 过滤器链的执行顺序与它们在 web.xml 中的声明顺序或注解的顺序相同。</p>
<p><strong>请求处理流程:</strong> 一个请求的完整过滤流程如下：</p>
<ul>
<li>请求到达服务器。</li>
<li>服务器根据 URL 匹配过滤器链。</li>
<li>第一个过滤器执行 doFilter() 方法。</li>
<li>第一个过滤器调用 chain.doFilter()，将控制权交给下一个过滤器或 servlet。</li>
<li>重复步骤 4，直到最后一个过滤器执行完毕。</li>
<li>目标 servlet 执行 service() 方法处理请求。</li>
<li>响应返回客户端，过滤器链反向执行，每个过滤器可以对响应进行处理。</li>
</ul>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>一个web项目一个ServletContext对象</p>
<blockquote>
<p>即使一个项目中有多个 Servlet，它们都共享同一个 ServletContext。ServletContext 代表整个 Web 应用程序，它提供了一种在不同 Servlet 之间共享信息和资源的机制。</p>
</blockquote>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/index.html">https://liaoxuefeng.com/books/java/spring/index.html</a></p>
<h2 id="IoC-与-AoP"><a href="#IoC-与-AoP" class="headerlink" title="IoC 与 AoP"></a>IoC 与 AoP</h2><p>Inversion of Control 控制反转</p>
<p>Aspect-Oriented-Programming 面向切面编程</p>
<p>AoP基于动态代理，AOP 的核心思想是将横切关注点 <strong>从核心业务逻辑中分离出来</strong>，并将其模块化为独立的 **切面 (Aspect)**。切面定义了在何处 (Join Point) 和何时 (Advice) 应用横切关注点。</p>
<h2 id="IoC容器与IoC对象"><a href="#IoC容器与IoC对象" class="headerlink" title="IoC容器与IoC对象"></a>IoC容器与IoC对象</h2><p><strong>Bean 对象</strong>通常被称为<strong>IoC 对象</strong>，它们是由 Spring 的 <strong>IoC 容器</strong>负责管理的对象。</p>
<p>Spring IoC 容器的创建过程：</p>
<ul>
<li><p><strong>基于 XML 配置</strong>：当加载 XML 配置文件时，容器会初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有spring注解哦，此时spring容器尚未启动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);  <span class="comment">// 启动spring容器并基于application.xml扫描并创建bean</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 UserService Bean</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 login 方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- application.xml --&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;emailService&quot;</span> class=<span class="string">&quot;com.example.EmailService&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">&quot;emailService&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基于 Java 配置类</strong>：当有 <code>@Configuration</code> 类时，Spring 会通过 Java 配置类创建 IoC 容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);  <span class="comment">// 基于AppConfig.java 扫描</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AppConfig.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(emailService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EmailService <span class="title function_">emailService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmailService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><strong>构造性注解</strong>: 被构造性注解标记的类，Spring会自动使用无参构造函数创建该类的Bean</p>
<ul>
<li><p>@Component:</p>
<ul>
<li>这是最通用的构造型注解，可以用于标记任何需要被 Spring 管理的类。</li>
</ul>
</li>
<li><p>@Service:</p>
<ul>
<li>用于标记服务层组件，通常包含业务逻辑。</li>
</ul>
</li>
<li><p>@Repository:</p>
<ul>
<li>用于标记数据访问层组件，例如 DAO (Data Access Object) 类。</li>
</ul>
</li>
<li><p>@Controller:</p>
<ul>
<li>用于标记 Web 层控制器组件，例如 Spring MVC 中的控制器类。</li>
<li>使用 @Controller，需要在每个处理 RESTful 请求的方法上添加 @ResponseBody 注解，以便将返回值作为响应体发送。</li>
</ul>
</li>
<li><p>@Configuration:</p>
<ul>
<li>用于标记配置类，通常包含 @Bean 注解标记的方法，用于创建 Bean。</li>
</ul>
<blockquote>
<p>Configuration也是构造性注解</p>
</blockquote>
</li>
<li><p>@RestController:</p>
<ul>
<li>用于标记 RESTful Web 服务的控制器组件，相当于 @Controller 和 @ResponseBody 的组合。</li>
<li>使用 @RestController，所有方法的返回值都将自动作为响应体发送，无需额外添加 @ResponseBody 注解。</li>
<li>编写REST接口需要定义<code>@RestController</code>，然后，每个方法都是一个API接口，输入和输出只要能被Jackson序列化或反序列化为JSON就没有问题。</li>
</ul>
</li>
</ul>
<blockquote>
<p>被构造性注解标记的类将会被注册创建为Bean</p>
<p>一般的，被构造性注解标记的类的属性<strong>不会被自动注入</strong></p>
</blockquote>
<p><strong>依赖注入注解：</strong></p>
<ul>
<li><p>@Autowired：用于自动注入依赖</p>
<ul>
<li>默认按照类型（byType）装配依赖对象。如果有多个相同类型的 Bean，会尝试按照名称（byName）进行匹配。如果没有匹配的 Bean，会抛出异常。</li>
<li>可以作用于构造函数、字段、Setter 方法等。</li>
</ul>
</li>
<li><p>@Resource：用于注入依赖</p>
<ul>
<li>默认按照名称（byName）装配依赖对象。名称可以通过 name 属性指定，如果没有指定，则默认使用字段名或 setter 方法的参数名作为名称。如果找不到名称匹配的 Bean，会回退到按照类型（byType）进行匹配。如果仍然找不到匹配的 Bean，会抛出异常。</li>
<li>可以用于字段和 setter 方法上，不能用于构造函数和配置方法上。</li>
</ul>
</li>
<li><p>@Value：用于注入属性值，可以注入配置文件中的值、系统属性、环境变量等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValueExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;&#125;访问外部属性（配置文件、系统属性、环境变量）,简单变量替换</span></span><br><span class="line">    <span class="comment">// #&#123;&#125;运行时计算表达式，动态计算值、条件判断、集合操作等</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注入 application.properties 或 application.yml 中的属性值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入系统属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.home&#125;&quot;)</span>  <span class="comment">// 等同于 System.getProperty(&quot;user.home&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userHome;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入环境变量 (需要先设置环境变量)</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;MY_ENV_VAR&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String myEnvVar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 SpEL 表达式设置默认值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.description:Default Description&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appDescription;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入字面量</span></span><br><span class="line">    <span class="meta">@Value(&quot;A hardcoded value&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String hardcodedValue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入数组 (application.properties: app.features=feature1,feature2,feature3)</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.features&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String[] appFeatures;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入 List (需要 Spring Boot 2.4 以上版本， application.properties: app.colors=red,green,blue)</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;$&#123;app.colors&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> java.util.List&lt;String&gt; appColors;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 + 2&#125;&quot;)</span> <span class="comment">// 计算 1 + 2 的结果，结果为 3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;T(java.lang.Math).random() * 100.0&#125;&quot;)</span> <span class="comment">// 调用 Math.random() 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> randomNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;beanName.methodName()&#125;&quot;)</span> <span class="comment">// 调用 Spring Bean 的方法</span></span><br><span class="line">    <span class="keyword">private</span> String result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printValues</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;App Name: &quot;</span> + appName);</span><br><span class="line">        System.out.println(<span class="string">&quot;User Home: &quot;</span> + userHome);</span><br><span class="line">        System.out.println(<span class="string">&quot;My Env Var: &quot;</span> + myEnvVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;App Description: &quot;</span> + appDescription);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hardcoded Value: &quot;</span> + hardcodedValue);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;App Features: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String feature : appFeatures) &#123;</span><br><span class="line">            System.out.print(feature + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;App Colors: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String color : appColors) &#123;</span><br><span class="line">            System.out.print(color + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// application.properties 示例</span></span><br><span class="line"><span class="comment">// app.name=My Application</span></span><br><span class="line"><span class="comment">// app.description=A great application</span></span><br><span class="line"><span class="comment">// app.features=feature1,feature2,feature3</span></span><br><span class="line"><span class="comment">// app.colors=red,green,blue</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>依赖注入只发生在被Spring管理的Bean上，这意味着，使用构造函数注入和使用 Setter 方法注入通常只会发生在被构造型注解标记的类上</p>
<p>使用<strong>使用构造函数注入</strong>和<strong>使用 Setter 方法注入</strong>的被构造方法标记类不需要显示的使用依赖注入注解</p>
</blockquote>
<p><strong>生命周期注解：</strong></p>
<ul>
<li>@PostConstruct：用于标记初始化方法，在 Bean 创建后执行。</li>
<li>@PreDestroy：用于标记销毁方法，在 Bean 销毁前执行。</li>
</ul>
<p><strong>AOP 相关注解：</strong></p>
<ul>
<li><p>@Aspect：用于标记切面类。</p>
<p>一个切面类可以对<strong>多个类的多个方法</strong>进行切面增强，</p>
<p>多切面类示例：例如，可以创建一个 LoggingAspect 用于日志记录，创建一个 SecurityAspect 用于安全控制，创建一个 TransactionAspect 用于事务管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 在执行UserService的每个方法前执行:</span></span><br><span class="line">    <span class="comment">// 切面增强UserService类的所有公共方法</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Before] do access check...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行MailService的每个方法前后执行:</span></span><br><span class="line">    <span class="comment">// 切面增强MailService类的所有公共方法</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] start &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] done &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>  <span class="comment">// 配合@Aspect使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring的IoC容器发现配置类存在该注解后，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。</p>
</li>
<li><p>@Before、@After、@Around 等：用于定义切点和增强。</p>
</li>
</ul>
<blockquote>
<p>AOP原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserServiceAopProxy <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceAopProxy</span><span class="params">(UserService target, LoggingAspect aspect)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.aspect = aspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 先执行Aspect的代码:</span></span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="comment">// 再执行UserService的逻辑:</span></span><br><span class="line">        <span class="keyword">return</span> target.login(email, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="keyword">return</span> target.register(email, password, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>事务管理注解：</strong></p>
<ul>
<li><p>@Transactional：用于声明事务，可以作用于类或方法</p>
<ul>
<li><p>表示被标记类的所有<code>public</code>方法&#x2F;被标记方法具有事务支持</p>
</li>
<li><p>类的方法或方法执行过程中如果抛出异常，回滚发生</p>
</li>
<li><p>可以针对指定异常抛出，发生回滚</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>Web 相关注解：</strong></p>
<ul>
<li><p>@RequestMapping：</p>
<p>将 HTTP 请求映射到控制器方法;</p>
<p>定义 URL 映射规则，例如 &#x2F;users、&#x2F;users&#x2F;{id} 等;</p>
<p>指定 HTTP 请求方法，例如 GET、POST、PUT、DELETE 等;</p>
<p>定义请求参数，例如 @RequestParam、@PathVariable 等.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@GetMapping、@PostMapping 等：@RequestMapping 的特化，用于简化请求映射的配置。</p>
</li>
<li><p>@PathVariable：用于获取 URL 中的路径变量。</p>
</li>
<li><p>@RequestParam：用于获取请求参数。</p>
</li>
<li><p>@RequestBody：用于将 HTTP 请求体转换为方法参数。</p>
</li>
<li><p>@ResponseBody: </p>
<ul>
<li>方法的返回值转换为指定的格式，例如 JSON 或 XML，并将其作为响应体发送给客户端。</li>
<li>应用于方法上, 只对该方法生效; 应用于类上, 对该类中的所有方法生效。</li>
</ul>
</li>
</ul>
<p><strong>测试相关注解：</strong></p>
<ul>
<li>@SpringBootTest：用于标记 Spring Boot 测试类。</li>
<li>@MockBean：用于模拟 Bean，方便进行单元测试。</li>
</ul>
<p><strong>其他注解：</strong></p>
<ul>
<li>@Scope：用于指定 Bean 的作用域。</li>
<li>@ComponentScan<ul>
<li>如果某类被注解<code>@ComponentScan</code>标注，则会扫描标注该注解的类所在包及其子包中的所有组件（包括 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 等）</li>
<li>如果被 <code>@ComponentScan</code> 标注的 <code>MyApplication</code> 类位于 <code>com.example</code> 包下，Spring 会默认扫描 <code>com.example</code> 包及其所有子包，例如 <code>com.example.domain</code>。</li>
</ul>
</li>
<li>@Lazy：用于延迟初始化 Bean。</li>
<li>@Profile：用于根据不同的环境激活不同的 Bean。</li>
<li>@Conditional：用于根据条件创建 Bean。</li>
<li><strong>@PropertySource:</strong><ul>
<li><strong>作用:</strong> 将外部属性文件加载到 Spring 的 Environment 中。这些属性文件可以是 properties 文件、yaml 文件或其他格式的文件。</li>
<li><strong>使用场景:</strong> 主要用于导入配置文件，例如 application.properties、application.yml 等，或者自定义的配置文件。</li>
<li><strong>绑定方式:</strong> @PropertySource <strong>不会</strong>直接将属性绑定到 Java Bean 上。它只是将属性加载到 Environment 中，使用 @Value 注解或 Environment 对象来访问这些属性。</li>
</ul>
</li>
<li><strong>@ConfigurationProperties:</strong><ul>
<li><strong>作用:</strong> 将配置文件中的属性绑定到一个 Java Bean 上。</li>
<li><strong>使用场景:</strong> 主要用于将一组相关的配置属性组织成一个 Java Bean，方便管理和使用。</li>
<li><strong>绑定方式:</strong> @ConfigurationProperties 会自动将配置文件中与 Bean 属性名称匹配的属性值注入到 Bean 中。支持松散绑定（relaxed binding），例如 my-property 可以绑定到 myProperty 属性。</li>
</ul>
</li>
</ul>
<h3 id="Resource-与-Autowired"><a href="#Resource-与-Autowired" class="headerlink" title="@Resource 与 @Autowired"></a><code>@Resource</code> 与 <code>@Autowired</code></h3><p><code>@Autowired</code> 是 Spring 提供的注解，它默认按照类型来注入依赖。可以使用 <code>@Qualifier</code> 来指定具体的 Bean 名称。</p>
<p><code>@Resource</code> 是 Java EE 规范的一部分，它默认按照字段名称来注入依赖，或者根据 <code>name</code> 属性来查找指定名称的 Bean。</p>
<p>@Autowired：用于自动注入依赖</p>
<ul>
<li>默认按照类型（byType）装配依赖对象。如果有多个相同类型的 Bean，会尝试按照名称（byName）进行匹配。如果没有匹配的 Bean，会抛出异常。</li>
<li>可以作用于构造函数、字段、Setter 方法等。</li>
</ul>
<p>@Resource：用于注入依赖</p>
<ul>
<li>默认按照名称（byName）装配依赖对象。名称可以通过 name 属性指定，如果没有指定，则默认使用字段名或 setter 方法的参数名作为名称。如果找不到名称匹配的 Bean，会回退到按照类型（byType）进行匹配。如果仍然找不到匹配的 Bean，会抛出异常。</li>
<li>可以用于字段和 setter 方法上，不能用于构造函数和配置方法上。</li>
</ul>
<h2 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h2><h3 id="使用构造函数注入-使用-Setter-方法注入"><a href="#使用构造函数注入-使用-Setter-方法注入" class="headerlink" title="使用构造函数注入 &amp;&amp; 使用 Setter 方法注入"></a>使用构造函数注入 &amp;&amp; 使用 Setter 方法注入</h3><blockquote>
<p>为什么不使用autowire注入？</p>
<p>构造函数注入的优点</p>
<ol>
<li><p>注入的目标变量可以是final的</p>
</li>
<li><p>被注入的对象必须存在，即注入的目标变量注入后不会为null</p>
</li>
</ol>
</blockquote>
<p><strong>构造函数注入</strong></p>
<p>假设我们有两个类：<code>UserService</code> 和 <code>EmailService</code>，<code>UserService</code> 依赖于 <code>EmailService</code>。</p>
<p><strong>EmailService 类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Sending email to &quot;</span> + to + <span class="string">&quot;:\nSubject: &quot;</span> + subject + <span class="string">&quot;\nBody: &quot;</span> + body);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UserService 类：</strong></p>
<p>使用构造函数注入 <code>EmailService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EmailService emailService;  <span class="comment">// 目标字段可以是 final，但不强制必须是 final，强烈建议在构造函数注入时将依赖字段声明为 final，因为这可以确保依赖在对象创建时被完全初始化，而且不会在对象生命周期中被修改，从而提供更高的安全性和不可变性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数注入</span></span><br><span class="line">    <span class="comment">// 这里没有使用@Autowired，但是属性emailService被自动注入bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(EmailService emailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username, String email)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 用户注册逻辑 ...</span></span><br><span class="line">        emailService.sendEmail(email, <span class="string">&quot;Welcome!&quot;</span>, <span class="string">&quot;Thank you for registering.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Setter 方法注入</strong></p>
<p>仍使用 <code>UserService</code> 和 <code>EmailService</code>，使用 Setter 方法注入 <code>EmailService</code>。</p>
<p><strong>EmailService 类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email to &quot;</span> + to + <span class="string">&quot;:\nSubject: &quot;</span> + subject + <span class="string">&quot;\nBody: &quot;</span> + body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserService 类：</strong></p>
<p>使用 Setter 方法注入 <code>EmailService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;  </span><br><span class="line">    <span class="comment">// 依赖不能是 final 的！！！，final 字段必须在对象构造时被赋值（即通过构造函数进行初始化）</span></span><br><span class="line">    <span class="comment">// 即使字段的访问级别是 private，Spring 仍然可以使用反射来绕过 Java 的访问控制机制，直接为私有字段设置值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter 方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 将Setter方法标记为@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmailService</span><span class="params">(EmailService emailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username, String email)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 用户注册逻辑 ...</span></span><br><span class="line">        emailService.sendEmail(email, <span class="string">&quot;Welcome!&quot;</span>, <span class="string">&quot;Thank you for registering.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>为什么不直接将 <code>@Autowired</code> 标记在属性上？</strong></p>
<p>实际上，<strong>Spring 支持将 <code>@Autowired</code> 直接标记在属性上</strong>，这种方式叫做<strong>字段注入</strong>（Field Injection）。这种注入方式不需要提供 <code>set</code> 方法，Spring 会直接通过反射为属性注入依赖。然而，字段注入通常被认为是<strong>不推荐的做法</strong>，原因如下：</p>
<p><strong>字段注入的缺点：</strong></p>
<ol>
<li><strong>不利于测试</strong>：直接将 <code>@Autowired</code> 注解标记在字段上，依赖会通过反射注入。这样会让单元测试变得困难，因为无法直接通过构造函数或 Setter 方法传递 mock 对象，而是必须使用像 <code>ReflectionTestUtils</code> 这样的工具来手动设置私有字段的依赖。</li>
<li><strong>违背封装原则</strong>：字段注入直接修改类的私有属性，违背了对象的封装性原则。在面向对象编程中，通常希望属性通过构造函数或 Setter 方法来进行操作，而不是直接被外部干预。</li>
<li><strong>无法支持 <code>final</code> 关键字</strong>：如果使用字段注入，属性不能声明为 <code>final</code>，因为 <code>final</code> 属性必须在构造函数中初始化，而不是通过反射。这限制了对不可变性的支持。</li>
</ol>
</blockquote>
<h3 id="使用-Component或-Bean声明"><a href="#使用-Component或-Bean声明" class="headerlink" title="使用@Component或@Bean声明"></a>使用@Component或@Bean声明</h3><ul>
<li><strong>对于大多数 Bean，使用 @Component (或其衍生注解) 进行声明，并让 Spring 自动扫描和注册。</strong> 这是最简洁和推荐的方式。</li>
<li><strong>只有在需要更细粒度的控制，例如自定义初始化、作用域或条件化创建 Bean 时，才需要在config类中使用 @Bean 方法。</strong></li>
<li><strong>始终为 @Bean 方法创建一个对应的类，即使它非常简单。</strong> 避免使用匿名内部类或 Lambda 表达式创建 Bean，除非有非常特殊的理由。</li>
</ul>
<h3 id="创建第三方Bean"><a href="#创建第三方Bean" class="headerlink" title="创建第三方Bean"></a>创建第三方Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bean注解创建</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String jdbcUsername;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        config.setJdbcUrl(jdbcUrl);</span><br><span class="line">        config.setUsername(jdbcUsername);</span><br><span class="line">        config.setPassword(jdbcPassword);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;autoCommit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除非显式地指定了 bean 的名字，Spring 默认会使用方法名作为 Bean 的 ID。</span></span><br><span class="line">    <span class="comment">// HikariDataSource类型，id为createDataSource的bean</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// JdbcTemplate类型，id为createJdbcTemplate的bean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// import导入</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ThirdPartyLibraryConfig.class)</span> <span class="comment">// 导入第三方库的配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring 通过以下机制得知在注入时使用哪个 bean：</p>
<ol>
<li><strong>@Autowired 注解:</strong> 在 createJdbcTemplate 方法中，@Autowired 注解告诉 Spring 需要注入一个 DataSource 类型的 Bean。</li>
<li><strong>类型匹配:</strong> Spring 容器会扫描所有带有 @Bean 注解的方法，并将其返回值注册为 Bean。当需要注入 DataSource 类型 Bean 时，Spring 会查找容器中所有类型为 DataSource 的 Bean。</li>
<li><strong>唯一 Bean:</strong> 在本例中，只有一个方法 createDataSource 返回 DataSource 类型的 Bean。因此，Spring 可以明确地将 createDataSource 方法创建的 Bean 注入到 createJdbcTemplate 方法的参数中。</li>
<li><strong>名称匹配（如果存在多个同类型 Bean）:</strong> 如果有多个 DataSource 类型的 Bean，@Autowired 默认会按照类型进行匹配。如果匹配到多个，则会尝试按照名称进行匹配。你可以使用 @Qualifier 注解来指定要注入的 Bean 的名称</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;  <span class="comment">// 将被spring正确注入</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>实现了FactoryBean接口的类将被Spring视为工厂Bean</p>
<p>Spring会将工厂Bean创建后保存在IoC容器中，并在注入该工厂Bean的时候，使用工厂Bean创建Bean进行注入；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myConnection&quot;)</span> <span class="comment">// bean name</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnectionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;MyConnection&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter methods for properties (url, username, password) -  injected via Spring</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyConnection <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Create and return a new MyConnection object</span></span><br><span class="line">        <span class="comment">// This is where the object creation logic resides</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Creating a new MyConnection object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyConnection</span>(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyConnection.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Return false for a new instance each time</span></span><br><span class="line">        <span class="comment">// return true;  // Return true for a singleton instance</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple connection class (replace with your actual connection logic)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConnection</span><span class="params">(String url, String username, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123; <span class="keyword">return</span> url;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; <span class="keyword">return</span> username;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;<span class="keyword">return</span> password;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyConnection myConnection; <span class="comment">// 注意，这里注入的是myConnection对象而不是myConnectionFactoryBean对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using MyConnection: &quot;</span> + myConnection.getUrl());</span><br><span class="line">        <span class="comment">// ... use the myConnection object ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取 FactoryBean 本身：</strong></p>
<p>如果需要获取 FactoryBean 实例本身，而不是它创建的对象，可以在 Bean 的名称前面加上 &amp; 符号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyConnectionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> (MyConnectionFactoryBean) applicationContext.getBean(<span class="string">&quot;&amp;myConnection&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong></p>
<ul>
<li><strong>封装复杂的创建逻辑：</strong> 当 Bean 的创建逻辑比较复杂时，可以使用 FactoryBean 将其封装起来，使配置更加简洁。</li>
<li><strong>延迟初始化：</strong> FactoryBean 的 getObject() 方法只有在需要的时候才会被调用，可以实现 Bean 的延迟初始化。</li>
<li><strong>创建不同类型的对象：</strong> FactoryBean 可以根据不同的配置创建不同类型的对象。</li>
<li><strong>与第三方库集成：</strong> 可以使用 FactoryBean 来集成第三方库，例如创建数据库连接、缓存连接等。</li>
</ul>
<h3 id="初始化与销毁"><a href="#初始化与销毁" class="headerlink" title="初始化与销毁"></a>初始化与销毁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span>  <span class="comment">// 创建后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init mail service with zoneId = &quot;</span> + <span class="built_in">this</span>.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span>  <span class="comment">// 销毁前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutdown mail service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>循环依赖存在三种场景：</p>
<ol>
<li>通过构造方法进行依赖注入时产生的循环依赖问题</li>
<li>通过setter方法进行依赖注入且是在多例模式下产生的循环依赖问题</li>
<li>通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题</li>
</ol>
<p>Spring 在处理 Bean 创建时，会使用 <strong>三级缓存</strong> 来处理依赖注入中的循环依赖问题：</p>
<ul>
<li><strong>一级缓存</strong>（<code>singletonObjects</code>）：存储完全初始化好的 Bean。</li>
<li><strong>二级缓存</strong>（<code>earlySingletonObjects</code>）：存储部分初始化的 Bean（即属性注入完成，但构造器还未执行完毕的 Bean）。</li>
<li><strong>三级缓存</strong>（<code>singletonFactories</code>）：存储还没有初始化的 Bean 的工厂方法，用于延迟创建 Bean。</li>
</ul>
<p>具体流程如下：</p>
<ol>
<li><p><strong>Bean 的创建开始</strong>：当创建 Bean A 时，Spring 会检查是否存在该 Bean 的实例。如果不存在，Spring 会继续创建。</p>
</li>
<li><p><strong>检查依赖</strong>：如果 A 需要注入 B，Spring 会继续检查 B 是否已经创建。如果 B 没有完全初始化，Spring 会查看三级缓存是否有其工厂方法。</p>
</li>
<li><p><strong>三级缓存</strong>：如果 B 没有被完全初始化，Spring 会使用三级缓存中的工厂方法，来创建一个“早期的” B 对象，并将这个对象放入二级缓存中。</p>
</li>
<li><p><strong>注入依赖</strong>：Spring 会将 B 的早期对象注入到 A 中。这样即使 B 本身还没有完全初始化，A 仍然能够获得一个有效的依赖。</p>
</li>
<li><p><strong>完成初始化</strong>：接下来，Spring 会继续完成 A 和 B 的初始化过程。A 完成初始化后，会被加入一级缓存（<code>singletonObjects</code>）中，表示它已经完全初始化。</p>
<p>同样，B 也会完成初始化并被加入到一级缓存中。</p>
</li>
</ol>
<h3 id="构造器注入与setter注入"><a href="#构造器注入与setter注入" class="headerlink" title="构造器注入与setter注入"></a>构造器注入与setter注入</h3><p><strong>Setter 注入</strong>：</p>
<ul>
<li>通过 JavaBean 的 setter 方法来注入依赖。这意味着在对象创建之后，Spring 会调用相应的 setter 方法来注入依赖。也就是说，依赖项的注入是在对象的初始化阶段进行的。</li>
<li>支持可选依赖项。你可以通过 setter 方法传入 <code>null</code> 值或者根本不注入某些依赖，这样被注入的 Bean 可以是可选的。如果依赖项没有被注入，那么该属性就会保持默认值（比如 <code>null</code> 或者空集合等）。</li>
</ul>
<p><strong>构造器注入</strong>：</p>
<ul>
<li>通过构造器来注入依赖。Spring 会在创建 Bean 时，通过构造函数来提供所有必要的依赖项。依赖项在对象创建时就已经提供，并且无法更改。</li>
<li>不支持可选依赖项。构造器注入要求在 Bean 创建时必须提供所有的依赖项。也就是说，如果某个必需的依赖没有传入，Spring 会抛出异常，导致 Bean 创建失败。</li>
</ul>
<h2 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h2><ol>
<li><p><strong>实例化 Bean：</strong></p>
<ul>
<li><p>根据配置的包路径，通过<strong>组件扫描（Component Scanning）</strong>找到带有构造型注解的类（例如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 等），标注了构造型注解的类注册为 Spring 容器中的 Bean。</p>
</li>
<li><p><strong>推断构造方法：</strong> Spring 选择合适的构造方法进行实例化。</p>
<blockquote>
<p><strong>在 config 中设置了类的构造方法：</strong></p>
<ul>
<li>如果在 @Configuration 类中使用 @Bean 注解定义了该类的构建方法，Spring 会使用该方法创建 Bean 对象。</li>
<li>在 @Bean 方法中，你可以手动创建 Bean 对象，并使用构造函数注入或 Setter 方法注入设置 Bean 的属性。</li>
<li>即使类上有构造型注解，Spring 也会优先使用 @Bean 方法创建 Bean 对象，而不是使用组件扫描和自动注册的方式。</li>
</ul>
<p><strong>没有在 config 中设置类的构建方法：</strong></p>
<ul>
<li>如果类上有构造型注解（例如 @Component、@Service 等），Spring 会通过组件扫描发现该类，并尝试使用其默认的无参构造函数创建 Bean 对象。</li>
<li>如果类没有默认的无参构造函数，但只有一个有参构造函数，Spring 也会尝试使用该有参构造函数创建 Bean 对象，并尝试自动注入构造函数所需的依赖。</li>
<li>如果类有多个构造函数，Spring 会优先选择标注了 <code>@Autowired</code> 的构造函数。如果没有标注 <code>@Autowired</code>，Spring 会尝试通过依赖匹配来选择合适的构造函数。如果不能成功解析依赖，将抛出异常。</li>
</ul>
</blockquote>
</li>
<li><p><strong>创建对象：</strong> 使用反射机制或工厂方法创建 Bean 的实例。此时，对象的属性还未被填充。</p>
</li>
</ul>
<blockquote>
<p>实例化时可能出现循环依赖问题</p>
<p>即 两个或多个 Bean 之间相互依赖，例如 A 依赖 B，B 又依赖 A。这种情况下，Spring 容器无法确定先创建哪个 Bean，就会导致循环依赖问题。</p>
<p>Spring 容器使用 <strong>三级缓存 + 提前AOP(可选)</strong> 来解决循环依赖和依赖顺序问题：</p>
<ol>
<li><strong>singletonObjects：</strong> 存放已经创建完成的单例 Bean。</li>
<li><strong>earlySingletonObjects：</strong> 存放正在创建过程中的单例 Bean。</li>
<li><strong>singletonFactories：</strong> 存放用于创建单例 Bean 的工厂。</li>
</ol>
<p><strong>解决过程：</strong></p>
<ol>
<li>当 Spring 容器创建 Bean A 时，发现 A 依赖 B。</li>
<li>Spring 容器检查 singletonObjects 中是否存在 B，如果存在，则直接注入 B。</li>
<li>如果 singletonObjects 中不存在 B，则检查 earlySingletonObjects 中是否存在 B，如果存在，则将 B 从 earlySingletonObjects 中取出，注入到 A 中。</li>
<li>如果 earlySingletonObjects 中也不存在 B，则检查 singletonFactories 中是否存在 B 的工厂，如果存在，则使用工厂创建 B 的实例，并将 B 放入 earlySingletonObjects 中，然后注入到 A 中。</li>
<li>如果 singletonFactories 中也不存在 B 的工厂，则说明 B 还没有开始创建，Spring 容器会先创建 B，然后再创建 A。</li>
</ol>
</blockquote>
</li>
<li><p><strong>填充属性 (依赖注入)：</strong></p>
<ul>
<li>Spring 容器根据配置信息解析 Bean 的依赖关系。</li>
<li><strong>依赖注入：</strong> 将依赖的 Bean 注入到当前 Bean 的属性中，例如使用 @Autowired 注解注入的依赖。</li>
</ul>
</li>
<li><p><strong>Aware 接口回调：</strong></p>
<ul>
<li>如果 Bean 实现了 Spring 的 Aware 接口 (例如 BeanNameAware、BeanFactoryAware 等)，Spring 容器会回调相应的方法，将 Bean 的名称、BeanFactory 等信息注入到 Bean 中。</li>
</ul>
</li>
<li><p><strong>BeanPostProcessor 的前置处理：</strong></p>
<ul>
<li>Spring 容器会调用所有实现了 BeanPostProcessor 接口的 postProcessBeforeInitialization() 方法，对 Bean 进行前置处理。</li>
<li><strong>初始化前：</strong> “初始化前” 阶段，开发者可以在 BeanPostProcessor 中对 Bean 进行一些自定义的处理，例如修改 Bean 的属性、添加 Bean 的代理等。</li>
</ul>
</li>
<li><p><strong>初始化：</strong></p>
<ul>
<li>如果 Bean 实现了 InitializingBean 接口，Spring 容器会调用其 afterPropertiesSet() 方法。</li>
<li>如果 Bean 定义了 init-method 属性，Spring 容器会调用指定的初始化方法。</li>
<li><strong>初始化：</strong> “初始化” 阶段，开发者可以在初始化方法中进行一些资源的初始化工作，例如打开数据库连接、加载配置文件等。</li>
</ul>
</li>
<li><p><strong>BeanPostProcessor 的后置处理：</strong></p>
<ul>
<li>Spring 容器会调用所有实现了 BeanPostProcessor 接口的 postProcessAfterInitialization() 方法，对 Bean 进行后置处理。</li>
<li><strong>AOP：</strong> “初始化后” 阶段，开发者可以在 BeanPostProcessor 中对 Bean 进行 AOP 代理，例如使用 Spring AOP 创建代理对象。</li>
<li><strong>代理对象：</strong> 如果 Bean 被 AOP 代理，那么此时返回的 Bean 就是代理对象，而不是原始的 Bean 对象。</li>
</ul>
</li>
<li><p><strong>放入单例池 (可选)：</strong></p>
<ul>
<li>如果 Bean 的作用域是单例 (singleton)，Spring 容器会将 Bean 放入单例池中，方便下次获取。</li>
<li>如果 类使用了AOP，则放入单例池的是<strong>代理对象</strong></li>
</ul>
</li>
<li><p><strong>Bean 对象：</strong></p>
<ul>
<li>此时，Bean 创建完成，可以被应用程序使用了。</li>
</ul>
</li>
<li><p><strong>销毁：</strong></p>
<ul>
<li>当 Bean 的生命周期结束时，Spring 容器会销毁 Bean。</li>
<li>如果 Bean 实现了 DisposableBean 接口，Spring 容器会调用其 destroy() 方法。</li>
<li>如果 Bean 定义了 destroy-method 属性，Spring 容器会调用指定的销毁方法。</li>
</ul>
</li>
</ol>
<h2 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String jdbcUsername;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">// 创建数据库连接池，并作为bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        config.setJdbcUrl(jdbcUrl);</span><br><span class="line">        config.setUsername(jdbcUsername);</span><br><span class="line">        config.setPassword(jdbcPassword);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;autoCommit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">// 创建JdbcTemplate，注入DataSource</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>JdbcTemplate用法</strong></p>
<p>配置类实现 JdbcTemplate Bean 的创建，注入到User类jdbcTemplate属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意传入的是ConnectionCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute((Connection conn) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:</span></span><br><span class="line">        <span class="comment">// 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)) &#123;</span><br><span class="line">            ps.setObject(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                            rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 需要传入SQL语句，以及PreparedStatementCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute(<span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>, (PreparedStatement ps) -&gt; &#123;</span><br><span class="line">        <span class="comment">// PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:</span></span><br><span class="line">        ps.setObject(<span class="number">1</span>, name);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入SQL，参数和RowMapper实例:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT * FROM users WHERE email = ?&quot;</span>,</span><br><span class="line">            (ResultSet rs, <span class="type">int</span> rowNum) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 将ResultSet的当前行映射为一个JavaBean:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;,</span><br><span class="line">            email);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>jdbcTemplate.queryForObject() 方法的第二个参数是一个 RowMapper 接口的实现。RowMapper 接口定义了一个 mapRow(ResultSet rs, int rowNum) 方法，它的作用就是将 ResultSet 的每一行数据映射成一个 Java 对象。</p>
</blockquote>
<p><strong>声明式事务</strong></p>
<p><code>PlatformTransactionManager</code>表示事务管理器；</p>
<p><code>TransactionStatus</code>表示事务；</p>
<blockquote>
<p>Spring为了同时支持JDBC和JTA两种事务模型，故使用<code>PlatformTransactionManager</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开启事务:</span></span><br><span class="line">    tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="comment">// 相关JDBC操作:</span></span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="comment">// 提交事务:</span></span><br><span class="line">    txManager.commit(tx);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务:</span></span><br><span class="line">    txManager.rollback(tx);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 启用声明式</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>声明式事务透过AOP代理的方式，为UserService类创建代理对象，该代理对象拥有属性txManager，并使每个方法事务化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService$$EnhancerBySpringCGLIB</span> <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">PlatformTransactionManager</span> <span class="variable">txManager</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">            target.register(email, password, name);</span><br><span class="line">            txManager.commit(tx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            txManager.rollback(tx);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>事务回滚</strong></p>
<p>默认情况下，如果发生了<code>RuntimeException</code>，Spring的声明式事务将自动回滚</p>
<p>如果要针对Checked Exception回滚事务，需要在<code>@Transactional</code>注解中写出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">buyProducts</span><span class="params">(<span class="type">long</span> productId, <span class="type">int</span> num)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JDBC事务传播"><a href="#JDBC事务传播" class="headerlink" title="JDBC事务传播"></a>JDBC事务传播</h3><p>Spring的声明式事务为事务传播定义分级，默认传播级别 <code>REQUIRED</code></p>
<p><code>REQUIRED</code>：表示如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。</p>
<p><code>SUPPORTS</code>：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；</p>
<p><code>MANDATORY</code>：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；</p>
<p><code>REQUIRES_NEW</code>：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；</p>
<p><code>NOT_SUPPORTED</code>：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；</p>
<p><code>NEVER</code>：和<code>NOT_SUPPORTED</code>相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；</p>
<p><code>NESTED</code>：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。</p>
<blockquote>
<p><strong>Spring使用ThreadLocal获知当前是否存在事务</strong></p>
<p>Spring将JDBC相关的<code>Connection</code>和<code>TransactionStatus</code>实例绑定到<code>ThreadLocal</code>。如果一个事务方法从<code>ThreadLocal</code>未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从<code>ThreadLocal</code>获取的JDBC连接以及<code>TransactionStatus</code>。</p>
<p>因此，事务能正确传播的前提是，方法调用必须在一个线程内。</p>
</blockquote>
<h3 id="结合Hibernate"><a href="#结合Hibernate" class="headerlink" title="结合Hibernate"></a>结合Hibernate</h3><p>将关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping</p>
<p>对于表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    createdAt <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `email` (`email`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>对于java对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>  <span class="comment">// @Entity 注解标记 User 类为一个实体，表示它对应数据库中的一个表。</span></span><br><span class="line"><span class="meta">@Table(name=&quot;users&quot;)</span>  <span class="comment">// 指定对应的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span>  <span class="comment">// @Id 注解标记 getId() 方法返回的值作为主键。</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// @Column 注解用于映射实体类的属性到数据库表的列。</span></span><br><span class="line">    <span class="comment">// @Column 注解在 getEmail() 方法上，Hibernate 会根据约定推断出对应的字段名为 email (去掉get，并将首字母小写)。</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个属性到数据库列的映射用<code>@Column()</code>标识，<code>nullable</code>指示列是否允许为<code>NULL</code>，<code>updatable</code>指示该列是否允许被用在<code>UPDATE</code>语句，<code>length</code>指示<code>String</code>类型的列的长度（如果没有指定，默认是<code>255</code>）。</p>
<p>对于主键，还需要用<code>@Id</code>标识，自增主键再追加一个<code>@GeneratedValue</code>，以便Hibernate能读取到自增主键的值。</p>
<blockquote>
<p>Hibernate 使用反射机制来访问和操作实体类的字段。@Column 注解标注在 getter 方法上只是一种便捷的声明方式，它实际上是告诉 Hibernate “这个 getter 方法对应的字段需要映射到数据库的列”。</p>
<p>Hibernate 使用一种基于约定的命名策略。它会查找符合 JavaBean 规范的 getter&#x2F;setter 方法，并根据方法名推断出对应的字段名。</p>
<p>具体规则如下:</p>
<ul>
<li>对于 getter 方法，去掉 get 或 is 前缀，并将剩余部分的首字母小写。例如，getEmail() 对应字段 email，isActivated() 对应字段 activated。</li>
<li>对于 setter 方法，去掉 set 前缀，并将剩余部分的首字母小写。例如，setEmail(String email) 对应字段 email。</li>
</ul>
</blockquote>
<p>可通过继承映射超类实现子类的映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span>  <span class="comment">// 映射超类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span>  <span class="comment">// 暫く，要求 JPA 忽略该字段，不要将其持久化到数据库中。这意味着 createdDateTime 字段不会在数据库表中拥有对应的列。</span></span><br><span class="line">    <span class="keyword">public</span> ZonedDateTime <span class="title function_">getCreatedDateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(<span class="built_in">this</span>.createdAt).atZone(ZoneId.systemDefault());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrePersist</span>  <span class="comment">// 指定在实体持久化到数据库之前要执行的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        setCreatedAt(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建</p>
<p>SessionFactory 是一个重量级对象，通常在应用启动时创建一次，并在线程之间共享。它用于创建 Session 对象。</p>
<p>Session 是一个轻量级对象，代表与数据库的一次交互。每次操作数据库都需要创建一个新的 Session 对象。在Spring架构中通过SessionFactory Bean的注入获得Session Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span> <span class="comment">// 使用 classpath</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span> String jdbcUrl,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span> String jdbcUsername,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span> String jdbcPassword)</span> &#123;</span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">        dataSource.setUrl(jdbcUrl);</span><br><span class="line">        dataSource.setUsername(jdbcUsername);</span><br><span class="line">        dataSource.setPassword(jdbcPassword);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里创建了 LocalSessionFactoryBean 对象，在类中要求注入时，会注入 SessionFactory 对象，由于 SessionFactory 对象是单例Bean，故 SessionFactory 并没有被反复创建注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    LocalSessionFactoryBean <span class="title function_">createSessionFactory</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">LocalSessionFactoryBean</span> <span class="variable">sessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalSessionFactoryBean</span>();</span><br><span class="line">        sessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sessionFactoryBean.setPackagesToScan(<span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>); <span class="comment">// 扫描 Entity 类</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>); <span class="comment">// 或 create-drop, validate</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.dialect&quot;</span>, <span class="string">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>); <span class="comment">// 根据数据库选择方言</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        sessionFactoryBean.setHibernateProperties(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> LocalSessionFactoryBean sessionFactoryBean)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取 SessionFactory 对象</span></span><br><span class="line">        <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> sessionFactoryBean.getObject();  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HibernateTransactionManager</span>(sessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>LocalSessionFactoryBean </code>是 Spring 提供的一个用于创建和配置 Hibernate <code>SessionFactory </code>的工厂 bean，实际上按照逻辑而言，<code>LocalSessionFactoryBean </code>应该为<code>SessionFactory FactoryBean </code>，因为它创建的是<code>SessionFactory </code> 。一般而言，<code>SessionFactory </code> 在创建后为单例 bean，不会出现创建多个<code>SessionFactory </code>的情况。在类需要使用<code>SessionFactory </code>时，Spring 注入<code>SessionFactory </code></p>
<p><strong>如果我们每个类需要的是Session，为什么我们不直接使用<code>SessionFactoryBean </code>注入原型 Session Bean到每个类中呢？</strong></p>
<ol>
<li><strong>Session 的生命周期管理困难:</strong> Session 代表与数据库的一次会话，它的生命周期应该与特定的操作（例如一次数据库事务）绑定。 如果将 Session 作为原型 bean 注入，就需要手动管理 Session 的生命周期，包括创建、关闭和事务管理。 这会使代码变得复杂，容易出错，并且难以维护。</li>
<li><strong>线程安全问题:</strong> Session 不是线程安全的。 如果将原型 Session bean 注入到单例 bean 中，并且在并发环境下使用，可能会导致数据不一致或其他并发问题。</li>
<li><strong>资源管理问题:</strong> Session 持有数据库连接等资源。 如果不正确地管理 Session 的生命周期，可能会导致资源泄露。</li>
<li><strong>违反 Hibernate 的设计理念:</strong> Hibernate 的设计理念是将 Session 的生命周期与事务绑定。 通过 SessionFactory.openSession() 或 SessionFactory.getCurrentSession() 获取 Session，可以确保 Session 的生命周期与事务同步，并由 Hibernate 管理资源。 直接注入 Session bean 会破坏这种设计。</li>
</ol>
</blockquote>
<p>CRUD</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 启用声明式事务管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setEmail(email);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setCreatedAt(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession(); <span class="comment">// 获取当前 Session</span></span><br><span class="line">        session.persist(user);</span><br><span class="line">        <span class="keyword">return</span> user; <span class="comment">// 不需要手动 commit，Spring 会自动处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span> <span class="comment">// 只读事务</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="keyword">return</span> session.get(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span> <span class="comment">// 只读事务</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="keyword">return</span> session.createQuery(<span class="string">&quot;FROM User&quot;</span>, User.class).list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id, String name)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, id);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            user.setName(name);</span><br><span class="line">            session.merge(user); <span class="comment">// 或 session.update(user)</span></span><br><span class="line">            <span class="comment">// 不需要手动 commit，Spring 会自动处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理用户不存在的情况...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, id);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            session.delete(user);</span><br><span class="line">            <span class="comment">// 不需要手动 commit，Spring 会自动处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用DAO层代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">get</span><span class="params">(Long id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line">	<span class="comment">// session在这里使用~</span></span><br><span class="line">    <span class="comment">// ... 实现 UserDao 接口中的方法，进行数据库操作 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 使用 userDao 获得数据 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结合MyBatis"><a href="#结合MyBatis" class="headerlink" title="结合MyBatis"></a>结合MyBatis</h3><p>@Mapper 注解</p>
<ul>
<li><strong>自动生成 Mapper 接口的实现类:</strong> @Mapper 注解会告诉 MyBatis 为标注的接口生成一个实现类，并将该实现类注册到 Spring 容器中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RuleTreeNodeDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询规则树节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeId    规则树ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          规则树节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;RuleTreeNodePO&gt; <span class="title function_">queryRuleTreeNodeList</span><span class="params">(Long treeId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询规则树节点数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeId    规则树ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          节点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">queryTreeNodeCount</span><span class="params">(Long treeId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询规则树节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeId    规则树ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;RuleTreeNodePO&gt; <span class="title function_">queryTreeRulePoint</span><span class="params">(Long treeId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>映射 SQL 语句:</strong> MyBatis 使用 XML 文件或注解的方式将 SQL 语句与 Java 方法关联起来。例如，queryRuleTreeNodeList 方法会对应一个 SQL 查询语句，该语句用于查询规则树节点。</p>
<p><strong>参数绑定:</strong> MyBatis 会将 Java 方法的参数绑定到 SQL 语句中的参数占位符。例如，queryRuleTreeNodeList 方法的 treeId 参数会被绑定到 SQL 语句中的 #{treeId} 占位符。</p>
<p><strong>结果映射:</strong> MyBatis 会将 SQL 查询结果映射到 Java 对象。例如，queryRuleTreeNodeList 方法的返回值类型是 <code>List&lt;RuleTreeNodePO&gt;</code>，MyBatis 会将查询结果的每一行映射到一个 <code>RuleTreeNodePO</code> 对象，并将这些对象添加到一个 List 中返回。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.bugstack.xfg.frame.infrastructure.dao.RuleTreeNodeDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;ruleTreeNodeMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;cn.bugstack.xfg.frame.infrastructure.po.RuleTreeNodePO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tree_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;treeId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;node_type&quot;</span> <span class="attr">property</span>=<span class="string">&quot;nodeType&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;node_value&quot;</span> <span class="attr">property</span>=<span class="string">&quot;nodeValue&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;rule_key&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ruleKey&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;rule_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ruleDesc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryRuleTreeNodeList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ruleTreeNodeMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT id, tree_id, node_type, node_value, rule_key, rule_desc</span><br><span class="line">        FROM rule_tree_node</span><br><span class="line">        where tree_id = #&#123;treeId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryTreeNodeCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        select count(id) from rule_tree_node where tree_id = #&#123;treeId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryTreeRulePoint&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ruleTreeNodeMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT distinct (rule_key), rule_desc</span><br><span class="line">        FROM rule_tree_node</span><br><span class="line">        where tree_id = #&#123;treeId&#125; and rule_key is not null</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="JDBC与Hibernate-JPA-MyBatis"><a href="#JDBC与Hibernate-JPA-MyBatis" class="headerlink" title="JDBC与Hibernate, JPA, MyBatis"></a>JDBC与Hibernate, JPA, MyBatis</h3><p>ORM，也是建立在JDBC的基础上，通过ResultSet到JavaBean的映射，实现各种查询。有自动跟踪Entity修改的全自动化ORM如Hibernate和JPA，需要为每个Entity创建代理，也有完全自己映射，连INSERT和UPDATE语句都需要手动编写的MyBatis，但没有任何透明的Proxy。</p>
<h3 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h3><p>在Bean内使用 <code>@Transactional</code> 注解是最推荐的方式，基于AOP实现</p>
<p>注意以下几点：</p>
<ul>
<li><strong>被 @Transactional 注解的方法不能是 private 的</strong> Spring AOP 的代理机制无法拦截 private 方法，因此 @Transactional 注解在 private 方法上不会生效。</li>
<li><strong>方法内使用 try-catch 处理异常</strong> 可以在 @Transactional 方法内部使用 try-catch 块来处理异常。但是，如果捕获了异常并且<strong>没有重新抛出</strong>，Spring 的事务管理机制就无法感知到异常的发生，从而导致事务不会回滚。 如果希望事务在特定异常发生时回滚，你需要在 catch 块中重新抛出异常，或者抛出一个 Spring 能够识别的异常类型（例如 RuntimeException 或其子类）。</li>
<li><strong>方法抛出的异常是 RuntimeException</strong> Spring 的事务管理机制默认只对 RuntimeException（运行时异常）及其子类进行回滚。 但是，你可以通过 @Transactional 注解的 rollbackFor 属性来指定需要回滚的其他异常类型。 例如，你可以指定 rollbackFor &#x3D; Exception.class 来让事务在任何异常发生时都回滚。 你也可以使用 noRollbackFor 属性来指定不回滚的异常类型。</li>
</ul>
<h2 id="Spring-网络相关"><a href="#Spring-网络相关" class="headerlink" title="Spring 网络相关"></a>Spring 网络相关</h2><p>标准的Maven Web工程目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">spring-web-mvc</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java  // Spring配置类</span><br><span class="line">        │               ├── DatabaseInitializer.java</span><br><span class="line">        │               ├── entity</span><br><span class="line">        │               │   └── User.java</span><br><span class="line">        │               ├── service</span><br><span class="line">        │               │   └── UserService.java</span><br><span class="line">        │               └── web</span><br><span class="line">        │                   └── UserController.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   ├── jdbc.properties  // 数据库连接配置文件，包含数据库URL、用户名、密码等信息。</span><br><span class="line">        │   └── logback.xml  // 日志配置文件，配置日志输出格式、级别等。</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   ├── templates</span><br><span class="line">            │   │   ├── _base.html</span><br><span class="line">            │   │   ├── index.html</span><br><span class="line">            │   │   ├── profile.html</span><br><span class="line">            │   │   ├── register.html</span><br><span class="line">            │   │   └── signin.html</span><br><span class="line">            │   └── web.xml  // 指导 Web 容器（例如 Tomcat）如何部署和运行应用, 一般包含Servlet信息,servlet-mapping信息, Filter信息, welcome页面信息.</span><br><span class="line">            └── static</span><br><span class="line">                ├── css</span><br><span class="line">                │   └── bootstrap.css</span><br><span class="line">                └── js</span><br><span class="line">                    └── jquery.js</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Web MVC 的标准做法，通常只有一个 Servlet, 多个 Filter, </p>
</blockquote>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p> <strong>传统的部署方式 (WAR包部署到外部Tomcat):</strong></p>
<ol>
<li><strong>构建WAR包:</strong> 使用Maven或Gradle等构建工具将Spring MVC项目打包成WAR文件。</li>
<li><strong>部署WAR包:</strong> 将WAR文件复制到Tomcat的webapps目录下。</li>
<li><strong>Tomcat启动:</strong> 启动Tomcat服务器。</li>
<li><strong>WAR包解压:</strong> Tomcat会自动解压WAR文件，创建一个同名的Web应用目录。</li>
<li><strong>读取web.xml:</strong> Tomcat读取Web应用目录下的WEB-INF&#x2F;web.xml文件。</li>
<li><strong>初始化DispatcherServlet:</strong> Tomcat根据web.xml中的配置，初始化DispatcherServlet。</li>
<li><strong>创建WebApplicationContext:</strong> DispatcherServlet初始化时，会根据contextConfigLocation参数指定的配置类（例如AppConfig）创建WebApplicationContext（Spring的IoC容器）。</li>
<li><strong>扫描和初始化Bean:</strong> WebApplicationContext会扫描指定的包，查找并初始化所有带有@Component、@Service、@Repository、@Controller等注解的Bean。</li>
<li><strong>初始化其他组件:</strong> WebApplicationContext还会初始化Spring MVC的其他组件，例如HandlerMapping、ViewResolver等。</li>
<li><strong>应用启动完成:</strong> Tomcat完成Web应用的启动，DispatcherServlet准备好接收HTTP请求。</li>
</ol>
<p><strong>嵌入式Tomcat:</strong></p>
<ol>
<li><strong>添加依赖:</strong> 在pom.xml中添加Spring Boot Starter Web依赖，该依赖包含了嵌入式Tomcat。</li>
<li><strong>编写启动类:</strong> 创建一个带有main()方法的启动类，使用@SpringBootApplication注解标记。</li>
<li><strong>运行main()方法:</strong> 运行启动类的main()方法。</li>
<li><strong>Spring Boot初始化:</strong> Spring Boot会进行自动配置，根据classpath中的依赖自动配置Spring MVC、嵌入式Tomcat等组件。</li>
<li><strong>启动嵌入式Tomcat:</strong> Spring Boot启动嵌入式Tomcat服务器。</li>
<li><strong>创建WebApplicationContext:</strong> 与传统方式类似，Spring Boot会创建WebApplicationContext。</li>
<li><strong>扫描和初始化Bean:</strong> WebApplicationContext扫描并初始化Bean。</li>
<li><strong>初始化DispatcherServlet:</strong> Spring Boot将DispatcherServlet注册到嵌入式Tomcat中。</li>
<li><strong>应用启动完成:</strong> 嵌入式Tomcat启动完成，DispatcherServlet准备好接收HTTP请求。</li>
</ol>
<blockquote>
<p>该方式完全运行在一个JVM内部</p>
<ul>
<li><strong>Spring Boot应用管理嵌入式Tomcat的生命周期:</strong> Spring Boot应用负责启动、停止和配置嵌入式Tomcat。</li>
<li><strong>嵌入式Tomcat提供Servlet容器的功能:</strong> 嵌入式Tomcat负责接收HTTP请求、管理Servlet生命周期、处理Servlet请求等。</li>
<li><strong>DispatcherServlet是运行在嵌入式Tomcat中的一个Servlet:</strong> DispatcherServlet依赖于嵌入式Tomcat提供的Servlet容器功能，它被注册到嵌入式Tomcat中，由嵌入式Tomcat负责调用它的service()方法来处理请求。</li>
</ul>
<p>DispatcherServlet的实例是由嵌入式Tomcat创建的，但它的初始化和配置是由Spring Boot完成的。 Spring Boot会将DispatcherSeHrvlet注册到嵌入式Tomcat中，并将其与Spring的WebApplicationContext关联起来。 这样，DispatcherServlet就可以访问Spring容器中的Bean，并使用Spring MVC的功能来处理请求。</p>
</blockquote>
<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><p><code>HandlerMapping</code>在Spring应用程序启动时进行初始化。它会扫描整个项目，缓存所有带有相关注解（如<code>@RequestMapping</code>、<code>@GetMapping</code>等）的Controller方法的<code>request</code>-<code>handler</code>映射到<code>HandlerMapping</code>的bean中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class="line">  ┌─────────────────────┐        ┌───────────┐   │</span><br><span class="line">│ │DelegatingFilterProxy│─│─│─ ─▶│AuthFilter │</span><br><span class="line">  └─────────────────────┘        └───────────┘   │</span><br><span class="line">│ ┌─────────────────────┐ │ │    ┌───────────┐</span><br><span class="line">  │  DispatcherServlet  │─ ─ ─ ─▶│Controllers│   │</span><br><span class="line">│ └─────────────────────┘ │ │    └───────────┘</span><br><span class="line">                                                 │</span><br><span class="line">│    Servlet Container    │ │  Spring Container</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>



<h3 id="REST-架构风格"><a href="#REST-架构风格" class="headerlink" title="REST 架构风格"></a>REST 架构风格</h3><p>REST（Representational State Transfer）是一种设计 Web 服务的架构风格，它强调客户端和服务器之间的交互应该围绕 <strong>资源</strong> 展开，并使用标准的 HTTP 方法来操作这些资源。</p>
<ul>
<li><strong>资源（Resources）：</strong> REST 架构的核心是资源。任何可以被命名的信息都可以被认为是一个资源，例如一个文档、一张图片、一个用户、一个订单等。每个资源都有一个唯一的标识符（URI）。</li>
<li><strong>表述（Representations）：</strong> 资源的表述是资源在某个特定时刻的状态的展现形式。它可以是各种格式，例如 JSON、XML、HTML 等。客户端通过获取资源的表述来了解资源的状态。</li>
<li><strong>状态转移（State Transfer）：</strong> 客户端通过 HTTP 方法（例如 GET、POST、PUT、DELETE）与服务器交互，从而改变资源的状态。这些 HTTP 方法对应着不同的操作：<ul>
<li><strong>GET:</strong> 获取资源的表述。</li>
<li><strong>POST:</strong> 创建新的资源。</li>
<li><strong>PUT:</strong> 更新现有资源。</li>
<li><strong>DELETE:</strong> 删除资源。</li>
</ul>
</li>
<li><strong>无状态（Stateless）：</strong> RESTful API 是无状态的，这意味着每个请求都包含了处理该请求所需的全部信息。服务器不存储客户端的任何状态信息，每个请求都是独立的。</li>
</ul>
<table>
<thead>
<tr>
<th>HTTP 方法</th>
<th>REST 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取资源</td>
<td>获取资源的表述</td>
</tr>
<tr>
<td>POST</td>
<td>创建资源</td>
<td>创建新的资源</td>
</tr>
<tr>
<td>PUT</td>
<td>更新资源</td>
<td>替换整个资源</td>
</tr>
<tr>
<td>PATCH</td>
<td>部分更新资源</td>
<td>更新资源的一部分</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
<td>删除资源</td>
</tr>
</tbody></table>
<p><strong>RESTful 请求</strong>是指符合 REST 架构风格的 HTTP 请求。它通常包含以下部分：</p>
<ul>
<li><strong>URL：</strong> 指向要操作的资源的唯一地址。</li>
<li><strong>HTTP 方法：</strong> 指示要执行的操作（GET、POST、PUT、DELETE 等）。</li>
<li><strong>请求头：</strong> 包含一些元数据，例如内容类型、授权信息等。</li>
<li><strong>请求体：</strong> 对于 POST 和 PUT 请求，可能包含要创建或更新的资源的数据。</li>
</ul>
<p><strong>例如：</strong></p>
<p>一个获取用户信息的 RESTful 请求可能是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /users/123</span><br></pre></td></tr></table></figure>









<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/index.html">https://liaoxuefeng.com/books/java/springboot/index.html</a></p>
<p>这些自动创建的Bean就是Spring Boot的特色：AutoConfiguration。</p>
<p>当我们引入<code>spring-boot-starter-jdbc</code>时，启动时会自动扫描所有的<code>XxxAutoConfiguration</code>：</p>
<ul>
<li><code>DataSourceAutoConfiguration</code>：自动创建一个<code>DataSource</code>，其中配置项从<code>application.yml</code>的<code>spring.datasource</code>读取；</li>
<li><code>DataSourceTransactionManagerAutoConfiguration</code>：自动创建了一个基于JDBC的事务管理器；</li>
<li><code>JdbcTemplateAutoConfiguration</code>：自动创建了一个<code>JdbcTemplate</code>。</li>
</ul>
<p>因此，我们自动得到了一个<code>DataSource</code>、一个<code>DataSourceTransactionManager</code>和一个<code>JdbcTemplate</code>。</p>
<p>类似的，当我们引入<code>spring-boot-starter-web</code>时，自动创建了：</p>
<ul>
<li><code>ServletWebServerFactoryAutoConfiguration</code>：自动创建一个嵌入式Web服务器，默认是Tomcat；</li>
<li><code>DispatcherServletAutoConfiguration</code>：自动创建一个<code>DispatcherServlet</code>；</li>
<li><code>HttpEncodingAutoConfiguration</code>：自动创建一个<code>CharacterEncodingFilter</code>；</li>
<li><code>WebMvcAutoConfiguration</code>：自动创建若干与MVC相关的Bean。</li>
<li>…</li>
</ul>
<p>引入第三方<code>pebble-spring-boot-starter</code>时，自动创建了：</p>
<ul>
<li><code>PebbleAutoConfiguration</code>：自动创建了一个<code>PebbleViewResolver</code>。</li>
</ul>
<h2 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h2><p>基于 Spring Boot 应用程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     SpringApplication.run(Application.class, args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 容器的创建是通过 <code>@SpringBootApplication</code> 注解触发的，它实际上是一个组合注解，包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</p>
<p>**<code>SpringApplication.run()</code>**：这是 Spring Boot 应用程序的入口。这个方法启动了 Spring Boot 应用，并创建了 IoC 容器。<code>@SpringBootApplication</code> 会自动扫描指定的包路径下的所有类，并将它们注册到 IoC 容器中。</p>
<p>@Configurable</p>
<p>@Configurable 允许将 Spring 管理的 Bean 注入到通过 new 关键字创建的对象中。这在一些情况下非常有用，例如在使用遗留代码或无法直接使用 Spring 管理的库时。</p>
<p>被添加 @Configurable 注解的类，在被new创建时，AspectJ 的代码会拦截对象的创建过程，并使用 Spring 的 BeanFactory 将依赖注入到对象中（即不会new出新对象，将从Spring中获得已经创建的该类型的Bean作为new的结果）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        repository.save(<span class="string">&quot;some data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他地方使用 new 创建对象</span></span><br><span class="line"><span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">service.doSomething(); <span class="comment">// repository 已经被注入，可以正常使用</span></span><br></pre></td></tr></table></figure>



<p>@ConfigurationProperties</p>
<p>读取指定配置文件，将配置文件中相应的值注入到Bean中</p>
<blockquote>
<p>配置文件搜索位置</p>
<p>打包在应用程序中的特定于配置文件的应用程序属性（application-{profile}.properties 和 YAML 变体）</p>
<p>打包在应用程序中的应用程序属性（application.properties 和 YAML 变体）</p>
</blockquote>
<p>假设有以下配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件：application.properties  yml格式</span></span><br><span class="line"><span class="attr">rate-limiter:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">unknown-property:</span> <span class="string">some-value</span></span><br></pre></td></tr></table></figure>

<p>以及以下 Java Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：RateLimiterAopConfigProperties.java</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;rate-limiter&quot;, ignoreInvalidFields = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">200</span>;  <span class="comment">// 默认值200，会被配置文件覆盖</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters for enabled and limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 ignoreInvalidFields &#x3D; true，unknown-property 将会被忽略，而 enabled 和 limit 将分别被设置为 true 和 100。</p>
<p>@EnableConfigurationProperties(…)</p>
<p>将一个类作为配置属性类，并启用属性绑定；<strong>被指定作为配置属性类可以没有任何 Spring 注解</strong></p>
<p>@Component + @ConfigurationProperties 的配置属性类 等于 @EnableConfigurationProperties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AliPayConfigProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPayConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;alipayClient&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AlipayClient <span class="title function_">alipayClient</span><span class="params">(AliPayConfigProperties properties)</span> &#123;  <span class="comment">// bean对象被注入作为传入参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(properties.getGatewayUrl(),</span><br><span class="line">                properties.getApp_id(),</span><br><span class="line">                properties.getMerchant_private_key(),</span><br><span class="line">                properties.getFormat(),</span><br><span class="line">                properties.getCharset(),</span><br><span class="line">                properties.getAlipay_public_key(),</span><br><span class="line">                properties.getSign_type());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><h2 id="retrofit"><a href="#retrofit" class="headerlink" title="retrofit"></a>retrofit</h2><p>Retrofit 是一个用于 Android 和 Java 的类型安全的 HTTP 客户端，它通过将 HTTP API 转换为 Java 接口，简化了网络请求的编写和管理。它利用注解来描述 HTTP 请求，并使用 OkHttp 库执行实际的网络操作。</p>
<p>一个Retrofit的Call对象通常只对应<strong>一次HTTP请求和一次HTTP响应</strong></p>
<p>Call&lt;T&gt; 的泛型T是用来指定该 HTTP 请求成功后，预期从服务器接收到的数据类型</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 API 接口，使用接口定义网络请求</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 @GET 注解指定 GET 请求，@Path 注解用于替换 URL 路径中的占位符 &#123;id&#125;</span></span><br><span class="line">    <span class="meta">@GET(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Query 注解添加查询参数</span></span><br><span class="line">    <span class="meta">@GET(&quot;/users&quot;)</span></span><br><span class="line">    Call&lt;List&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">(<span class="meta">@Query(&quot;page&quot;)</span> <span class="type">int</span> page, <span class="meta">@Query(&quot;per_page&quot;)</span> <span class="type">int</span> perPage)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @QueryMap 注解添加多个查询参数，以 Map 的形式传递</span></span><br><span class="line">    <span class="meta">@GET(&quot;/users&quot;)</span></span><br><span class="line">    Call&lt;List&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">(<span class="meta">@QueryMap</span> Map&lt;String, String&gt; options)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @POST 注解指定 POST 请求，@Headers 注解添加静态请求头, @Body 注解用于发送请求体，即被标记传入参数会直接作为post报文体</span></span><br><span class="line">    <span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line">    <span class="meta">@Headers(&#123;</span></span><br><span class="line"><span class="meta">            &quot;Content-Type: application/json&quot;,</span></span><br><span class="line"><span class="meta">            &quot;Accept: application/json&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Body</span> User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @FormUrlEncoded 注解指定 POST 请求的编码类型为 application/x-www-form-urlencoded，@Field 注解添加表单数据，即被标记的传入参数会拼接，作为post报文体</span></span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Field(&quot;name&quot;)</span> String name, <span class="meta">@Field(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @FieldMap 注解添加多个表单数据，以 Map 的形式传递</span></span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@FieldMap</span> Map&lt;String, String&gt; fields)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Multipart 注解指定 POST 请求为多部分请求，@Part 注解用于多部分请求中的每个部分；请求体会被分割成多个部分，每个部分都包含自己的内容类型、头部信息和数据；按照@Part进行切割，即file为块1，description为块2</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;/upload&quot;)</span></span><br><span class="line">    Call&lt;ResponseBody&gt; <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@Part(&quot;file&quot;)</span> RequestBody file, <span class="meta">@Part(&quot;description&quot;)</span> RequestBody description)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @PartMap 注解添加多个 Part，以 Map 的形式传递；按照一个键值对一块进行切割</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;/upload&quot;)</span></span><br><span class="line">    Call&lt;ResponseBody&gt; <span class="title function_">uploadMultipleFiles</span><span class="params">(<span class="meta">@PartMap</span> Map&lt;String, RequestBody&gt; files)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @PUT 注解指定 PUT 请求</span></span><br><span class="line">    <span class="meta">@PUT(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> <span class="type">int</span> id, <span class="meta">@Body</span> User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @DELETE 注解指定 DELETE 请求，@Header 注解添加动态请求头</span></span><br><span class="line">    <span class="meta">@DELETE(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    Call&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> <span class="type">int</span> id, <span class="meta">@Header(&quot;Authorization&quot;)</span> String authToken)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetrofitExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 拦截器 拦截的是 OkHttp 发出的网络请求</span></span><br><span class="line">        <span class="comment">// 创建 HttpLoggingInterceptor，用于打印请求和响应的日志</span></span><br><span class="line">        <span class="type">HttpLoggingInterceptor</span> <span class="variable">loggingInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpLoggingInterceptor</span>();</span><br><span class="line">        loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); <span class="comment">// 设置日志级别为 BODY，打印请求和响应体</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建自定义拦截器，例如添加认证信息</span></span><br><span class="line">        <span class="type">Interceptor</span> <span class="variable">authInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">Request</span> <span class="variable">original</span> <span class="operator">=</span> chain.request(); <span class="comment">// 获取原始请求</span></span><br><span class="line">                <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> original.newBuilder() <span class="comment">// 创建新的请求构建器</span></span><br><span class="line">                        .header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer your_token_here&quot;</span>) <span class="comment">// 添加 Authorization 请求头</span></span><br><span class="line">                        .build(); <span class="comment">// 构建新的请求</span></span><br><span class="line">                <span class="keyword">return</span> chain.proceed(request); <span class="comment">// 执行请求</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 OkHttpClient，并添加拦截器</span></span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .addInterceptor(loggingInterceptor) <span class="comment">// 添加日志拦截器</span></span><br><span class="line">                .addInterceptor(authInterceptor) <span class="comment">// 添加认证拦截器</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Retrofit 实例</span></span><br><span class="line">        <span class="comment">// 注意：可以不显式的指定 OkHttpClient 实例，默认会创建</span></span><br><span class="line">        <span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.example.com/&quot;</span>) <span class="comment">// 设置 API 基地址</span></span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 添加 Gson 转换器</span></span><br><span class="line">                .client(okHttpClient) <span class="comment">// 设置 OkHttpClient</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 API 服务</span></span><br><span class="line">        <span class="type">ApiService</span> <span class="variable">apiService</span> <span class="operator">=</span> retrofit.create(ApiService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 GET 请求</span></span><br><span class="line">        Call&lt;User&gt; call = apiService.getUser(<span class="number">123</span>);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;User&gt;() &#123; <span class="comment">// 使用 enqueue() 方法异步执行请求</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> &#123; <span class="comment">// 请求成功的回调</span></span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful()) &#123; <span class="comment">// 检查响应是否成功</span></span><br><span class="line">                    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> response.body(); <span class="comment">// 获取响应体</span></span><br><span class="line">                    System.out.println(user);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Error: &quot;</span> + response.code()); <span class="comment">// 打印错误码</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;User&gt; call, Throwable t)</span> &#123; <span class="comment">// 请求失败的回调</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Failure: &quot;</span> + t.getMessage()); <span class="comment">// 打印错误信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 QueryMap 的示例</span></span><br><span class="line">        Map&lt;String, String&gt; options = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        options.put(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">        options.put(<span class="string">&quot;per_page&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">        Call&lt;List&lt;User&gt;&gt; callWithQueryMap = apiService.getUsers(options);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 FieldMap 的示例</span></span><br><span class="line">        Map&lt;String, String&gt; fields = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        fields.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">        fields.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;john.doe@example.com&quot;</span>);</span><br><span class="line">        Call&lt;User&gt; callWithFieldMap = apiService.createUser(fields);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 其他请求示例</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 User 类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重写 toString 方法，方便打印 User 对象的信息</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                    <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于 Multipart 请求的 RequestBody 接口 (需要添加 okhttp3 依赖)</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">RequestBody</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于接收响应体的 ResponseBody 接口 (需要添加 okhttp3 依赖)</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">ResponseBody</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h2><p>Guava 是 Google 开发的一个 Java 核心库，它提供了一组常用的实用工具类、扩展类和数据结构，旨在提高 Java 代码的效率、可读性和可维护性。Guava 的设计理念是补充 JDK 的不足，提供一些 JDK 缺少的功能，并对一些 JDK 中已有的功能进行改进和优化。</p>
<p><strong>缓存 (Caching):</strong> 提供了强大的缓存功能，支持多种缓存策略，例如：</p>
<ul>
<li>CacheBuilder: 用于构建缓存实例。</li>
<li>LoadingCache: 在缓存未命中时自动加载数据的缓存。</li>
</ul>
<p><strong>事件总线 (EventBus):</strong> 实现了发布-订阅模式，</p>
<p>…</p>
<h2 id="Spring-Security-jwt"><a href="#Spring-Security-jwt" class="headerlink" title="Spring Security &amp; jwt"></a>Spring Security &amp; jwt</h2><p><strong>客户端接收JWT：</strong> 服务器将生成的JWT返回给客户端，通常放在HTTP Authorization header中，使用Bearer scheme。例如：Authorization: Bearer &lt;token&gt;。</p>
<p><strong>客户端携带JWT：</strong> 客户端在后续的请求中，将JWT添加到Authorization header中，发送给服务器。 JWT可以存储在客户端的localStorage、cookie或session storage中。</p>
<h3 id="jwt生成流程"><a href="#jwt生成流程" class="headerlink" title="jwt生成流程"></a>jwt生成流程</h3><ol>
<li>服务器<strong>分别</strong>对头部和载荷进行 <strong>Base64Url 编码</strong> 。</li>
<li>将编码后的头部和载荷用 . 拼接在一起，例如 encodedHeader.encodedPayload。</li>
<li>将拼接后的字符串作为输入，<strong>使用密钥和指定的签名算法 (例如 HS256, RS256) 进行签名</strong>，得到一个签名值。 这个过程不是“加密”，更准确地说是“生成签名”。 对于HS256，是进行HMAC-SHA256哈希运算；对于RS256，是使用RSA私钥对数据进行签名。</li>
<li>将签名值进行 <strong>Base64Url 编码</strong>。</li>
<li>最终的JWT是由 <strong>编码后的头部、编码后的载荷和编码后的签名</strong> 三部分用 . 连接而成，例如 encodedHeader.encodedPayload.encodedSignature。</li>
</ol>
<h3 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h3><p>在 Spring MVC 项目中，DispatcherServlet 是唯一的 Servlet，它充当前端控制器，负责接收所有请求并分发给相应的 Spring Bean（例如 Controller）进行处理。</p>
<p>Spring Security Filter 在 Servlet 容器（例如 Tomcat）的过滤器链中进行注册</p>
<p>客户端 –&gt; Nginx –&gt; Tomcat –&gt; Filter 1(Tomcat Filter) –&gt; Filter 2 –&gt; … –&gt; Spring Security Filter –&gt; … –&gt; DispatcherServlet –&gt; Controller</p>
<ol>
<li><strong>网络层:</strong><ul>
<li><strong>负载均衡器 (Load Balancer，可选):</strong> 如果服务器集群有多台机器，负载均衡器会将请求分发到其中一台服务器。</li>
<li><strong>反向代理 (Reverse Proxy，可选):</strong> 反向代理服务器可以作为服务器的前置，处理一些通用的任务，例如缓存、SSL 加密&#x2F;解密、负载均衡等。例如 Nginx、Apache。</li>
</ul>
</li>
<li><strong>Servlet 容器 (例如 Tomcat、Jetty、Undertow):</strong><ul>
<li><strong>连接器 (Connector):</strong> 接收客户端的连接请求，并将其转换为 Servlet 容器可以处理的请求对象。</li>
<li><strong>引擎 (Engine):</strong> 负责处理所有请求。</li>
<li><strong>主机 (Host):</strong> 基于域名或 IP 地址将请求路由到相应的虚拟主机。</li>
<li><strong>上下文 (Context):</strong> 代表一个 Web 应用程序，包含 Servlet、过滤器、监听器等组件。</li>
</ul>
</li>
<li><strong>Spring Security 过滤器链 (Filter Chain):</strong><ul>
<li>请求进入 Servlet 容器后，会先经过一系列的过滤器。过滤器可以对请求进行预处理或后处理，例如身份验证、授权、日志记录、数据转换等。</li>
<li>过滤器链的执行顺序由 web.xml 或 Spring Security 配置决定。</li>
</ul>
</li>
<li><strong>Servlet (例如 Spring MVC 的 DispatcherServlet):</strong><ul>
<li>DispatcherServlet 是 Spring MVC 框架的核心组件，它负责将请求分发到相应的 Controller。</li>
<li>DispatcherServlet 会根据请求的 URL 和配置的处理器映射 (Handler Mapping) 找到对应的 Controller 方法。</li>
</ul>
</li>
<li><strong>拦截器 (Interceptor，可选):</strong><ul>
<li>拦截器可以在 Controller 方法执行前后进行一些处理，例如性能监控、日志记录等。</li>
</ul>
</li>
<li><strong>Controller:</strong><ul>
<li>Controller 接收请求参数，调用业务逻辑，并返回 ModelAndView 对象。</li>
</ul>
</li>
</ol>
<p>先身份验证，再权限判断</p>
<h3 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h3><p><strong>带 JWT 请求的流程</strong></p>
<ol>
<li><strong>请求到达 <code>JwtRequestFilter</code></strong><ul>
<li>当用户发送一个带 JWT 的请求时，Spring Security 会首先通过 <code>JwtRequestFilter</code> 过滤器。</li>
<li><code>JwtRequestFilter</code> 会检查请求中的 Authorization 头部，提取 JWT 并验证其合法性。</li>
</ul>
</li>
<li><strong>JWT 验证</strong><ul>
<li><code>JwtRequestFilter</code> 会验证 JWT 是否有效（例如是否过期、是否篡改），并从中解析出用户的身份信息（如用户名）。</li>
<li>如果验证成功，<code>JwtRequestFilter</code> 会创建一个 <code>UsernamePasswordAuthenticationToken</code> 对象，该对象包含从 JWT 中解析出来的用户信息（如用户名）。</li>
<li><code>UsernamePasswordAuthenticationToken</code> 对象将被存储到 <code>SecurityContextHolder</code> 中，这样 Spring Security 就知道当前请求的用户身份。</li>
</ul>
</li>
<li><strong><code>SecurityContextHolder</code> 中的身份信息</strong><ul>
<li>由于用户身份已经通过 JWT 被验证，<code>SecurityContextHolder</code> 中的 <code>Authentication</code> 对象已包含了有效的身份信息。接下来的授权处理（如访问控制）会基于这个 <code>Authentication</code> 对象，而不需要重新通过 <code>AuthenticationManager</code> 进行身份验证。</li>
</ul>
</li>
<li><strong>授权过程（权限验证）</strong><ul>
<li>一旦身份信息存储在 <code>SecurityContextHolder</code> 中，Spring Security 会进行授权处理（根据用户的角色、权限等判断是否允许访问资源）。如果 JWT 解析成功且验证通过，Spring Security 会基于 <code>GrantedAuthority</code>（用户的角色和权限）进行权限验证。</li>
</ul>
</li>
<li><strong>无 <code>UsernamePasswordAuthenticationFilter</code> 参与</strong><ul>
<li>由于 JWT 已经通过 <code>JwtRequestFilter</code> 进行验证，<code>UsernamePasswordAuthenticationFilter</code> 不会再被触发。因此，整个认证过程不涉及传统的用户名&#x2F;密码验证。</li>
</ul>
</li>
</ol>
<p><strong>不带 JWT 请求的流程</strong></p>
<ol>
<li><strong>请求到达 <code>UsernamePasswordAuthenticationFilter</code></strong><ul>
<li>当用户发送一个不带 JWT 的请求时（通常是通过用户名和密码登录），Spring Security 会通过 <code>UsernamePasswordAuthenticationFilter</code> 来处理该请求。</li>
<li><code>UsernamePasswordAuthenticationFilter</code> 会从请求中获取用户名和密码（通常来自表单提交），并将其封装成一个 <code>UsernamePasswordAuthenticationToken</code> 对象。</li>
</ul>
</li>
<li><strong>身份验证</strong><ul>
<li><code>UsernamePasswordAuthenticationFilter</code> 会将 <code>UsernamePasswordAuthenticationToken</code> 交给 <code>AuthenticationManager</code> 进行身份验证。此时，Spring Security 会调用你在 <code>SecurityConfig</code> 中配置的 <code>userDetailsService</code> 来加载用户信息。</li>
<li>在 <code>userDetailsService.loadUserByUsername()</code> 中，Spring Security 会从数据库中加载用户的用户名、密码和权限信息，并将其封装成 <code>UserDetails</code> 对象返回。</li>
<li><code>AuthenticationManager</code> 会对比请求中提供的密码与数据库中存储的密码（经过加密的），如果密码匹配，身份验证通过。</li>
</ul>
</li>
<li><strong>创建认证对象并存储到 <code>SecurityContextHolder</code></strong><ul>
<li>如果用户名和密码匹配成功，<code>AuthenticationManager</code> 会创建一个 <code>UsernamePasswordAuthenticationToken</code> 对象（包含用户的身份信息和权限）。</li>
<li>然后，<code>UsernamePasswordAuthenticationToken</code> 会被存储到 <code>SecurityContextHolder</code> 中，表示用户已经通过身份验证。</li>
</ul>
</li>
<li><strong>授权过程（权限验证）</strong><ul>
<li>在 <code>SecurityContextHolder</code> 中存储了有效的认证对象后，Spring Security 会根据用户的角色和权限进行授权判断，确保用户有权访问请求的资源。</li>
</ul>
</li>
<li><strong>会话管理与状态管理</strong><ul>
<li>如果你配置了会话管理（例如，<code>sessionCreationPolicy(SessionCreationPolicy.STATELESS)</code>），Spring Security 会根据配置创建相应的会话或确保无状态认证。</li>
</ul>
</li>
</ol>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>在 MyBatis 中，注解 <code>@Select</code> 用来定义 SQL 查询。对于以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM user WHERE user_name = #&#123;username&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">getUserByName</span><span class="params">(String username)</span>;</span><br></pre></td></tr></table></figure>

<p>执行过程</p>
<ol>
<li><strong>查询执行</strong>：当你调用 <code>getUserByName</code> 方法时，MyBatis 将接收传入的 <code>username</code> 参数，并将其注入到 SQL 语句中替换 <code>#&#123;username&#125;</code> 占位符。</li>
<li><strong>SQL 查询</strong>：MyBatis 会在数据库中执行替换后的 SQL 查询。</li>
<li><strong>结果映射</strong>：查询结果将映射到 <code>User</code> 对象。MyBatis 使用 <strong>结果映射</strong> 机制，将查询得到的数据库记录中的字段与 <code>User</code> 类的属性进行匹配。映射的依据通常是字段名称和属性名称相同。</li>
</ol>
<p>结果处理</p>
<ul>
<li><strong>自动映射</strong>：MyBatis 会根据 <code>User</code> 类的属性名称与 <code>SELECT</code> 语句返回的列名称进行映射。例如，如果数据库中的 <code>user</code> 表有 <code>id</code>, <code>user_name</code>, <code>password</code> 等字段，MyBatis 会自动将这些列的值填充到 <code>User</code> 类的 <code>id</code>, <code>userName</code>, <code>password</code> 等相应的属性中。</li>
<li><strong>映射规则</strong>：默认情况下，MyBatis 使用 <strong>驼峰命名规则</strong>，即如果数据库中列的名称是 <code>user_name</code>，它会映射到 Java 类中的 <code>userName</code> 属性。如果属性和列名不匹配，你可能需要使用 <code>@Results</code> 或 XML 配置来手动指定映射关系。</li>
</ul>
<p>结果返回</p>
<ul>
<li><strong>返回对象</strong>：<code>getUserByName</code> 方法会返回一个 <code>User</code> 对象，如果查询到的结果为空，方法将返回 <code>null</code>。</li>
<li><strong>错误处理</strong>：如果查询返回了多行，而该方法定义为返回单个 <code>User</code> 对象，MyBatis 将抛出异常。</li>
</ul>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>DDD结构</p>
<ul>
<li>Domain (领域层)：<ul>
<li>model:<ul>
<li>aggregate (聚合): 核心业务对象，例如订单、用户等。</li>
<li>entity (实体): 具有唯一标识的对象。</li>
<li>valobj (值对象): 描述对象的某个特征，没有唯一标识，例如地址、颜色等。</li>
</ul>
</li>
<li>repository (仓储接口): 定义数据访问接口，具体实现放在基础设施层。</li>
<li>service (领域服务): 处理不属于任何实体或值对象的业务逻辑。</li>
</ul>
</li>
<li>Application (应用层)：协调领域对象完成用户用例，不包含业务逻辑。<ul>
<li>config</li>
<li>Application.java</li>
</ul>
</li>
<li>Infrastructure (基础设施层)：提供技术实现，例如数据库访问、消息队列等。<ul>
<li>dao</li>
<li>redis</li>
<li>gateway<ul>
<li>dto</li>
</ul>
</li>
<li>adapter<ul>
<li>port</li>
<li>repositroy</li>
</ul>
</li>
<li>security</li>
</ul>
</li>
<li>trigger<ul>
<li>http<ul>
<li>httpController.java</li>
</ul>
</li>
<li>job</li>
<li>listener</li>
</ul>
</li>
<li>types<ul>
<li>common</li>
<li>enums</li>
<li>exception</li>
<li>utils</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java-Spring/" rel="tag"># java, Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/08/16/Docker-K8s/" rel="prev" title="Docker/K8s">
      <i class="fa fa-chevron-left"></i> Docker/K8s
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/01/17/ABAP-related/" rel="next" title="ABAP-related">
      ABAP-related <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3"><span class="nav-text">网络相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#servlet"><span class="nav-text">servlet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redirect-%E4%B8%8E-Forward"><span class="nav-text">Redirect 与 Forward</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session-%E4%B8%8E-Cookie"><span class="nav-text">Session 与 Cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSP"><span class="nav-text">JSP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filter"><span class="nav-text">Filter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Listener"><span class="nav-text">Listener</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring"><span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC-%E4%B8%8E-AoP"><span class="nav-text">IoC 与 AoP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC%E5%AE%B9%E5%99%A8%E4%B8%8EIoC%E5%AF%B9%E8%B1%A1"><span class="nav-text">IoC容器与IoC对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource-%E4%B8%8E-Autowired"><span class="nav-text">@Resource 与 @Autowired</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">Bean的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5-%E4%BD%BF%E7%94%A8-Setter-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">使用构造函数注入 &amp;&amp; 使用 Setter 方法注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Component%E6%88%96-Bean%E5%A3%B0%E6%98%8E"><span class="nav-text">使用@Component或@Bean声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%89%E6%96%B9Bean"><span class="nav-text">创建第三方Bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FactoryBean"><span class="nav-text">FactoryBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81"><span class="nav-text">初始化与销毁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">循环依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%E4%B8%8Esetter%E6%B3%A8%E5%85%A5"><span class="nav-text">构造器注入与setter注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">Spring Bean 的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3"><span class="nav-text">数据库相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC"><span class="nav-text">JDBC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD"><span class="nav-text">JDBC事务传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88Hibernate"><span class="nav-text">结合Hibernate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88MyBatis"><span class="nav-text">结合MyBatis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E4%B8%8EHibernate-JPA-MyBatis"><span class="nav-text">JDBC与Hibernate, JPA, MyBatis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Transaction"><span class="nav-text">Spring Transaction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3"><span class="nav-text">Spring 网络相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8"><span class="nav-text">启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerMapping"><span class="nav-text">HandlerMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#REST-%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="nav-text">REST 架构风格</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot"><span class="nav-text">Spring Boot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3-1"><span class="nav-text">注解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%BA%93"><span class="nav-text">常用库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#retrofit"><span class="nav-text">retrofit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Guava"><span class="nav-text">Guava</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Security-jwt"><span class="nav-text">Spring Security &amp; jwt</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jwt%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B"><span class="nav-text">jwt生成流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="nav-text">请求过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B"><span class="nav-text">身份认证流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis"><span class="nav-text">Mybatis</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="nav-text">项目结构</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="marigo1d"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">marigo1d</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/marigo1d" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;marigo1d" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">marigo1d</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">326k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">9:53</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
