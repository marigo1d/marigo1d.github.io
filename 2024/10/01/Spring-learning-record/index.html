<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marigo1d.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Spring相关学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-learning-record">
<meta property="og:url" content="https://marigo1d.github.io/2024/10/01/Spring-learning-record/index.html">
<meta property="og:site_name" content="Marigold">
<meta property="og:description" content="Spring相关学习记录">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-10-01T10:30:43.000Z">
<meta property="article:modified_time" content="2024-10-09T11:23:45.900Z">
<meta property="article:author" content="marigo1d">
<meta property="article:tag" content="java, Spring">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://marigo1d.github.io/2024/10/01/Spring-learning-record/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Spring-learning-record | Marigold</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Marigold</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Salt, Pepper and Birds~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://marigo1d.github.io/2024/10/01/Spring-learning-record/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="marigo1d">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marigold">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring-learning-record
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-01 18:30:43" itemprop="dateCreated datePublished" datetime="2024-10-01T18:30:43+08:00">2024-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-09 19:23:45" itemprop="dateModified" datetime="2024-10-09T19:23:45+08:00">2024-10-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Spring相关学习记录</p>
<span id="more"></span>



<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p>案例</p>
<p><strong>处理 GET 请求的流程举例 (以一个简单的 Java Web 应用为例):</strong></p>
<p>假设用户在浏览器中访问 <a target="_blank" rel="noopener" href="http://www.example.com/products/123%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96%E4%BA%A7%E5%93%81">http://www.example.com/products/123，这是一个获取产品</a> ID 为 123 的产品的 GET 请求。</p>
<ol>
<li><p><strong>客户端 (浏览器) 发起请求:</strong> 浏览器将 GET 请求发送到 <a target="_blank" rel="noopener" href="http://www.example.com./">www.example.com。</a></p>
</li>
<li><p><strong>反向代理服务器 (如果存在):</strong> 反向代理服务器接收请求。它可能执行一些操作，例如检查缓存，如果缓存命中则直接返回结果。如果没有缓存，则将请求转发到 Web 服务器。</p>
</li>
<li><p><strong>Web 服务器 (例如 Apache&#x2F;Nginx):</strong> Web 服务器接收请求，根据配置将请求转发到相应的应用服务器。</p>
<p>对于静态内容（如 HTML 文件、图片、CSS 和 JavaScript 文件），Web 服务器可以直接从文件系统中读取并返回给客户端，无需涉及应用服务器，从而显著提升性能。Web 服务器通过配置文件中的规则（例如，Nginx 中的 location 指令）来识别静态文件请求，通常根据 URL 路径或文件扩展名进行匹配。例如，请求 &#x2F;images&#x2F;logo.png 或 &#x2F;styles.css，Web 服务器会直接返回对应的文件。 此外，Web服务器还可以设置缓存过期时间，例如通过expires指令，进一步优化对静态资源的访问速度。</p>
<p>对于动态内容，Web 服务器则充当反向代理的角色，将请求转发到后端的应用服务器。例如，URL 路径 &#x2F;products 可能对应一个需要数据库交互的产品列表页面，Web 服务器会将该请求转发到专门处理产品相关请求的应用服务器。转发规则同样在配置文件中定义，可以基于 URL 路径、请求方法等进行匹配。例如，所有 &#x2F;api&#x2F; 开头的请求都可能被转发到特定的应用服务器。</p>
</li>
<li><p><strong>应用服务器 (例如 Tomcat):</strong> 应用服务器接收请求。</p>
<ul>
<li><strong>路由:</strong> 应用服务器根据 URL 路径 &#x2F;products&#x2F;123 确定哪个控制器 (Controller) 和方法 (Method) 应该处理这个请求。例如，它可能将请求路由到 ProductController 的 getProduct 方法。</li>
<li><strong>控制器:</strong> ProductController 的 getProduct 方法被调用。该方法从 URL 中提取产品 ID (123)。</li>
<li><strong>服务层 (可选):</strong> 控制器调用服务层 (Service Layer) 的方法来获取产品数据。服务层封装了业务逻辑，例如从数据库中检索产品信息。</li>
<li><strong>数据访问层 (DAO):</strong> 服务层调用数据访问层 (Data Access Object) 的方法来与数据库交互。DAO 负责执行数据库查询。</li>
<li><strong>数据库:</strong> 数据库服务器接收查询请求，返回产品 ID 为 123 的产品数据。</li>
<li><strong>返回数据:</strong> DAO 将数据返回给服务层，服务层将数据返回给控制器。</li>
<li><strong>视图渲染 (可选):</strong> 控制器将数据传递给视图渲染引擎 (例如 JSP, Thymeleaf)，生成 HTML 响应。如果返回的是 JSON 数据，则跳过此步骤。</li>
</ul>
</li>
<li><p><strong>应用服务器返回响应:</strong> 应用服务器将生成的 HTML 响应或 JSON 数据返回给 Web 服务器。</p>
</li>
<li><p><strong>Web 服务器返回响应:</strong> Web 服务器将响应返回给反向代理服务器 (如果存在)。</p>
</li>
<li><p><strong>反向代理服务器返回响应:</strong> 反向代理服务器将响应返回给客户端 (浏览器)。</p>
</li>
<li><p><strong>浏览器渲染:</strong> 浏览器接收 HTML 响应并渲染页面，或者处理 JSON 数据。</p>
</li>
</ol>
<h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebServlet注解表示这是一个Servlet，并映射到地址/:</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置响应类型:</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取输出流:</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        <span class="comment">// 写入响应:</span></span><br><span class="line">        pw.write(<span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 最后不要忘记flush强制输出:</span></span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignInServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span>  <span class="comment">// 会接收所有未匹配的路径，相当于 /*</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程</p>
<ol>
<li><strong>客户端发送GET请求:</strong> 客户端浏览器向服务器发送一个HTTP GET请求到指定的URL（例如&#x2F;）。</li>
<li><strong>服务器接收请求:</strong> 服务器（例如Tomcat）接收到请求。</li>
<li><strong>Servlet容器匹配Servlet:</strong> Servlet容器根据URL找到对应的Servlet（本例中是HelloServlet）。</li>
<li><strong>Servlet容器创建request和response对象:</strong> Servlet容器创建HttpServletRequest和HttpServletResponse对象。HttpServletRequest封装了客户端请求的信息（例如请求头、参数等），HttpServletResponse用于构建服务器的响应。</li>
<li><strong>Servlet容器调用doGet方法:</strong> Servlet容器调用HelloServlet的doGet方法，并将创建的HttpServletRequest和HttpServletResponse对象作为参数传入。</li>
<li><strong>Servlet处理请求:</strong> 在doGet方法中，使用req对象获取客户端请求的信息，并使用resp对象构建响应。例如，设置响应的内容类型、写入响应内容等。</li>
<li><strong>Servlet容器发送响应:</strong> doGet方法执行完毕后，Servlet容器将resp对象中封装的响应信息发送回客户端。</li>
</ol>
<blockquote>
<p>一个Servlet类在服务器中只有一个实例，但对于每个HTTP请求，Web服务器会使用多线程执行请求。因此，一个Servlet的<code>doGet()</code>、<code>doPost()</code>等处理请求的方法是多线程并发执行的。如果Servlet中定义了字段，要注意多线程并发访问的问题.</p>
</blockquote>
<h2 id="Redirect-与-Forward"><a href="#Redirect-与-Forward" class="headerlink" title="Redirect 与 Forward"></a>Redirect 与 Forward</h2><p>Redirect透过HTTP 301 和 302实现</p>
<p>浏览器收到302响应后，它会立刻根据<code>Location</code>的指示发送一个新的<code>GET /hello</code>请求，这个过程就是重定向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 302 临时重定向</span></span><br><span class="line"><span class="type">String</span> <span class="variable">redirectToUrl</span> <span class="operator">=</span> <span class="string">&quot;/hello&quot;</span> + (name == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;?name=&quot;</span> + name);</span><br><span class="line">resp.sendRedirect(redirectToUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 301 永久重定向，浏览器会缓存/hi到/hello这个重定向的关联，下次请求/hi的时候，浏览器就直接发送/hello请求了</span></span><br><span class="line">resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); <span class="comment">// 301</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;/hello&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/morning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForwardServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/hello&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, name);</span><br></pre></td></tr></table></figure>

<p>流程: </p>
<ol>
<li><p>HttpSession session &#x3D; req.getSession();: 这一行代码获取或创建一个与当前请求关联的 HttpSession 对象。如果<strong>请求报文</strong>中包含的会话 ID（<code>Cookie: JSESSIONID=ABCDEF1234567890</code>），服务器会尝试检索与该 ID 关联的现有会话。如果找不到或会话 ID 无效，服务器会创建一个新的会话，并生成一个新的会话 ID。</p>
</li>
<li><p>session.setAttribute(“user”, name);: 这一行代码将名为 “user” 的属性及其值 name 存储到会话对象中。此数据存储在服务器端，而不是直接发送到客户端。</p>
<blockquote>
<p>HttpSession 对象保存在服务器端。存储在 Session 中的值代表了与特定客户端会话相关的数据。例如，在用户登录后，可以将用户名存储在 Session 中，以便在后续请求中识别用户身份，而无需用户每次都重新登录。其他常见的例子包括：</p>
<ul>
<li>购物车中的商品</li>
<li>用户的偏好设置</li>
<li>用户的浏览历史</li>
<li>游戏中的分数</li>
</ul>
</blockquote>
</li>
<li><p><strong>设置 Cookie：</strong> 当服务器处理完请求并准备发送响应时，如果创建了新的会话或现有会话被修改，服务器会将 Set-Cookie 头添加到响应中。这个头包含新创建的或更新的会话 ID。客户端（通常是浏览器）收到此头后，会将会话 ID 存储在一个 cookie 中。</p>
<blockquote>
<p>只有当以下几种情况发生时，服务器才会更新或发送新的 Cookie：</p>
<ol>
<li><strong>创建新的会话：</strong> 当客户端第一次访问需要会话的资源时，服务器会创建一个新的 HttpSession 对象，并生成一个新的会话 ID，然后通过 Set-Cookie 头将新的会话 ID 发送给客户端。</li>
<li><strong>会话 ID 重新生成（较少见）：</strong> 出于安全考虑，服务器可能会在某些情况下重新生成会话 ID，例如用户登录后。这时服务器会发送一个新的 Set-Cookie 头，其中包含新的会话 ID。</li>
<li><strong>会话过期时间更新（如果配置了）：</strong> 如果服务器配置了会话的过期时间，并且在会话过程中更新了过期时间，服务器可能会发送一个新的 Set-Cookie 头来更新 Cookie 中的过期时间信息。</li>
<li><strong>其他与会话相关的 Cookie 属性更改：</strong> 例如，如果服务器更改了 Cookie 的 HttpOnly、Secure、Path 或 Domain 属性，则需要发送新的 Set-Cookie 头来更新客户端的 Cookie。</li>
</ol>
</blockquote>
</li>
<li><p><strong>后续请求：</strong> 客户端在后续请求中会自动将这个 cookie 发送回服务器。服务器根据 cookie 中的会话 ID 检索相应的 HttpSession 对象，从而维护会话状态。</p>
</li>
</ol>
<p>除了使用Cookie机制可以实现Session外，还可以通过隐藏表单、URL末尾附加ID来追踪Session。</p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP（JavaServer Pages）是一种用于创建动态 Web 页面的技术。它允许您在 HTML 页面中嵌入 Java 代码，从而生成动态内容。Tomcat 在处理 JSP 页面时扮演着关键角色，其过程如下：</p>
<ol>
<li><p><strong>翻译阶段 (Translation):</strong> 当浏览器第一次请求 JSP 页面时，Tomcat 的 JSP 引擎会将 JSP 页面翻译成一个 Java Servlet 源文件。这个源文件包含了 JSP 页面中的所有 HTML、Java 代码以及 JSP 指令。  这个转换过程主要包括以下步骤：</p>
<ul>
<li><strong>解析 JSP 指令:</strong>  JSP 指令（例如 <code>&lt;%@ page ... %&gt;</code>, <code>&lt;%@ include ... %&gt;</code>, <code>&lt;%@ taglib ... %&gt;</code>）会被解析并用于配置生成的 Servlet。</li>
<li><strong>将 HTML 转换为 Java 代码:</strong> JSP 页面中的 HTML 代码会被转换为 <code>out.write()</code> 语句，其中 <code>out</code> 是 <code>JspWriter</code> 对象，用于将内容输出到客户端。</li>
<li><strong>嵌入 Java 代码:</strong>  JSP 页面中的 Java 代码片段（例如 <code>&lt;% ... %&gt;</code> 和 <code>&lt;%= ... %&gt;</code>）会被直接嵌入到生成的 Servlet 的 <code>_jspService()</code> 方法中。</li>
</ul>
</li>
<li><p><strong>编译阶段 (Compilation):</strong> 翻译生成的 Java Servlet 源文件会被 Java 编译器编译成一个 Java Servlet class 文件 (<code>.class</code> 文件)。</p>
</li>
<li><p><strong>加载阶段 (Loading):</strong> Tomcat 的类加载器会将编译好的 Servlet class 文件加载到内存中。</p>
</li>
<li><p><strong>实例化阶段 (Instantiation):</strong> Tomcat 创建 Servlet 的一个实例。</p>
</li>
<li><p><strong>初始化阶段 (Initialization):</strong> Tomcat 调用 Servlet 的 <code>init()</code> 方法，对 Servlet 进行初始化。 这通常只发生一次，在 Servlet 第一次被请求时。</p>
</li>
<li><p><strong>请求处理阶段 (Request Processing):</strong>  当浏览器请求 JSP 页面时，Tomcat 会调用 Servlet 的 <code>_jspService()</code> 方法。这个方法包含了 JSP 页面中的所有逻辑，并负责生成动态内容。  <code>_jspService()</code> 方法会根据 HTTP 请求的类型 (GET, POST 等) 执行相应的逻辑。</p>
</li>
<li><p><strong>销毁阶段 (Destruction):</strong> 当 Tomcat 关闭或需要卸载 Servlet 时，会调用 Servlet 的 <code>destroy()</code> 方法，释放资源。</p>
</li>
</ol>
<p><strong>简而言之，Tomcat 将 JSP 页面转换为 Servlet，然后像对待其他 Servlet 一样处理它。 这意味着 JSP 页面最终会被转换成 Java 代码，并在服务器端执行。</strong></p>
<p><strong>示例：</strong></p>
<p>假设有一个简单的 JSP 页面 <code>hello.jsp</code>：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello, &lt;%= <span class="keyword">new</span> <span class="title class_">java</span>.util.Date() %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>Tomcat 会将其转换为类似以下的 Servlet 代码 (简化版)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello_jsp</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">JspWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">    out.write(<span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;html&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;head&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;title&gt;Hello JSP&lt;/title&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/head&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;body&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;h1&gt;Hello, &quot;</span>);</span><br><span class="line">    out.print(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date());</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/h1&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/body&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/html&gt;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，HTML 代码被转换为 <code>out.write()</code> 语句，而 Java 代码 <code>&lt;%= new java.util.Date() %&gt;</code> 被嵌入到 <code>_jspService()</code> 方法中。  最终，这个 Servlet 会被编译并执行，生成动态的 HTML 页面并返回给浏览器。</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p><strong>过滤器链 (FilterChain):</strong> Servlet 容器会根据 web.xml 或注解中的配置，将匹配 URL 模式的过滤器组成一个链条。当请求到达时，容器会依次调用链上的过滤器。</p>
<p><strong>chain.doFilter():</strong> 这个方法是将控制权交给过滤器链中的下一个实体。</p>
<ul>
<li><strong>如果有下一个过滤器:</strong> 控制权会转移到下一个过滤器，执行其 doFilter() 方法。</li>
<li><strong>如果没有下一个过滤器:</strong> 控制权会转移到目标 servlet，执行其 service() 方法 (进而调用 doGet(), doPost() 等)。</li>
</ul>
<p><strong>过滤器执行顺序:</strong> 过滤器链的执行顺序与它们在 web.xml 中的声明顺序或注解的顺序相同。</p>
<p><strong>请求处理流程:</strong> 一个请求的完整过滤流程如下：</p>
<ul>
<li>请求到达服务器。</li>
<li>服务器根据 URL 匹配过滤器链。</li>
<li>第一个过滤器执行 doFilter() 方法。</li>
<li>第一个过滤器调用 chain.doFilter()，将控制权交给下一个过滤器或 servlet。</li>
<li>重复步骤 4，直到最后一个过滤器执行完毕。</li>
<li>目标 servlet 执行 service() 方法处理请求。</li>
<li>响应返回客户端，过滤器链反向执行，每个过滤器可以对响应进行处理。</li>
</ul>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>一个web项目一个ServletContext对象</p>
<blockquote>
<p>即使一个项目中有多个 Servlet，它们都共享同一个 ServletContext。ServletContext 代表整个 Web 应用程序，它提供了一种在不同 Servlet 之间共享信息和资源的机制。</p>
</blockquote>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/index.html">https://liaoxuefeng.com/books/java/spring/index.html</a></p>
<h2 id="REST-架构风格"><a href="#REST-架构风格" class="headerlink" title="REST 架构风格"></a>REST 架构风格</h2><p>REST（Representational State Transfer）是一种设计 Web 服务的架构风格，它强调客户端和服务器之间的交互应该围绕 <strong>资源</strong> 展开，并使用标准的 HTTP 方法来操作这些资源。</p>
<table>
<thead>
<tr>
<th>HTTP 方法</th>
<th>REST 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取资源</td>
<td>获取资源的表述</td>
</tr>
<tr>
<td>POST</td>
<td>创建资源</td>
<td>创建新的资源</td>
</tr>
<tr>
<td>PUT</td>
<td>更新资源</td>
<td>替换整个资源</td>
</tr>
<tr>
<td>PATCH</td>
<td>部分更新资源</td>
<td>更新资源的一部分</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
<td>删除资源</td>
</tr>
</tbody></table>
<p><strong>RESTful 请求</strong>是指符合 REST 架构风格的 HTTP 请求。它通常包含以下部分：</p>
<ul>
<li><strong>URL：</strong> 指向要操作的资源的唯一地址。</li>
<li><strong>HTTP 方法：</strong> 指示要执行的操作（GET、POST、PUT、DELETE 等）。</li>
<li><strong>请求头：</strong> 包含一些元数据，例如内容类型、授权信息等。</li>
<li><strong>请求体：</strong> 对于 POST 和 PUT 请求，可能包含要创建或更新的资源的数据。</li>
</ul>
<p><strong>例如：</strong></p>
<p>一个获取用户信息的 RESTful 请求可能是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /users/123</span><br></pre></td></tr></table></figure>



<h2 id="IoC容器与IoC对象"><a href="#IoC容器与IoC对象" class="headerlink" title="IoC容器与IoC对象"></a>IoC容器与IoC对象</h2><p><strong>Bean 对象</strong>通常被称为<strong>IoC 对象</strong>，它们是由 Spring 的 <strong>IoC 容器</strong>负责管理的对象。</p>
<p>Spring IoC 容器的创建过程：</p>
<ul>
<li><p><strong>基于 XML 配置</strong>：当加载 XML 配置文件时，容器会初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有spring注解哦，此时spring容器尚未启动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);  <span class="comment">// 启动spring容器并基于application.xml扫描并创建bean</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 UserService Bean</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 login 方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- application.xml --&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;emailService&quot;</span> class=<span class="string">&quot;com.example.EmailService&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">&quot;emailService&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基于 Java 配置类</strong>：当有 <code>@Configuration</code> 类时，Spring 会通过 Java 配置类创建 IoC 容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);  <span class="comment">// 基于AppConfig.java 扫描</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AppConfig.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(emailService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EmailService <span class="title function_">emailService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmailService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>基于 Spring Boot 应用程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用 Spring Boot，Spring 容器的创建是通过 <code>@SpringBootApplication</code> 注解触发的，它实际上是一个组合注解，包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</p>
<p>**<code>SpringApplication.run()</code>**：这是 Spring Boot 应用程序的入口。这个方法启动了 Spring Boot 应用，并创建了 IoC 容器。<code>@SpringBootApplication</code> 会自动扫描指定的包路径下的所有类，并将它们注册到 IoC 容器中。</p>
</blockquote>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><strong>构造性注解</strong></p>
<ul>
<li><p>@Component:</p>
<ul>
<li>这是最通用的构造型注解，可以用于标记任何需要被 Spring 管理的类。</li>
</ul>
</li>
<li><p>@Service:</p>
<ul>
<li>用于标记服务层组件，通常包含业务逻辑。</li>
</ul>
</li>
<li><p>@Repository:</p>
<ul>
<li>用于标记数据访问层组件，例如 DAO (Data Access Object) 类。</li>
</ul>
</li>
<li><p>@Controller:</p>
<ul>
<li>用于标记 Web 层控制器组件，例如 Spring MVC 中的控制器类。</li>
<li>使用 @Controller，需要在每个处理 RESTful 请求的方法上添加 @ResponseBody 注解，以便将返回值作为响应体发送。</li>
</ul>
</li>
<li><p>@Configuration:</p>
<ul>
<li>用于标记配置类，通常包含 @Bean 注解标记的方法，用于创建 Bean。</li>
</ul>
<blockquote>
<p>Configuration也是构造性注解，被视为 @Component</p>
</blockquote>
</li>
<li><p>@RestController:</p>
<ul>
<li>用于标记 RESTful Web 服务的控制器组件，相当于 @Controller 和 @ResponseBody 的组合。</li>
<li>使用 @RestController，所有方法的返回值都将自动作为响应体发送，无需额外添加 @ResponseBody 注解。</li>
</ul>
</li>
</ul>
<blockquote>
<p>被构造性注解标记的类将会被注册为Bean</p>
<p>一般的，被构造性注解标记的类的属性<strong>不会被自动注入</strong></p>
<p>希望类的属性被自动注入的，应使用<strong>使用构造函数注入</strong>和<strong>使用 Setter 方法注入</strong>方法</p>
</blockquote>
<p><strong>依赖注入注解：</strong></p>
<ul>
<li><p>@Autowired：用于自动注入依赖，可以作用于构造函数、字段、Setter 方法等。</p>
</li>
<li><p>@Resource：用于注入依赖，默认按名称注入，如果找不到同名 Bean，则按类型注入。</p>
</li>
<li><p>@Value：用于注入属性值，可以注入配置文件中的值、系统属性、环境变量等。</p>
<blockquote>
<p>可以配合@PropertySource使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;app.properties&quot;)</span>  <span class="comment">// 表示读取classpath的app.properties 文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span>  <span class="comment">// &quot;$&#123;app.zone:Z&#125;&quot;表示读取key为app.zone的value，但如果key不存在，就使用默认值Z</span></span><br><span class="line">    String zoneId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zoneId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<blockquote>
<p>依赖注入只发生在被Spring管理的Bean上，这意味着，使用构造函数注入和使用 Setter 方法注入通常只会发生在被构造型注解标记的类上</p>
<p>使用<strong>使用构造函数注入</strong>和<strong>使用 Setter 方法注入</strong>的被构造方法标记类不需要显示的使用依赖注入注解</p>
</blockquote>
<p><strong>生命周期注解：</strong></p>
<ul>
<li>@PostConstruct：用于标记初始化方法，在 Bean 创建后执行。</li>
<li>@PreDestroy：用于标记销毁方法，在 Bean 销毁前执行。</li>
</ul>
<p><strong>AOP 相关注解：</strong></p>
<ul>
<li><p>@Aspect：用于标记切面类。</p>
<p>一个切面类可以对<strong>多个类的多个方法</strong>进行切面增强，</p>
<p>多切面类示例：例如，可以创建一个 LoggingAspect 用于日志记录，创建一个 SecurityAspect 用于安全控制，创建一个 TransactionAspect 用于事务管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 在执行UserService的每个方法前执行:</span></span><br><span class="line">    <span class="comment">// 切面增强UserService类的所有公共方法</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Before] do access check...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行MailService的每个方法前后执行:</span></span><br><span class="line">    <span class="comment">// 切面增强MailService类的所有公共方法</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] start &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] done &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>  <span class="comment">// 配合@Aspect使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring的IoC容器发现配置类存在该注解后，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。</p>
</li>
<li><p>@Before、@After、@Around 等：用于定义切点和增强。</p>
</li>
</ul>
<blockquote>
<p>AOP原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserServiceAopProxy <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceAopProxy</span><span class="params">(UserService target, LoggingAspect aspect)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.aspect = aspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 先执行Aspect的代码:</span></span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="comment">// 再执行UserService的逻辑:</span></span><br><span class="line">        <span class="keyword">return</span> target.login(email, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="keyword">return</span> target.register(email, password, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>事务管理注解：</strong></p>
<ul>
<li><p>@Transactional：用于声明事务，可以作用于类或方法</p>
<ul>
<li><p>表示被标记类的所有<code>public</code>方法&#x2F;被标记方法具有事务支持</p>
</li>
<li><p>类的方法或方法执行过程中如果抛出异常，回滚发生</p>
</li>
<li><p>可以针对指定异常抛出，发生回滚</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>Web 相关注解：</strong></p>
<ul>
<li><p>@RequestMapping：</p>
<p>将 HTTP 请求映射到控制器方法;</p>
<p>定义 URL 映射规则，例如 &#x2F;users、&#x2F;users&#x2F;{id} 等;</p>
<p>指定 HTTP 请求方法，例如 GET、POST、PUT、DELETE 等;</p>
<p>定义请求参数，例如 @RequestParam、@PathVariable 等.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@GetMapping、@PostMapping 等：@RequestMapping 的特化，用于简化请求映射的配置。</p>
</li>
<li><p>@PathVariable：用于获取 URL 中的路径变量。</p>
</li>
<li><p>@RequestParam：用于获取请求参数。</p>
</li>
<li><p>@RequestBody：用于将 HTTP 请求体转换为方法参数。</p>
</li>
<li><p>@ResponseBody: </p>
<ul>
<li>方法的返回值转换为指定的格式，例如 JSON 或 XML，并将其作为响应体发送给客户端。</li>
<li>应用于方法上, 只对该方法生效; 应用于类上, 对该类中的所有方法生效。</li>
</ul>
</li>
</ul>
<p><strong>测试相关注解：</strong></p>
<ul>
<li>@SpringBootTest：用于标记 Spring Boot 测试类。</li>
<li>@MockBean：用于模拟 Bean，方便进行单元测试。</li>
</ul>
<p><strong>其他注解：</strong></p>
<ul>
<li><p>@Scope：用于指定 Bean 的作用域。</p>
</li>
<li><p>@ComponentScan</p>
<ul>
<li>如果某类被注解<code>@ComponentScan</code>标注，则会扫描标注该注解的类所在包及其子包中的所有组件（包括 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 等）</li>
<li>如果被 <code>@ComponentScan</code> 标注的 <code>MyApplication</code> 类位于 <code>com.example</code> 包下，Spring 会默认扫描 <code>com.example</code> 包及其所有子包，例如 <code>com.example.domain</code>。</li>
</ul>
</li>
<li><p>@Lazy：用于延迟初始化 Bean。</p>
</li>
<li><p>@Profile：用于根据不同的环境激活不同的 Bean。</p>
</li>
<li><p>@Conditional：用于根据条件创建 Bean。</p>
</li>
</ul>
<h2 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h2><h3 id="使用构造函数注入-使用-Setter-方法注入"><a href="#使用构造函数注入-使用-Setter-方法注入" class="headerlink" title="使用构造函数注入 &amp;&amp; 使用 Setter 方法注入"></a>使用构造函数注入 &amp;&amp; 使用 Setter 方法注入</h3><p><strong>构造函数注入</strong></p>
<p>假设我们有两个类：<code>UserService</code> 和 <code>EmailService</code>，<code>UserService</code> 依赖于 <code>EmailService</code>。</p>
<p><strong>EmailService 类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Sending email to &quot;</span> + to + <span class="string">&quot;:\nSubject: &quot;</span> + subject + <span class="string">&quot;\nBody: &quot;</span> + body);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UserService 类：</strong></p>
<p>使用构造函数注入 <code>EmailService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EmailService emailService;  <span class="comment">// 目标字段可以是 final，但不强制必须是 final，强烈建议在构造函数注入时将依赖字段声明为 final，因为这可以确保依赖在对象创建时被完全初始化，而且不会在对象生命周期中被修改，从而提供更高的安全性和不可变性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数注入</span></span><br><span class="line">    <span class="comment">// 这里没有使用@Autowired，但是属性emailService被自动注入bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(EmailService emailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username, String email)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 用户注册逻辑 ...</span></span><br><span class="line">        emailService.sendEmail(email, <span class="string">&quot;Welcome!&quot;</span>, <span class="string">&quot;Thank you for registering.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Setter 方法注入</strong></p>
<p>假设我们仍然使用 <code>UserService</code> 和 <code>EmailService</code>，但这次使用 Setter 方法注入 <code>EmailService</code>。</p>
<p><strong>EmailService 类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email to &quot;</span> + to + <span class="string">&quot;:\nSubject: &quot;</span> + subject + <span class="string">&quot;\nBody: &quot;</span> + body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserService 类：</strong></p>
<p>使用 Setter 方法注入 <code>EmailService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;  </span><br><span class="line">    <span class="comment">// 依赖不能是 final 的！！！，final 字段必须在对象构造时被赋值（即通过构造函数进行初始化）</span></span><br><span class="line">    <span class="comment">// 即使字段的访问级别是 private，Spring 仍然可以使用反射来绕过 Java 的访问控制机制，直接为私有字段设置值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter 方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 将Setter方法标记为@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmailService</span><span class="params">(EmailService emailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username, String email)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 用户注册逻辑 ...</span></span><br><span class="line">        emailService.sendEmail(email, <span class="string">&quot;Welcome!&quot;</span>, <span class="string">&quot;Thank you for registering.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>为什么不直接将 <code>@Autowired</code> 标记在属性上？</strong></p>
<p>实际上，<strong>Spring 支持将 <code>@Autowired</code> 直接标记在属性上</strong>，这种方式叫做<strong>字段注入</strong>（Field Injection）。这种注入方式不需要提供 <code>set</code> 方法，Spring 会直接通过反射为属性注入依赖。然而，字段注入通常被认为是<strong>不推荐的做法</strong>，原因如下：</p>
<p><strong>字段注入的缺点：</strong></p>
<ol>
<li><strong>不利于测试</strong>：直接将 <code>@Autowired</code> 注解标记在字段上，依赖会通过反射注入。这样会让单元测试变得困难，因为无法直接通过构造函数或 Setter 方法传递 mock 对象，而是必须使用像 <code>ReflectionTestUtils</code> 这样的工具来手动设置私有字段的依赖。</li>
<li><strong>违背封装原则</strong>：字段注入直接修改类的私有属性，违背了对象的封装性原则。在面向对象编程中，通常希望属性通过构造函数或 Setter 方法来进行操作，而不是直接被外部干预。</li>
<li><strong>无法支持 <code>final</code> 关键字</strong>：如果使用字段注入，属性不能声明为 <code>final</code>，因为 <code>final</code> 属性必须在构造函数中初始化，而不是通过反射。这限制了对不可变性的支持。</li>
</ol>
</blockquote>
<h3 id="使用-Component或-Bean声明"><a href="#使用-Component或-Bean声明" class="headerlink" title="使用@Component或@Bean声明"></a>使用@Component或@Bean声明</h3><ul>
<li><strong>对于大多数 Bean，使用 @Component (或其衍生注解) 进行声明，并让 Spring 自动扫描和注册。</strong> 这是最简洁和推荐的方式。</li>
<li><strong>只有在需要更细粒度的控制，例如自定义初始化、作用域或条件化创建 Bean 时，才需要在config类中使用 @Bean 方法。</strong></li>
<li><strong>始终为 @Bean 方法创建一个对应的类，即使它非常简单。</strong> 避免使用匿名内部类或 Lambda 表达式创建 Bean，除非有非常特殊的理由。</li>
</ul>
<h3 id="创建第三方Bean"><a href="#创建第三方Bean" class="headerlink" title="创建第三方Bean"></a>创建第三方Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bean注解创建</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String jdbcUsername;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        config.setJdbcUrl(jdbcUrl);</span><br><span class="line">        config.setUsername(jdbcUsername);</span><br><span class="line">        config.setPassword(jdbcPassword);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;autoCommit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除非显式地指定了 bean 的名字，Spring 默认会使用方法名作为 Bean 的 ID。</span></span><br><span class="line">    <span class="comment">// HikariDataSource类型，id为createDataSource的bean</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// JdbcTemplate类型，id为createJdbcTemplate的bean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// import导入</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ThirdPartyLibraryConfig.class)</span> <span class="comment">// 导入第三方库的配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring 通过以下机制得知在注入时使用哪个 bean：</p>
<ol>
<li><strong>@Autowired 注解:</strong> 在 createJdbcTemplate 方法中，@Autowired 注解告诉 Spring 需要注入一个 DataSource 类型的 Bean。</li>
<li><strong>类型匹配:</strong> Spring 容器会扫描所有带有 @Bean 注解的方法，并将其返回值注册为 Bean。当需要注入 DataSource 类型 Bean 时，Spring 会查找容器中所有类型为 DataSource 的 Bean。</li>
<li><strong>唯一 Bean:</strong> 在本例中，只有一个方法 createDataSource 返回 DataSource 类型的 Bean。因此，Spring 可以明确地将 createDataSource 方法创建的 Bean 注入到 createJdbcTemplate 方法的参数中。</li>
<li><strong>名称匹配（如果存在多个同类型 Bean）:</strong> 如果有多个 DataSource 类型的 Bean，@Autowired 默认会按照类型进行匹配。如果匹配到多个，则会尝试按照名称进行匹配。你可以使用 @Qualifier 注解来指定要注入的 Bean 的名称</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;  <span class="comment">// 将被spring正确注入</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>实现了FactoryBean接口的类将被Spring视为工厂Bean</p>
<p>Spring会将工厂Bean创建后保存在IoC容器中，并在注入该工厂Bean的时候，使用工厂Bean创建Bean进行注入；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myConnection&quot;)</span> <span class="comment">// bean name</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnectionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;MyConnection&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter methods for properties (url, username, password) -  injected via Spring</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyConnection <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Create and return a new MyConnection object</span></span><br><span class="line">        <span class="comment">// This is where the object creation logic resides</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Creating a new MyConnection object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyConnection</span>(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyConnection.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Return false for a new instance each time</span></span><br><span class="line">        <span class="comment">// return true;  // Return true for a singleton instance</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple connection class (replace with your actual connection logic)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConnection</span><span class="params">(String url, String username, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123; <span class="keyword">return</span> url;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; <span class="keyword">return</span> username;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;<span class="keyword">return</span> password;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyConnection myConnection; <span class="comment">// 注意，这里注入的是myConnection对象而不是myConnectionFactoryBean对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using MyConnection: &quot;</span> + myConnection.getUrl());</span><br><span class="line">        <span class="comment">// ... use the myConnection object ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取 FactoryBean 本身：</strong></p>
<p>如果需要获取 FactoryBean 实例本身，而不是它创建的对象，可以在 Bean 的名称前面加上 &amp; 符号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyConnectionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> (MyConnectionFactoryBean) applicationContext.getBean(<span class="string">&quot;&amp;myConnection&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong></p>
<ul>
<li><strong>封装复杂的创建逻辑：</strong> 当 Bean 的创建逻辑比较复杂时，可以使用 FactoryBean 将其封装起来，使配置更加简洁。</li>
<li><strong>延迟初始化：</strong> FactoryBean 的 getObject() 方法只有在需要的时候才会被调用，可以实现 Bean 的延迟初始化。</li>
<li><strong>创建不同类型的对象：</strong> FactoryBean 可以根据不同的配置创建不同类型的对象。</li>
<li><strong>与第三方库集成：</strong> 可以使用 FactoryBean 来集成第三方库，例如创建数据库连接、缓存连接等。</li>
</ul>
<h3 id="初始化与销毁"><a href="#初始化与销毁" class="headerlink" title="初始化与销毁"></a>初始化与销毁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span>  <span class="comment">// 创建后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init mail service with zoneId = &quot;</span> + <span class="built_in">this</span>.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span>  <span class="comment">// 销毁前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutdown mail service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h2><ol>
<li><p><strong>实例化 Bean：</strong></p>
<ul>
<li><p>根据配置的包路径，通过<strong>组件扫描（Component Scanning）</strong>找到带有构造型注解的类（例如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 等），标注了构造型注解的类注册为 Spring 容器中的 Bean。</p>
</li>
<li><p><strong>推断构造方法：</strong> Spring 选择合适的构造方法进行实例化。</p>
<blockquote>
<p><strong>在 config 中设置了类的构造方法：</strong></p>
<ul>
<li>如果在 @Configuration 类中使用 @Bean 注解定义了该类的构建方法，Spring 会使用该方法创建 Bean 对象。</li>
<li>在 @Bean 方法中，你可以手动创建 Bean 对象，并使用构造函数注入或 Setter 方法注入设置 Bean 的属性。</li>
<li>即使类上有构造型注解，Spring 也会优先使用 @Bean 方法创建 Bean 对象，而不是使用组件扫描和自动注册的方式。</li>
</ul>
<p><strong>没有在 config 中设置类的构建方法：</strong></p>
<ul>
<li>如果类上有构造型注解（例如 @Component、@Service 等），Spring 会通过组件扫描发现该类，并尝试使用其默认的无参构造函数创建 Bean 对象。</li>
<li>如果类没有默认的无参构造函数，但只有一个有参构造函数，Spring 也会尝试使用该有参构造函数创建 Bean 对象，并尝试自动注入构造函数所需的依赖。</li>
<li>如果类有多个构造函数，Spring 会优先选择标注了 <code>@Autowired</code> 的构造函数。如果没有标注 <code>@Autowired</code>，Spring 会尝试通过依赖匹配来选择合适的构造函数。如果不能成功解析依赖，将抛出异常。</li>
</ul>
</blockquote>
</li>
<li><p><strong>创建对象：</strong> 使用反射机制或工厂方法创建 Bean 的实例。此时，对象的属性还未被填充。</p>
</li>
</ul>
<blockquote>
<p>实例化时可能出现循环依赖问题</p>
<p>即 两个或多个 Bean 之间相互依赖，例如 A 依赖 B，B 又依赖 A。这种情况下，Spring 容器无法确定先创建哪个 Bean，就会导致循环依赖问题。</p>
<p>Spring 容器使用 <strong>三级缓存 + 提前AOP(可选)</strong> 来解决循环依赖和依赖顺序问题：</p>
<ol>
<li><strong>singletonObjects：</strong> 存放已经创建完成的单例 Bean。</li>
<li><strong>earlySingletonObjects：</strong> 存放正在创建过程中的单例 Bean。</li>
<li><strong>singletonFactories：</strong> 存放用于创建单例 Bean 的工厂。</li>
</ol>
<p><strong>解决过程：</strong></p>
<ol>
<li>当 Spring 容器创建 Bean A 时，发现 A 依赖 B。</li>
<li>Spring 容器检查 singletonObjects 中是否存在 B，如果存在，则直接注入 B。</li>
<li>如果 singletonObjects 中不存在 B，则检查 earlySingletonObjects 中是否存在 B，如果存在，则将 B 从 earlySingletonObjects 中取出，注入到 A 中。</li>
<li>如果 earlySingletonObjects 中也不存在 B，则检查 singletonFactories 中是否存在 B 的工厂，如果存在，则使用工厂创建 B 的实例，并将 B 放入 earlySingletonObjects 中，然后注入到 A 中。</li>
<li>如果 singletonFactories 中也不存在 B 的工厂，则说明 B 还没有开始创建，Spring 容器会先创建 B，然后再创建 A。</li>
</ol>
</blockquote>
</li>
<li><p><strong>填充属性 (依赖注入)：</strong></p>
<ul>
<li>Spring 容器根据配置信息解析 Bean 的依赖关系。</li>
<li><strong>依赖注入：</strong> 将依赖的 Bean 注入到当前 Bean 的属性中，例如使用 @Autowired 注解注入的依赖。</li>
</ul>
</li>
<li><p><strong>Aware 接口回调：</strong></p>
<ul>
<li>如果 Bean 实现了 Spring 的 Aware 接口 (例如 BeanNameAware、BeanFactoryAware 等)，Spring 容器会回调相应的方法，将 Bean 的名称、BeanFactory 等信息注入到 Bean 中。</li>
</ul>
</li>
<li><p><strong>BeanPostProcessor 的前置处理：</strong></p>
<ul>
<li>Spring 容器会调用所有实现了 BeanPostProcessor 接口的 postProcessBeforeInitialization() 方法，对 Bean 进行前置处理。</li>
<li><strong>初始化前：</strong> “初始化前” 阶段，开发者可以在 BeanPostProcessor 中对 Bean 进行一些自定义的处理，例如修改 Bean 的属性、添加 Bean 的代理等。</li>
</ul>
</li>
<li><p><strong>初始化：</strong></p>
<ul>
<li>如果 Bean 实现了 InitializingBean 接口，Spring 容器会调用其 afterPropertiesSet() 方法。</li>
<li>如果 Bean 定义了 init-method 属性，Spring 容器会调用指定的初始化方法。</li>
<li><strong>初始化：</strong> “初始化” 阶段，开发者可以在初始化方法中进行一些资源的初始化工作，例如打开数据库连接、加载配置文件等。</li>
</ul>
</li>
<li><p><strong>BeanPostProcessor 的后置处理：</strong></p>
<ul>
<li>Spring 容器会调用所有实现了 BeanPostProcessor 接口的 postProcessAfterInitialization() 方法，对 Bean 进行后置处理。</li>
<li><strong>AOP：</strong> “初始化后” 阶段，开发者可以在 BeanPostProcessor 中对 Bean 进行 AOP 代理，例如使用 Spring AOP 创建代理对象。</li>
<li><strong>代理对象：</strong> 如果 Bean 被 AOP 代理，那么此时返回的 Bean 就是代理对象，而不是原始的 Bean 对象。</li>
</ul>
</li>
<li><p><strong>放入单例池 (可选)：</strong></p>
<ul>
<li>如果 Bean 的作用域是单例 (singleton)，Spring 容器会将 Bean 放入单例池中，方便下次获取。</li>
<li>如果 类使用了AOP，则放入单例池的是<strong>代理对象</strong></li>
</ul>
</li>
<li><p><strong>Bean 对象：</strong></p>
<ul>
<li>此时，Bean 创建完成，可以被应用程序使用了。</li>
</ul>
</li>
<li><p><strong>销毁：</strong></p>
<ul>
<li>当 Bean 的生命周期结束时，Spring 容器会销毁 Bean。</li>
<li>如果 Bean 实现了 DisposableBean 接口，Spring 容器会调用其 destroy() 方法。</li>
<li>如果 Bean 定义了 destroy-method 属性，Spring 容器会调用指定的销毁方法。</li>
</ul>
</li>
</ol>
<h2 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String jdbcUsername;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">// 创建数据库连接池，并作为bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        config.setJdbcUrl(jdbcUrl);</span><br><span class="line">        config.setUsername(jdbcUsername);</span><br><span class="line">        config.setPassword(jdbcPassword);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;autoCommit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">// 创建JdbcTemplate，注入DataSource</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>JdbcTemplate用法</strong></p>
<p>配置类实现 JdbcTemplate Bean 的创建，注入到User类jdbcTemplate属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意传入的是ConnectionCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute((Connection conn) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:</span></span><br><span class="line">        <span class="comment">// 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)) &#123;</span><br><span class="line">            ps.setObject(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                            rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 需要传入SQL语句，以及PreparedStatementCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute(<span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>, (PreparedStatement ps) -&gt; &#123;</span><br><span class="line">        <span class="comment">// PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:</span></span><br><span class="line">        ps.setObject(<span class="number">1</span>, name);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入SQL，参数和RowMapper实例:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT * FROM users WHERE email = ?&quot;</span>,</span><br><span class="line">            (ResultSet rs, <span class="type">int</span> rowNum) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 将ResultSet的当前行映射为一个JavaBean:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;,</span><br><span class="line">            email);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>jdbcTemplate.queryForObject() 方法的第二个参数是一个 RowMapper 接口的实现。RowMapper 接口定义了一个 mapRow(ResultSet rs, int rowNum) 方法，它的作用就是将 ResultSet 的每一行数据映射成一个 Java 对象。</p>
</blockquote>
<p><strong>声明式事务</strong></p>
<p><code>PlatformTransactionManager</code>表示事务管理器；</p>
<p><code>TransactionStatus</code>表示事务；</p>
<blockquote>
<p>Spring为了同时支持JDBC和JTA两种事务模型，故使用<code>PlatformTransactionManager</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开启事务:</span></span><br><span class="line">    tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="comment">// 相关JDBC操作:</span></span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="comment">// 提交事务:</span></span><br><span class="line">    txManager.commit(tx);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务:</span></span><br><span class="line">    txManager.rollback(tx);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 启用声明式</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>声明式事务透过AOP代理的方式，为UserService类创建代理对象，该代理对象拥有属性txManager，并使每个方法事务化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService$$EnhancerBySpringCGLIB</span> <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">PlatformTransactionManager</span> <span class="variable">txManager</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">            target.register(email, password, name);</span><br><span class="line">            txManager.commit(tx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            txManager.rollback(tx);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>事务回滚</strong></p>
<p>默认情况下，如果发生了<code>RuntimeException</code>，Spring的声明式事务将自动回滚</p>
<p>如果要针对Checked Exception回滚事务，需要在<code>@Transactional</code>注解中写出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">buyProducts</span><span class="params">(<span class="type">long</span> productId, <span class="type">int</span> num)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JDBC事务传播"><a href="#JDBC事务传播" class="headerlink" title="JDBC事务传播"></a>JDBC事务传播</h3><p>Spring的声明式事务为事务传播定义分级，默认传播级别 <code>REQUIRED</code></p>
<p><code>REQUIRED</code>：表示如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。</p>
<p><code>SUPPORTS</code>：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；</p>
<p><code>MANDATORY</code>：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；</p>
<p><code>REQUIRES_NEW</code>：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；</p>
<p><code>NOT_SUPPORTED</code>：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；</p>
<p><code>NEVER</code>：和<code>NOT_SUPPORTED</code>相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；</p>
<p><code>NESTED</code>：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。</p>
<blockquote>
<p><strong>Spring使用ThreadLocal获知当前是否存在事务</strong></p>
<p>Spring将JDBC相关的<code>Connection</code>和<code>TransactionStatus</code>实例绑定到<code>ThreadLocal</code>。如果一个事务方法从<code>ThreadLocal</code>未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从<code>ThreadLocal</code>获取的JDBC连接以及<code>TransactionStatus</code>。</p>
<p>因此，事务能正确传播的前提是，方法调用必须在一个线程内。</p>
</blockquote>
<h3 id="结合Hibernate"><a href="#结合Hibernate" class="headerlink" title="结合Hibernate"></a>结合Hibernate</h3><p>将关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping</p>
<p>对于表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    createdAt <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `email` (`email`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>对于java对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>  <span class="comment">// @Entity 注解标记 User 类为一个实体，表示它对应数据库中的一个表。</span></span><br><span class="line"><span class="meta">@Table(name=&quot;users&quot;)</span>  <span class="comment">// 指定对应的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span>  <span class="comment">// @Id 注解标记 getId() 方法返回的值作为主键。</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// @Column 注解用于映射实体类的属性到数据库表的列。</span></span><br><span class="line">    <span class="comment">// @Column 注解在 getEmail() 方法上，Hibernate 会根据约定推断出对应的字段名为 email (去掉get，并将首字母小写)。</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个属性到数据库列的映射用<code>@Column()</code>标识，<code>nullable</code>指示列是否允许为<code>NULL</code>，<code>updatable</code>指示该列是否允许被用在<code>UPDATE</code>语句，<code>length</code>指示<code>String</code>类型的列的长度（如果没有指定，默认是<code>255</code>）。</p>
<p>对于主键，还需要用<code>@Id</code>标识，自增主键再追加一个<code>@GeneratedValue</code>，以便Hibernate能读取到自增主键的值。</p>
<blockquote>
<p>Hibernate 使用反射机制来访问和操作实体类的字段。@Column 注解标注在 getter 方法上只是一种便捷的声明方式，它实际上是告诉 Hibernate “这个 getter 方法对应的字段需要映射到数据库的列”。</p>
<p>Hibernate 使用一种基于约定的命名策略。它会查找符合 JavaBean 规范的 getter&#x2F;setter 方法，并根据方法名推断出对应的字段名。</p>
<p>具体规则如下:</p>
<ul>
<li>对于 getter 方法，去掉 get 或 is 前缀，并将剩余部分的首字母小写。例如，getEmail() 对应字段 email，isActivated() 对应字段 activated。</li>
<li>对于 setter 方法，去掉 set 前缀，并将剩余部分的首字母小写。例如，setEmail(String email) 对应字段 email。</li>
</ul>
</blockquote>
<p>可通过继承映射超类实现子类的映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span>  <span class="comment">// 映射超类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span>  <span class="comment">// 暫く，要求 JPA 忽略该字段，不要将其持久化到数据库中。这意味着 createdDateTime 字段不会在数据库表中拥有对应的列。</span></span><br><span class="line">    <span class="keyword">public</span> ZonedDateTime <span class="title function_">getCreatedDateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(<span class="built_in">this</span>.createdAt).atZone(ZoneId.systemDefault());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrePersist</span>  <span class="comment">// 指定在实体持久化到数据库之前要执行的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        setCreatedAt(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建</p>
<p>SessionFactory 是一个重量级对象，通常在应用启动时创建一次，并在线程之间共享。它用于创建 Session 对象。</p>
<p>Session 是一个轻量级对象，代表与数据库的一次交互。每次操作数据库都需要创建一个新的 Session 对象。在Spring架构中通过SessionFactory Bean的注入获得Session Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span> <span class="comment">// 使用 classpath</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span> String jdbcUrl,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span> String jdbcUsername,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span> String jdbcPassword)</span> &#123;</span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">        dataSource.setUrl(jdbcUrl);</span><br><span class="line">        dataSource.setUsername(jdbcUsername);</span><br><span class="line">        dataSource.setPassword(jdbcPassword);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里创建了 LocalSessionFactoryBean 对象，在类中要求注入时，会注入 SessionFactory 对象，由于 SessionFactory 对象是单例Bean，故 SessionFactory 并没有被反复创建注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    LocalSessionFactoryBean <span class="title function_">createSessionFactory</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">LocalSessionFactoryBean</span> <span class="variable">sessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalSessionFactoryBean</span>();</span><br><span class="line">        sessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sessionFactoryBean.setPackagesToScan(<span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>); <span class="comment">// 扫描 Entity 类</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>); <span class="comment">// 或 create-drop, validate</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.dialect&quot;</span>, <span class="string">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>); <span class="comment">// 根据数据库选择方言</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        sessionFactoryBean.setHibernateProperties(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> LocalSessionFactoryBean sessionFactoryBean)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取 SessionFactory 对象</span></span><br><span class="line">        <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> sessionFactoryBean.getObject();  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HibernateTransactionManager</span>(sessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>LocalSessionFactoryBean </code>是 Spring 提供的一个用于创建和配置 Hibernate <code>SessionFactory </code>的工厂 bean，实际上按照逻辑而言，<code>LocalSessionFactoryBean </code>应该为<code>SessionFactory FactoryBean </code>，因为它创建的是<code>SessionFactory </code> 。一般而言，<code>SessionFactory </code> 在创建后为单例 bean，不会出现创建多个<code>SessionFactory </code>的情况。在类需要使用<code>SessionFactory </code>时，Spring 注入<code>SessionFactory </code></p>
<p><strong>如果我们每个类需要的是Session，为什么我们不直接使用<code>SessionFactoryBean </code>注入原型 Session Bean到每个类中呢？</strong></p>
<ol>
<li><strong>Session 的生命周期管理困难:</strong> Session 代表与数据库的一次会话，它的生命周期应该与特定的操作（例如一次数据库事务）绑定。 如果将 Session 作为原型 bean 注入，就需要手动管理 Session 的生命周期，包括创建、关闭和事务管理。 这会使代码变得复杂，容易出错，并且难以维护。</li>
<li><strong>线程安全问题:</strong> Session 不是线程安全的。 如果将原型 Session bean 注入到单例 bean 中，并且在并发环境下使用，可能会导致数据不一致或其他并发问题。</li>
<li><strong>资源管理问题:</strong> Session 持有数据库连接等资源。 如果不正确地管理 Session 的生命周期，可能会导致资源泄露。</li>
<li><strong>违反 Hibernate 的设计理念:</strong> Hibernate 的设计理念是将 Session 的生命周期与事务绑定。 通过 SessionFactory.openSession() 或 SessionFactory.getCurrentSession() 获取 Session，可以确保 Session 的生命周期与事务同步，并由 Hibernate 管理资源。 直接注入 Session bean 会破坏这种设计。</li>
</ol>
</blockquote>
<p>CRUD</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 启用声明式事务管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setEmail(email);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setCreatedAt(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession(); <span class="comment">// 获取当前 Session</span></span><br><span class="line">        session.persist(user);</span><br><span class="line">        <span class="keyword">return</span> user; <span class="comment">// 不需要手动 commit，Spring 会自动处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span> <span class="comment">// 只读事务</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="keyword">return</span> session.get(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span> <span class="comment">// 只读事务</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="keyword">return</span> session.createQuery(<span class="string">&quot;FROM User&quot;</span>, User.class).list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id, String name)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, id);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            user.setName(name);</span><br><span class="line">            session.merge(user); <span class="comment">// 或 session.update(user)</span></span><br><span class="line">            <span class="comment">// 不需要手动 commit，Spring 会自动处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理用户不存在的情况...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, id);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            session.delete(user);</span><br><span class="line">            <span class="comment">// 不需要手动 commit，Spring 会自动处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用DAO层代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">get</span><span class="params">(Long id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line">	<span class="comment">// session在这里使用~</span></span><br><span class="line">    <span class="comment">// ... 实现 UserDao 接口中的方法，进行数据库操作 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 使用 userDao 获得数据 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结合MyBatis"><a href="#结合MyBatis" class="headerlink" title="结合MyBatis"></a>结合MyBatis</h3><h3 id="JDBC与Hibernate-JPA-MyBatis"><a href="#JDBC与Hibernate-JPA-MyBatis" class="headerlink" title="JDBC与Hibernate, JPA, MyBatis"></a>JDBC与Hibernate, JPA, MyBatis</h3><p>ORM，也是建立在JDBC的基础上，通过ResultSet到JavaBean的映射，实现各种查询。有自动跟踪Entity修改的全自动化ORM如Hibernate和JPA，需要为每个Entity创建代理，也有完全自己映射，连INSERT和UPDATE语句都需要手动编写的MyBatis，但没有任何透明的Proxy。</p>
<h2 id="Spring-网络相关"><a href="#Spring-网络相关" class="headerlink" title="Spring 网络相关"></a>Spring 网络相关</h2><p>标准的Maven Web工程目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">spring-web-mvc</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java  // Spring配置类</span><br><span class="line">        │               ├── DatabaseInitializer.java</span><br><span class="line">        │               ├── entity</span><br><span class="line">        │               │   └── User.java</span><br><span class="line">        │               ├── service</span><br><span class="line">        │               │   └── UserService.java</span><br><span class="line">        │               └── web</span><br><span class="line">        │                   └── UserController.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   ├── jdbc.properties  // 数据库连接配置文件，包含数据库URL、用户名、密码等信息。</span><br><span class="line">        │   └── logback.xml  // 日志配置文件，配置日志输出格式、级别等。</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   ├── templates</span><br><span class="line">            │   │   ├── _base.html</span><br><span class="line">            │   │   ├── index.html</span><br><span class="line">            │   │   ├── profile.html</span><br><span class="line">            │   │   ├── register.html</span><br><span class="line">            │   │   └── signin.html</span><br><span class="line">            │   └── web.xml  // 指导 Web 容器（例如 Tomcat）如何部署和运行应用, 一般包含Servlet信息,servlet-mapping信息, Filter信息, welcome页面信息.</span><br><span class="line">            └── static</span><br><span class="line">                ├── css</span><br><span class="line">                │   └── bootstrap.css</span><br><span class="line">                └── js</span><br><span class="line">                    └── jquery.js</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Web MVC 的标准做法，通常只有一个 Servlet, 多个 Filter, </p>
</blockquote>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p> <strong>传统的部署方式 (WAR包部署到外部Tomcat):</strong></p>
<ol>
<li><strong>构建WAR包:</strong> 使用Maven或Gradle等构建工具将Spring MVC项目打包成WAR文件。</li>
<li><strong>部署WAR包:</strong> 将WAR文件复制到Tomcat的webapps目录下。</li>
<li><strong>Tomcat启动:</strong> 启动Tomcat服务器。</li>
<li><strong>WAR包解压:</strong> Tomcat会自动解压WAR文件，创建一个同名的Web应用目录。</li>
<li><strong>读取web.xml:</strong> Tomcat读取Web应用目录下的WEB-INF&#x2F;web.xml文件。</li>
<li><strong>初始化DispatcherServlet:</strong> Tomcat根据web.xml中的配置，初始化DispatcherServlet。</li>
<li><strong>创建WebApplicationContext:</strong> DispatcherServlet初始化时，会根据contextConfigLocation参数指定的配置类（例如AppConfig）创建WebApplicationContext（Spring的IoC容器）。</li>
<li><strong>扫描和初始化Bean:</strong> WebApplicationContext会扫描指定的包，查找并初始化所有带有@Component、@Service、@Repository、@Controller等注解的Bean。</li>
<li><strong>初始化其他组件:</strong> WebApplicationContext还会初始化Spring MVC的其他组件，例如HandlerMapping、ViewResolver等。</li>
<li><strong>应用启动完成:</strong> Tomcat完成Web应用的启动，DispatcherServlet准备好接收HTTP请求。</li>
</ol>
<p><strong>嵌入式Tomcat:</strong></p>
<ol>
<li><strong>添加依赖:</strong> 在pom.xml中添加Spring Boot Starter Web依赖，该依赖包含了嵌入式Tomcat。</li>
<li><strong>编写启动类:</strong> 创建一个带有main()方法的启动类，使用@SpringBootApplication注解标记。</li>
<li><strong>运行main()方法:</strong> 运行启动类的main()方法。</li>
<li><strong>Spring Boot初始化:</strong> Spring Boot会进行自动配置，根据classpath中的依赖自动配置Spring MVC、嵌入式Tomcat等组件。</li>
<li><strong>启动嵌入式Tomcat:</strong> Spring Boot启动嵌入式Tomcat服务器。</li>
<li><strong>创建WebApplicationContext:</strong> 与传统方式类似，Spring Boot会创建WebApplicationContext。</li>
<li><strong>扫描和初始化Bean:</strong> WebApplicationContext扫描并初始化Bean。</li>
<li><strong>初始化DispatcherServlet:</strong> Spring Boot将DispatcherServlet注册到嵌入式Tomcat中。</li>
<li><strong>应用启动完成:</strong> 嵌入式Tomcat启动完成，DispatcherServlet准备好接收HTTP请求。</li>
</ol>
<blockquote>
<p>该方式完全运行在一个JVM内部</p>
<ul>
<li><strong>Spring Boot应用管理嵌入式Tomcat的生命周期:</strong> Spring Boot应用负责启动、停止和配置嵌入式Tomcat。</li>
<li><strong>嵌入式Tomcat提供Servlet容器的功能:</strong> 嵌入式Tomcat负责接收HTTP请求、管理Servlet生命周期、处理Servlet请求等。</li>
<li><strong>DispatcherServlet是运行在嵌入式Tomcat中的一个Servlet:</strong> DispatcherServlet依赖于嵌入式Tomcat提供的Servlet容器功能，它被注册到嵌入式Tomcat中，由嵌入式Tomcat负责调用它的service()方法来处理请求。</li>
</ul>
<p>DispatcherServlet的实例是由嵌入式Tomcat创建的，但它的初始化和配置是由Spring Boot完成的。 Spring Boot会将DispatcherServlet注册到嵌入式Tomcat中，并将其与Spring的WebApplicationContext关联起来。 这样，DispatcherServlet就可以访问Spring容器中的Bean，并使用Spring MVC的功能来处理请求。</p>
</blockquote>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/index.html">https://liaoxuefeng.com/books/java/springboot/index.html</a></p>
<p>这些自动创建的Bean就是Spring Boot的特色：AutoConfiguration。</p>
<p>当我们引入<code>spring-boot-starter-jdbc</code>时，启动时会自动扫描所有的<code>XxxAutoConfiguration</code>：</p>
<ul>
<li><code>DataSourceAutoConfiguration</code>：自动创建一个<code>DataSource</code>，其中配置项从<code>application.yml</code>的<code>spring.datasource</code>读取；</li>
<li><code>DataSourceTransactionManagerAutoConfiguration</code>：自动创建了一个基于JDBC的事务管理器；</li>
<li><code>JdbcTemplateAutoConfiguration</code>：自动创建了一个<code>JdbcTemplate</code>。</li>
</ul>
<p>因此，我们自动得到了一个<code>DataSource</code>、一个<code>DataSourceTransactionManager</code>和一个<code>JdbcTemplate</code>。</p>
<p>类似的，当我们引入<code>spring-boot-starter-web</code>时，自动创建了：</p>
<ul>
<li><code>ServletWebServerFactoryAutoConfiguration</code>：自动创建一个嵌入式Web服务器，默认是Tomcat；</li>
<li><code>DispatcherServletAutoConfiguration</code>：自动创建一个<code>DispatcherServlet</code>；</li>
<li><code>HttpEncodingAutoConfiguration</code>：自动创建一个<code>CharacterEncodingFilter</code>；</li>
<li><code>WebMvcAutoConfiguration</code>：自动创建若干与MVC相关的Bean。</li>
<li>…</li>
</ul>
<p>引入第三方<code>pebble-spring-boot-starter</code>时，自动创建了：</p>
<ul>
<li><code>PebbleAutoConfiguration</code>：自动创建了一个<code>PebbleViewResolver</code>。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java-Spring/" rel="tag"># java, Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/08/16/Docker-K8s/" rel="prev" title="Docker/K8s">
      <i class="fa fa-chevron-left"></i> Docker/K8s
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3"><span class="nav-text">网络相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#servlet"><span class="nav-text">servlet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redirect-%E4%B8%8E-Forward"><span class="nav-text">Redirect 与 Forward</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session-%E4%B8%8E-Cookie"><span class="nav-text">Session 与 Cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSP"><span class="nav-text">JSP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filter"><span class="nav-text">Filter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Listener"><span class="nav-text">Listener</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring"><span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#REST-%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="nav-text">REST 架构风格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC%E5%AE%B9%E5%99%A8%E4%B8%8EIoC%E5%AF%B9%E8%B1%A1"><span class="nav-text">IoC容器与IoC对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-text">注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">Bean的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5-%E4%BD%BF%E7%94%A8-Setter-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">使用构造函数注入 &amp;&amp; 使用 Setter 方法注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Component%E6%88%96-Bean%E5%A3%B0%E6%98%8E"><span class="nav-text">使用@Component或@Bean声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%89%E6%96%B9Bean"><span class="nav-text">创建第三方Bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FactoryBean"><span class="nav-text">FactoryBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81"><span class="nav-text">初始化与销毁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">Spring Bean 的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3"><span class="nav-text">数据库相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC"><span class="nav-text">JDBC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD"><span class="nav-text">JDBC事务传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88Hibernate"><span class="nav-text">结合Hibernate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88MyBatis"><span class="nav-text">结合MyBatis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E4%B8%8EHibernate-JPA-MyBatis"><span class="nav-text">JDBC与Hibernate, JPA, MyBatis</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3"><span class="nav-text">Spring 网络相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8"><span class="nav-text">启动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot"><span class="nav-text">Spring Boot</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="marigo1d"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">marigo1d</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">marigo1d</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
