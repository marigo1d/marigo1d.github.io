<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marigo1d.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Android学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="Android-Learning-Record">
<meta property="og:url" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/index.html">
<meta property="og:site_name" content="Marigold">
<meta property="og:description" content="Android学习记录">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/activity_lifecycle.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240813144056439.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240813145303945.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240813145313326.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240813144733590.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240723153011448-1722133358773.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240806112818621.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240806155020313.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240806155033149.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240805194744173.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240721155920403-1722133033018.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/944365-34992eb46bdf93e7.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240831191655656.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240831192314544.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240831145006895.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240831150437519.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240831152442110.png">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc27655e1184f1fa60b1b8ac4ed4a3b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/944365-c1adb9dd2d22c056.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/944365-858de1faa38df1b2.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/Android-learning-record/image-20240714103234291.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240731155705321.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240731160912852.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240731162932328.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240801102057483.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240801102304897.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240801102823567.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240801102846996.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240801103107985.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240805152408375.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240805152418585.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240805193239427.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240805193517661.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240805193529451.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240805193338222.png">
<meta property="og:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/image-20240805193638556.png">
<meta property="article:published_time" content="2024-07-28T02:16:25.000Z">
<meta property="article:modified_time" content="2025-03-28T02:22:03.736Z">
<meta property="article:author" content="marigo1d">
<meta property="article:tag" content="Android, Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/activity_lifecycle.png">

<link rel="canonical" href="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Android-Learning-Record | Marigold</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Marigold</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Salt, Pepper and Birds~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://marigo1d.github.io/2024/07/28/Android-Learning-Record/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="marigo1d">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marigold">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android-Learning-Record
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-28 10:16:25" itemprop="dateCreated datePublished" datetime="2024-07-28T10:16:25+08:00">2024-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-03-28 10:22:03" itemprop="dateModified" datetime="2025-03-28T10:22:03+08:00">2025-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>60k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:48</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Android学习记录</p>
<span id="more"></span>
<h1>Android Learning Record</h1>
<h2 id="Android程序">Android程序</h2>
<h3 id="View">View</h3>
<p><strong>dp 和 sp</strong></p>
<p><strong>dp (Density-independent Pixel - 密度无关像素)</strong></p>
<ul>
<li><strong>定义:</strong> dp 是一个基于屏幕密度的抽象单位。它代表了在 160 dpi (dots per inch) 屏幕上一个物理像素的长度。</li>
<li><strong>用途:</strong> 主要用于定义 View 的尺寸和间距，例如按钮的宽度、边距、内边距等。</li>
<li><strong>优势:</strong> 使用 dp 可以保证应用在不同屏幕密度的设备上保持一致的显示效果。系统会根据设备的屏幕密度自动将 dp 值转换为对应的像素值。</li>
<li><strong>示例:</strong>
<ul>
<li>android:layout_width=“100dp” 表示该 View 的宽度为 100dp，在不同密度的屏幕上，系统会将其转换为对应的像素值，以保持相同的物理尺寸。</li>
</ul>
</li>
</ul>
<p><strong>sp (Scale-independent Pixel - 缩放无关像素)</strong></p>
<ul>
<li><strong>定义:</strong> sp 与 dp 类似，也是一个基于屏幕密度的抽象单位。不同之处在于，sp 还受到用户字体大小设置的影响。</li>
<li><strong>用途:</strong> 主要用于定义文字大小。</li>
<li><strong>优势:</strong> 使用 sp 可以根据用户的字体大小偏好自动调整文字大小，提高应用的可访问性。</li>
<li><strong>示例:</strong>
<ul>
<li>android:textSize=“18sp” 表示该 TextView 的文字大小为 18sp，如果用户在系统设置中调整了字体大小，该 TextView 的文字大小也会随之改变。</li>
</ul>
</li>
</ul>
<p><strong>layout_gravity 和 gravity</strong></p>
<p><strong>layout_gravity</strong></p>
<ul>
<li><strong>作用目标:</strong> layout_gravity 属性用于控制 <strong>当前 View 在其父布局中的对齐方式</strong>。</li>
<li><strong>适用范围:</strong> 该属性只能应用于 <strong>ViewGroup 的子 View</strong>，因为它需要依赖于父布局的特性才能生效。</li>
<li><strong>常见取值:</strong>
<ul>
<li>top、bottom、left、right：分别表示顶部对齐、底部对齐、左侧对齐、右侧对齐。</li>
<li>center：表示水平和垂直居中对齐。</li>
<li>center_horizontal、center_vertical：分别表示水平居中对齐、垂直居中对齐。</li>
<li>start、end：分别表示在当前语言环境下，内容开始的方向对齐、内容结束的方向对齐。</li>
<li>可以使用 | 符号组合多个值，例如 android:layout_gravity=“bottom|right” 表示右下角对齐。</li>
</ul>
</li>
</ul>
<p><strong>gravity</strong></p>
<ul>
<li>
<p><strong>作用目标:</strong> gravity 属性用于控制 <strong>当前 View 中的内容对齐方式</strong>。</p>
</li>
<li>
<p><strong>适用范围:</strong> 该属性可以应用于 <strong>任何 View</strong>，因为它控制的是 View 自身内容的显示方式。</p>
</li>
<li>
<p><strong>常见取值:</strong></p>
<ul>
<li>与 layout_gravity 的取值基本相同，例如 top、bottom、left、right、center 等等。</li>
</ul>
</li>
</ul>
<p><strong>padding 与 margin</strong></p>
<ul>
<li>
<p><strong>padding(内边距)：</strong></p>
<ul>
<li>使视图的内容与其边界保持一定的距离。</li>
<li>使 TextView 中的文字距离 TextView 的边界 10dp，设置 android:padding=“10dp”。</li>
<li>padding 就像是在视图内部加了一圈空白边框，使得内容不会紧贴着视图边界。</li>
</ul>
</li>
<li>
<p><strong>margin(外边距)：</strong></p>
<ul>
<li>控制视图在布局中的位置，或者让视图之间保持一定的距离。</li>
<li>使两个 Button 之间保持 20dp 的距离，就可以为其中一个 Button 设置 android:layout_marginRight=“20dp”，或者为另一个 Button 设置 android:layout_marginLeft=“20dp”。</li>
<li><strong>margin 就像是在视图外部加了一圈透明边框，使得视图与其他视图之间保持一定的距离。</strong></li>
</ul>
</li>
</ul>
<p>margin和padding作用对象都是自身，非其他视图</p>
<p><strong>ConstrainLayout</strong></p>
<ul>
<li>
<p><strong>android:layout_width=“0dp”:</strong> 在 ConstraintLayout 中，将视图的宽度设置为 0dp 是一个特殊的用法。它表示该视图的宽度应该 <strong>匹配约束条件</strong>。在这个例子中，Button 的左右两边分别被约束到了 login_container 的左右两边 (app:layout_constraintEnd_toEndOf=“@id/login_container” 和 app:layout_constraintStart_toStartOf=“@id/login_container”)，因此 Button 的宽度会扩展到与 login_container 的宽度相同。</p>
</li>
<li>
<p><strong>app:layout_margin…</strong>: 这是一组专门用于 ConstraintLayout 的 margin 属性，用于设置视图与其约束目标之间的距离。例如：</p>
<ul>
<li>app:layout_marginStart：设置视图与其约束目标的起始边距（取决于布局方向，可能是左边距或右边距）。</li>
<li>app:layout_marginEnd：设置视图与其约束目标的结束边距。</li>
<li>app:layout_marginTop：设置视图与其约束目标的顶部边距。</li>
<li>app:layout_marginBottom：设置视图与其约束目标的底部边距。</li>
</ul>
</li>
</ul>
<p><strong>RecyclerView</strong></p>
<p>onCreateViewHolder触发时机</p>
<ul>
<li><strong>首次加载 RecyclerView 时：</strong> 当 RecyclerView 第一次被加载到屏幕上时，onCreateViewHolder 方法会被调用，用于创建 ViewHolder 实例。此时，RecyclerView 需要根据你的布局文件实例化 ViewHolder，并将它们缓存起来以备后用。</li>
<li><strong>缓存中没有可用的 ViewHolder 时：</strong> 当用户滚动 RecyclerView，需要显示新的 item，而缓存中没有可用的 ViewHolder 时，onCreateViewHolder 会被调用以创建新的 ViewHolder。</li>
</ul>
<p>onBindViewHolder触发时机</p>
<ul>
<li><strong>首次加载 RecyclerView 时：</strong> 在 onCreateViewHolder 创建了 ViewHolder 后，onBindViewHolder 方法会被立即调用，用于将数据绑定到 ViewHolder 上。</li>
<li><strong>用户滚动 RecyclerView，新的 item 需要显示时：</strong> 当用户滚动 RecyclerView，新的 item 进入屏幕时，onBindViewHolder 会被调用，将对应位置的数据绑定到复用的 ViewHolder 上。</li>
<li><strong>调用 notifyDataSetChanged() 等方法刷新 RecyclerView 时：</strong> 当你更新了数据源并调用 notifyDataSetChanged()、notifyItemInserted() 等方法刷新 RecyclerView 时，onBindViewHolder 会被调用，以更新 ViewHolder 的数据。</li>
</ul>
<p><strong>LayoutInflater</strong></p>
<p>LayoutInflater 是与 Context 绑定的，而 Activity 本身就是一个 Context。每个 Activity 都会持有自己唯一的 LayoutInflater 对象，用于加载布局文件。</p>
<p>该 Activity 中所有的 Fragment 和 RecyclerView 所使用的 LayoutInflater 对象为 Activity 对应的 Context LayoutInflater 对象</p>
<p>**ViewBinding 与 ViewHolder **</p>
<p>在启用ViewBinding后，ViewBinding 会为每个 XML 布局文件生成一个绑定类</p>
<p>针对每个xml文件，将使用(xml的驼峰文件名+Bindng)作为java文件名的方式，生成对应的java类</p>
<p>xml对应生成的 ViewBinding 类：</p>
<p><strong>根视图属性 (<code>root</code>)</strong>:</p>
<ul>
<li>每个生成的 ViewBinding 类都有一个 <code>root</code> 属性，表示布局的根视图（通常是最外层的 <code>ViewGroup</code>），通过 <code>getRoot()</code> 获取，为 View 类型。</li>
</ul>
<p><strong>每个视图的属性 (<code>views</code>)</strong> :</p>
<ul>
<li>对于布局中的每个视图，ViewBinding 类会生成一个相应的属性。这些属性的名称是基于视图的 <code>id</code> 自动生成的，格式为 <code>viewId</code>，其中 <code>viewId</code> 是 XML 布局中视图的 <code>android:id</code> 属性。</li>
</ul>
<p><strong><code>inflate</code> 方法</strong>:</p>
<ul>
<li>ViewBinding 类提供静态 <code>inflate</code> 方法，用于将布局文件转换为相应的视图层次结构，并返回 ViewBinding 类的实例。
<ul>
<li><code>inflate</code> 方法调用 LayoutInflater 将布局文件转换为对应的 View 层级结构。</li>
<li><code>inflate</code> 方法将 View 实例绑定到 Binding 对象的属性中。</li>
</ul>
</li>
</ul>
<p><strong><code>bind</code> 方法</strong>:</p>
<ul>
<li>ViewBinding 类还提供一个静态 <code>bind</code> 方法，用于将现有的视图（比如已经通过 <code>setContentView()</code> 加载的视图）绑定到 ViewBinding 类上。</li>
</ul>
<p>ViewHolder在创建时，通过 new Viewholder(binding) 创建，实际上是将 binding.root 赋值给了 ViewHolder.itemView</p>
<blockquote>
<p>ViewHolder 像是视图的“控制器”: ViewHolder 对根视图 (itemView) 进行了一次封装，但它更像是 MVC 模式中的 Controller，负责管理视图的生命周期、数据绑定、事件处理等逻辑。</p>
<p>ViewHolder 像是视图的“访问器”: ViewBinding 是对 View 树进行了一次包装，但它更像是提供了 类型安全、便捷 的方式来访问视图。</p>
</blockquote>
<h3 id="Context">Context</h3>
<ul>
<li><strong>资源访问:</strong> 获取字符串、颜色、尺寸、图片等资源。</li>
<li><strong>组件启动:</strong> 启动 Activity、Service、BroadcastReceiver 等组件。</li>
<li><strong>系统服务获取:</strong> 获取布局服务 (LayoutInflater)、包管理器 (PackageManager)、通知服务 (NotificationManager) 等系统服务。</li>
<li><strong>文件操作:</strong> 访问设备存储、缓存目录等。</li>
<li><strong>数据库操作:</strong> 使用 SQLite 数据库。</li>
<li><strong>网络操作:</strong> 发送网络请求。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字符串资源</span></span><br><span class="line"><span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> context.getString(R.string.app_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取颜色资源</span></span><br><span class="line"><span class="type">int</span> <span class="variable">primaryColor</span> <span class="operator">=</span> context.getColor(R.color.colorPrimary);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 Activity</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(context, SecondActivity.class);</span><br><span class="line">context.startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取布局加载器</span></span><br><span class="line"><span class="type">LayoutInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> LayoutInflater.from(context);</span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.my_layout, parent, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取包管理器</span></span><br><span class="line"><span class="type">PackageManager</span> <span class="variable">packageManager</span> <span class="operator">=</span> context.getPackageManager();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取通知服务</span></span><br><span class="line"><span class="type">NotificationManager</span> <span class="variable">notificationManager</span> <span class="operator">=</span> </span><br><span class="line">    (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br></pre></td></tr></table></figure>
<p><strong>ContextImpl与ContextWrapper</strong></p>
<p>Context类为抽象类，其中<strong>ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类</strong>。ContextWrapper在初始化时会创建ContextImpl对象，ContextImpl对象实现了Context中方法。</p>
<blockquote>
<p>所以说getApplication()和getApplicationContext()获取到的都是Appliction对象，但是在使用 getApplicationContext() 应该是使用Appliction对象的基类ContextImpl对象</p>
</blockquote>
<p>应用程序中拥有Context的对象：1 + numActivity + numService</p>
<ul>
<li>
<p><strong>Application:</strong> 继承自ContextWrapper</p>
</li>
<li>
<p><strong>Activity:</strong> 继承于ContextWrapper的子类ContextThemeWrapper类，</p>
</li>
<li>
<p><strong>Service:</strong> 继承于ContextWrapper类</p>
</li>
<li>
<p><strong>BroadcastReceiver:</strong> 非继承，通过其他传入获得</p>
</li>
<li>
<p><strong>ContentProvider:</strong> 非继承，通过其他传入获得</p>
</li>
</ul>
<p>启动其他Activity和弹出Dialog必须使用Activity的Context</p>
<ul>
<li>基于某Activity的Context启动的Activity将在此Activity基础上形成任务栈（即Activity栈），如果使用非Activity的Context启动Activity，必须指定该Activity的启动方式为 <code>FLAG_ACTIVITY_NEW_TASK</code></li>
<li>View.getContext返回的是设置该View布局的Activity对象的Context</li>
</ul>
<h2 id="Android">Android</h2>
<h3 id="四大组件">四大组件</h3>
<p>Activity（活动）、Service（服务）、BroadcastReceiver（广播接收器）和 ContentProvider（内容提供者）</p>
<h3 id="持久化">持久化</h3>
<p><strong>文件存储</strong></p>
<p><strong>SharedPreference - DataStore</strong></p>
<p>key - value</p>
<p><strong>SQLite</strong></p>
<p>数据库</p>
<h3 id="Adapter">Adapter</h3>
<p><code>Adapter</code> 负责：</p>
<ul>
<li>从数据源获取数据</li>
<li>创建 <code>View</code> 并将数据绑定到 <code>View</code> 上</li>
<li>通过 <code>notifyDataSetChanged()</code> 动态更新 UI</li>
</ul>
<p>View → adapter → data</p>
<h3 id="Activity与Fragment生命周期">Activity与Fragment生命周期</h3>
<img src="/2024/07/28/Android-Learning-Record/activity_lifecycle.png" class="" title="image1.png">
<p>单个Activity:</p>
<p>应用开启时：onCreate() -&gt; onStart() -&gt; onResume();</p>
<p>按下返回键：onPause() -&gt; onStop() -&gt; onDestory();</p>
<p>多个Activity之间交互时：</p>
<p>从第一个Activity启动第二个Activity时：</p>
<table>
<thead>
<tr>
<th>FirstActivity</th>
<th>SecondActivity</th>
</tr>
</thead>
<tbody>
<tr>
<td>onPause()</td>
<td></td>
</tr>
<tr>
<td></td>
<td>onCreate()</td>
</tr>
<tr>
<td></td>
<td>onStart()</td>
</tr>
<tr>
<td></td>
<td>onResume()</td>
</tr>
<tr>
<td>onStop()</td>
<td></td>
</tr>
</tbody>
</table>
<p>按下锁屏键时</p>
<table>
<thead>
<tr>
<th>SecondActivity</th>
</tr>
</thead>
<tbody>
<tr>
<td>onPause()</td>
</tr>
<tr>
<td>onStop()</td>
</tr>
</tbody>
</table>
<p>屏幕解锁</p>
<table>
<thead>
<tr>
<th>SecondActivity</th>
</tr>
</thead>
<tbody>
<tr>
<td>onRestart()</td>
</tr>
<tr>
<td>OnStart()</td>
</tr>
<tr>
<td>OnResume()</td>
</tr>
</tbody>
</table>
<p>按下返回键 / SecondActivity调用 <code>finish()</code></p>
<table>
<thead>
<tr>
<th>FirstActivity</th>
<th>SecondActivity</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>onPause()</td>
</tr>
<tr>
<td>onRestart()</td>
<td></td>
</tr>
<tr>
<td>onStart()</td>
<td></td>
</tr>
<tr>
<td>onResume()</td>
<td></td>
</tr>
<tr>
<td></td>
<td>onStop()</td>
</tr>
<tr>
<td></td>
<td>onDestory()</td>
</tr>
</tbody>
</table>
<p>Fragment</p>
<p>在创建的过程中，是Activity带领Fragment执行生命周期中的方法，所以生命周期方法的执行顺序是这样的：</p>
<p>1.Activity–onCreate();</p>
<p>2.Fragment–onAttach();</p>
<p>3.Fragment–onCreate();</p>
<p>4.Fragment–onCreateView();</p>
<p>5.Fragment–onActivityCreated();</p>
<p>接着是这样的：</p>
<p>6.Activity–onStart();</p>
<p>7.Fragment–onStart();</p>
<p>8.Activity–onResume();</p>
<p>9.Fragment–onResume();</p>
<p>我们知道，无论对于Activity还是对于Fragment，onResume这个生命周期都是他们执行时间最长的，当我们的Activity或者Fragment打开之后，它就一直处于这个生命周期中。</p>
<p>当销毁的时候，春江水暖鸭先知，当然是Fragment先感知到，于是销毁的时候就是Fragment带领Activity：</p>
<p>10.Fragment–onPause();</p>
<p>11.Activity–onPause();</p>
<p>12.Fragment–onStop();</p>
<p>13.Activity–onStop();</p>
<p>14.Fragment–onDestroyView();</p>
<p>15.Fragment–onDestroy();</p>
<p>16.Fragment–onDetach();</p>
<p>17.Activity–onDestroy();</p>
<p>上面这个顺序有一个前提，就是我们所有的日志打印代码都是紧挨着super方法写。因为如果我们如果把Fragment写在了布局文件中，同时又在Activity的onCreate()方法中的setContentView之后打印日志，那么我们看到的生命周期的执行顺序就会有所不同，不过只是细微的差别，这点大家自己研究，道理也很好明白。</p>
<p>总之一句话，在创建的过程中，是Activity带领着Fragment，在销毁的过程中，是Fragment带领着Activity。</p>
<p>文章来源: <a target="_blank" rel="noopener" href="http://wangsong.blog.csdn.net">wangsong.blog.csdn.net</a>，作者：_江南一点雨，版权归原作者所有，如需转载，请联系作者。</p>
<h3 id="智能指针">智能指针</h3>
<p>为了解决手动内存管理带来的问题而设计的。它们通过引用计数来跟踪有多少个指针指向同一个对象。</p>
<ul>
<li>当你创建一个指向对象的智能指针时，对象的引用计数加 1。</li>
<li>当智能指针超出作用域或被赋值为其他值时，引用计数减 1。</li>
<li>当引用计数变为 0 时，智能指针会自动销毁对象，释放内存。</li>
</ul>
<p><strong>循环引用问题</strong>： 对象A中存在智能指针指向对象B，对象B中存在智能指针指向对象A；</p>
<p>由于智能指针的引用计数始终不为0，对象A和对象B将始终不能被释放。</p>
<p><strong>解决方案</strong>：使用弱引用；对某对象使用弱引用将不增加引用计数。</p>
<h3 id="Java层与Native层">Java层与Native层</h3>
<p><strong>流程</strong></p>
<p><strong>1. Java 层调用 native 方法：</strong></p>
<ul>
<li>当 Java 代码执行到 native 方法调用时，例如 System.loadLibrary(“mylib”); 或调用某个 native 方法，JVM 会暂停当前 Java 方法的执行。</li>
</ul>
<p><strong>2. 检查方法表：</strong></p>
<ul>
<li>JVM 会先检查该 native 方法是否已经链接到对应的 native 函数。</li>
<li>每个类都有一个方法表（<strong>methodTable</strong>），存储了该类的所有方法信息，包括 native 方法。</li>
<li>如果方法表中已经有该 native 方法的入口地址，说明已经完成链接，可以直接跳转到步骤 6 执行 native 代码。</li>
</ul>
<p><strong>3. 加载动态链接库：</strong></p>
<ul>
<li>如果方法表中没有找到 native 方法的入口地址，说明该 native 方法还没有链接。</li>
<li>JVM 会调用 System.loadLibrary() 方法加载指定的动态链接库 (例如 <a target="_blank" rel="noopener" href="http://libmylib.so">libmylib.so</a>)。</li>
<li>动态链接库加载后，会被映射到进程的地址空间。</li>
</ul>
<p><strong>4. 查找 JNI_OnLoad 函数：</strong></p>
<ul>
<li>JVM 会在加载的动态链接库中查找名为 JNI_OnLoad 的函数。</li>
<li>这个函数是可选的，如果存在，JVM 会调用它。</li>
<li>JNI_OnLoad 函数可以进行一些初始化工作，例如注册 native 方法。</li>
</ul>
<p><strong>5. 注册 native 方法：</strong></p>
<ul>
<li>如果动态链接库中存在 JNI_OnLoad 函数，并且该函数调用了 RegisterNatives 方法，那么 JVM 会根据 RegisterNatives 提供的参数，将 Java native 方法与动态链接库中的 native 函数进行关联。</li>
<li>JVM 会更新方法表，将 native 方法的入口地址设置为对应的 native 函数地址。</li>
</ul>
<p><strong>6. 执行 native 代码：</strong></p>
<ul>
<li>现在，JVM 已经找到了 native 方法对应的 native 函数地址。</li>
<li>JVM 将控制权转移到 native 函数，并将必要的参数传递给 native 函数。
<ul>
<li><strong>参数转换：</strong> Java 和 native 代码使用不同的数据类型，因此 JVM 需要将 Java 参数转换为 native 函数能够理解的数据类型。 例如，将 Java 的 String 类型转换为 C 的 char* 类型。</li>
<li><strong>压入 JNIEnv 指针：</strong> JVM 会将 JNIEnv 指针作为第一个参数压入 native 方法栈。 JNIEnv 指针指向一个线程局部变量，包含了大量的 JNI 函数指针，native 函数可以通过这些函数与 JVM 进行交互。</li>
<li><strong>压入 jclass 或 jobject 引用：</strong> 对于非静态 native 方法，JVM 还会将调用该方法的 Java 对象的引用 (jobject) 压入 native 方法栈。 对于静态 native 方法，则会将该方法所属类的引用 (jclass) 压入 native 方法栈。</li>
</ul>
</li>
<li>native 函数执行完毕后，将结果返回给 JVM。</li>
</ul>
<p><strong>7. 返回 Java 层：</strong></p>
<ul>
<li>JVM 恢复 Java 方法的执行，并使用 native 函数返回的结果继续执行后续的指令。</li>
</ul>
<blockquote>
<p><strong>JNIEnv</strong> 仅用于访问 <strong>JVM 自带的 JNI 函数</strong></p>
<p><strong>程序员自行加载的 JNI 函数</strong> 通过JVM查类的<strong>methodTable</strong>获取JNI函数入口</p>
<p><strong>so 库中的 native 函数:</strong></p>
<ul>
<li>这些函数是由开发者使用 C/C++ 等 native 语言编写的，用于实现特定的功能，例如访问硬件、调用第三方库等。</li>
<li>这些函数需要通过 JNI_OnLoad 和 RegisterNatives 注册到 JVM，才能被 Java 代码调用。</li>
</ul>
<p><strong>JVM 自身实现的 JNI 函数:</strong></p>
<ul>
<li>这些函数是 JVM 内部实现的，用于处理 Java 和 native 代码之间的交互，例如创建 Java 对象、调用 Java 方法、处理异常等等。</li>
<li>这些函数不需要开发者手动注册，它们是 JVM 的一部分，可以直接通过 JNIEnv 指针访问。</li>
</ul>
<p>– NewStringUTF 函数： 这个函数用于创建一个新的 Java 字符串对象，它是 JVM 自身实现的 JNI 函数，你可以在 jni.h 头文件中找到它的声明。<br>
– FindClass 函数： 这个函数用于查找指定的 Java 类，它也是 JVM 自身实现的 JNI 函数。<br>
– CallObjectMethod 函数： 这个函数用于调用 Java 对象的实例方法，它也是 JVM 自身实现的 JNI 函数。</p>
</blockquote>
<p><strong>Java函数，native函数与JNI函数</strong></p>
<p>native函数</p>
<p>即为标准c/c++函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算两个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印字符串到控制台</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JNI函数：可供Java语言调用的，非Java语言实现函数（服务于Java的C函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Java 字符串的长度</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_com_example_MyClass_getStringLength</span><span class="params">(JNIEnv *env, jobject thiz, jstring str)</span> </span>&#123;  <span class="comment">// JNIEXPORT 和 JNICALL 是平台相关的宏定义</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* nativeStr = env-&gt;<span class="built_in">GetStringUTFChars</span>(str, <span class="number">0</span>);</span><br><span class="line">  jint len = <span class="built_in">strlen</span>(nativeStr); </span><br><span class="line">  env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(str, nativeStr);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java函数调用JNI函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJavaClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;my_native_lib&quot;</span>); <span class="comment">// 加载 Native 库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 native 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">getSumFromNative</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyJavaClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyJavaClass</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> obj.getSumFromNative(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用 native 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Sum from Native: &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JNI 函数 (C++)</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL </span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_MyJavaClass_getSumFromNative</span><span class="params">(JNIEnv *env, jobject thiz, jint a, jint b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算 a 和 b 的和</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>native函数调用Java函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JNI 函数 (C++)</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL </span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_MyNativeClass_callJavaMethod</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;  <span class="comment">// 实际上普通的C函数就可以使用JNIEnv调用java函数，这里写成JNI函数是为了使用Java访问该函数再调用其他的java函数</span></span><br><span class="line">    <span class="comment">// 获取 Java 类</span></span><br><span class="line">    jclass cls = env-&gt;<span class="built_in">GetObjectClass</span>(thiz); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Java 方法的 ID</span></span><br><span class="line">    jmethodID mid = env-&gt;<span class="built_in">GetMethodID</span>(cls, <span class="string">&quot;printMessage&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Java 字符串</span></span><br><span class="line">    jstring message = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello from Native!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Java 方法</span></span><br><span class="line">    env-&gt;<span class="built_in">CallVoidMethod</span>(thiz, mid, message); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNativeClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message from Native: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常见内存泄露情况">常见内存泄露情况</h3>
<p><strong>非静态的内部类默认持有外部类的引用</strong></p>
<p>将一个长时间运行的（匿名）内部类对象传递给其他对象，而这些对象的生命周期比外部类更长，就会导致外部类无法被垃圾回收，从而造成内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_leaky);</span><br><span class="line"></span><br><span class="line">        textView = findViewById(R.id.text_view);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>); <span class="comment">// 模拟耗时 10 秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 尝试更新 UI，但此时 Activity 可能已经销毁</span></span><br><span class="line">                textView.setText(<span class="string">&quot;更新 UI&quot;</span>); <span class="comment">// 这里会造成内存泄漏</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案，使用静态内部类 + 弱引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyHandler</span> <span class="variable">mMyHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Activity&gt; mReference;</span><br><span class="line"></span><br><span class="line">        MyHandler(Activity reference) &#123;</span><br><span class="line">            mReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(reference);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="type">MainActivity</span> <span class="variable">activity</span> <span class="operator">=</span> (MainActivity) mReference.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">                activity.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        mMyHandler.removeCallbacksAndMessages(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>匿名内部类与匿名函数 (Lambda 表达式)</strong></p>
<p><strong>匿名内部类</strong></p>
<p><strong>定义：</strong></p>
<ul>
<li>匿名内部类是<strong>没有名字的类定义</strong>，通常在需要使用类的地方直接定义和实例化。</li>
<li>必须继承一个类或实现一个接口。</li>
</ul>
<p><strong>语法：</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口() &#123;</span><br><span class="line">    <span class="comment">// 类体，可以包含成员变量、方法、构造函数等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个实现 Runnable 接口的匿名内部类</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名内部类执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;按钮被点击了！ (普通类)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;点击我&quot;</span>);</span><br><span class="line">        <span class="type">MyButtonListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyButtonListener</span>();</span><br><span class="line">        button.addActionListener(listener); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;点击我&quot;</span>);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;按钮被点击了！ (匿名内部类)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匿名函数 (Lambda 表达式)</strong></p>
<p><strong>定义：</strong></p>
<ul>
<li>Lambda 表达式是 Java 8 引入的一种<strong>简洁的函数式编程语法</strong>。</li>
<li>可以看作是<strong>匿名函数</strong>，可以直接传递给需要函数式接口作为参数的方法。</li>
</ul>
<p><strong>语法：</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表可以省略类型，如果只有一个参数，括号也可以省略。</li>
<li>如果函数体只有一行代码，花括号也可以省略。</li>
</ul>
<p><strong>示例：</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式创建 Runnable 实例</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Lambda 表达式执行中...&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>静态变量持有对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(context);  <span class="comment">// 静态变量持有context对象，导致Activity对象无法被GC</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Message">Message</h3>
<h4 id="Handler，Looper与MessageQueue">Handler，Looper与MessageQueue</h4>
<p><strong>Message</strong></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240813144056439.png" class="" title="image-20240813144056439">
<ul>
<li>obtain(): 若sPool中存在msg，取出并返回；否则new返回</li>
<li>obtain(h: Handler): 调用obtain()并指定msg的target为Handler</li>
<li>obtain(h: Handler, callback: Runnable): 额外指定callback</li>
</ul>
<p><strong>Looper&amp;MessageQueue</strong></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240813145303945.png" class="" title="image-20240813145303945">
<img src="/2024/07/28/Android-Learning-Record/image-20240813145313326.png" class="" title="image-20240813145313326">
<p>主线程有且只有一个 Looper，它是在应用启动时由系统自动创建并启动的。</p>
<p>子线程默认没有Looper，需要手动创建和启动。</p>
<p>Looper与MessageQueue</p>
<ul>
<li>
<p>每个 Looper 都会关联一个唯一的 MessageQueue。Looper 对象创建时，会创建一个 MessageQueue 对象。</p>
</li>
<li>
<p>MessageQueue 就像一个消息容器，负责存储消息。当我们使用 Handler 发送消息时，消息并不会直接被处理，而是会被添加到 Looper 关联的 MessageQueue 中。</p>
</li>
<li>
<p>Looper 通过一个无限循环不断地从 MessageQueue 中读取消息。当 Looper 发现 MessageQueue 中没有消息可处理时，就会判断是否有 IdleHandler 需要执行；若没有， Looper 就会进入休眠状态，等待新的消息到来。</p>
</li>
<li>
<p>当 Looper 从 MessageQueue 中读取到消息后，会根据消息的 target 属性（即发送消息时使用的 Handler 对象），将消息分发给对应的 Handler 进行处理。</p>
</li>
</ul>
<p><strong>一个线程最多一个Looper！！！</strong></p>
<blockquote>
<p>如何保证一个线程最多一个Looper？</p>
<p>ThreadLocal是一个线程内部的数据存储类，当某个线程调用prepare方法的时候，会首先通过ThreadLocal检查这个线程是否已经创建了Looper,如果还没创建，则实例化Looper并将实例化后的Looper保存到ThreadLocal中，而如果ThreadLocal中已经保存了Looper，则会抛出一个RuntimeException的异常。那么意味着在一个线程中最多只能调用一次prepare方法，这样就保证了Looper的唯一性。</p>
</blockquote>
<p><strong>Handler</strong></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240813144733590.png" class="" title="image-20240813144733590">
<p>Handler不会被默认创建，需手动创建</p>
<p><strong>多个 Handler 可绑定同一个 Looper</strong>，在创建 Handler 时，若未指定 Looper，则默认绑定当前线程的 Looper</p>
<p>使用 Handler 对象的 send 或 post 方法，向 Handler 对象绑定的 Looper 对应的 MessageQueue 发送Msg。<strong>若发送的为runnable，handler会将其封装为Message。</strong></p>
<p>Looper.loop() 方法不断从 MessageQueue 中取出消息。</p>
<p>Looper 取出消息后，会根据 Message.target 属性找到当初发送该消息的 Handler。</p>
<p><strong>Handler 处理消息:</strong> Handler 接收到 Looper 派发的消息后，执行以下逻辑：</p>
<ul>
<li>
<p>检查 Message 是否携带 Callback，若有则调用 Callback.run() 处理消息。</p>
</li>
<li>
<p>若 Message 没有 Callback，则检查Handler自身是否设置了默认的 mCallback，若有则调用 mCallback.handleMessage() 处理消息。</p>
</li>
<li>
<p>若以上两种 Callback 都没有，则调用自身 handleMessage() 方法处理消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="comment">// msg.callback.run() msg处理次序1</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;  <span class="comment">// msg处理次序2</span></span><br><span class="line">            <span class="comment">// mCallback.handleMessage(msg)</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// msg处理次序3</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意1：进行Msg处理（调用 handleMessage 方法）的是Handler所绑定的Looper所在的线程，即消息发送到哪个消息队列，该队列所在线程就进行消息处理</strong></p>
<p><strong>注意2：主线程的大部分时间都在 Looper 的循环中度过，所有的操作，包括生命周期方法调用、UI 更新、事件处理等，都是作为消息被 Looper 依次处理的，每个消息的处理都是短暂的。一个消息处理完毕后，Looper 立即处理下一个消息或等待新消息。</strong></p>
<p>在通常情况下，主线程创建 Handler 对象并绑定mainLooper，子线程使用该 Handler 对象发送信息到主线程的MessageQueue ，当 Looper 从 MessageQueue 中读取到消息后，调用发送该 Msg 的 Handler handleMessage 方法处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler networkHandler;</span><br><span class="line">    <span class="keyword">private</span> Handler uiHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建处理网络请求的 Handler</span></span><br><span class="line">        networkHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 处理网络请求结果</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) msg.obj;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;网络请求结果: &quot;</span> + result, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建处理用户输入事件的 Handler</span></span><br><span class="line">        uiHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 处理用户输入事件</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> (String) msg.obj;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;用户输入: &quot;</span> + input, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟网络请求</span></span><br><span class="line">        simulateNetworkRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟用户输入事件</span></span><br><span class="line">        simulateUserInput();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">simulateNetworkRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送网络请求结果</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">            message.obj = <span class="string">&quot;成功!&quot;</span>;</span><br><span class="line">            networkHandler.sendMessage(message);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">simulateUserInput</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 发送用户输入事件</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        message.obj = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">        uiHandler.sendMessageDelayed(message, <span class="number">3000</span>); <span class="comment">// 延迟 3 秒发送</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>runOnUiThread()</p>
<p>Android 应用中的 UI 元素（例如按钮、文本框、图片等）都是运行在主线程中，这个主线程也被称为 UI 线程。如果在后台线程（非 UI 线程）中执行耗时操作（例如网络请求、文件读写），操作完成后如果需要更新 UI，就不能直接在后台线程中进行。这是因为 Android 规定只能在 UI 线程中更新 UI 元素。</p>
<p>runOnUiThread() 方法的作用是将一段代码逻辑放入 UI 线程的消息队列中，等待 UI 线程空闲时执行。这样就保证了更新 UI 的操作一定会在 UI 线程中进行，避免了线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runOnUiThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(), <span class="string">&quot;This is a Toast message&quot;</span>, Toast.LENGTH_SHORT).show();  <span class="comment">// Toast必须放在Ui线程执行哦</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>IdleHandler</strong></p>
<p><strong>消息队列中有消息</strong>: Looper 会取出消息并分发给对应的 Handler 处理。</p>
<p><strong>消息队列为空</strong>: Looper 会检查是否有 IdleHandler 需要执行。如果有，就依次执行 IdleHandler 的 queueIdle() 方法；如果没有，Looper 就会进入休眠状态，等待新的消息到来。</p>
<p>queueIdle() 方法的返回值是一个boolean值，返回true会将IdleHandler保留，否则会将其移除。重写Idle的 queueIdle 方法实现在消息队列为空时进行的任务。</p>
<p>在MessageQueue中维护了一个IdleHandler集合<code>mIdleHandlers</code>，并且提供了添加IdleHandler和移除IdleHandler的方法。可以通过 <code>Looper.myQueue().addIdleHandler(new Idler())</code> 添加一个IdleHandler。</p>
<p><strong>HandlerThread</strong></p>
<p>自带 Looper 的线程，启动后会自动创建并运行 Looper 的消息循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.HandlerThread;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerThread mCompressThread;</span><br><span class="line">    <span class="keyword">private</span> Handler mCompressHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 HandlerThread</span></span><br><span class="line">        mCompressThread = <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;CompressThread&quot;</span>);</span><br><span class="line">        mCompressThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Handler，绑定到 HandlerThread 的 Looper</span></span><br><span class="line">        mCompressHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mCompressThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟图片压缩操作</span></span><br><span class="line">                <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> (Bitmap) msg.obj;</span><br><span class="line">                compressImage(bitmap);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务完成，计数器减一</span></span><br><span class="line">                ((CountDownLatch) msg.getData().getParcelable(<span class="string">&quot;latch&quot;</span>)).countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟添加多个图片压缩任务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">imageCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(imageCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; imageCount; i++) &#123;</span><br><span class="line">            <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher_background);</span><br><span class="line">            addTaskToQueue(bitmap, latch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;所有图片压缩任务已完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加压缩任务到消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTaskToQueue</span><span class="params">(Bitmap bitmap, CountDownLatch latch)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        message.obj = bitmap;</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        data.putParcelable(<span class="string">&quot;latch&quot;</span>, latch);</span><br><span class="line">        message.setData(data);</span><br><span class="line">        mCompressHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟图片压缩操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">compressImage</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="number">80</span>, baos);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            Log.d(TAG, <span class="string">&quot;图片压缩完成，线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 退出 HandlerThread</span></span><br><span class="line">        mCompressThread.quitSafely();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步屏障">同步屏障</h4>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6924733444509892622">图示Android系统原理之Handler同步屏障（二）答：Demo工程中详细演示了插入屏障消息的方式。插入和移除屏障消 - 掘金</a></p>
<p>输入事件/invalidate方法请求屏幕刷新后，会产生同步屏障，屏蔽同步消息的处理，直到一下次Vsync信号到达→Choreographer撤销同步屏障，执行measure, layout, draw</p>
<h3 id="进程间交互">进程间交互</h3>
<p>平时我们所熟知的前端（Web\Android\iOS）通过网络与服务器通信是客户端-服务端模式的体现，而在Android Framework中，四大组件的创建、生命周期也是通过这样的模式进行通信：</p>
<ul>
<li>服务器端(server)指的就是SystemServer进程，这个进程提供了很多服务，比如AMS、PMS、WMS等等，所有的APP进程都可以与其通信。</li>
<li>客户端(client)指的就是各个独立的APP进程。</li>
</ul>
<p>Android开发中，我们可以通过Package包名和Activity类名，来打开一个APP。实际上，项目里的业务代码startActivity()方法并不是直接创建进程、拉起APP的。而是通过一系列的调用，把请求传递给SystemServer的AMS。AMS收到来自客户端的请求后，再通知zygote进程来fork一个新进程，来开启我们的目标APP。APP中所有Activity的生命周期过程，都由AMS（SystemServer进程）统一调度，并在APP自身进程中具体完成。</p>
<p>这个过程涉及到3个进程：APP进程、SystemServer进程、Zygote进程。</p>
<ul>
<li>APP进程与SystemServer进程通过Binder机制，进行跨进程通信。</li>
<li>SystemServer进程与Zygote进程通过Socket，进行跨进程通信。</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240723153011448-1722133358773.png" class="" title="image-20240723153011448">
<h4 id="AIDL与Binder">AIDL与Binder</h4>
<p><strong>Android Interface Definition Language</strong></p>
<p>仅当需要在<strong>不同应用间通过 IPC 方式访问服务（在服务中进行多线程处理）时</strong>才有必要使用 AIDL。若<strong>无需跨越不同应用，同应用内执行并发 IPC，则应通过实现 Binder</strong> 来创建接口；又或者<strong>只想执行 IPC，但不需要处理多线程时使用 Messenger</strong> 来实现接口。</p>
<p>server进程与client进程交互</p>
<p><strong>普通方式</strong></p>
<p>server进程：</p>
<p>继承Service，实现onBinder并返回Binder对象；</p>
<p>需在该Binder对象中实现onTransact(…)和服务方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> REQUEST_CODE=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Binder</span> <span class="variable">mBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binder</span>() &#123;</span><br><span class="line">        <span class="comment">// 透过匿名内部类方式继承Binder并实现服务方法，该方式存在内存泄露</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, <span class="meta">@NonNull</span> Parcel data, <span class="meta">@Nullable</span> Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            <span class="keyword">if</span> (code == REQUEST_CODE) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> data.readString();</span><br><span class="line">                <span class="comment">// 根据姓名查询学生成绩并将成绩写入到返回数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">studentGrade</span> <span class="operator">=</span> getStudentGrade(name);</span><br><span class="line">                <span class="keyword">if</span> (reply != <span class="literal">null</span>)</span><br><span class="line">                    reply.writeInt(studentGrade);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 服务方法：根据姓名查询学生成绩</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;         </span><br><span class="line">            <span class="keyword">return</span> StudentMap.getStudentGrade(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>client进程：</p>
<p>通过bindService(intent, mServiceConnection, xxx)绑定服务，</p>
<p>mServiceConnection对象中实现onServiceConnected和onServiceDisconnected方法，方法中获得server进程返回的Binder对象</p>
<p>调用Binder对象的onTransact方法得到结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinderActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="comment">// 远程服务的Binder代理</span></span><br><span class="line">    <span class="keyword">private</span> IBinder mRemoteBinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取远程服务的Binder代理</span></span><br><span class="line">            mRemoteBinder = iBinder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> &#123;</span><br><span class="line">            mRemoteBinder = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_binder);</span><br><span class="line">        <span class="comment">// 绑定服务</span></span><br><span class="line">        findViewById(R.id.btn_bind_service).setOnClickListener(view -&gt; bindGradeService());</span><br><span class="line">        <span class="comment">// 查询学生成绩</span></span><br><span class="line">        findViewById(R.id.btn_find_grade).setOnClickListener(view -&gt; getStudentGrade(<span class="string">&quot;Anna&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定远程服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindGradeService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> <span class="string">&quot;android.intent.action.server.gradeservice&quot;</span>;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(action);</span><br><span class="line">        intent.setPackage(getPackageName());</span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从远程服务查询学生成绩</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">int</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRemoteBinder == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Need Bind Remote Server...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mRemoteBinder.transact(REQUEST_CODE, data, reply, <span class="number">0</span>);</span><br><span class="line">            grade = reply.readInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用ServiceConnection对象的原因</p>
<ul>
<li>绑定服务是一个异步操作，服务进程的连接和启动都需要时间。</li>
<li>如果客户端进程同步等待服务连接，可能会导致 UI 线程阻塞，造成 ANR (Application Not Responding)。</li>
<li><code>ServiceConnection</code>  提供了一种异步回调机制，当服务连接成功或断开时，系统会自动回调 <code>ServiceConnection</code>  中的 <code>onServiceConnected()</code>  和 <code>onServiceDisconnected()</code>  方法，通知客户端进程。默认情况下，bindService() 方法是在主线程中调用的，因此 ServiceConnection 的回调方法也会在主线程中执行。</li>
<li>这样，客户端进程就可以在 <code>onServiceConnected()</code>  方法中获取到服务的代理对象，并在 <code>onServiceDisconnected()</code>  方法中处理服务断开的情况，而无需阻塞等待。</li>
</ul>
<p>客户端调用Binder对象的transact方法中转</p>
<ul>
<li>客户端调用的是 Binder 代理对象（客户端内的binder对象）的 transact()。这个方法会将请求发送给 Binder 驱动。</li>
<li>Binder 驱动收到请求后，会找到对应的服务端 Binder 对象，并在服务端进程调用 <strong>服务端 Binder 对象</strong> 的 onTransact() 方法。</li>
</ul>
<p><strong>xxxbinder.transact() 方法是一个同步方法，这意味着在默认情况下，客户端进程会在调用 transact() 方法后阻塞，直到服务端进程完成请求并返回结果。</strong></p>
</blockquote>
<p><strong>代理模式</strong></p>
<p>server进程：</p>
<p>引入服务方法端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGradeInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入xxxBinder继承一般Binder类并实现服务端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> <span class="keyword">implements</span> <span class="title class_">IGradeInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StudentMap.getStudentGrade(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, <span class="meta">@NonNull</span> Parcel data, <span class="meta">@Nullable</span> Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">if</span> (code == REQUEST_CODE) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> data.readString();</span><br><span class="line">            <span class="type">int</span> <span class="variable">studentGrade</span> <span class="operator">=</span> getStudentGrade(name);</span><br><span class="line">            <span class="keyword">if</span> (reply != <span class="literal">null</span>)</span><br><span class="line">                reply.writeInt(studentGrade);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端继承Service，实现onBinder并返回xxxBinder对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> REQUEST_CODE=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Binder</span> <span class="variable">mBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeBinder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client进程：</p>
<p>引入服务方法端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGradeInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现服务接口得到代理Binder类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinderProxy</span> <span class="keyword">implements</span> <span class="title class_">IGradeInterface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mBinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BinderProxy</span><span class="params">(IBinder binder)</span> &#123;</span><br><span class="line">        mBinder = binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 通过Binder查询成绩</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">int</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBinder == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Need Bind Remote Server...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mBinder.transact(REQUEST_CODE, data, reply, <span class="number">0</span>);</span><br><span class="line">            grade = reply.readInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 实例化Binder代理类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IGradeInterface <span class="title function_">asInterface</span><span class="params">(IBinder iBinder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (iBinder == <span class="literal">null</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 始终返回 BinderProxy 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BinderProxy</span>(iBinder); </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主activity中通过ServiceConnection对象的onServiceConnected方法从服务端得到返回的Binder对象，转成代理类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> &#123;</span><br><span class="line">      	<span class="comment">// 连接服务成功，根据是否跨进程获取BinderProxy或者GradeBinder实例</span></span><br><span class="line">        mBinderProxy = BinderProxy.asInterface(iBinder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> &#123;</span><br><span class="line">        mBinderProxy = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关于 onTransact()/transact(…) 方法：</strong></p>
<ul>
<li>虽然客户端代码中没有直接调用 transact(…) 方法，但实际上，客户端的BinderProxy 的 getStudentGrade() 方法内部会调用 mBinder.transact(…)，最终还是会走到服务端的 onTransact() 方法。</li>
<li>代理模式只是隐藏了底层的通信细节，让客户端代码看起来像是在调用本地方法一样，但实际上跨进程通信仍然是通过 transact() 和 onTransact() 方法来完成的。</li>
</ul>
</blockquote>
<p><strong>AIDL</strong></p>
<blockquote>
<p>类似于代理模式，AIDL 会自动生成类似于所写的 <code>IGradeInterface</code>、服务端<code>GradeBinder</code>、客户端<code>BinderProxy</code>  这样的代码结构，从而简化了 Binder 通信的开发。</p>
</blockquote>
<p>server进程：</p>
<p>创建AIDL文件，将暴露给客户端的<strong>接口在这个AIDL文件中声明</strong>，</p>
<ul>
<li>在服务端项目的 src/main 目录下创建一个名为 aidl 的文件夹（如果还没有的话）。</li>
<li>在 aidl 文件夹内创建一个与你的包名相同的文件夹，例如 com/example/gradeservice。</li>
<li>在该包名文件夹下创建一个名为 IGradeService.aidl 的文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IGradeService.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.gradeservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IGradeService</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Service中实现这个AIDL接口并创建<strong>Service用来监听客户端的连接请求</strong>。</p>
<ul>
<li>Rebuild 项目。Android Studio 会自动根据 AIDL 文件生成对应的 Java 接口文件（IGradeService.java）。</li>
<li>创建一个名为 GradeService 的 Service 类，并实现 IGradeService.Stub 抽象类。</li>
<li>在 GradeService 中实现 getStudentGrade() 方法，提供具体的业务逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GradeService.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.gradeservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IGradeService.<span class="type">Stub</span> <span class="variable">mBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IGradeService</span>.Stub() &#123; <span class="comment">// 实现接口IGradeService的binder类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            <span class="keyword">return</span> StudentMap.getStudentGrade(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client进程：</p>
<p>引入AIDL</p>
<ul>
<li>将服务端的 IGradeService.aidl 文件 <strong>原封不动地</strong> 复制到客户端项目的 src/main/aidl/com/example/gradeservice/ 目录下。</li>
</ul>
<p><strong>绑定服务端的Service</strong>，绑定成功后，将<strong>服务端返回的Binder对象转成AIDL接口所属的类型</strong>，调用AIDL接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.gradeservice.IGradeService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">BaseViewBindingActivity</span>&lt;ActivityBinderBinding&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IGradeService mBinderProxy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> &#123;</span><br><span class="line">          	<span class="comment">// 透过服务端返回的binder对象转换为代理binder对象</span></span><br><span class="line">            mBinderProxy = IGradeService.Stub.asInterface(iBinder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> &#123;</span><br><span class="line">            mBinderProxy = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        binding.btnBindService.setOnClickListener(view -&gt; bindGradeService());</span><br><span class="line">      	<span class="comment">// 查询学生成绩</span></span><br><span class="line">        binding.btnFindGrade.setOnClickListener(view -&gt; getStudentGrade(<span class="string">&quot;Anna&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 绑定服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindGradeService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> <span class="string">&quot;android.intent.action.server.aidl.gradeservice&quot;</span>;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(action);</span><br><span class="line">        intent.setPackage(getPackageName());</span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 查询成绩</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            grade = mBinderProxy.getStudentGrade(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ToastUtils.showShort(<span class="string">&quot;Anna grade is &quot;</span> + grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Binder实现">Binder实现</h4>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/samchen2009/p/3316001.html">https://www.cnblogs.com/samchen2009/p/3316001.html</a></p>
<p><a target="_blank" rel="noopener" href="https://sharrychoo.github.io/blog/android-source/dc-binder1">https://sharrychoo.github.io/blog/android-source/dc-binder1</a></p>
<p>进程使用Binder与System_Server通信，例如：AlarmManagerService、BluetoothService 和 BatteryService，</p>
<p><strong>Binder结构</strong></p>
<p><strong>device_node</strong>: Binder设备节点。</p>
<p><strong>global_state</strong>: 全局状态信息，包括上下文管理器、进程计数、线程计数等。</p>
<p><strong>binder_procs</strong>: 使用Binder的进程列表，每个<strong>binder_proc</strong>包含：</p>
<ul>
<li>nodes: 红黑树，用于存储该进程创建的所有 Binder 对象。
<ul>
<li><strong>Binder 对象:</strong> 提供特定功能的接口，例如 MediaPlayerService、ActivityManagerService 等系统服务。进程每提供一种服务就有一个binder对象。</li>
</ul>
</li>
<li>refs: 记录其他进程对该进程中 Binder 对象的引用。
<ul>
<li><strong>Binder 引用对象:</strong> 代表对一个 Binder 对象的引用，可以在进程间传递，例如客户端进程持有的服务端 Binder 对象的引用。</li>
</ul>
</li>
<li>buffers: 管理 Binder 通信过程中使用到的内存缓冲区。</li>
<li>binder_thread: binder_thread 结构体指针数组，存储了该进程所有 Binder 线程的信息。</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240806112818621.png" class="" title="image-20240806112818621">
<p><strong>Binder源码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">	<span class="comment">// 用于将该 binder_proc 结构体插入到一个哈希链表中。该哈希链表存储了系统中所有的 binder_proc 结构体，方便查找。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line">	<span class="comment">// 红黑树的根节点。该红黑树存储了该进程中所有的 binder_thread 结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">	<span class="comment">// 红黑树的根节点。该红黑树存储了该进程中所有的 binder_node 结构体，用于管理 Binder 实体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动函数映射。定义了 Binder 驱动的文件操作函数集。每个成员都是一个函数指针，指向处理特定文件操作的函数。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册驱动参数结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> =</span> &#123;</span><br><span class="line">	.minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    <span class="comment">// 驱动名称</span></span><br><span class="line">	.name = <span class="string">&quot;binder&quot;</span>,</span><br><span class="line">	.fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// binder_open : 处理 open 系统调用的函数，用于打开 Binder 设备文件。</span></span><br><span class="line"><span class="comment">// binder_mmap: 处理 mmap 系统调用的函数，用于将 Binder 驱动的内存映射到用户空间。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span>&#123;......&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span>&#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">binder_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 创建名为binder的单线程的工作队列</span></span><br><span class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">&quot;binder&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 注册驱动，misc设备其实也就是特殊的字符设备</span></span><br><span class="line">    ret = misc_register(&amp;binder_miscdev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 驱动注册函数</span></span><br><span class="line">device_initcall(binder_init);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Binder 通信流程:</strong></p>
<p><strong>Main_MediaServer.cpp</strong></p>
<p>Server获得ProcessState实例，使用该实例创建线程池</p>
<p>Server调用<code>defaultServiceManager()</code>获得 IServiceManager，即BpBinder，对应ServiceManager的客户端Binder</p>
<p><strong>ProcessState.cpp</strong></p>
<p>ProcessState的构造函数初始化</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240806155020313.png" class="" title="image-20240806155020313">
<img src="/2024/07/28/Android-Learning-Record/image-20240806155033149.png" class="" title="image-20240806155033149">
<p><code>open_driver()</code>函数打开了设备 <code>/dev/binder</code> ，并设置该进程在Binder中的线程池</p>
<blockquote>
<p>每个使用Binder的进程都在Binder驱动中有自己的线程池，该线程用于信息的处理</p>
</blockquote>
<p>然后，调用<code>mmap(...)</code>创建内存映射，即为下图中的Server进程中操作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240805194744173.png" class="" title="image-20240805194744173">
<p><strong>IServiceManager.cpp</strong></p>
<p>返回BpBinder(handler)，即 IServiceManager</p>
<h4 id="Message跨进程通信">Message跨进程通信</h4>
<h4 id="Socket">Socket</h4>
<img src="/2024/07/28/Android-Learning-Record/image-20240721155920403-1722133033018.png" class="" title="image-20240721155920403">
<h3 id="View与事件分发机制">View与事件分发机制</h3>
<h4 id="事件分发流程">事件分发流程</h4>
<p>参考链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6931914294980411406">https://juejin.cn/post/6931914294980411406</a></p>
<p>每次进行事件传递的是单个事件，即 ACTION_DOWN, ACTION_MOVE, ACTION_UP, 并非事件序列</p>
<p>case 1: -&gt; dispatch -&gt; dispatch -&gt; InterceptTouchEvent -&gt; TouchEvent - &gt; TouchEvent</p>
<p>case 2: -&gt; dispatch -&gt; dispatch -&gt; TouchEvent - &gt; TouchEvent</p>
<p>case 3: -&gt; dispatch -&gt; dispatch -&gt; TouchEvent</p>
<ol>
<li>
<p><strong>事件传递：</strong> 当用户触摸屏幕时，系统会将事件封装成 MotionEvent 对象，并将其传递给当前 Activity 的 dispatchTouchEvent(…) 方法。</p>
</li>
<li>
<p><strong>分发：</strong> Activity 会将事件传递给其根视图ViewGroup（通常是 DecorView）的 dispatchTouchEvent(…) 方法。ViewGroup和View将继续调用dispatchTouchEvent(…) 方法分发该动作。</p>
</li>
</ol>
<ul>
<li>如果返回 true，则表示<strong>当前事件在此 View 及其子 View 中被处理</strong>，后续事件序列将被继续下发。</li>
<li>如果返回 false，则表示<strong>当前事件在此 View 及其子 View 中未被处理</strong>，后续事件序列将不会到达此View</li>
</ul>
<ol start="3">
<li><strong>拦截：</strong> ViewGroup 在接收到事件后，会调用自身的 onInterceptTouchEvent() 方法判断是否拦截该事件。</li>
</ol>
<ul>
<li>如果返回 true，则表示拦截该事件，事件将由 ViewGroup 自身处理，调用自身的 onTouchEvent() 方法。
<ul>
<li>如果返回 false，则表示不拦截该事件，事件将继续传递给其子 View 或 ViewGroup 进行分发。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>
<p><strong>处理：</strong> View 和 ViewGroup 接收到事件后，会调用自身的 onTouchEvent() 方法进行处理。 ACTION_DOWN 事件在处理后，将归属于该View进行完整事件序列处理。</p>
<ul>
<li>如果返回 true，则表示该事件被消费，事件传递结束。</li>
<li>如果返回 false，则表示该事件没有被消费，事件将回传给父 View 的 onTouchEvent() 方法进行处理。</li>
</ul>
</li>
<li>
<p><strong>事件回传：</strong> 如果事件没有被任何 View 消费，最终会回到 Activity 的 onTouchEvent() 方法进行处理。</p>
</li>
</ol>
<blockquote>
<p><strong>事件传递方向：</strong></p>
<ul>
<li>向下传递（分发）： 事件是从根视图 (DecorView) 开始，沿着视图树 <strong>逐层向下</strong> 分发，直到传递到最终处理该事件的子视图或被某个 ViewGroup 拦截。</li>
<li>向上回传： 如果事件没有被任何子视图消费，则会 <strong>原路返回</strong>，沿着视图树 <strong>逐层向上</strong> 回传，直到被某个 View 或 ViewGroup 处理或最终到达 Activity。</li>
</ul>
<p><strong>事件拦截</strong></p>
<p>在正常情况下，一个事件序列只应该由单独一个 View 或者 ViewGroup 进行处理。这意味着， 哪个 View 消费了 ACTION_DOWN 事件，哪个 View 就会接管整个事件序列的处理，不再经过其他事件</p>
<ol>
<li>
<p>拦截&amp;处理：整个事件序列将直接传递给该ViewGroup处理，不再经过其他事件</p>
</li>
<li>
<p>拦截&amp;不处理：后续事件序列将不会再传递给该 ViewGroup，而是直接交给其父视图处理</p>
</li>
</ol>
<p>ext：若所有View和ViewGroup均不处理 ACTION_DOWN 事件，后续事件序列将直接由Activity处理；</p>
</blockquote>
<p><strong>坐标系</strong></p>
<p><strong>屏幕坐标系</strong>： Raw 以屏幕左上角作为坐标原点，水平向右方向为 X 轴正轴方向，竖直向下方向为 Y 轴正轴方向。</p>
<p><strong>View 坐标系</strong>： 默认 以 View 所在的 ViewGroup 的左上角作为坐标原点，水平向右方向为 X 轴正轴方向，竖直向下方向为 Y 轴正轴方向。View 类包含了以下几个方法用于获取其相对父容器 ViewGroup 的距离：</p>
<ul>
<li>getLeft()。View 左侧到 ViewGroup 左侧之间的距离</li>
<li>getTop()。View 顶部到 ViewGroup 顶部之间的距离</li>
<li>getRight()。View 右侧到 ViewGroup 左侧之间的距离</li>
<li>getBottom()。View 底部到 ViewGroup 顶部之间的距离</li>
</ul>
<p>参考链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6931914294980411406">https://juejin.cn/post/6931914294980411406</a></p>
<p><strong>事件序列</strong></p>
<p>一个触摸事件序列，指的是从手指触摸屏幕开始，到手指离开屏幕结束，期间产生的一系列事件。</p>
<p>这个序列包含如下三个阶段：</p>
<ol>
<li><strong>按下（ACTION_DOWN）：</strong> 手指触碰屏幕的瞬间触发。</li>
<li><strong>移动（ACTION_MOVE）：</strong> 手指在屏幕上滑动时，会多次触发该事件。</li>
<li><strong>抬起（ACTION_UP）：</strong> 手指离开屏幕的瞬间触发。</li>
</ol>
<p><strong>Mutil View</strong></p>
<blockquote>
<p>核心：(ViewGroup)DispatchTouchEvent() -&gt; (ViewGroup)onInterceptTouchEvent()  -&gt; {(ViewGroup)onTouchEvent()} -&gt; (View)DispatchTouchEvent() -&gt;  (View)onTouchEvent()</p>
<p>DispatchTouchEvent 返回 True 事件被消费</p>
<p>onInterceptTouchEvent 返回 True 事件被拦截，调用当前级的onTouch()</p>
<p>onTouchEvent() 返回 True 事件被消费</p>
<p>Activity: DispatchTouchEvent + onTouchEvent</p>
<p>ViewGroup: DispatchTouchEvent + onInterceptTouchEvent + onTouchEvent</p>
<p>View: DispatchTouchEvent + onTouchEvent</p>
</blockquote>
<p><strong>View</strong></p>
<p>Android 界面中所有可视化元素的基类，代表一个矩形区域，负责自身内容的绘制、事件处理以及布局等。<strong>常见子类：</strong> TextView、Button、ImageView、EditText 等。</p>
<ul>
<li>
<p>DispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 用于表示当前 View 是否消费了该事件</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> event.getActionMasked();</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">//View启用&amp;&amp;handleScrollBarDragging返回true</span></span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在OnTouchListener&amp;&amp;View启用&amp;&amp;OnTouchListener返回true</span></span><br><span class="line">        <span class="comment">//OnTouchListener优先级高于onClickListener！！</span></span><br><span class="line">        <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">           result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//result仍为false&amp;&amp;自身onTouchEvent消费动作事件</span></span><br><span class="line">        <span class="comment">// onClickListener在onTouchEvent方法中被调用的</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ···</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>OnTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 事件可点击判断</span></span><br><span class="line">    <span class="comment">// CLICKABLE、LONG_CLICKABLE、CONTEXT_CLICKABLE对应着：可点击、可长按点击、可上下文点击</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">clickable</span> <span class="operator">=</span> ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">          || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">          || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">// 如果当前 View 处于禁用状态 DISABLED 的话，当前 View 是否会消耗触摸事件都由 clickable 来决定，</span></span><br><span class="line">        <span class="keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TouchDelegate 可以用于改变 View 的触摸区域，例如将一个较小的 View 的触摸区域扩大。</span></span><br><span class="line">    <span class="comment">// 如果设置了 TouchDelegate，调用 TouchDelegate 的 onTouchEvent 方法处理触摸事件</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可点击 OR View为工具提示</span></span><br><span class="line">    <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">// 判断是否取得焦点</span></span><br><span class="line">        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPerformClick == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPerformClick = <span class="keyword">new</span> <span class="title class_">PerformClick</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// PerformClick 对象添加到消息队列中</span></span><br><span class="line">            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">               <span class="comment">// 如果无法将 PerformClick 对象添加到消息队列中，则直接调用 performClickInternal 方法执行点击事件。performClickInternal() 方法是 View 类中的一个私有方法，它会执行实际的点击操作，例如调用 OnClickListener 的 onClick() 方法等。</span></span><br><span class="line">               performClickInternal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>ViewGroup</strong></p>
<p>继承自 View，但它本身是一个容器，可以包含多个子 View，并负责管理这些子 View 的布局和事件分发。<strong>常见子类：</strong>  LinearLayout、RelativeLayout、FrameLayout、ConstraintLayout 等。</p>
<ul>
<li>
<p>DispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">     ···</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">  </span><br><span class="line">         <span class="comment">// 新的事件序列</span></span><br><span class="line">         <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">             <span class="comment">// 清除旧事件引用</span></span><br><span class="line">             cancelAndClearTouchTargets(ev);</span><br><span class="line">             resetTouchState();</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">         <span class="comment">// 新事件序列 或 存在旧事件引用</span></span><br><span class="line">         <span class="comment">// 存在旧事件引用意味着有子View消费了当前事件序列的ACTION_DOWN</span></span><br><span class="line">         <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">         <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                 || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 子View可以请求父View不拦截</span></span><br><span class="line">             <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                 <span class="comment">// 调用onInterceptTouchEvent判断是否拦截</span></span><br><span class="line">                 intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                 ev.setAction(action);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 子View请求父View不拦截</span></span><br><span class="line">                 intercepted = <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             intercepted = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">         ···</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">             <span class="type">View</span> <span class="variable">childWithAccessibilityFocus</span> <span class="operator">=</span> ev.isTargetAccessibilityFocus()</span><br><span class="line">                     ? findChildWithAccessibilityFocus() : <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">             <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                     || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                     || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                 <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionIndex</span> <span class="operator">=</span> ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                 <span class="keyword">final</span> <span class="type">int</span> <span class="variable">idBitsToAssign</span> <span class="operator">=</span> split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                         : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line">  </span><br><span class="line">                 <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                 <span class="comment">// have become out of sync.</span></span><br><span class="line">                 removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line">  </span><br><span class="line">                 <span class="comment">// 遍历子View找到ACTION_DOWN落点</span></span><br><span class="line">                 <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childrenCount</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">                 <span class="keyword">if</span> (newTouchTarget == <span class="literal">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                     ···</span><br><span class="line">                     <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                         ···</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     ···</span><br><span class="line">                 &#125;</span><br><span class="line">	   ···</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 动作未被子类消费 或 被拦截</span></span><br><span class="line">             handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                     TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// </span></span><br><span class="line">             <span class="type">TouchTarget</span> <span class="variable">predecessor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">             <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> mFirstTouchTarget;</span><br><span class="line">             <span class="keyword">while</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">next</span> <span class="operator">=</span> target.next;</span><br><span class="line">                 <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                     handled = <span class="literal">true</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">cancelChild</span> <span class="operator">=</span> resetCancelNextUpFlag(target.child)</span><br><span class="line">                             || intercepted;</span><br><span class="line">                     <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                             target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                         handled = <span class="literal">true</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (predecessor == <span class="literal">null</span>) &#123;</span><br><span class="line">                             mFirstTouchTarget = next;</span><br><span class="line">                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                             predecessor.next = next;</span><br><span class="line">                         &#125;</span><br><span class="line">                         target.recycle();</span><br><span class="line">                         target = next;</span><br><span class="line">                         <span class="keyword">continue</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 predecessor = target;</span><br><span class="line">                 target = next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">···</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="literal">null</span>) &#123;</span><br><span class="line">         mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> handled;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>PhoneWindow与DecorView</strong></p>
<ul>
<li>每个 Activity 都对应一个 PhoneWindow，即每个 Activity 实例均包含了一个 PhoneWindow 对象</li>
<li>每个 PhoneWindow 都对应一个 DecorView，DecorView 依靠 PhoneWindow 作为构造参数之一来实例化</li>
<li>DecorView 是 FrameLayout 的子类，是 Activity 视图树的根视图，我们平时调用 setContentView 所添加的 View 就对应 DecorView 的 ContentParent 区域</li>
<li>在这三者中 DecorView 会最先接收到触摸事件，DecorView 作为视图树的根视图，就负责向其内部 View 下发触摸事件</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Activity</span><br><span class="line">│</span><br><span class="line">└── PhoneWindow</span><br><span class="line">    │</span><br><span class="line">    └── DecorView (继承FrameLayout)</span><br><span class="line">		│</span><br><span class="line">		└── LinearLayout</span><br><span class="line">                │</span><br><span class="line">                ├── TitleBar/ActionBar</span><br><span class="line">                │</span><br><span class="line">                └── ContentView (setContentView(..))</span><br><span class="line">                    │</span><br><span class="line">                    └── ... 其他 View</span><br></pre></td></tr></table></figure>
<blockquote>
<p>StatusBar (状态栏) 不属于 当前Activity，位于屏幕最上方</p>
<p>TitleBar/ActionBar 属于 DecorView，位于 StatusBar (状态栏) 下方</p>
</blockquote>
<img src="/2024/07/28/Android-Learning-Record/944365-34992eb46bdf93e7.png" class="" title="image-20240812184518922">
<p>参考链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6931914294980411406">https://juejin.cn/post/6931914294980411406</a></p>
<blockquote>
<p>硬件 -&gt; WindowManager -&gt; ViewRoot(ViewRootImpl类，连接层) -&gt; DecorView -&gt; Activity-PhoneWindow-DecorView -&gt; ViewGroup -&gt; View</p>
<p>这三者之间的联系又是怎样的呢？这样兜兜转转一圈，其实就是 DecorView 先将事件传给了 Activity，Activity 又传给了 PhoneWindow，PhoneWindow 又将事件传给了 DecorView，DecorView 最后又按照 ViewGroup 默认的方式进行事件分发，看起来就是在绕圈，这样设计的意义是什么呢？</p>
<p>其实，DecorView 作为触摸事件的第一个接收者，是触摸事件从系统下发到 Activity 之间的一个沟通桥梁，而开发者可以直接接触并继承的是 Activity。DecorView 需要先将事件转发给最外层的 Activity，使得开发者可以通过重写 dispatchTouchEvent 和 onTouchEvent 方法以达到对当前屏幕触摸事件进行拦截的目的。DecorView 作为 View 树的根节点，从 PhoneWindow 接收到事件后，又负责将将事件事件分发给子 View，从而将整个事件链给串联了起来</p>
</blockquote>
<img src="/2024/07/28/Android-Learning-Record/image-20240831191655656.png" class="" title="image-20240831191655656">
<img src="/2024/07/28/Android-Learning-Record/image-20240831192314544.png" class="" title="image-20240831192314544">
<p>Activity 创建 时：</p>
<p>​	创建PhoneWindow对象(Window对象实现)；</p>
<p>​	PhoneWindow.setCallback(this)</p>
<p>​	PhoneWindow.setWindowManger(…)</p>
<p>Activity setContentView 时：</p>
<p>​	setContentView</p>
<p>​		-&gt; installDecor()</p>
<p>​			-&gt; generateDecor() -&gt;new DecorView(getContext(), -1)</p>
<p>​			    generateLayout(mDecor)</p>
<p>​	InitWindowDecorActionBar</p>
<p><strong>message，handler与View交互案例</strong></p>
<ol>
<li>触摸事件的产生：<br>
当用户触摸屏幕时，Android系统的底层（Input系统）会捕获这个物理事件。</li>
<li>事件的初步处理：<br>
这个触摸事件首先被封装成一个原始的输入事件（Input Event）。</li>
<li>事件分发到应用：<br>
系统将这个事件分发给当前激活的应用程序。</li>
<li>转化为消息：<br>
在应用程序这一层，这个输入事件被转换成一个消息（Message），并被添加到主线程的消息队列（MessageQueue）中。</li>
<li>Looper处理消息：<br>
主线程的Looper从消息队列中取出这个消息，并将其分发给适当的Handler处理。</li>
<li>ViewRootImpl的角色：<br>
在大多数情况下，这个Handler是与ViewRootImpl关联的。ViewRootImpl是连接WindowManager和DecorView的纽带。</li>
<li>事件的向下分发：<br>
ViewRootImpl接收到消息后，会调用DecorView的dispatchTouchEvent()方法，开始事件的向下分发过程。</li>
<li>到达目标View：<br>
事件会沿着View层级树向下传递，直到到达你点击的按钮（Button）。</li>
<li>OnClickListener的调用：<br>
如果按钮设置了OnClickListener，其onClick()方法会在这个分发过程中被调用。</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/38015afcdb58">https://www.jianshu.com/p/38015afcdb58</a></p>
<p>Activity事件分发</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240831145006895.png" class="" title="image-20240831145006895">
<p>ViewGroup事件分发</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240831150437519.png" class="" title="image-20240831150437519">
<p>拦截发生时，调用自己的没有被重写的dispatchTouchEvent()处理事件；</p>
<p>例外：</p>
<p>若ViewGroup拦截了中间事件（即没有拦截ACTION_DOWN，拦截了ACTION_MOVE），此时第一个被拦截的事件将成为ACTION_CANCEL传递至ViewGroup的子ViewC，后续事件将进入ViewGroup的没有重写的dispatchTouchEvent()，且ViewC也将不再接受到后续事件；</p>
<blockquote>
<p>ViewGroup父类dispatchTouchEvent()说明：</p>
<p>ViewGroup继承于View，其为包含其他View的特殊的View；ViewGroup继承View后重写了父类的dispatchTouchEvent()方法</p>
<p>此处执行ViewGroup父类dispatchTouchEvent()即为调用父类的没有被重写的View.dispatchTouchEvent()</p>
</blockquote>
<p>View事件分发</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240831152442110.png" class="" title="image-20240831152442110">
<p><strong>View触摸事件优先级高于点击事件！！</strong></p>
<p><strong>View中若控件可点击(Clickable)，则View.dispatchTouchEvent(…)—&gt;View.onTouchEvent(…)一定返回true；若不可点击，则一定返回false！！！</strong></p>
<p>在不设置触摸事件监听器的情况下，View和ViewGroup均默认使用onTouchEvent()处理事件；</p>
<p>PS: 可以同时触发<strong>触摸事件监听器</strong>和<strong>点击事件监听器</strong></p>
<blockquote>
<p>Touch处理所有点击事件，即：</p>
<ul>
<li><strong>MotionEvent.ACTION_DOWN</strong>: 手指初次接触到屏幕的瞬间。</li>
<li><strong>MotionEvent.ACTION_MOVE</strong>: 手指在屏幕上滑动时，会持续触发此事件。</li>
<li><strong>MotionEvent.ACTION_UP</strong>: 手指离开屏幕的瞬间。</li>
<li><strong>MotionEvent.ACTION_CANCEL</strong>: 触摸事件被系统取消，例如突然弹出对话框。</li>
<li><strong>MotionEvent.ACTION_POINTER_DOWN</strong>: 多点触控时，另一只手指触碰屏幕。</li>
<li><strong>MotionEvent.ACTION_POINTER_UP</strong>: 多点触控时，其中一只手指离开屏幕。</li>
</ul>
<p>Click处理一个完整的点击操作（按下/抬起），即：</p>
<ul>
<li>ACTION_DOWN -&gt; ACTION_UP</li>
</ul>
</blockquote>
<h4 id="滑动冲突与解决">滑动冲突与解决</h4>
<p>假设存在一个包含 <code>ScrollView</code> 的布局，而 <code>ScrollView</code> 内部嵌套了一个 <code>RecyclerView</code>。两者都有滑动能力，<code>ScrollView</code> 用于垂直滚动，<code>RecyclerView</code> 用于显示列表项，并且本身支持垂直滑动。这种布局会容易发生滑动冲突。</p>
<p><strong>外部拦截法</strong>：父容器去控制事件的拦截，若事件是父容器需要的，则进行拦截，不需要的则向下传递。</p>
<p><strong>父视图强制拦截事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父视图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScrollView</span> <span class="keyword">extends</span> <span class="title class_">ScrollView</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsScrolling;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyScrollView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否是滑动事件，若是则拦截</span></span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            <span class="comment">// 如果子视图有滑动需求，父视图就不再拦截</span></span><br><span class="line">            <span class="keyword">if</span> (mIsScrolling) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不拦截，交给子视图</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            mIsScrolling = <span class="literal">true</span>;  <span class="comment">// 滑动时，设置为正在滚动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>父视图通过横向移动距离/纵向移动距离拦截事件</strong></p>
<p>作者：parting_soul<br>
链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903806308712456">https://juejin.cn/post/6844903806308712456</a><br>
来源：稀土掘金</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父视图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewPager</span> <span class="keyword">extends</span> <span class="title class_">ViewPager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mLastX;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mLastY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="comment">//一些ViewPager拖拽的标志位要设置，必调super，否则看不到效果</span></span><br><span class="line">        <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isIntercepted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">if</span> (needEvent(ev)) &#123;</span><br><span class="line">                    isIntercepted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        mLastX = (<span class="type">int</span>) ev.getX();</span><br><span class="line">        mLastY = (<span class="type">int</span>) ev.getY();</span><br><span class="line"></span><br><span class="line">        LogUtils.d(<span class="string">&quot; lastX = &quot;</span> + mLastX + <span class="string">&quot; lastY = &quot;</span> + mLastY);</span><br><span class="line">        <span class="keyword">return</span> isIntercepted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">needEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="comment">//水平滚动距离大于垂直滚动距离则将事件交由ViewPager处理</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(ev.getX() - mLastX) &gt; Math.abs(ev.getY() - mLastY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>内部拦截法</strong>：ViewGroup默认情况下不拦截事件，由子View去控制事件的处理，若子View需要此事件，则自己处理，否则交由父容器处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子视图</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">//禁止父容器拦截事件</span></span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (当期View不需要此事件) &#123;</span><br><span class="line">                <span class="comment">// 允许父容器拦截事件</span></span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父视图</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="RecyclerView与ListView缓存机制">RecyclerView与ListView缓存机制</h3>
<p>ListView的缓存分为两级</p>
<p>ListView存在内部类 RecycleBin，RecycleBin存在对象Active View和Scrap View</p>
<ul>
<li>
<p>Active View</p>
</li>
<li>
<p>Scrap view</p>
</li>
</ul>
<p>Active View是在屏幕内的ItemView，当列表数据发生变化时，屏幕内的数据可以直接拿来复用，无须进行数据绑定。</p>
<p>Scrap view是在屏幕外的ItemView，这里所有的缓存的数据都是’脏的’，也就是数据需要重新绑定，也就是说屏幕外的所有数据在进入屏幕的时候需要执行 <code>getView()</code> 方法。</p>
<p>ListView缓存机制：</p>
<p>在mActiveViews缓存集合中查找，成功返回itemView，失败进入下一级缓存；</p>
<p>下一级缓存mScrapViews中进行查找，成功返回itemView，失败创建CreateView。</p>
<p>RecyclerView 的缓存分为四级</p>
<ul>
<li>
<p>AttachedScrap</p>
</li>
<li>
<p>CachedViews</p>
</li>
<li>
<p>ViewCacheExtension</p>
</li>
<li>
<p>RecycledViewPool</p>
</li>
</ul>
<p>Scrap 对应 ListView 的 Active View，为屏幕内缓存数据；</p>
<blockquote>
<p>ChangedScrap内ViewHolder在复用时，需调用 onBindViewHolder(ViewHolder viewHolder, int position) 方法将数据绑定在 ViewHolder 对象中。</p>
</blockquote>
<p>CachedViews 为最近移出屏幕的 ViewHolder，默认大小是2个；当其容量满时且出现新的数据添加时，会根据FIFO原则，原 ViewHolder 移出并放到下一级缓存。</p>
<p>CachedViews 里面的数据是干净的，也就是携带了原来的 ViewHolder 的所有数据信息，数据可以直接来拿来复用。需要注意的是，CachedViews 是根据 position 来寻找数据的，这个 postion 是根据第一个或者最后一个可见的 item 的 position 以及用户操作行为（上拉还是下拉）。</p>
<blockquote>
<p>例：当前屏幕内第一个可见的 item 的 position 是1，用户进行了一个下拉操作，那么当前预测的 position 就相当于（1-1=0），也就是 position = 0 的那个 item 要被拉回到屏幕，此时 RecyclerView 就从 Cache 里面找 position=0 的数据，如果找到了就直接拿来复用。</p>
</blockquote>
<p>ViewCacheExtension 是 google 留给开发者自己来自定义缓存的</p>
<p>RecycledViewPool 对比于 Cache 默认缓存数量是2个，当 Cache 缓存满了以后会根据 FIFO 把 Cache 中的 ViewHolder 移出并缓存到 RecycledViewPool 中，RecycledViewPool 默认缓存数为5。</p>
<p>RecycledViewPool 与 Cache 相比不同的是，从 Cache 里面移出的 ViewHolder 在存入 RecycledViewPool 之前，该 ViewHolder 的数据会被全部重置，相当于一个新的 ViewHolder ；同时 Cache 是根据 position 来获取 ViewHolder，而 RecycledViewPool 是根据 itemType 获取的，如果没有重写 <code>getItemType()</code> 方法，itemType 就是默认的。由于 RecycledViewPool 缓存的 ViewHolder 是全新的，所以取出来的时候需要执行 <code>onBindViewHolder()</code> 方法。</p>
<p>RecyclerView的复用整体流程：</p>
<p>首先会去 Scrap 这个集合 mAttachedScrap 中找是否有 ViewHolder，有就复用 ViewHolder，没有就去下一级缓存集合 mCachedViews 中查找，找到就直接复用，没有就去下一级缓存自定义的 mViewCacheExtension 这个类中查找，但是基本很少用，没找到就去下一级 RecyclerViewPool 中查找，找到就直接复用，没找到就会调用我们在adapter中重写的方法 onCreateViewHolder 新建。</p>
<p><strong>每当 RecyclerView 的子项出现在屏幕上时或将要出现在屏幕上时，系统会按照如下的顺序调用函数</strong></p>
<p>1 调用 getItemCount() 方法获取子项的数量。</p>
<p>2 调用 onCreateViewHolder(ViewGroup parent, int viewType) 方法加载每一个子项的布局</p>
<p>3 构造一个 ViewHolder 对象。</p>
<p>4 调用 onBindViewHolder(ViewHolder viewHolder, int position) 方法将数据绑定在 ViewHolder 对象中。</p>
<p><strong>每个子项在创建的时候会重复循环上面4个步骤，直到所有的子项加载完</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc27655e1184f1fa60b1b8ac4ed4a3b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="recyclerView"></p>
<p>通过mAttachedScrap、mCachedViews及mViewCacheExtension获取的ViewHolder不需要重新创建布局(<code>onCreateViewHolder()</code>)及绑定数据(<code>onBindViewHolder()</code>)；通过缓存池mRecyclerPool获取的ViewHolder不需要重新创建布局，但是需要重新绑定数据；如果上述缓存中都没有获取到目标ViewHolder，那么就会回调Adapter#onCreateViewHolder创建布局，以及回调Adapter#onBindViewHolder来绑定数据。</p>
<p>作者：<em>小马快跑</em><br>
链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7229895703392518205">https://juejin.cn/post/7229895703392518205</a></p>
<h3 id="屏幕刷新">屏幕刷新</h3>
<p>画面撕裂：Display在读取buffer内数据时，被读取数据被CPU/GPU修改，导致当前画面左上部分和右下部分来自不同帧</p>
<p>双缓冲（显示器使用Frame Buffer，CPU/GPU使用Back Buffer）</p>
<p>BackBuffer的数据就绪后，写数据到FrameBuffer，防止画面撕裂</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7163858831309537294">&quot;一文读懂&quot;系列：Android屏幕刷新机制为什么要学习屏幕刷新知识？ 很多同学觉得屏幕刷新绘制知识点对他们开发不重要， - 掘金</a></p>
<p>作者：胡飞洋链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6863756420380196877%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://juejin.cn/post/6863756420380196877来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
<p>VSync(垂直同步):</p>
<p>垂直同步利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。</p>
<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。此个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p>
<p>以时间的顺序来看下将会发生的过程：</p>
<ol>
<li>Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，且在Display显示下一帧前完成</li>
<li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li>
<li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li>
<li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li>
<li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li>
</ol>
<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p>
<p>原因是 第2帧的CPU/GPU计算 没能在VSync信号到来前完成 。</p>
<p><strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。</p>
<p><strong>VSync同步使得CPU/GPU充分利用了16.6ms时间，减少jank。</strong></p>
<p>问题又来了，如果界面比较复杂，CPU/GPU的处理时间较长 超过了16.6ms呢？</p>
<ol>
<li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li>
<li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li>
<li>当下一个VSync出现时，CPU/GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>
</ol>
<p><strong>三缓存</strong></p>
<p>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p>
<ol>
<li>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU/GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</li>
<li>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</li>
</ol>
<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong></p>
<p><strong>谷歌在4.1之后对屏幕绘制与刷新过程引入了Project Butter（黄油工程），系统在收到VSync信号之后，马上进行CPU的绘制以及GPU的buffer写入</strong>。</p>
<h3 id="View绘制流程">View绘制流程</h3>
<img src="/2024/07/28/Android-Learning-Record/944365-c1adb9dd2d22c056.png" class="" title="image-20240831192540253">
<img src="/2024/07/28/Android-Learning-Record/944365-858de1faa38df1b2.png" class="" title="image-20240831192606617">
<p>View绘制流程</p>
<p>创建Activity调用onCreate方法，方法内调用handleResumeActivity(…)</p>
<p>handleResumeActivity(…)调用performResumeActivity(token, clearHide)，获得ActivityClientRecord r</p>
<p>通过r获取DecorView和WindowManager</p>
<p>使用WindowManager执行方法addView</p>
<p>addView方法创建ViewRootImpl实例，<em>把DecorView加载到Window中</em></p>
<p>绘制会从根视图ViewRoot的performTraversals()方法开始，从上到下遍历整个视图树，每个View控件负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。</p>
<p>performTraversals {getRootMeasureSpec + performMeasure + performLayout + performDraw}</p>
<p>绘制流程从根视图 <code>ViewRootImpl</code> 的 <code>performTraversals()</code> 方法开始，按照 <strong>Measure → Layout → Draw</strong> 的顺序，自顶向下遍历整个视图树进行绘制。每个 <code>View</code> 负责绘制自身，而 <code>ViewGroup</code> 还需要通知其子 <code>View</code> 进行测量、布局和绘制操作。</p>
<p><code>performTraversals()</code> 方法依次执行以下步骤：</p>
<ol>
<li><strong>获取根视图的 MeasureSpec</strong>（<code>getRootMeasureSpec</code>）</li>
<li><strong>执行测量流程</strong>（<code>performMeasure</code>）</li>
<li><strong>执行布局流程</strong>（<code>performLayout</code>）</li>
<li><strong>执行绘制流程</strong>（<code>performDraw</code>）</li>
</ol>
<p><strong>测量（performMeasure）</strong></p>
<p>视图的测量流程是一个 <strong>递归</strong> 过程：</p>
<ul>
<li><code>ViewGroup</code> 递归调用子 <code>View</code> 的 <code>measure()</code> 方法，子 <code>View</code> 再根据父 <code>View</code> 传递的 <code>MeasureSpec</code> 计算自身的尺寸。</li>
<li><code>MeasureSpec</code> 计算规则：
<ul>
<li><strong>对于 <code>DecorView</code>（根视图）</strong>：<code>MeasureSpec</code> 由窗口尺寸和 <code>LayoutParams</code> 共同决定。</li>
<li><strong>对于普通 <code>View</code></strong>：<code>MeasureSpec</code> 由父视图的 <code>MeasureSpec</code> 和 <code>LayoutParams</code> 共同决定。</li>
</ul>
</li>
<li><code>MeasureSpec</code> 由两部分组成：
<ul>
<li>模式（Mode）：
<ul>
<li><code>EXACTLY</code>（精确模式）：View 的尺寸已经确定，使用指定的值。</li>
<li><code>AT_MOST</code>（最大模式）：View 的最大尺寸由 <code>MeasureSpec</code> 限制，实际大小不能超过此值。</li>
<li><code>UNSPECIFIED</code>（未指定模式）：View 的大小不受限制，通常用于 <code>ScrollView</code> 这类场景。</li>
</ul>
</li>
<li><strong>大小（Size）</strong>：具体的数值。</li>
</ul>
</li>
</ul>
<p><strong>布局（performLayout）</strong></p>
<ul>
<li><code>ViewGroup</code> 递归调用子 <code>View</code> 的 <code>layout()</code> 方法，子 <code>View</code> 再根据父 <code>View</code> 分配的位置和自身的测量结果，确定自己的最终位置。</li>
<li><strong><code>layout(left, top, right, bottom)</code></strong> 方法用于确定 <code>View</code> 的摆放位置。</li>
<li><code>ViewGroup</code> 需要遍历所有子 <code>View</code> 并调用它们的 <code>layout()</code> 方法，以确保每个 <code>View</code> 在正确的位置上。</li>
</ul>
<p><strong>绘制（performDraw）</strong></p>
<p>绘制流程同样是一个 <strong>递归</strong> 过程，每个 <code>View</code> 负责绘制自身，而 <code>ViewGroup</code> 还需要通知子 <code>View</code> 进行绘制。</p>
<p><strong>绘制的6个步骤</strong></p>
<ol>
<li>绘制 <code>View</code> 的背景
<ul>
<li>调用 <code>drawBackground(canvas)</code> 方法，如果 <code>View</code> 设置了背景，则会先绘制背景。</li>
</ul>
</li>
<li>如果需要的话，保存 <code>Canvas</code> 的图层，为 <code>fading</code> 做准备
<ul>
<li>主要用于 <code>FadingEdge</code>（渐变边缘效果），如果 <code>View</code> 具有 <code>fading edge</code>，则会保存 <code>Canvas</code> 以便后续恢复。</li>
</ul>
</li>
<li>绘制 <code>View</code> 的内容
<ul>
<li>调用 <code>onDraw(canvas)</code>，绘制 <code>View</code> 的主体内容（如 <code>TextView</code> 绘制文本、<code>ImageView</code> 绘制图片等）。</li>
</ul>
</li>
<li>绘制 <code>View</code> 的子 <code>View</code>
<ul>
<li>如果当前 <code>View</code> 是 <code>ViewGroup</code>，会遍历所有子 <code>View</code> 并调用 <code>drawChild(canvas, child, drawingTime)</code> 递归绘制。</li>
</ul>
</li>
<li>如果需要的话，绘制 <code>View</code> 的 <code>fading</code> 边缘并恢复 <code>Canvas</code>
<ul>
<li>处理 <code>FadingEdge</code>，绘制 <code>View</code> 边缘的渐变效果，并恢复 <code>Canvas</code> 以保证后续绘制不受影响。</li>
</ul>
</li>
<li>绘制 <code>View</code> 的装饰（如滚动条等）
<ul>
<li>如果 <code>View</code> 需要滚动条，则会在 <code>dispatchDraw()</code> 之后绘制滚动条。</li>
</ul>
</li>
</ol>
<h3 id="Gradle">Gradle</h3>
<p>每个 Gradle 项目都由一个或多个 Project 构成，每个 Project 又都由 Task 构成。一个 <code>build.gradle</code>文件便是对一个 Project 对象的配置。在 Android 项目中，根目录会存在一个<code>build.gradle</code>文件，每个模块下也会有一个<code>build.gradle</code>文件。</p>
<p><strong>闭包</strong></p>
<p><strong>封装代码块</strong>: 就像普通的函数一样，闭包封装了一段可以执行的代码块。</p>
<p><strong>访问外部作用域</strong>: 闭包最关键的特点是，它可以“捕获”并访问定义它所在的外部作用域（也称为词法作用域）中的变量，即使在定义作用域之外执行也是如此。</p>
<p><strong>作为对象传递</strong>: 闭包可以像普通变量一样被传递、存储和返回，因为它本质上是一个对象。这可以防止外部对象被垃圾回收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，返回一个闭包</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 定义在外部函数作用域</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 返回一个闭包</span></span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个计数器</span></span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="title function_">makeCounter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个计数器都拥有独立的 count 变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter1</span>()); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter1</span>()); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter2</span>()); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>
<p><strong>Gradle Wrapper</strong></p>
<p>Gradle 包装器。为了应对团队开发中 Gradle 环境和版本的差异会对编译结果带来的不确定性，使用 Gradle Wrapper，它是一个脚本，可以指定构建版本、快速运行项目，从而达到标准化、提到开发效率。Android Studio 新建项目时自带 Gradle Wrapper，因此 Android 开发者很少单独下载安装 Gradle</p>
<p><strong>常见文件</strong></p>
<p><strong><code>build.gradle</code></strong></p>
<ul>
<li>
<p>定义项目的构建配置，包括依赖项、插件、任务等。</p>
</li>
<li>
<p><strong>类型:</strong></p>
<ul>
<li>
<p><strong>顶层 <code>build.gradle</code> (Project):</strong></p>
<ul>
<li>
<p><strong>作用:</strong> 配置整个项目的全局设置</p>
</li>
<li>
<p><strong>代码示例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span> <span class="comment">// 用于声明项目需要使用的Gradle插件。这些插件直接影响项目的构建过程和可用任务。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildscript &#123;  <span class="comment">// 用于声明构建脚本自身需要的依赖。这些依赖通常是Gradle插件，它们在构建过程中被使用，但不直接成为项目的一部分。</span></span><br><span class="line">    repositories &#123;  </span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">  dependencies &#123;  </span><br><span class="line">        classpath <span class="string">&quot;com.android.tools.build:gradle:7.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123; <span class="comment">// 通常用于定义共享的配置和仓库, 不推荐在这里声明具体的项目依赖</span></span><br><span class="line">    repositories &#123;  </span><br><span class="line">      google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>模块级 <code>build.gradle</code> (Module):</strong></p>
<ul>
<li>
<p><strong>作用:</strong> 配置特定模块的构建选项</p>
</li>
<li>
<p><strong>代码示例 (Android 应用模块):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  plugins &#123;</span><br><span class="line">      id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">      id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">31</span>  <span class="comment">// 指定用于编译应用的Android SDK版本</span></span><br><span class="line">      </span><br><span class="line">      defaultConfig &#123;</span><br><span class="line">          applicationId <span class="string">&quot;com.example.myapp&quot;</span></span><br><span class="line">          minSdkVersion <span class="number">21</span>  <span class="comment">// 指定您希望应用支持的最低 Android 版本。设置 minSdk 可限制哪些设备可以安装您的应用。</span></span><br><span class="line">          targetSdkVersion <span class="number">31</span>  <span class="comment">// 如果设备搭载的 Android 版本高于 targetSdk，Android 会以兼容模式运行您的应用</span></span><br><span class="line">          versionCode <span class="number">1</span></span><br><span class="line">          versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">          <span class="comment">// 借助 compileSdk，您可以访问新 API</span></span><br><span class="line">  		<span class="comment">// targetSdk 用于设置应用的运行时行为</span></span><br><span class="line">  		<span class="comment">// targetSdk必须小于或等于 compileSdk</span></span><br><span class="line">          </span><br><span class="line">          testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      buildTypes &#123;  <span class="comment">// 定义不同的构建类型。这里配置了release构建类型,启用了代码混淆。</span></span><br><span class="line">          release &#123;</span><br><span class="line">              minifyEnabled <span class="literal">true</span></span><br><span class="line">              proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      compileOptions &#123;  <span class="comment">// 设置Java编译选项。</span></span><br><span class="line">          sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">          targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      kotlinOptions &#123;  <span class="comment">// 设置Kotlin编译选项。</span></span><br><span class="line">          jvmTarget = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  dependencies &#123;</span><br><span class="line">      implementation <span class="string">&#x27;androidx.core:core-ktx:1.7.0&#x27;</span></span><br><span class="line">      implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.4.1&#x27;</span></span><br><span class="line">      implementation <span class="string">&#x27;com.google.android.material:material:1.5.0&#x27;</span></span><br><span class="line">      implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:2.1.3&#x27;</span></span><br><span class="line">      testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">      androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span></span><br><span class="line">      androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Plugins是用于Gradle的，Dependencies是用于java/kotlin项目的</p>
<p>通过引入不同的Plugins，可以构建不同语言的项目，比如说java语言编写的android项目，kotlin语言编写的android项目，混合Java和Kotlin的Android项目，Flutter项目…</p>
<p>Dependencies 主要是指项目所需的外部库或模块，如Java库，Kotlin库</p>
</blockquote>
<p><strong><code>gradle.properties</code></strong></p>
<ul>
<li>
<p><strong>作用:</strong> 配置全局 Gradle 设置，影响所有使用该 Gradle 版本的项目。</p>
</li>
<li>
<p><strong>示例:</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.gradle.daemon</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">org.gradle.parallel</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">android.useAndroidX</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>gradle-wrapper.properties</code></strong></p>
<ul>
<li>
<p><strong>作用:</strong> 配置 Gradle Wrapper，确保项目使用特定版本的 Gradle 进行构建。</p>
</li>
<li>
<p><strong>示例:</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gradle-wrapperdistributionBase</span>=<span class="string">GRADLE_USER_HOME</span></span><br><span class="line"><span class="attr">distributionPath</span>=<span class="string">wrapper/dists</span></span><br><span class="line"><span class="attr">distributionUrl</span>=<span class="string">https\://services.gradle.org/distributions/gradle-7.4.2-bin.zip</span></span><br><span class="line"><span class="attr">zipStoreBase</span>=<span class="string">GRADLE_USER_HOME</span></span><br><span class="line"><span class="attr">zipStorePath</span>=<span class="string">wrapper/dists</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>gradle-wrapper</p>
<p>gradle-wrapper就像python的vir_env/miniconda，为每个项目提供了相互独立的gradle环境。通过读取配置文件中gradle的版本，为每个项目自动的下载和配置gradle</p>
<ol>
<li>当执行 gradlew 脚本时，它会读取 gradle-wrapper.properties 文件中的配置信息。</li>
<li>如果本地没有找到指定的 Gradle 版本，Gradle Wrapper 会自动从 distributionUrl 下载并缓存到本地。</li>
<li>下载完成后，Gradle Wrapper 会使用指定的 Gradle 版本执行构建任务。</li>
</ol>
</blockquote>
<p><strong><code>settings.gradle</code></strong></p>
<ul>
<li>
<p><strong>作用:</strong> 此设置文件会定义项目级代码库设置，并告知 Gradle 在构建应用时应将哪些模块包含在内。多模块项目需要指定应包含在最终 build 中的每个模块。</p>
</li>
<li>
<p><strong>示例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pluginManagement &#123;  <span class="comment">// 集中管理插件版本：项目中使用的所有的使用于 Gradle 的插件版本 与 配置插件获取仓库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * pluginManagement.repositories 代码块配置了 Gradle 用于</span></span><br><span class="line"><span class="comment">      * 搜索或下载 Gradle 插件及其传递依赖项的仓库。Gradle 预先配置了对远程仓库的支持，</span></span><br><span class="line"><span class="comment">      * 例如 JCenter、Maven Central 和 Ivy。您也可以使用本地仓库或定义自己的远程仓库。</span></span><br><span class="line"><span class="comment">      * 下面的代码将 Gradle 插件门户、Google 的 Maven 仓库和 Maven 中央仓库定义为</span></span><br><span class="line"><span class="comment">      * Gradle 应该用来查找其依赖项的仓库。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencyResolutionManagement &#123;  <span class="comment">// 集中管理项目依赖项（Java 库、Android 库等），获取仓库与配置依赖解析规则</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 您可以在 dependencyResolutionManagement.repositories 代码块中配置</span></span><br><span class="line"><span class="comment">      * 项目中所有模块使用的仓库和依赖项，例如您用于创建应用程序的库。但是，您应该</span></span><br><span class="line"><span class="comment">      * 在每个模块级别的 build.gradle 文件中配置模块特定的依赖项。对于新项目，</span></span><br><span class="line"><span class="comment">      * Android Studio 默认包含 Google 的 Maven 仓库和 Maven 中央仓库，</span></span><br><span class="line"><span class="comment">      * 但它不会配置任何依赖项（除非您选择需要某些依赖项的模板）。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)  <span class="comment">// 这意味着 Gradle 将只在 settings.gradle.kts 文件中定义的仓库中查找依赖项，而不会在项目模块的 build.gradle 文件中定义的仓库中查找。</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;&#125;  <span class="comment">// 声明依赖版本，但不会将依赖添加到任何模块，仅用于版本约束。</span></span><br><span class="line">    resolutionStrategy &#123;</span><br><span class="line">        <span class="comment">// 强制使用 2.0.0 版本的 Gson 库</span></span><br><span class="line">        force(<span class="string">&quot;com.google.code.gson:gson:2.0.0&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">rootProject.name = <span class="string">&quot;My Application&quot;</span>  <span class="comment">// 设置项目的根模块名称为 &quot;My Application&quot;。</span></span><br><span class="line">include <span class="string">&#x27;:app&#x27;</span>  <span class="comment">// 这意味着项目中存在一个名为 &quot;app&quot; 的子目录，其中包含一个模块级别的 build.gradle 文件，用于配置该模块的构建设置。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>build.gradle</code> allprojects {} 中的 <code>settings.gradle</code> dependencies {} 的区别</p>
<ul>
<li>dependencyResolutionManagement {} 中的 dependencies {} 仅声明依赖版本，不添加依赖。</li>
<li>allprojects {} 中的 dependencies {} 会将依赖添加到所有模块。</li>
</ul>
</blockquote>
<p><strong><code>local.properties</code></strong></p>
<ul>
<li>
<p><strong>作用:</strong> 为构建系统配置本地环境属性，例如 SDK 和 NDK 路径。由Android Studio自动生成</p>
</li>
<li>
<p><strong>示例:</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## This file is automatically generated by Android Studio.</span></span><br><span class="line"><span class="comment"># Do not modify this file -- YOUR CHANGES WILL BE ERASED!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Local properties for the project.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sdk.dir</span>=<span class="string">/Users/username/Library/Android/Sdk</span></span><br><span class="line"><span class="attr">ndk.dir</span>=<span class="string">/Users/username/Library/Android/Sdk/ndk</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>multiDexKeep.pro</code>&amp;<code>proguard-rules.pro</code></strong>: 可选的混淆文件，用于配置放置在主 Dex 的类、声明避免混淆的类</p>
<p><strong>常见块</strong></p>
<p><strong><code>buildscript</code> 块</strong>:</p>
<ul>
<li><strong>作用</strong>: 配置 Gradle 构建系统本身所需的依赖和仓库。</li>
<li><strong>出现位置</strong>: 顶层 <code>build.gradle</code> 文件。</li>
</ul>
<p><strong>代码案例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google() <span class="comment">// Google Maven 仓库</span></span><br><span class="line">        mavenCentral() <span class="comment">// Maven 中央仓库</span></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;com.android.tools.build:gradle:7.2.1&quot;</span> <span class="comment">// Android Gradle 插件</span></span><br><span class="line">        classpath <span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.7.10&quot;</span> <span class="comment">// Kotlin Gradle 插件 (如果使用 Kotlin)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>allprojects</code> 块</strong>:</p>
<ul>
<li><strong>作用</strong>: 配置所有子项目/模块通用的选项，例如仓库、插件版本等。</li>
<li><strong>出现位置</strong>: 顶层 <code>build.gradle</code> 文件。</li>
</ul>
<p><strong>代码案例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        <span class="comment">// 添加其他需要的仓库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>plugins</code> 块</strong>:</p>
<ul>
<li><strong>作用</strong>: 声明和应用插件，用于扩展 Gradle 的功能。</li>
<li><strong>出现位置</strong>: 顶层或模块级 <code>build.gradle</code> 文件。</li>
</ul>
<p><strong>代码案例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span> version <span class="string">&#x27;7.2.1&#x27;</span> apply <span class="literal">false</span> <span class="comment">// 应用 Android Application 插件 (仅在模块级应用)</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.kotlin.android&#x27;</span> version <span class="string">&#x27;1.7.10&#x27;</span> apply <span class="literal">false</span> <span class="comment">// 应用 Kotlin Android 插件 (仅在模块级应用)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>android</code> 块</strong>:</p>
<ul>
<li><strong>作用</strong>: 配置 Android 项目相关的构建选项。</li>
<li><strong>出现位置</strong>: 模块级 <code>build.gradle</code> 文件。</li>
</ul>
<p><strong>代码案例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">33</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.myapp&quot;</span></span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">33</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dependencies</code> 块: 声明项目的依赖项。</p>
<p><code>repositories</code>: 定义 Gradle 查找依赖项的仓库地址。</p>
<p><code>task</code>: 定义 Gradle 任务，用于执行特定的构建操作。</p>
<p><code>ext</code>: 定义额外的属性，可以在构建脚本中使用。</p>
<h3 id="Android启动">Android启动</h3>
<p>Android系统启动过程中，会先启动linux内核，然后加载init.rc文件，启动init进程。然后，init进程通过解析init.rc文件fork生成Zygote进程，该进程也是Android系统的首个Java进程。之后Zygote进程负责孵化System Server进程和APP进程。</p>
<p><img src="Android-learning-record/image-20240714103234291.png" alt="image-20240714103234291"></p>
<h4 id="Init进程">Init进程</h4>
<p>设置子进程退出信号处理函数</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240731155705321.png" class="" title="image-20240731155705321">
<blockquote>
<p>本进程在接受到子进程退出信号后，调用sigchld_handler函数</p>
</blockquote>
<p>创建文件夹与挂载设备</p>
<p>将标准输入、标准输出和标准错误重定向到 <code>/dev/null</code> 和 将<code>init</code> 进程的日志输出设置为 <code>/dev/__kmsg__</code></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240731160912852.png" class="" title="image-20240731160912852">
<blockquote>
<p>重定向标准输入/输出/错误的方式是通过修改进程的文件描述符表</p>
<p>int dup2(int oldfd, int newfd)：通过将旧文件描述符复制到新文件描述符位置（即将oldfd内容写入newfd在文件描述符表中所在的位置），若新文件描述符已打开，则将其关闭并复制，使得后续访问文件描述符表对应位置的时候被重定向到修改后位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">// 读写方式打开 /dev/null</span></span><br><span class="line"><span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    dup2(fd, <span class="number">0</span>); <span class="comment">// 重定向标准输入到 /dev/null</span></span><br><span class="line">    dup2(fd, <span class="number">1</span>); <span class="comment">// 重定向标准输出到 /dev/null</span></span><br><span class="line">    dup2(fd, <span class="number">2</span>); <span class="comment">// 重定向标准错误到 /dev/null</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        close(fd); <span class="comment">// 关闭多余的文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解析<code>init.rc</code>文件</p>
<p>获取硬件名并根据硬件名解析<code>init.&lt;硬件名&gt;.rc</code>文件</p>
<p>从文件中获得<code>early-init</code>阶段需要执行的动作，将动作添加到一个执行队列的尾部并执行队列中的所有动作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240731162932328.png" class="" title="image-20240731162932328">
<blockquote>
<p>动作一般是函数指针，执行动作时通过函数指针执行函数</p>
</blockquote>
<p>获得 <code>device</code>, <code>property</code>, <code>keychord</code>的文件描述符</p>
<p>加载文件作为系统的开机画面</p>
<p>判断系统是否在QEMU虚拟机运行，执行？操作</p>
<p>设置系统属性</p>
<p>执行位于<code>init</code>阶段的动作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240801102057483.png" class="" title="image-20240801102057483">
<p>启动属性服务</p>
<p>创建socket</p>
<p>执行 <code>early-boot</code> 和 <code>boot</code> 阶段动作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240801102304897.png" class="" title="image-20240801102304897">
<p>创建文件描述符数组，将<code>device</code>, <code>property</code>, <code>signal_recv</code>,<code>keychord</code>的文件描述符写入，添加期望动作。</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240801102823567.png" class="" title="image-20240801102823567">
<img src="/2024/07/28/Android-Learning-Record/image-20240801102846996.png" class="" title="image-20240801102846996">
<p>循环，清空接收动作；开始监视文件描述符传入信息，并根据传入信息执行对应动作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240801103107985.png" class="" title="image-20240801103107985">
<blockquote>
<p>poll() 函数监视多个文件描述符(实际上监视的是文件描述符对应的文件表项的<code>f_flags</code>属性)，等待它们中的任何一个变为可读、可写或发生错误。在其变化时，revent将记录该变化。</p>
</blockquote>
<h4 id="Zygote进程">Zygote进程</h4>
<p><strong>App_main.cpp</strong></p>
<p>对传入参数进行统计与设置</p>
<p>创建<code>AppRuntime</code>，并设置成员值</p>
<p>判断条件，修改进程名与执行<code>runtime.start(...)</code></p>
<p><strong>AndroidRuntime.cpp</strong></p>
<p><code>runtime.start(...)</code></p>
<ul>
<li>创建虚拟机<code>AndroidRuntime:startVm(...)</code></li>
<li>注册JNI函数<code>AndroidRuntime:startReg(...)</code></li>
<li>使用注册JNI函数的<code>JNIEnv</code>调用Java函数，进入Java</li>
</ul>
<p><code>AndroidRuntime:startVm(...)</code></p>
<ul>
<li>设置虚拟机参数</li>
<li>调用<code>JNI_CreateJavaVM(...)</code>创建虚拟机并得到当前线程的<code>JNIEnv</code></li>
</ul>
<p><code>AndroidRuntime:startReg(...)</code></p>
<ul>
<li>调用<code>register_jni_procs(...)</code>注册JNI函数</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240805152408375.png" class="" title="image-20240805152408375">
<img src="/2024/07/28/Android-Learning-Record/image-20240805152418585.png" class="" title="image-20240805152418585">
<blockquote>
<p>注册JNI函数即将该函数指针写入指定java类的方法表(Method Table)中，在java类使用该方法时，可以直接查方法表得到该函数的地址并访问/使用</p>
</blockquote>
<p><strong>ZygoteInit.java</strong></p>
<p>调用<code>registerZygoteSocket()</code>注册zygote的socket</p>
<p>调用<code>preloadClasses()</code>&amp;<code>preloadResource()</code>预加载类和资源</p>
<p>调用<code>startSystemServer()</code>启动system_server进程</p>
<p>调用<code>runSelectLoopMode()</code>函数</p>
<p>调用<code>caller.run()</code>函数</p>
<p><code>registerZygoteSocket()</code></p>
<ul>
<li>创建服务端Socket</li>
</ul>
<p><code>preloadClasses()</code>&amp;<code>preloadResource()</code></p>
<ul>
<li>加载资源</li>
</ul>
<p><code>startSystemServer()</code></p>
<ul>
<li>fork子进程，创建system_server进程</li>
</ul>
<p><code>runSelectLoopMode()</code></p>
<ul>
<li>处理客户连接和客户请求</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240805193239427.png" class="" title="image-20240805193239427">
<p>-&gt; <code>runOnce()</code></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240805193517661.png" class="" title="image-20240805193517661">
<img src="/2024/07/28/Android-Learning-Record/image-20240805193529451.png" class="" title="image-20240805193529451">
<h4 id="SystemServer进程">SystemServer进程</h4>
<ul>
<li>由Zygote进程fork生成，SystemServer是Zygote孵化的第一个进程。</li>
<li>负责启动、管理整个Java Framework，系统里面重要的服务都是在这个进程里面开启的，比如ActivityManagerService、WindowManagerService。</li>
</ul>
<p><strong>ActivityManagerService.java</strong></p>
<p>函数<code>startProcessLocked(...)</code>中调用<code>Process.start()</code>启动Process</p>
<p><strong>Process.java</strong></p>
<p><code>Process.start()</code></p>
<ul>
<li>调用<code>startViaZygote(...)</code></li>
</ul>
<p><code>startViaZygote(...)</code></p>
<ul>
<li>参数处理</li>
<li>调用<code>zygoteSendArgsAndGetPid(参数)</code></li>
</ul>
<p><code>zygoteSendArgsAndGetPid(...)</code></p>
<ul>
<li>判断是否存在与zygote通信的Socket，并创建连接</li>
<li>发送请求参数到Zygote并获取返回结果pid</li>
</ul>
<h4 id="APP进程">APP进程</h4>
<ul>
<li>Zygote进程在App层中孵化出的第一个进程是Launcher进程，即手机的桌面APP。</li>
<li>Zygote还会孵化出Browser、Email、Phone等APP进程，每个APP至少运行在一个进程上。</li>
<li>所有APP进程都由Zygote进程fork生成。</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240805193338222.png" class="" title="image-20240805193338222">
<p>上接<code>runOnce()</code></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240805193638556.png" class="" title="image-20240805193638556">
<h3 id="常用框架">常用框架</h3>
<h4 id="Glide">Glide</h4>
<h4 id="okHttp">okHttp</h4>
<p>待完成</p>
<h4 id="Retrofit">Retrofit</h4>
<p>待完成</p>
<h4 id="RxJava">RxJava</h4>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android-Java/" rel="tag"># Android, Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/06/22/common-commands/" rel="prev" title="common-commands">
      <i class="fa fa-chevron-left"></i> common-commands
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/08/10/Database-Learning-Record/" rel="next" title="Database-Learning-Record">
      Database-Learning-Record <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">Android Learning Record</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android%E7%A8%8B%E5%BA%8F"><span class="nav-text">Android程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#View"><span class="nav-text">View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context"><span class="nav-text">Context</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android"><span class="nav-text">Android</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="nav-text">四大组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adapter"><span class="nav-text">Adapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity%E4%B8%8EFragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">Activity与Fragment生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%B1%82%E4%B8%8ENative%E5%B1%82"><span class="nav-text">Java层与Native层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%83%85%E5%86%B5"><span class="nav-text">常见内存泄露情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Message"><span class="nav-text">Message</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Handler%EF%BC%8CLooper%E4%B8%8EMessageQueue"><span class="nav-text">Handler，Looper与MessageQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C"><span class="nav-text">同步屏障</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BA%A4%E4%BA%92"><span class="nav-text">进程间交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AIDL%E4%B8%8EBinder"><span class="nav-text">AIDL与Binder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binder%E5%AE%9E%E7%8E%B0"><span class="nav-text">Binder实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Message%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">Message跨进程通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket"><span class="nav-text">Socket</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#View%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-text">View与事件分发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-text">事件分发流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="nav-text">滑动冲突与解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RecyclerView%E4%B8%8EListView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-text">RecyclerView与ListView缓存机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0"><span class="nav-text">屏幕刷新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-text">View绘制流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gradle"><span class="nav-text">Gradle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android%E5%90%AF%E5%8A%A8"><span class="nav-text">Android启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Init%E8%BF%9B%E7%A8%8B"><span class="nav-text">Init进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Zygote%E8%BF%9B%E7%A8%8B"><span class="nav-text">Zygote进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SystemServer%E8%BF%9B%E7%A8%8B"><span class="nav-text">SystemServer进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#APP%E8%BF%9B%E7%A8%8B"><span class="nav-text">APP进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="nav-text">常用框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Glide"><span class="nav-text">Glide</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#okHttp"><span class="nav-text">okHttp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Retrofit"><span class="nav-text">Retrofit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RxJava"><span class="nav-text">RxJava</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="marigo1d"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">marigo1d</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/marigo1d" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;marigo1d" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">marigo1d</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">528k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">16:01</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
