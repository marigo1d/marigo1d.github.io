<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algo Learning Record</title>
    <url>/2024/04/25/Algo-Learning-Record/</url>
    <content><![CDATA[<p>算法相关学习记录</p>
<span id="more"></span>
<h1>Java 数组 String 与容器</h1>
<h2 id="数组">数组</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line">String[][] names = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Eve&quot;</span>, <span class="string">&quot;Frank&quot;</span>, <span class="string">&quot;Grace&quot;</span>, <span class="string">&quot;Henry&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="comment">// 声明一个 3x4 的 int 型二维数组</span></span><br><span class="line"><span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];  <span class="comment">// 3 行 4 列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// java允许创建不规则二维数组</span></span><br><span class="line"><span class="type">int</span>[][] jaggedArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];  <span class="comment">// 只指定行数</span></span><br><span class="line"></span><br><span class="line">jaggedArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 第一行有 5 列</span></span><br><span class="line">jaggedArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 第二行有 3 列</span></span><br><span class="line">jaggedArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>]; <span class="comment">// 第三行有 7 列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组和</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(numbers).sum();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用迭代</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i: numbers)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Comparator">Comparator</h2>
<p><strong>Comparator 接口的 compare(T o1, T o2) 方法：</strong></p>
<ul>
<li><strong>返回负数：</strong> 如果 o1 应该排在 o2 <em>之前</em> （即 o1 小于 o2）。</li>
<li><strong>返回零：</strong> 如果 o1 和 o2 相等。</li>
<li><strong>返回正数：</strong> 如果 o1 应该排在 o2 <em>之后</em> （即 o1 大于 o2）。</li>
</ul>
<blockquote>
<p>通俗理解， o1 在 o2 的前面即为升序排序（o1, o2）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(students, (s1, s2) -&gt; Integer.compare(s1.getAge(), s2.getAge()));</span><br><span class="line"></span><br><span class="line">Arrays.sort(nums, (o1, o2) -&gt; o1 - o2);</span><br></pre></td></tr></table></figure>
<h2 id="String">String</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);  </span><br><span class="line"><span class="keyword">if</span> ( s.indexOf(c) == s.lastIndexOf(c)) <span class="keyword">return</span> s.indexOf(c) +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,orange,grape&quot;</span>;</span><br><span class="line"><span class="comment">// 使用逗号作为分隔符进行分割</span></span><br><span class="line">String[] fruits = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;coode&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> <span class="string">&quot;c*de&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">wildcardIndex</span> <span class="operator">=</span> p.indexOf(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> p.substring(<span class="number">0</span>, wildcardIndex);</span><br><span class="line"><span class="comment">// substring beginIndex: 字符串起始索引（包含）</span></span><br><span class="line"><span class="comment">// substring endIndex: 字符串结束索引（不包含）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> p.substring(wildcardIndex + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (t.startsWith(prefix) &amp;&amp; t.endsWith(suffix)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Character x : s.toCharArray()) &#123; <span class="comment">// 转字符串为char数组</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();  <span class="comment">// 使用length()获取字符串长，同StringBuilder使用length()获取字符串长</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(s); <span class="comment">// 转字符串为整型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(i); <span class="comment">// 转整形为字符串</span></span><br></pre></td></tr></table></figure>
<h2 id="StringBuilder">StringBuilder</h2>
<p>StringBuilder和String均使用length()获得长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 StringBuffer 对象</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Initial StringBuffer: &quot;</span> + sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// append() - 追加字符串</span></span><br><span class="line">        sb.append(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;append(): &quot;</span> + sb);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        sb.append(sb1); <span class="comment">// 向StringBuilder中追加其他的StringBuilder</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// insert() - 插入字符串，插入位置的索引，从 0 开始，目标索引的右侧开始插入。</span></span><br><span class="line">        sb.insert(<span class="number">5</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;insert(): &quot;</span> + sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delete() - 删除字符串</span></span><br><span class="line">        sb.delete(<span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 删除 &quot;, &quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;delete(): &quot;</span> + sb);</span><br><span class="line">        sb.delete(<span class="number">0</span>, sb.length()); <span class="comment">// 清空字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// deleteCharAt() - 删除指定位置字符</span></span><br><span class="line">        sb.deleteCharAt(<span class="number">5</span>); <span class="comment">//删除逗号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;deleteCharAt(): &quot;</span> + sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// replace() - 替换字符串</span></span><br><span class="line">        sb.replace(<span class="number">5</span>, <span class="number">10</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;replace(): &quot;</span> + sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// charAt() - 获取指定位置字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> sb.charAt(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;charAt(0): &quot;</span> + ch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setCharAt() - 设置指定位置字符</span></span><br><span class="line">        sb.setCharAt(<span class="number">0</span>, <span class="string">&#x27;J&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;setCharAt(0, &#x27;J&#x27;): &quot;</span> + sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// substring() - 获取子字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sub1</span> <span class="operator">=</span> sb.substring(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;substring(5): &quot;</span> + sub1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sub2</span> <span class="operator">=</span> sb.substring(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;substring(0, 5): &quot;</span> + sub2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse() - 反转字符串</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(<span class="string">&quot;reverse(): &quot;</span> + sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// length() - 获取字符串长度！！！不是size()</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        System.out.println(<span class="string">&quot;length(): &quot;</span> + len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// capacity() - 获取容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> sb.capacity();</span><br><span class="line">        System.out.println(<span class="string">&quot;capacity(): &quot;</span> + capacity); <span class="comment">// 默认容量为 16 + 初始字符串长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//indexOf</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> sb.indexOf(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;indexOf(\&quot;Java\&quot;): &quot;</span> + index1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> sb.indexOf(<span class="string">&quot;Java&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;indexOf(\&quot;Java\&quot;, 6): &quot;</span> + index2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex1</span> <span class="operator">=</span> sb.lastIndexOf(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;lastIndexOf(\&quot;Java\&quot;): &quot;</span> + lastIndex1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex2</span> <span class="operator">=</span> sb.lastIndexOf(<span class="string">&quot;Java&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;lastIndexOf(\&quot;Java\&quot;, 10): &quot;</span> + lastIndex2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// toString() - 转换为 String</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;toString(): &quot;</span> + str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ensureCapacity</span></span><br><span class="line">        sb.ensureCapacity(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ensureCapacity(50): &quot;</span> + sb.capacity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//setLength</span></span><br><span class="line">        sb.setLength(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;setLength(5): &quot;</span> + sb);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="List">List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList</span><br><span class="line"><span class="keyword">import</span> java.util.List    </span><br><span class="line">    </span><br><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; l1 = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">l.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 添加元素</span></span><br><span class="line">l.add(<span class="number">1</span>, <span class="string">&quot;banana&quot;</span>); <span class="comment">// 指定索引位添加元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> l.get(<span class="number">0</span>); <span class="comment">// 获取指定索引位置的元素</span></span><br><span class="line">l.set(<span class="number">0</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 修改指定索引位的元素值</span></span><br><span class="line">list.remove(<span class="number">0</span>); <span class="comment">// 移除指定索引位置的元素，后续元素前移</span></span><br><span class="line">list.remove(<span class="string">&quot;banana&quot;</span>); <span class="comment">// 移除指定对象的第一个匹配项，注意：存在多个相同项时，仅移除第一个</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> list.remove(<span class="string">&quot;grape&quot;</span>); <span class="comment">// 返回是否成功移除</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isContains</span> <span class="operator">=</span> l.contains(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 检查list是否含有指定元素</span></span><br><span class="line"></span><br><span class="line">list.clear(); <span class="comment">// 移除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 返回指定对象的第一个匹配项的索引，如果没有找到则返回 -1</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// LinkedList 支持首尾添加/移除</span></span><br><span class="line">linkedList.addLast(<span class="number">1</span>);</span><br><span class="line">linkedList.removeLast();</span><br><span class="line">linkedList.addFirst(<span class="number">2</span>);</span><br><span class="line">linkedList.removeFirst();</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 转为 二维数组</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 这里 new int[0][0] 创建了一个空的二维整数数组。</span></span><br><span class="line"><span class="comment">// toArray 方法使用这个数组来确定返回数组的类型。即使你传入的是一个空数组，toArray 方法也会根据集合的大小创建一个新的数组，并将元素复制到新数组中。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ArrayList动态扩容机制</p>
<p>add插入元素时</p>
<ul>
<li>检查容量是否满足
<ul>
<li>计算新的数组容量</li>
<li>copy移动原数组内元素到创建新的数组</li>
</ul>
</li>
<li>插入元素</li>
</ul>
<p><code>add(val, index)</code>方法通过copy目标索引后的元素向后移动的方式，留空目标索引位置并插入</p>
<p><code>remove(index)</code>方法将删除位置后面的元素向前移动一位</p>
<p>LinkedList为含头指针，尾指针的链表</p>
</blockquote>
<h2 id="栈">栈</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line">ArrayDeque&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">s.push(<span class="number">1</span>);  <span class="comment">// 压栈</span></span><br><span class="line">q.pop();  <span class="comment">// 出栈操作</span></span><br><span class="line">q.peek();  <span class="comment">// 获取栈顶元素</span></span><br><span class="line">queue.isEmpty();</span><br></pre></td></tr></table></figure>
<h2 id="最小堆">最小堆</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">minHeap.add(<span class="number">5</span>);</span><br><span class="line">minHeap.add(<span class="number">1</span>);</span><br><span class="line">minHeap.add(<span class="number">3</span>);</span><br><span class="line">minHeap.add(<span class="number">7</span>);</span><br><span class="line">minHeap.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;最小堆元素 (使用迭代器遍历，顺序不保证): &quot;</span> + minHeap);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;按顺序取出最小元素: &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">	System.out.print(minHeap.poll() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列">队列</h2>
<p>Queue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">q.add(<span class="number">1</span>);  <span class="comment">// 无返回值，队列满抛出异常</span></span><br><span class="line">q.offer(<span class="number">1</span>);  <span class="comment">// 如果插入成功，返回 true；如果队列已满，返回 false，而不会抛出异常。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> dq.peek();  <span class="comment">// 查看队头元素</span></span><br><span class="line">first = q.poll();  <span class="comment">// 出队操作</span></span><br><span class="line">queue.isEmpty();</span><br></pre></td></tr></table></figure>
<p>Deque</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList</span><br><span class="line"><span class="keyword">import</span> java.util.Deque    </span><br><span class="line"></span><br><span class="line">Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾操作</span></span><br><span class="line">dq.add(<span class="number">1</span>);</span><br><span class="line">dq.offer(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> deque.peekLast();</span><br><span class="line">last = dq.removeLast();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队首操作</span></span><br><span class="line">dq.push(<span class="number">1</span>);</span><br><span class="line">dq.offerFirst(<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> dq.peek();</span><br><span class="line">first = dq.poll();</span><br><span class="line">first = dq.removeFirst();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Set">Set</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">hashSet.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">hashSet.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">hashSet.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 重复元素会被忽略</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">containsApple</span> <span class="operator">=</span> hashSet.contains(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 快速查找</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">linkedHashSet.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">linkedHashSet.forEach(System.out::println);</span><br><span class="line"><span class="comment">// System.out::println为方法引用，引用System.out对象的println方法，编译器将其转换为相应的函数式接口实例，得到一个Consumer&lt;String&gt; 的实例</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">treeSet.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String fruit : treeSet)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Map">Map</h2>
<p>Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">90</span>);  <span class="comment">// 添加键值对</span></span><br><span class="line">map.get(<span class="string">&quot;Alice&quot;</span>);  <span class="comment">// 根据键获取值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名: &quot;</span> + entry.getKey() + <span class="string">&quot;, 分数: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> (Integer i : m.keySet())  <span class="comment">// 注意是 keySet</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> (Integer i : m.values())  <span class="comment">// 注意是 values</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否包含某键或某值</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否包含Bob: &quot;</span> + map.containsKey(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;是否包含分数85: &quot;</span> + map.containsValue(<span class="number">85</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line">map.remove(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;删除后HashMap内容: &quot;</span> + map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超实用！！！如果 key 不存在，设置默认值为0；key 存在，则 value+1</span></span><br><span class="line"><span class="comment">// Lambda 表达式的返回值会自动赋值给 value</span></span><br><span class="line">map.compute(key, (k, v) -&gt; (v == <span class="literal">null</span>) ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">map.compute(key, (key, value) -&gt; value != <span class="number">1</span> ? value - <span class="number">1</span> : <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 所以说如果v为列表必须按以下形式写</span></span><br><span class="line">listInMap.compute(key, (k, v) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">        v = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    v.add(someElement);  <span class="comment">// someElement 是你希望添加的元素</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>TreeMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自然排序（对于 String 键来说是字母顺序）</span></span><br><span class="line">TreeMap&lt;String, Integer&gt; treeMap1 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">treeMap1.put(<span class="string">&quot;Apple&quot;</span>, <span class="number">1</span>);</span><br><span class="line">treeMap1.put(<span class="string">&quot;Banana&quot;</span>, <span class="number">2</span>);</span><br><span class="line">treeMap1.put(<span class="string">&quot;Orange&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> treeMap1.get(<span class="string">&quot;Banana&quot;</span>); <span class="comment">// 获取键为 &quot;Banana&quot; 的值</span></span><br><span class="line">System.out.println(value); <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getOrDefault() 方法可以在键不存在时返回默认值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">defaultValue</span> <span class="operator">=</span> treeMap1.getOrDefault(<span class="string">&quot;Grape&quot;</span>, <span class="number">0</span>); <span class="comment">// &quot;Grape&quot; 不存在，返回 0</span></span><br><span class="line">System.out.println(defaultValue); <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 forEach 遍历</span></span><br><span class="line">treeMap1.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 entrySet() 遍历</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : treeMap1.entrySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 keySet() 遍历键，然后获取值</span></span><br><span class="line"><span class="keyword">for</span> (String key : treeMap1.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + treeMap1.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeMap&lt;String, Integer&gt; treeMap2 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((s1, s2) -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value1</span> <span class="operator">=</span> treeMap1.getOrDefault(s1, <span class="number">0</span>); <span class="comment">// 处理键不存在的情况</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> treeMap1.getOrDefault(s2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> value2 - value1;</span><br><span class="line">    <span class="comment">// 返回值含义</span></span><br><span class="line">    <span class="comment">// 负数: 表示 s1 小于 s2 (按值逆序排列，值大的排在前面)。</span></span><br><span class="line">	<span class="comment">// 零: 表示 s1 等于 s2。</span></span><br><span class="line">	<span class="comment">// 正数: 表示 s1 大于 s2 (按值逆序排列，值小的排在后面)。</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">treeMap2.putAll(treeMap1); <span class="comment">// 将 treeMap1 的元素复制到 treeMap2</span></span><br><span class="line"></span><br><span class="line">treeMap2.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HashMap 底层为数组实现，通过哈希码（int类型）与数组长取模得到插入位置</p>
<p>当前的元素数量超过了 <strong>扩容阈值</strong>（ <code>容量（capacity） * 负载因子（loadFactor）</code>）时发生扩容</p>
<p>扩容通过创建新数组并转移（遍历每个元素并重新计算存放位置）原数组中的Entry实现</p>
<p>当元素发生位置冲突时，使用链表或红黑树（Java 8+）存储冲突元素，重新分布到新数组的对应链表中。</p>
</blockquote>
<h1>常用排序</h1>
<h2 id="冒泡排序">冒泡排序*</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;  <span class="comment">// 大的向上冒泡</span></span><br><span class="line">                    <span class="comment">// 比较相邻的两个元素并交换它们的位置</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序">选择排序</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次从未排序部分中找到最小值，并将其放到已排序部分的末尾。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[minIndex];</span><br><span class="line">            arr[minIndex] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序">插入排序*</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="comment">// 每次从未排序部分取一个元素，插入到已排序部分的合适位置。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];  <span class="comment">// 相当于取出了在位置i的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;  <span class="comment">// 已排序部分的末尾</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">// 向右移动已排序部分</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = key; <span class="comment">// 写入目标位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序">快速排序*</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="comment">// 选择一个基准值（pivot）。</span></span><br><span class="line">	<span class="comment">// 将小于基准值的元素放到左侧，大于基准值的元素放到右侧。</span></span><br><span class="line">	<span class="comment">// 对左右部分递归排序，直到数组被完全排序。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pi</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];  <span class="comment">// 选择最右端元素为枢值并取出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;  <span class="comment">// i 为小于pivot的数的最大索引，此时相当于-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123; <span class="comment">// 遍历范围[low, high - 1]</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;  <span class="comment">// 元素值小于枢值</span></span><br><span class="line">                i++;  <span class="comment">// 将该元素交换到小于枢值的元素组的最右端</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];  <span class="comment">// 将枢值插回小于枢值的元素组的最右端的右侧</span></span><br><span class="line">        arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 返回枢值索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机枢纽</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();  <span class="comment">// 创建 Random 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 选择随机 pivot 并交换到 end 位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIdx</span> <span class="operator">=</span> start + random.nextInt(end - start + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[randomIdx];</span><br><span class="line">        nums[randomIdx] = nums[end];</span><br><span class="line">        nums[end] = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 继续 Lomuto 分区</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotValue</span> <span class="operator">=</span> nums[end];  <span class="comment">// 选择 pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pIdx</span> <span class="operator">=</span> start;  <span class="comment">// pIdx 指向小于 pivot 的区域的下一个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivotValue) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[i] 和 nums[pIdx]</span></span><br><span class="line">                tmp = nums[i];</span><br><span class="line">                nums[i] = nums[pIdx];</span><br><span class="line">                nums[pIdx] = tmp;</span><br><span class="line">                pIdx++;  <span class="comment">// 右移 pIdx</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换 pivotValue 和 nums[pIdx]，确保 pivot 归位</span></span><br><span class="line">        tmp = nums[pIdx];</span><br><span class="line">        nums[pIdx] = nums[end];</span><br><span class="line">        nums[end] = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pIdx;  <span class="comment">// 返回 pivot 的正确索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;  <span class="comment">// 递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIdx</span> <span class="operator">=</span> partition(nums, start, end);</span><br><span class="line">        quickSort(nums, start, pivotIdx - <span class="number">1</span>);  <span class="comment">// 递归排序左侧</span></span><br><span class="line">        quickSort(nums, pivotIdx + <span class="number">1</span>, end);  <span class="comment">// 递归排序右侧</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序*</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(arr, left, mid);</span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数组不断分成两部分，直到无法再分。</span></span><br><span class="line">	<span class="comment">// 然后通过合并两个有序数组的方式，将小规模数组逐步合并为一个完整有序数组。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> right - mid;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] L = <span class="keyword">new</span> <span class="title class_">int</span>[n1];</span><br><span class="line">        <span class="type">int</span>[] R = <span class="keyword">new</span> <span class="title class_">int</span>[n2];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) L[i] = arr[left + i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n2; j++) R[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">                arr[k] = L[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = R[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1) arr[k++] = L[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n2) arr[k++] = R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序*</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">            heapify(arr, n, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数组构造成一个大顶堆（父节点大于或等于子节点）。</span></span><br><span class="line">	<span class="comment">// 取出堆顶元素（最大值），并将其与堆的末尾元素交换。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) </span><br><span class="line">            largest = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) </span><br><span class="line">            largest = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">swap</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[largest];</span><br><span class="line">            arr[largest] = swap;</span><br><span class="line"></span><br><span class="line">            heapify(arr, n, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;;</span><br><span class="line">        QuickSort.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度 (最好/最坏/平均)</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n) / O(n²) / O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单小规模数据</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²) / O(n²) / O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>简单数据，无需稳定性</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n) / O(n²) / O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
<td>小规模、部分有序数据</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n log n) / O(n²) / O(n log n)</td>
<td>O(log n)</td>
<td>不稳定</td>
<td>大规模数据，追求高效率</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n log n) / O(n log n) / O(n log n)</td>
<td>O(n)</td>
<td>稳定</td>
<td>大规模数据，需要稳定性</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n log n) / O(n log n) / O(n log n)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>大规模数据，需要原地排序</td>
</tr>
</tbody>
</table>
<h1>算法题目与设计模式</h1>
<h2 id="红黑树">红黑树</h2>
<p>改进平衡二叉树</p>
<ul>
<li>根节点为黑</li>
<li>不存在红节点相邻</li>
<li>黑高一致</li>
<li>叶节点为黑（NIL节点或空节点）</li>
</ul>
<p>黑高不一致/红节点相邻时 <strong>发生平衡</strong></p>
<p><strong>默认插入节点为红色</strong></p>
<p>按平衡二叉树逻辑插入红色新节点，交替以下过程</p>
<p>1.父节点重新染色 &lt;-&gt; 2.从下往上第一个黑高不一致节点旋转</p>
<h2 id="B树与B-树">B树与B+树</h2>
<p>二叉搜索树</p>
<ul>
<li>
<p>所有非叶子结点至多拥有两个儿子（Left和Right）；</p>
</li>
<li>
<p>所有结点存储一个关键字；</p>
</li>
<li>
<p>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树。</p>
</li>
</ul>
<p>(m阶)B树</p>
<img src="/2024/04/25/Algo-Learning-Record/afba36911df7499610fe68102efe9e41.png" class="" title="img">
<ul>
<li>根节点最多 M - 1个关键字，最多 M 个子节点；<strong>最少 1 个关键字，最少 2 个子节点</strong></li>
<li>非根节点（包括叶节点）最多M - 1个关键字，最多 M 个子节点；最少 M/2-1 个关键字，最少 M/2 个子节点</li>
<li>节点内关键字有序排列</li>
<li>所有叶子结点位于同一层</li>
</ul>
<p>(m阶)B+树</p>
<img src="/2024/04/25/Algo-Learning-Record/20200926212656.png" class="" title="img">
<p>继承B树</p>
<ul>
<li>
<p>非叶子结点为索引节点，叶子节点提供信息</p>
</li>
<li>
<p><strong>叶子节点最大元素数为 m，最小为 m/2</strong></p>
<blockquote>
<p>由于非叶节点不保存信息，故叶子节点可保存元素变多，重复保存非叶中的索引节点值；查找过程相当于索引左右两边是左开右闭区间</p>
</blockquote>
</li>
<li>
<p>叶子节点新增链指针</p>
</li>
<li>
<p>所有关键字均在叶子节点出现</p>
</li>
</ul>
<p><strong>对比</strong></p>
<ul>
<li>
<p>B树的每个节点都存储了key和data，而B+树的data存储在叶子节点上。<br>
<strong>B+树非叶子节点仅存储key不存储data，这样一个节点就可以存储更多的key，可以使得B+树相对B树来说更矮（IO次数就是树的高度），所以与磁盘交换的IO操作次数更少。</strong></p>
</li>
<li>
<p>B+树所有叶子节点构成一个 <em>有序链表</em>，按主键排序来遍历全部记录，能更好支持<strong>范围查找</strong>。<br>
由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p>
</li>
<li>
<p>B+树所有的查询都要从根节点查找到叶子节点，<strong>查询性更稳定</strong>；而B树，每个节点都可能查找到数据，需要在叶子节点和内部节点不停的往返移动，所以不稳定。</p>
</li>
</ul>
<p>作者：梦<br>
链接：<a href="https://juejin.cn/post/7117516433386373133">https://juejin.cn/post/7117516433386373133</a><br>
来源：稀土掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="设计模式">设计模式</h2>
<h3 id="单例模式">单例模式</h3>
<p>环境中仅存在唯一的对象</p>
<h3 id="工厂模式">工厂模式</h3>
<p>适用于多种相似类型的类的创建</p>
<p>例如：工厂类存在方法A和方法B</p>
<p>方法A用于创建实现了接口A的类A1和类A2，通过传入参数区别；</p>
<p>方法B用于创建实现了接口B的类B1和类B2，通过传入参数区别；</p>
<h3 id="建造者模式">建造者模式</h3>
<p>构造时允许某些参数不传递（可选参数）和链式创建（User.builder().name().age().email().build()）</p>
<p>例如：Lombok注解</p>
<p><code>@Builder</code> 自动生成构造方法</p>
<h3 id="适配器模式">适配器模式</h3>
<p>被调类实现适配器接口，调用类可以统一调用</p>
<p>例如： Spring MVC 里的 <code>HandlerAdapter</code></p>
<p>数据库驱动 <code>JDBC DriverManager</code></p>
<h3 id="装饰者模式">装饰者模式</h3>
<p>例如：Spring AOP / python 装饰器</p>
<p>Open/Closed Principle，OCP</p>
<p><strong>对扩展开放（Open for extension），对修改关闭（Closed for modification）</strong>。</p>
<h2 id="常见架构">常见架构</h2>
<h3 id="MVC">MVC</h3>
<p>MVC 架构调用流程</p>
<img src="/2024/04/25/Algo-Learning-Record/road-map-230623-02.png" class="" title="MVC">
<img src="/2024/04/25/Algo-Learning-Record/road-map-230623-03.png" class="" title="MVC_workflow">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">项目结构</span><br><span class="line">├── docs</span><br><span class="line">│   └── mvc.drawio - 架构文档</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── cn</span><br><span class="line">│   │   │       └── bugstack</span><br><span class="line">│   │   │           └── xfg</span><br><span class="line">│   │   │               └── frame</span><br><span class="line">│   │   │                   ├── Application.java</span><br><span class="line">│   │   │                   ├── common</span><br><span class="line">│   │   │                   │   ├── Constants.java</span><br><span class="line">│   │   │                   │   └── Result.java</span><br><span class="line">│   │   │                   ├── controller</span><br><span class="line">│   │   │                   │   └── UserController.java</span><br><span class="line">│   │   │                   ├── dao</span><br><span class="line">│   │   │                   │   └── IUserDao.java</span><br><span class="line">│   │   │                   ├── domain</span><br><span class="line">│   │   │                   │   ├── po</span><br><span class="line">│   │   │                   │   │   └── User.java</span><br><span class="line">│   │   │                   │   ├── req</span><br><span class="line">│   │   │                   │   │   └── UserReq.java</span><br><span class="line">│   │   │                   │   ├── res</span><br><span class="line">│   │   │                   │   │   └── UserRes.java</span><br><span class="line">│   │   │                   │   └── vo</span><br><span class="line">│   │   │                   │       └── UserInfo.java</span><br><span class="line">│   │   │                   └── service</span><br><span class="line">│   │   │                       ├── IUserService.java</span><br><span class="line">│   │   │                       └── impl</span><br><span class="line">│   │   │                           └── UserServiceImpl.java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   │       ├── application.yml</span><br><span class="line">│   │       └── mybatis</span><br><span class="line">│   │           ├── config</span><br><span class="line">│   │           │   └── mybatis-config.xml</span><br><span class="line">│   │           └── mapper</span><br><span class="line">│   │               └── User_Mapper.xml</span><br><span class="line">│   └── test</span><br><span class="line">│       └── java</span><br><span class="line">│           └── cn</span><br><span class="line">│               └── bugstack</span><br><span class="line">│                   └── xfg</span><br><span class="line">│                       └── frame</span><br><span class="line">│                           └── test</span><br><span class="line">│                               └── ApiTest.java</span><br><span class="line">└── road-map.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="DDD">DDD</h3>
<img src="/2024/04/25/Algo-Learning-Record/roadmap-ddd-stc-11.png" class="" title="ddd">
<h3 id="Diff">Diff</h3>
<p>mvc</p>
<img src="/2024/04/25/Algo-Learning-Record/ddd-easy-guide-03-02.png" class="" title="diff">
<p>ddd</p>
<img src="/2024/04/25/Algo-Learning-Record/ddd-easy-guide-03-04.png" class="" title="diff2">
<img src="/2024/04/25/Algo-Learning-Record/ddd-easy-guide-03-05.png" class="" title="diff3">
<h2 id="题目">题目</h2>
<h3 id="图">图</h3>
<p><a href="https://leetcode.cn/problems/course-schedule/">课程表</a>：</p>
<p>使用邻接表+入度表；从入度为0的节点出发，从图中移除；</p>
<h3 id="树">树</h3>
<blockquote>
<p>明确递归返回值；</p>
<p>合理使用递归返回值为变量赋值；</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第 K 小的元素</a>:</p>
<p>中序遍历的第k个元素</p>
<blockquote>
<p>第k大 以 （右-&gt;根-&gt;左） 方式遍历的第k个元素</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a>：</p>
<p>每个子树的节点都需要小于/大于当前节点，不能只比较当前节点与左右子树；故需要在递归中需要传递允许最大值/允许最小值；</p>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径</a>：</p>
<p>任意两点的距离；使用全局变量保存最大值；</p>
<p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)</a>：</p>
<p>字典树每个节点由 词结束标（当前节点是否为一个词的结尾字符） + 节点数组（数组中不为null的位置的索引对应于该节点所表示的字符，该位置的值为指向下一个节点的指针） 组成</p>
<p>根节点的节点数组不含词信息，仅作为出发点使用</p>
<p>ref: <a href="https://blog.csdn.net/m0_46202073/article/details/107253959">https://blog.csdn.net/m0_46202073/article/details/107253959</a></p>
<h3 id="字符串">字符串</h3>
<p><a href="https://www.fastprep.io/problems/amazon-match-strings">co*d与code的匹配 </a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] matchStrings(String[] text, String[] pat) &#123;</span><br><span class="line">       String[] results = <span class="keyword">new</span> <span class="title class_">String</span>[text.length];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> text[i];</span><br><span class="line">           <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> pat[i];</span><br><span class="line">           <span class="type">int</span> <span class="variable">wildcardIndex</span> <span class="operator">=</span> p.indexOf(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// Split pattern into prefix and suffix</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> p.substring(<span class="number">0</span>, wildcardIndex);</span><br><span class="line">           <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> p.substring(wildcardIndex + <span class="number">1</span>);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// Check if the prefix matches the start of the text</span></span><br><span class="line">           <span class="comment">// and the suffix matches the end of the text</span></span><br><span class="line">           <span class="keyword">if</span> (t.startsWith(prefix) &amp;&amp; t.endsWith(suffix)) &#123;</span><br><span class="line">               <span class="comment">// Check if the combined length of prefix and suffix is less than or equal to text length</span></span><br><span class="line">               <span class="keyword">if</span> (prefix.length() + suffix.length() &lt;= t.length()) &#123;</span><br><span class="line">                   results[i] = <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   results[i] = <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               results[i] = <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> results;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆">堆</h3>
<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p>
<p>从mid向前遍历到root，调用 自上而下 的最大堆函数，实现最大堆建立</p>
<h3 id="单调栈">单调栈</h3>
<p>单调增栈</p>
<ul>
<li>
<p>单调递增栈即栈内元素保持单调递增的栈</p>
</li>
<li>
<p>如果新的元素比栈顶元素大，就入栈</p>
</li>
<li>
<p>如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小</p>
</li>
</ul>
<p>核心：</p>
<ul>
<li>当遍历到元素X时，发生出栈，出栈元素A，说明元素X是出栈元素A向后方向第一个比其小的元素</li>
<li>当遍历到元素X时，发生出栈，出栈元素A，当前栈顶元素B，说明栈顶元素B是出栈元素A向前方向第一个比其小的元素</li>
</ul>
<p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></p>
<p><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></p>
<h3 id="回溯">回溯</h3>
<p>画出回溯树！</p>
<p>回溯体：叶节点处理-&gt;左子树进入-&gt;右子树进入</p>
<p><a href="https://leetcode.cn/problems/subsets/">子集</a></p>
<p>基础</p>
<p><a href="https://leetcode.cn/problems/permutations-ii/">全排列 II</a></p>
<p>剪枝条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; used[i-<span class="number">1</span>] == <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>剪枝条件 1：用过的元素不能再使用;</p>
<p>剪枝条件 2：当前元素和前一个元素值相同（此处隐含这个元素的 index&gt;0 ），并且前一个元素还没有被使用过的时候</p>
<h3 id="双指针">双指针</h3>
<p>「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2) 减少至 O(N)。</p>
<p>即在一次循环中，同时存在两个移动的指针，<strong>该方法旨在减少一层循环</strong></p>
<h3 id="二分查找">二分查找</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (array[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>; <span class="comment">// low移动到mid + 1, 防止不必要的比较和无限循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>; <span class="comment">// 相同原因</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 未找到目标值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口">滑动窗口</h3>
<p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界；</p>
<p>在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；</p>
<p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p>
<p><strong>该方法旨在利用已有的信息（即已经遍历过的不加重复遍历，类似于动态规划的思想）</strong></p>
<h3 id="线段树">线段树</h3>
<p>统计数组中任意 [a, b] 的和/最大值/…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">maxSubArrayIterState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">maxSubArrayIterState</span><span class="params">(<span class="type">int</span> lSum, <span class="type">int</span> rSum, <span class="type">int</span> mSum, <span class="type">int</span> iSum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lSum = lSum;</span><br><span class="line">        <span class="built_in">this</span>.rSum = rSum;</span><br><span class="line">        <span class="built_in">this</span>.iSum = iSum;</span><br><span class="line">        <span class="built_in">this</span>.mSum = mSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> maxSubArrayIterState <span class="title function_">maxSubArrayIter</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">maxSubArrayIterState</span>(a[l], a[l], a[l], a[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">maxSubArrayIterState</span> <span class="variable">lInterval</span> <span class="operator">=</span> maxSubArrayIter(a,l, (l + r) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="type">maxSubArrayIterState</span> <span class="variable">rInterval</span> <span class="operator">=</span> maxSubArrayIter(a, (((l + r) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>), r);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lS</span> <span class="operator">=</span> Math.max(lInterval.lSum, lInterval.iSum + rInterval.lSum);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rS</span> <span class="operator">=</span> Math.max(rInterval.rSum, rInterval.iSum + lInterval.rSum);</span><br><span class="line">    <span class="type">int</span> <span class="variable">mS</span> <span class="operator">=</span> Math.max(Math.max(lInterval.mSum, rInterval.mSum), lInterval.rSum + rInterval.lSum);</span><br><span class="line">    <span class="type">int</span> <span class="variable">iS</span> <span class="operator">=</span> lInterval.iSum + rInterval.iSum;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">maxSubArrayIterState</span>(lS, rS, mS, iS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dynamic-Programming">Dynamic Programming</h3>
<p>模板</p>
<p><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 完整dp模板</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l1 + <span class="number">1</span>][l2 + <span class="number">1</span>];  </span><br><span class="line">        <span class="comment">// dp[i][j]表示word1[0:i]和word2[0:j]之间的编辑距离。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l1 + <span class="number">1</span>; i++) &#123; <span class="comment">// 0列初始化</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; l2 + <span class="number">1</span>; j++) &#123; <span class="comment">// 0行初始化</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= l1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= l2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 递推公式</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - <span class="number">1</span>, Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min( dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变化点：</p>
<ol>
<li>
<p><code>dp[nums.length]</code> 或 <code>dp[nums.length + 1]</code></p>
</li>
<li>
<p>初始化</p>
</li>
<li>
<p>遍历顺序</p>
</li>
<li>
<p>递推公式</p>
</li>
<li>
<p>返回值</p>
</li>
</ol>
<p><s>动态规划</s></p>
<p>贪心剪枝的全状态值记录</p>
<h4 id="DP问题分析">DP问题分析</h4>
<p>递归&amp;动态规划</p>
<img src="/2024/04/25/Algo-Learning-Record/IMG_0091.PNG" class="" title="IMG_0091(20240425-192828)">
<p><strong>DP核心：</strong></p>
<p>1.状态</p>
<blockquote>
<p>一般来说，某一天为状态维度1，某一天的某一种状态为状态维度2</p>
</blockquote>
<p>2.起点和终点</p>
<blockquote>
<p>一般终点都是确定的，偶尔起点也会是确定的</p>
</blockquote>
<p>3.如何转移+剪枝</p>
<blockquote>
<p>越复杂的问题转移越复杂，例如：从<code>状态[x][y][z]</code>转移到<code>状态[x+1][y][z]</code></p>
<p>一般采用贪心剪枝，移除不需要的状态链</p>
</blockquote>
<h4 id="无权图两点间路径数">无权图两点间<strong>路径数</strong></h4>
<p>递归思路：</p>
<p>1.从终点出发，存在多个选择，每个选择为分支，<strong>传入递归函数</strong>并进入；取得递归结果相加。</p>
<p>2.对于每一个中间态，存在多个选择，<strong>传入递归函数</strong>并进入；</p>
<p>3.到达起点，当前递归结束，返回；</p>
<p>DP思路：</p>
<p>1.从起点出发，到达所有<strong>邻接点</strong>的走法已知；</p>
<p>2.到达<strong>次邻接点</strong>的走法为从<strong>邻接点</strong>到<strong>次邻接点</strong>的走法之和；</p>
<p>3.到达终点的走法为从<strong>终点邻接点</strong>到终点的走法之和；</p>
<p>实例：</p>
<img src="/2024/04/25/Algo-Learning-Record/image-20240426101614103.png" class="" title="image-20240426101614103">
<p>递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathsCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//到达起点</span></span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//从终点前进</span></span><br><span class="line">    <span class="keyword">return</span> pathsCount(m - <span class="number">1</span>, n) + pathsCount(m , n -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathsCounts</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化起点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//从起点前进</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到达终点</span></span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有权图两点间最大路径">有权图两点间<strong>最大路径</strong></h4>
<p>递归思路：</p>
<p>1.从终点出发，存在多个选择，每个选择为分支，<strong>传入递归函数</strong>并进入；取得递归结果取最大。</p>
<p>2.对于每一个中间态，存在多个选择，<strong>传入递归函数</strong>并进入；</p>
<p>3.到达起点，当前递归结束，返回当前节点值；</p>
<p>DP思路：</p>
<p>1.从起点出发，到达所有<strong>邻接点</strong>的距离可知；</p>
<p>2.到达<strong>次邻接点</strong>的最大距离为从<strong>邻接点</strong>到<strong>次邻接点</strong>的最大距离；</p>
<p>3.到达终点的走法为从<strong>终点邻接点</strong>到终点的最大距离；</p>
<p>实例：</p>
<img src="/2024/04/25/Algo-Learning-Record/image-20240426102031155.png" class="" title="image-20240426102031155">
<p>递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//从终点前进</span></span><br><span class="line">    <span class="keyword">return</span> getMin(grid, m-<span class="number">1</span>, n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">//到达起点</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[i][j] + getMin(grid, i, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[i][j] + getMin(grid, i-<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minRow</span> <span class="operator">=</span> getMin(grid, i-<span class="number">1</span>, j);</span><br><span class="line">    <span class="type">int</span> <span class="variable">minColumn</span> <span class="operator">=</span> getMin(grid, i, j-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grid[i][j] + Math.min(minRow, minColumn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化起点</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m ;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n;i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从起点前进</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = grid[i][j] + Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到达终点</span></span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="技巧">技巧</h3>
<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/">寻找重复数</a>：数组中存在唯一的出现了两次的数，其他数均为一次</p>
<p>index-&gt;value(index)-&gt;value(index)…，形成含环链表：0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2-&gt;4…</p>
<p>1，3，4，2，2；// value</p>
<p>0，1，2，3，4； // index</p>
<p><a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a>：数组中出现唯一仅出现一次的数，其他数均为两次</p>
<p>异或</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java, Design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker/K8s</title>
    <url>/2024/08/16/Docker-K8s/</url>
    <content><![CDATA[<p>容器相关学习记录</p>
<span id="more"></span>
<h1>Container-related Learning Records</h1>
<p>待完成</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>AI-Agent</title>
    <url>/2025/04/21/AI-Agent/</url>
    <content><![CDATA[<p>AI-Agent设计相关</p>
<p>施工中…</p>
<span id="more"></span>
<h1>AI-Agent</h1>
<img src="/2025/04/21/AI-Agent/Gu-NqzLb0AAG0lX" class="" title="Agent_workflow">
<p>AI-Agent侧区分</p>
<ul>
<li>LLM部分，包含对基座LLM的特化，如SFT和RLHF</li>
<li>Agent部分，包含执行链，如上下文管理，MCP（工具管理与使用）</li>
<li>数据部分，包含训练数据和检索数据，如RAG检索数据，SFT训练数据，FAISS库</li>
</ul>
<blockquote>
<p>LLM部分详见 LLM&amp;Rela</p>
</blockquote>
<br>
<h2 id="LangChain">LangChain</h2>
<p>LangChain 是一个用于构建由语言模型驱动的应用程序的框架。它的目标是让 LLM（大型语言模型）能够访问外部数据源、执行复杂任务链式逻辑，并具备决策能力。LangChain 支持多种模块组合，如提示模板、上下文管理、链式调用、文档问答、代理等。</p>
<blockquote>
<p>官方文档：<a href="https://docs.langchain.com/">https://docs.langchain.com/</a></p>
</blockquote>
<br>
<h3 id="Model">Model</h3>
<h4 id="Key-methods">Key methods</h4>
<ol>
<li>invoke：与聊天模型交互的主要方法。它接受一个消息列表作为输入，并返回一个消息列表作为输出。</li>
<li>stream：允许您以流的形式接收聊天模型生成的输出的方法。</li>
<li>batch：允许您将多个请求批量发送到聊天模型，以提高处理效率的方法。</li>
<li>bind_tools：一种允许您将工具绑定到聊天模型，以便在模型的执行上下文中使用的方法。</li>
<li>with_structured_output：针对原生支持结构化输出的模型的 <code>invoke</code> 方法的包装器。</li>
</ol>
<br>
<h4 id="Tool-calling">Tool calling</h4>
<img src="/2025/04/21/AI-Agent/tool_calling_components-bef9d2bcb9d3706c2fe58b57bf8ccb60.png" class="" title="Conceptual parts of tool calling">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tool creation</span></span><br><span class="line"><span class="keyword">from</span> langchain_core.tools <span class="keyword">import</span> tool</span><br><span class="line"></span><br><span class="line"><span class="meta">@tool</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Multiply a and b.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tool binding</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Multiply a and b.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        a: first int</span></span><br><span class="line"><span class="string">        b: second int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line">llm_with_tools = tool_calling_model.bind_tools([multiply])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tool calls</span></span><br><span class="line">query = <span class="string">&quot;What is 3 * 12? Also, what is 11 + 49?&quot;</span></span><br><span class="line"></span><br><span class="line">llm_with_tools.invoke(query).tool_calls</span><br></pre></td></tr></table></figure>
<br>
<h4 id="Structured-Output">Structured Output</h4>
<img src="/2025/04/21/AI-Agent/structured_output-2c42953cee807dedd6e96f3e1db17f69.png" class="" title="Structured output">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define schema</span></span><br><span class="line">schema = &#123;<span class="string">&quot;foo&quot;</span>: <span class="string">&quot;bar&quot;</span>&#125;</span><br><span class="line"><span class="comment"># Bind schema to model</span></span><br><span class="line">model_with_structure = model.with_structured_output(schema)</span><br><span class="line"><span class="comment"># Invoke the model to produce structured output that matches the schema</span></span><br><span class="line">structured_output = model_with_structure.invoke(user_input)</span><br></pre></td></tr></table></figure>
<br>
<h4 id="Multimodality">Multimodality</h4>
<p>多模态指的是处理不同形式数据的能力，例如文本、音频、图像和视频。多模态可以出现在各种组件中，使模型和系统能够无缝地处理这些数据类型的混合。</p>
<ul>
<li>聊天模型：理论上，这些模型可以接受和生成多模态输入和输出，处理各种数据类型，如文本、图像、音频和视频。</li>
<li>嵌入模型：嵌入模型可以表示多模态内容，将各种形式的数据（如文本、图像和音频）嵌入到向量空间中。</li>
<li>向量存储：向量存储可以搜索表示多模态数据的嵌入，实现不同类型信息的检索。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage</span><br><span class="line"></span><br><span class="line">message = HumanMessage(</span><br><span class="line">    content=[</span><br><span class="line">        &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Describe the weather in this image:&quot;</span>&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;image&quot;</span>,</span><br><span class="line">            <span class="string">&quot;source_type&quot;</span>: <span class="string">&quot;base64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;data&quot;</span>: <span class="string">&quot;&lt;base64 string&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mime_type&quot;</span>: <span class="string">&quot;image/jpeg&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line">response = model.invoke([message])</span><br><span class="line"></span><br><span class="line">message = HumanMessage(</span><br><span class="line">    content=[</span><br><span class="line">        &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Describe the weather in this image:&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;image_url&quot;</span>, <span class="string">&quot;image_url&quot;</span>: &#123;<span class="string">&quot;url&quot;</span>: image_url&#125;&#125;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line">response = model.invoke([message])</span><br></pre></td></tr></table></figure>
<br>
<h4 id="Memory">Memory</h4>
<img src="/2025/04/21/AI-Agent/short-vs-long.png" class="" title="img">
<h5 id="短期记忆">短期记忆</h5>
<p>会话历史管理</p>
<h6 id="编辑消息列表">编辑消息列表</h6>
<p>聊天模型通过消息接受上下文，这些消息包括开发者提供的指令（系统消息）和用户输入（人类消息）。在聊天应用中，消息在人类输入和模型响应之间交替，导致消息列表随着时间的推移而变长。由于上下文窗口有限且富标记的消息列表可能成本高昂，许多应用可以从使用手动删除或忘记过时信息的技术中受益。</p>
<img src="/2025/04/21/AI-Agent/filter.png" class="" title="img">
<p>最直接的方法是从列表中删除旧消息（类似于最近最少使用缓存）</p>
<br>
<h6 id="总结过往对话">总结过往对话</h6>
<p>问题在于修剪或删除消息，如上所示，我们可能会从消息队列的筛选中丢失信息。因此，一些应用程序从使用聊天模型对消息历史进行更复杂的总结方法中受益。</p>
<img src="/2025/04/21/AI-Agent/summary.png" class="" title="img">
<br>
<h5 id="长期记忆">长期记忆</h5>
<h6 id="记忆存储">记忆存储</h6>
<p>通过{（用户名，上下文）：记忆}保存</p>
<br>
<h6 id="长期记忆思考框架">长期记忆思考框架</h6>
<br>
<h5 id="记忆类型">记忆类型</h5>
<ul>
<li>
<p>Semantic Memory：</p>
<p>语义记忆通常用于通过记住过去交互中的事实或概念来个性化应用程序。个性化的记忆</p>
<p>例如个人资料和收藏</p>
</li>
<li>
<p>Episodic Memory：</p>
<p>情景记忆通常用于帮助代理记住如何完成任务。</p>
</li>
<li>
<p>Procedural Memory：</p>
<p>程序性记忆是模型权重、代理代码和代理提示的组合；</p>
<p>一般仅修改系统提示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个节点函数，该函数使用存储中的指令来调用模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call_model</span>(<span class="params">state: State, store: BaseStore</span>):</span><br><span class="line">    <span class="comment"># 定义命名空间，这里使用&quot;agent_instructions&quot;作为命名空间</span></span><br><span class="line">    namespace = (<span class="string">&quot;agent_instructions&quot;</span>, )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从存储中获取键为&quot;agent_a&quot;的指令数据</span></span><br><span class="line">    <span class="comment"># [0]表示获取搜索结果的第一项(假设search返回列表)</span></span><br><span class="line">    instructions = store.get(namespace, key=<span class="string">&quot;agent_a&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 应用逻辑：使用获取的指令构建提示词</span></span><br><span class="line">    <span class="comment"># prompt_template是一个格式化字符串模板，包含&#123;instructions&#125;占位符</span></span><br><span class="line">    prompt = prompt_template.<span class="built_in">format</span>(instructions=instructions.value[<span class="string">&quot;instructions&quot;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里应该有调用模型等后续操作...</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个节点函数，该函数更新存储中的指令</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_instructions</span>(<span class="params">state: State, store: BaseStore</span>):</span><br><span class="line">    <span class="comment"># 定义命名空间，这里使用&quot;instructions&quot;作为命名空间</span></span><br><span class="line">    namespace = (<span class="string">&quot;instructions&quot;</span>,)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 搜索当前命名空间下的所有指令，并获取第一个结果</span></span><br><span class="line">    current_instructions = store.search(namespace)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记忆逻辑：使用当前指令和对话状态构建提示词</span></span><br><span class="line">    prompt = prompt_template.<span class="built_in">format</span>(</span><br><span class="line">        instructions=instructions.value[<span class="string">&quot;instructions&quot;</span>], </span><br><span class="line">        conversation=state[<span class="string">&quot;messages&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用语言模型获取输出</span></span><br><span class="line">    output = llm.invoke(prompt)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从模型输出中提取新的指令</span></span><br><span class="line">    new_instructions = output[<span class="string">&#x27;new_instructions&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将新指令存储到&quot;agent_instructions&quot;命名空间下，键为&quot;agent_a&quot;</span></span><br><span class="line">    store.put(</span><br><span class="line">        (<span class="string">&quot;agent_instructions&quot;</span>,),  <span class="comment"># 命名空间</span></span><br><span class="line">        <span class="string">&quot;agent_a&quot;</span>,                <span class="comment"># 键名</span></span><br><span class="line">        &#123;<span class="string">&quot;instructions&quot;</span>: new_instructions&#125;  <span class="comment"># 值(新指令)</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里可能有其他后续操作...</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<h5 id="记忆写入">记忆写入</h5>
<ul>
<li>
<p>热写入</p>
</li>
<li>
<p>后台写入</p>
</li>
</ul>
<br>
<h4 id="Caching">Caching</h4>
<p>一种替代方法是使用语义缓存，即根据输入的意义而不是精确输入本身来缓存响应。在某些情况下这可能有效，但在其他情况下则不然。</p>
<p>语义缓存引入了对应用程序关键路径上另一个模型的依赖（例如，语义缓存可能依赖于嵌入模型将文本转换为向量表示），并且无法保证准确捕捉输入的意义。</p>
<p>然而，可能存在一些情况下缓存聊天模型响应是有益的。例如，如果您有一个用于回答常见问题的聊天模型，缓存响应可以帮助减轻模型提供者的负担、降低成本并提高响应速度。</p>
<br>
<h3 id="Prompt">Prompt</h3>
<h4 id="PromptTemplate">PromptTemplate</h4>
<p>LangChain 提供了 <code>PromptTemplate</code> 模块用于动态地构建提示词（Prompt）。它支持变量替换，让开发者能灵活构造提示语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">template = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;product&quot;</span>],</span><br><span class="line">    template=<span class="string">&quot;请为以下产品写一段广告文案：&#123;product&#125;&quot;</span></span><br><span class="line">)</span><br><span class="line">prompt = template.<span class="built_in">format</span>(product=<span class="string">&quot;智能手表&quot;</span>)</span><br></pre></td></tr></table></figure>
<br>
<h3 id="Semantic-search-engine">Semantic search engine</h3>
<p>LangChain 非常适合构建基于知识库的问答系统，其流程如下：</p>
<h4 id="Chunking">Chunking</h4>
<p>ref: <a href="https://x.com/i/status/1952300998942396582">https://x.com/i/status/1952300998942396582</a></p>
<img src="/2025/04/21/AI-Agent/image-20250810091717337.png" class="" title="image-20250810091717337">
<p>将长文档按段落或 token 限制拆分为小块（chunk），以避免输入超长。</p>
<p><code>RecursiveCharacterTextSplitter</code> 通过<strong>递归尝试不同的分隔符层级</strong>，逐步将文本分割为语义连贯的块。它优先尝试更高级别的分隔符（如段落），如果分割后的块仍过大，则递归使用更低级别的分隔符（如句子、单词）进行二次分割。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"></span><br><span class="line">splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="number">500</span>, chunk_overlap=<span class="number">50</span>)</span><br><span class="line">chunks = splitter.split_text(document_text)</span><br></pre></td></tr></table></figure>
<br>
<h5 id="Better-Chunking">Better Chunking</h5>
<p>ref: <a href="https://github.com/ConardLi/easy-dataset">https://github.com/ConardLi/easy-dataset</a></p>
<ol>
<li>首先需要设定文本块的最小，最大分割长度</li>
<li>自动对章节（Markdown文件中的 <code>#, ##, ###</code>）进行识别</li>
<li>对已识别到的章节字数进行计数，在恰好位于 &gt; 最小分割长度 和 &lt; 最大分割长度的前提下进行分段</li>
<li>遇到长段落（超出最大分割长度）时，执行递归分段算法 <code>RecursiveCharacterTextSplitter</code>；</li>
</ol>
<blockquote>
<p>其实就是加了一个对章节的识别分割</p>
</blockquote>
<br>
<h4 id="Embedding-Vector-Store">Embedding &amp; Vector Store</h4>
<p>使用 Embedding 模型（如 OpenAI、HuggingFace）将文本向量化，然后存入向量数据库（如 FAISS、Chroma、Pinecone）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> FAISS</span><br><span class="line"></span><br><span class="line">embeddings = OpenAIEmbeddings(model=<span class="string">&quot;text-embedding-3-large&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># FAISS存储</span></span><br><span class="line">embedding_dim = <span class="built_in">len</span>(embeddings.embed_query(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">index = faiss.IndexFlatL2(embedding_dim)</span><br><span class="line"></span><br><span class="line">vector_store = FAISS(</span><br><span class="line">    embedding_function=embeddings,</span><br><span class="line">    index=index,</span><br><span class="line">    docstore=InMemoryDocstore(),</span><br><span class="line">    index_to_docstore_id=&#123;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ids = vector_store.add_documents(documents=all_splits)</span><br></pre></td></tr></table></figure>
<br>
<h4 id="Retrieval">Retrieval</h4>
<p>使用向量检索获取相关 chunk，输入给 LLM，生成答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@chain</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">retriever</span>(<span class="params">query: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[Document]:</span><br><span class="line">    <span class="keyword">return</span> vector_store.similarity_search(query, k=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">retriever.batch(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&quot;How many distribution centers does Nike have in the US?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;When was Nike incorporated?&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<br>
<br>
<h3 id="Agent">Agent</h3>
<p>Agent 是 LangChain 中实现 LLM 推理和决策的核心模块，支持动态选择工具（Tool）来完成多步任务。</p>
<p>ref: <a href="https://x.com/DailyDoseOfDS_/status/1940342200216482211">https://x.com/DailyDoseOfDS_/status/1940342200216482211</a></p>
<img src="/2025/04/21/AI-Agent/image-20250810092757168.png" class="" title="image-20250810092757168">
<h4 id="Base">Base</h4>
<p>核心组件：</p>
<ul>
<li><strong>Agent</strong>：负责推理和调用工具</li>
<li><strong>Tool</strong>：工具函数，如 Web 搜索、数据库查询、Python 计算等</li>
<li><strong>LLM</strong>：驱动 Agent 的大脑</li>
<li><strong>AgentExecutor</strong>：执行器，负责管理 Agent 的执行逻辑</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import relevant functionality</span></span><br><span class="line"><span class="keyword">from</span> langchain_anthropic <span class="keyword">import</span> ChatAnthropic</span><br><span class="line"><span class="keyword">from</span> langchain_community.tools.tavily_search <span class="keyword">import</span> TavilySearchResults</span><br><span class="line"><span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage</span><br><span class="line"><span class="keyword">from</span> langgraph.checkpoint.memory <span class="keyword">import</span> MemorySaver</span><br><span class="line"><span class="keyword">from</span> langgraph.prebuilt <span class="keyword">import</span> create_react_agent</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the agent</span></span><br><span class="line">memory = MemorySaver()</span><br><span class="line">model = ChatAnthropic(model_name=<span class="string">&quot;claude-3-sonnet-20240229&quot;</span>)</span><br><span class="line">search = TavilySearchResults(max_results=<span class="number">2</span>)</span><br><span class="line">tools = [search]</span><br><span class="line">agent_executor = create_react_agent(model, tools, checkpointer=memory)</span><br></pre></td></tr></table></figure>
<br>
<h4 id="QA-Processing-Method">QA Processing Method</h4>
<p>Stuff Method（塞入式）</p>
<p>直接将所有相关文档的内容“塞”进 Prompt 里，适用于内容少、上下文短的场景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LLMChain + 文档组合直接生成 Prompt</span></span><br></pre></td></tr></table></figure>
<p>MapReduce</p>
<p>将所有 chunk 分别用 LLM 处理后，再用另一个 LLM 汇总（Reduce），类似 MapReduce 思维。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文档切片 -&gt; 各片段生成回答（Map）-&gt; 汇总为最终答案（Reduce）</span></span><br></pre></td></tr></table></figure>
<p>Refine</p>
<p>初始文档回答一个粗略答案，接着逐步引入更多 chunk 来细化和完善答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初步回答 + 后续 refine，适合逐步深入处理</span></span><br></pre></td></tr></table></figure>
<p>MapRerank</p>
<p>类似 Map 方法，但最后不汇总所有回答，而是由 LLM 对每个回答打分，选择最优答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多个回答 -&gt; 打分排序 -&gt; 返回最高分</span></span><br></pre></td></tr></table></figure>
<br>
<h4 id="Streaming-message-Streaming-tokens">Streaming message &amp; Streaming tokens</h4>
<p><strong>streaming tokens</strong></p>
<p>指逐个生成文本片段（Token），适用于需要实时展示生成过程的场景，如逐词显示回答。</p>
<p>测试代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">model = ChatOpenAI(model=<span class="string">&quot;gpt-4o-mini&quot;</span>, streaming=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 同步流式处理</span></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> model.stream(<span class="string">&quot;天空是什么颜色？&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(chunk.content, end=<span class="string">&quot;|&quot;</span>, flush=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>输出效果：<br>
<code>The| sky| appears| blue| during| the| day|.</code></p>
<br>
<p><strong>Streaming Messages</strong></p>
<p>我们已经看到如何使用 <code>.invoke</code> 来调用代理以获取最终响应。如果代理执行多个步骤，这可能需要一些时间。为了展示中间进度，我们可以按消息发生时实时返回消息。</p>
<p>测试代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> agent_executor.stream(</span><br><span class="line">    &#123;<span class="string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="string">&quot;whats the weather in sf?&quot;</span>)]&#125;,</span><br><span class="line">    stream_mode=<span class="string">&quot;values&quot;</span>,</span><br><span class="line">):</span><br><span class="line">    step[<span class="string">&quot;messages&quot;</span>][-<span class="number">1</span>].pretty_print()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">================================[1m Human Message [0m=================================</span><br><span class="line"></span><br><span class="line">whats the weather <span class="keyword">in</span> sf?</span><br><span class="line">==================================[1m Ai Message [0m==================================</span><br><span class="line"></span><br><span class="line">[&#123;<span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;Okay, let me look up the current weather for San Francisco using a search engine:&#x27;</span>, <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;text&#x27;</span>&#125;, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;toolu_01H1brh5EZpZqtqHBxkosPtN&#x27;</span>, <span class="string">&#x27;input&#x27;</span>: &#123;<span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;san francisco weather&#x27;</span>&#125;, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;tavily_search_results_json&#x27;</span>, <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;tool_use&#x27;</span>&#125;]</span><br><span class="line">Tool Calls:</span><br><span class="line">  tavily_search_results_json (toolu_01H1brh5EZpZqtqHBxkosPtN)</span><br><span class="line"> Call ID: toolu_01H1brh5EZpZqtqHBxkosPtN</span><br><span class="line">  Args:</span><br><span class="line">    query: san francisco weather</span><br><span class="line">=================================[1m Tool Message [0m=================================</span><br><span class="line">Name: tavily_search_results_json</span><br><span class="line"></span><br><span class="line">[&#123;<span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.weatherapi.com/&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;&#123;&#x27;location&#x27;: &#123;&#x27;name&#x27;: &#x27;San Francisco&#x27;, &#x27;region&#x27;: &#x27;California&#x27;, &#x27;country&#x27;: &#x27;United States of America&#x27;, &#x27;lat&#x27;: 37.775, &#x27;lon&#x27;: -122.4183, &#x27;tz_id&#x27;: &#x27;America/Los_Angeles&#x27;, &#x27;localtime_epoch&#x27;: 1739994486, &#x27;localtime&#x27;: &#x27;2025-02-19 11:48&#x27;&#125;, &#x27;current&#x27;: &#123;&#x27;last_updated_epoch&#x27;: 1739994300, &#x27;last_updated&#x27;: &#x27;2025-02-19 11:45&#x27;, &#x27;temp_c&#x27;: 13.3, &#x27;temp_f&#x27;: 55.9, &#x27;is_day&#x27;: 1, &#x27;condition&#x27;: &#123;&#x27;text&#x27;: &#x27;Light rain&#x27;, &#x27;icon&#x27;: &#x27;//cdn.weatherapi.com/weather/64x64/day/296.png&#x27;, &#x27;code&#x27;: 1183&#125;, &#x27;wind_mph&#x27;: 5.8, &#x27;wind_kph&#x27;: 9.4, &#x27;wind_degree&#x27;: 195, &#x27;wind_dir&#x27;: &#x27;SSW&#x27;, &#x27;pressure_mb&#x27;: 1023.0, &#x27;pressure_in&#x27;: 30.2, &#x27;precip_mm&#x27;: 0.0, &#x27;precip_in&#x27;: 0.0, &#x27;humidity&#x27;: 87, &#x27;cloud&#x27;: 100, &#x27;feelslike_c&#x27;: 12.7, &#x27;feelslike_f&#x27;: 54.8, &#x27;windchill_c&#x27;: 9.1, &#x27;windchill_f&#x27;: 48.4, &#x27;heatindex_c&#x27;: 10.2, &#x27;heatindex_f&#x27;: 50.3, &#x27;dewpoint_c&#x27;: 9.8, &#x27;dewpoint_f&#x27;: 49.7, &#x27;vis_km&#x27;: 4.0, &#x27;vis_miles&#x27;: 2.0, &#x27;uv&#x27;: 1.4, &#x27;gust_mph&#x27;: 8.9, &#x27;gust_kph&#x27;: 14.4&#125;&#125;&quot;</span>&#125;, &#123;<span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://world-weather.info/forecast/usa/san_francisco/february-2025/&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Weather in San Francisco in February 2025 (California) - Detailed Weather Forecast for a Month Weather World Weather in San Francisco Weather in San Francisco in February 2025 San Francisco Weather Forecast for February 2025, is based on previous years&#x27; statistical data. +59°+50° +59°+52° +59°+50° +61°+52° +59°+50° +61°+50° +61°+52° +63°+52° +61°+52° +61°+50° +61°+50° +61°+50° +59°+50° +59°+50° +61°+50° +61°+52° +59°+50° +59°+48° +57°+48° +59°+50° +59°+48° +59°+50° +57°+46° +61°+50° +61°+50° +59°+50° +59°+48° +59°+50° Extended weather forecast in San Francisco HourlyWeek10-Day14-Day30-DayYear Weather in large and nearby cities Weather in Washington, D.C.+41° Sacramento+55° Pleasanton+55° Redwood City+55° San Leandro+55° San Mateo+54° San Rafael+52° San Ramon+52° South San Francisco+54° Vallejo+50° Palo Alto+55° Pacifica+55° Berkeley+54° Castro Valley+55° Concord+52° Daly City+54° Noverd+52° Sign Hill+54° world&#x27;s temperature today day day Temperature units&quot;</span>&#125;]</span><br><span class="line">==================================[1m Ai Message [0m==================================</span><br><span class="line"></span><br><span class="line">The search results provide details on the current weather conditions and forecast <span class="keyword">for</span> San Francisco. Some key details:</span><br><span class="line"></span><br><span class="line">- It is lightly raining <span class="keyword">in</span> San Francisco right now, with a temperature around 55°F/13°C. </span><br><span class="line">- The forecast <span class="keyword">for</span> the rest of February 2025 shows daytime highs mostly <span class="keyword">in</span> the upper 50s to low 60s F, with night lows <span class="keyword">in</span> the upper 40s to low 50s F. </span><br><span class="line">- Typical weather includes some rain, clouds, cool temperatures and breezy conditions.</span><br><span class="line"></span><br><span class="line">So <span class="keyword">in</span> summary, as is common <span class="keyword">for</span> San Francisco <span class="keyword">in</span> late winter, it is currently cool with light rain showers, and similar mild, unsettled weather is expected over the next couple weeks. Layers and a light jacket would be advisable <span class="keyword">for</span> being outdoors. Let me know <span class="keyword">if</span> you need any other details!</span><br></pre></td></tr></table></figure>
<br>
<h4 id="Memory-Adding">Memory Adding</h4>
<p>通过config实现对线程上下文的记忆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">agent_executor = create_react_agent(model, tools, checkpointer=memory)</span><br><span class="line"></span><br><span class="line">config = &#123;<span class="string">&quot;configurable&quot;</span>: &#123;<span class="string">&quot;thread_id&quot;</span>: <span class="string">&quot;abc123&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> agent_executor.stream(</span><br><span class="line">    &#123;<span class="string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="string">&quot;hi im bob!&quot;</span>)]&#125;, config</span><br><span class="line">):</span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;agent&#x27;</span>: &#123;<span class="string">&#x27;messages&#x27;</span>: [AIMessage(content=<span class="string">&quot;Hello Bob! It&#x27;s nice to meet you again.&quot;</span>, response_metadata=&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;msg_013C1z2ZySagEFwmU1EsysR2&#x27;</span>, <span class="string">&#x27;model&#x27;</span>: <span class="string">&#x27;claude-3-sonnet-20240229&#x27;</span>, <span class="string">&#x27;stop_reason&#x27;</span>: <span class="string">&#x27;end_turn&#x27;</span>, <span class="string">&#x27;stop_sequence&#x27;</span>: None, <span class="string">&#x27;usage&#x27;</span>: &#123;<span class="string">&#x27;input_tokens&#x27;</span>: 1162, <span class="string">&#x27;output_tokens&#x27;</span>: 14&#125;&#125;, <span class="built_in">id</span>=<span class="string">&#x27;run-f878acfd-d195-44e8-9166-e2796317e3f8-0&#x27;</span>, usage_metadata=&#123;<span class="string">&#x27;input_tokens&#x27;</span>: 1162, <span class="string">&#x27;output_tokens&#x27;</span>: 14, <span class="string">&#x27;total_tokens&#x27;</span>: 1176&#125;)]&#125;&#125;</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<p>尝试上下文记忆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> agent_executor.stream(</span><br><span class="line">    &#123;<span class="string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="string">&quot;whats my name?&quot;</span>)]&#125;, config</span><br><span class="line">):</span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;agent&#x27;</span>: &#123;<span class="string">&#x27;messages&#x27;</span>: [AIMessage(content=<span class="string">&#x27;You mentioned your name is Bob when you introduced yourself earlier. So your name is Bob.&#x27;</span>, response_metadata=&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;msg_01WNwnRNGwGDRw6vRdivt6i1&#x27;</span>, <span class="string">&#x27;model&#x27;</span>: <span class="string">&#x27;claude-3-sonnet-20240229&#x27;</span>, <span class="string">&#x27;stop_reason&#x27;</span>: <span class="string">&#x27;end_turn&#x27;</span>, <span class="string">&#x27;stop_sequence&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;usage&#x27;</span>: &#123;<span class="string">&#x27;input_tokens&#x27;</span>: <span class="number">1184</span>, <span class="string">&#x27;output_tokens&#x27;</span>: <span class="number">21</span>&#125;&#125;, <span class="built_in">id</span>=<span class="string">&#x27;run-f5c0b957-8878-405a-9d4b-a7cd38efe81f-0&#x27;</span>, usage_metadata=&#123;<span class="string">&#x27;input_tokens&#x27;</span>: <span class="number">1184</span>, <span class="string">&#x27;output_tokens&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;total_tokens&#x27;</span>: <span class="number">1205</span>&#125;)]&#125;&#125;</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<br>
<h3 id="Example">Example</h3>
<h4 id="Extraction-Chain">Extraction Chain</h4>
<h5 id="Schema-Extrator">Schema &amp; Extrator</h5>
<p>Schema 描述如何从文本中提取信息，通过结构化指定 + prompt invoke实现信息提取</p>
<blockquote>
<p>关于 pydantic 库的使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="comment"># 必填字段，字符串类型</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 可选字段，带有默认值</span></span><br><span class="line">    age: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用 Field 添加额外验证和元数据</span></span><br><span class="line">    email: <span class="built_in">str</span> = Field(</span><br><span class="line">        ...,  <span class="comment"># 表示必填字段</span></span><br><span class="line">        min_length=<span class="number">5</span>,</span><br><span class="line">        max_length=<span class="number">100</span>,</span><br><span class="line">        regex=<span class="string">r&quot;^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;用户的电子邮件地址&quot;</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 带有默认值和额外验证的字段</span></span><br><span class="line">    score: <span class="built_in">float</span> = Field(</span><br><span class="line">        default=<span class="number">0.0</span>,</span><br><span class="line">        ge=<span class="number">0</span>,</span><br><span class="line">        le=<span class="number">100</span>,</span><br><span class="line">        description=<span class="string">&quot;用户评分，范围0-100&quot;</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 别名示例</span></span><br><span class="line">    full_name: <span class="built_in">str</span> = Field(..., alias=<span class="string">&quot;fullName&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型</span></span><br><span class="line">user_data = &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;john_doe&quot;</span>,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;john@example.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fullName&quot;</span>: <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user = User(**user_data)</span><br><span class="line"><span class="built_in">print</span>(user)</span><br><span class="line"><span class="comment"># 输出: username=&#x27;john_doe&#x27; age=None email=&#x27;john@example.com&#x27; score=0.0 full_name=&#x27;John Doe&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(user.<span class="built_in">dict</span>(by_alias=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;username&#x27;: &#x27;john_doe&#x27;, &#x27;age&#x27;: None, &#x27;email&#x27;: &#x27;john@example.com&#x27;, &#x27;score&#x27;: 0.0, &#x27;fullName&#x27;: &#x27;John Doe&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>default</code>: 字段的默认值</li>
<li><code>default_factory</code>: 生成默认值的可调用对象</li>
<li><code>alias</code>: 字段的别名（用于序列化/反序列化）</li>
<li><code>title</code>: 字段的标题（用于文档）</li>
<li><code>description</code>: 字段的描述（用于文档）</li>
<li><code>gt</code>: 大于 (greater than)</li>
<li><code>ge</code>: 大于等于 (greater than or equal)</li>
<li><code>lt</code>: 小于 (less than)</li>
<li><code>le</code>: 小于等于 (less than or equal)</li>
<li><code>min_length</code>: 最小长度（字符串、列表等）</li>
<li><code>max_length</code>: 最大长度（字符串、列表等）</li>
<li><code>regex</code>: 正则表达式验证</li>
</ul>
</blockquote>
<br>
<p>案例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Information about a person.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ^ Doc-string for the entity Person.</span></span><br><span class="line">    <span class="comment"># This doc-string is sent to the LLM as the description of the schema Person,</span></span><br><span class="line">    <span class="comment"># and it can help to improve extraction results.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note that:</span></span><br><span class="line">    <span class="comment"># 1. Each field is an `optional` -- this allows the model to decline to extract it!</span></span><br><span class="line">    <span class="comment"># 2. Each field has a `description` -- this description is used by the LLM.</span></span><br><span class="line">    <span class="comment"># Having a good description can help improve extraction results.</span></span><br><span class="line">    name: <span class="type">Optional</span>[<span class="built_in">str</span>] = Field(default=<span class="literal">None</span>, description=<span class="string">&quot;The name of the person&quot;</span>)</span><br><span class="line">    hair_color: <span class="type">Optional</span>[<span class="built_in">str</span>] = Field(</span><br><span class="line">        default=<span class="literal">None</span>, description=<span class="string">&quot;The color of the person&#x27;s hair if known&quot;</span></span><br><span class="line">    )</span><br><span class="line">    height_in_meters: <span class="type">Optional</span>[<span class="built_in">str</span>] = Field(</span><br><span class="line">        default=<span class="literal">None</span>, description=<span class="string">&quot;Height measured in meters&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Extracted data about people.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Creates a model so that we can extract multiple entities.</span></span><br><span class="line">    people: <span class="type">List</span>[Person]        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 为LLM设置schema</span></span><br><span class="line"><span class="comment"># structured_llm = llm.with_structured_output(schema=Person)</span></span><br><span class="line"></span><br><span class="line">structured_llm = llm.with_structured_output(schema=Data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a custom prompt to provide instructions and any additional context.</span></span><br><span class="line"><span class="comment"># 1) You can add examples into the prompt template to improve extraction quality</span></span><br><span class="line"><span class="comment"># 2) Introduce additional parameters to take context into account (e.g., include metadata</span></span><br><span class="line"><span class="comment">#    about the document from which the text was extracted.)</span></span><br><span class="line">prompt_template = ChatPromptTemplate.from_messages(</span><br><span class="line">    [</span><br><span class="line">        (</span><br><span class="line">            <span class="string">&quot;system&quot;</span>,</span><br><span class="line">            <span class="string">&quot;You are an expert extraction algorithm. &quot;</span></span><br><span class="line">            <span class="string">&quot;Only extract relevant information from the text. &quot;</span></span><br><span class="line">            <span class="string">&quot;If you do not know the value of an attribute asked to extract, &quot;</span></span><br><span class="line">            <span class="string">&quot;return null for the attribute&#x27;s value.&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment"># Please see the how-to about improving performance with</span></span><br><span class="line">        <span class="comment"># reference examples.</span></span><br><span class="line">        <span class="comment"># MessagesPlaceholder(&#x27;examples&#x27;),</span></span><br><span class="line">        (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;&#123;text&#125;&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;My name is Jeff, my hair is black and i am 6 feet tall. Anna has the same color hair as me.&quot;</span></span><br><span class="line">prompt = prompt_template.invoke(&#123;<span class="string">&quot;text&quot;</span>: text&#125;)</span><br><span class="line">structured_llm.invoke(prompt)</span><br></pre></td></tr></table></figure>
<br>
<p>output</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Data(people=[Person(name=<span class="string">&#x27;Jeff&#x27;</span>, hair_color=<span class="string">&#x27;black&#x27;</span>, height_in_meters=<span class="string">&#x27;1.83&#x27;</span>), Person(name=<span class="string">&#x27;Anna&#x27;</span>, hair_color=<span class="string">&#x27;black&#x27;</span>, height_in_meters=None)])</span><br></pre></td></tr></table></figure>
<br>
<h5 id="RAG-based-long-context-extraction">RAG based long context extraction</h5>
<p>使用 FAISS</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KeyDevelopment</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Information about a development in the history of cars.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    year: <span class="built_in">int</span> = Field(</span><br><span class="line">        ...,  <span class="comment"># `...` 表示必填字段</span></span><br><span class="line">        description=<span class="string">&quot;The year when there was an important historic development.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    description: <span class="built_in">str</span> = Field(</span><br><span class="line">        ..., </span><br><span class="line">        description=<span class="string">&quot;What happened in this year? What was the development?&quot;</span></span><br><span class="line">    )</span><br><span class="line">    evidence: <span class="built_in">str</span> = Field(</span><br><span class="line">        ...,</span><br><span class="line">        description=<span class="string">&quot;Repeat verbatim the sentence(s) from which the year and description were extracted.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtractionData</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Extracted information about key developments in the history of cars.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    key_developments: <span class="type">List</span>[KeyDevelopment]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a custom prompt to provide instructions and any additional context.</span></span><br><span class="line"><span class="comment"># 1) You can add examples into the prompt template to improve extraction quality</span></span><br><span class="line"><span class="comment"># 2) Introduce additional parameters to take context into account (e.g., include metadata</span></span><br><span class="line"><span class="comment">#    about the document from which the text was extracted.)</span></span><br><span class="line">prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">    [</span><br><span class="line">        (</span><br><span class="line">            <span class="string">&quot;system&quot;</span>,</span><br><span class="line">            <span class="string">&quot;You are an expert at identifying key historic development in text. &quot;</span></span><br><span class="line">            <span class="string">&quot;Only extract important historic developments. Extract nothing if no important information can be found in the text.&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">        (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;&#123;text&#125;&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入必要的库和模块</span></span><br><span class="line"><span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> FAISS  <span class="comment"># FAISS向量数据库，用于高效相似性搜索</span></span><br><span class="line"><span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document      <span class="comment"># 文档处理基础类</span></span><br><span class="line"><span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> RunnableLambda <span class="comment"># 可运行Lambda函数</span></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings     <span class="comment"># OpenAI的文本嵌入模型</span></span><br><span class="line"><span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> CharacterTextSplitter  <span class="comment"># 文本分割器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用文本分割器将文档内容分割成多个文本块</span></span><br><span class="line"><span class="comment"># document.page_content是原始文档内容</span></span><br><span class="line">texts = text_splitter.split_text(document.page_content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用FAISS创建向量存储库</span></span><br><span class="line"><span class="comment"># 将分割后的文本块(texts)转换为向量表示，使用OpenAI的嵌入模型</span></span><br><span class="line">vectorstore = FAISS.from_texts(texts, embedding=OpenAIEmbeddings())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建检索器(retriever)，用于从向量库中检索相关文档</span></span><br><span class="line"><span class="comment"># search_kwargs=&#123;&quot;k&quot;: 1&#125; 表示只返回最相关的1个文档</span></span><br><span class="line">retriever = vectorstore.as_retriever(</span><br><span class="line">    search_kwargs=&#123;<span class="string">&quot;k&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">extractor = prompt | llm.with_structured_output(</span><br><span class="line">    schema=ExtractionData,</span><br><span class="line">    include_raw=<span class="literal">False</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建RAG(检索增强生成)提取器</span></span><br><span class="line"><span class="comment"># 1. 首先使用retriever检索文档</span></span><br><span class="line"><span class="comment"># 2. 然后通过Lambda函数提取第一个文档的内容(docs[0].page_content)</span></span><br><span class="line"><span class="comment"># 3. 最后将提取的文本传递给extractor进行处理</span></span><br><span class="line">rag_extractor = &#123;</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: retriever | (<span class="keyword">lambda</span> docs: docs[<span class="number">0</span>].page_content)</span><br><span class="line">&#125; | extractor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用RAG提取器，查询&quot;与汽车相关的关键发展&quot;</span></span><br><span class="line"><span class="comment"># 系统会先检索相关文档，然后提取信息</span></span><br><span class="line">results = rag_extractor.invoke(<span class="string">&quot;Key developments associated with cars&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历并打印提取出的每个关键发展</span></span><br><span class="line"><span class="keyword">for</span> key_development <span class="keyword">in</span> results.key_developments:</span><br><span class="line">    <span class="built_in">print</span>(key_development)</span><br></pre></td></tr></table></figure>
<br>
<h4 id="Classify">Classify</h4>
<p>案例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classification</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    sentiment: <span class="built_in">str</span> = Field(..., enum=[<span class="string">&quot;happy&quot;</span>, <span class="string">&quot;neutral&quot;</span>, <span class="string">&quot;sad&quot;</span>])</span><br><span class="line">    aggressiveness: <span class="built_in">int</span> = Field(</span><br><span class="line">        ...,</span><br><span class="line">        description=<span class="string">&quot;describes how aggressive the statement is, the higher the number the more aggressive&quot;</span>,</span><br><span class="line">        enum=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    )</span><br><span class="line">    language: <span class="built_in">str</span> = Field(</span><br><span class="line">        ..., enum=[<span class="string">&quot;spanish&quot;</span>, <span class="string">&quot;english&quot;</span>, <span class="string">&quot;french&quot;</span>, <span class="string">&quot;german&quot;</span>, <span class="string">&quot;italian&quot;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tagging_prompt = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Extract the desired information from the following passage.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Only extract the properties mentioned in the &#x27;Classification&#x27; function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Passage:</span></span><br><span class="line"><span class="string">&#123;input&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># LLM</span></span><br><span class="line">llm = ChatOpenAI(temperature=<span class="number">0</span>, model=<span class="string">&quot;gpt-4o-mini&quot;</span>).with_structured_output(</span><br><span class="line">    Classification</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">inp = <span class="string">&quot;Estoy increiblemente contento de haberte conocido! Creo que seremos muy buenos amigos!&quot;</span></span><br><span class="line">prompt = tagging_prompt.invoke(&#123;<span class="string">&quot;input&quot;</span>: inp&#125;)</span><br><span class="line">response = llm.invoke(prompt)</span><br><span class="line"></span><br><span class="line">response</span><br><span class="line"><span class="comment"># output: </span></span><br><span class="line"><span class="comment"># Classification(sentiment=&#x27;positive&#x27;, aggressiveness=1, language=&#x27;Spanish&#x27;)</span></span><br><span class="line">response.model_dump()  <span class="comment"># dictionary output</span></span><br><span class="line"><span class="comment"># output: </span></span><br><span class="line"><span class="comment"># sentiment=&#x27;positive&#x27;, aggressiveness=1, language=&#x27;Spanish&#x27;</span></span><br></pre></td></tr></table></figure>
<br>
<h2 id="LangGraph">LangGraph</h2>
<h3 id="Graph">Graph</h3>
<p>Graph 由 nodes 和 edge 构成</p>
<p>state 为每个图的 context，在定义图时传入；</p>
<p>每个 <code>node</code> 都可以接收当前的 <code>State</code> 作为输入，并输出状态更新。</p>
<p>The <code>State</code> includes the graph’s schema and <a href="https://langchain-ai.github.io/langgraph/concepts/low_level/#reducers">reducer functions</a> that handle state updates.</p>
<br>
<p><strong>常用方法</strong></p>
<p><code>add_node</code></p>
<ul>
<li>
<p>通过 <code>.add_node(str, node)</code> 添加节点到图，第一个参数为唯一节点名，第二个参数为节点被使用时所调用的函数或对象；</p>
<blockquote>
<p>每个node相当于一个可执行函数，可以在函数内做任何事情</p>
</blockquote>
</li>
</ul>
<br>
<p><code>add_edge</code></p>
<ul>
<li>通过 <code>.add_edge(START, str)</code> 和 <code>.add_edge(node, str)</code> 添加 <code>entry</code> point 和 <code>finish</code> point，指名图的起点和终点，str 为节点名</li>
</ul>
<br>
<p><code>add_conditional_edges</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_conditional_edges(</span><br><span class="line">    source: <span class="built_in">str</span>,</span><br><span class="line">    path: <span class="type">Union</span>[</span><br><span class="line">        <span class="type">Callable</span>[..., <span class="type">Union</span>[Hashable, <span class="built_in">list</span>[Hashable]]],</span><br><span class="line">        <span class="type">Callable</span>[</span><br><span class="line">            ..., Awaitable[<span class="type">Union</span>[Hashable, <span class="built_in">list</span>[Hashable]]]</span><br><span class="line">        ],</span><br><span class="line">        Runnable[<span class="type">Any</span>, <span class="type">Union</span>[Hashable, <span class="built_in">list</span>[Hashable]]],</span><br><span class="line">    ],</span><br><span class="line">    path_map: <span class="type">Optional</span>[</span><br><span class="line">        <span class="type">Union</span>[<span class="built_in">dict</span>[Hashable, <span class="built_in">str</span>], <span class="built_in">list</span>[<span class="built_in">str</span>]]</span><br><span class="line">    ] = <span class="literal">None</span>,</span><br><span class="line">    then: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span><br><span class="line">) -&gt; Self</span><br></pre></td></tr></table></figure>
<p>从起始节点添加条件边到任意数量的目标节点。</p>
<p><strong>Parameters: 参数：</strong></p>
<ul>
<li><code>source</code> （ <code>str</code> ）- 起始节点。当退出此节点时，将运行此条件边。</li>
<li><code>path</code> （ <code>Union[Callable, Runnable]</code> ）- 确定下一个节点或节点的可调用对象。如果不指定 <code>path_map</code> ，它应该返回一个或多个节点。如果返回 END，则图形将停止执行。</li>
<li><code>path_map</code> （ <code>Optional[dict[Hashable, str]]</code> ，默认： <code>None</code> ）- 可选的路径到节点名称的映射。如果省略，则 <code>path</code> 返回的路径应该是节点名称。</li>
<li><code>then</code> （ <code>Optional[str]</code> ，默认： <code>None</code> ）- 在 <code>path</code> 选择的节点之后执行节点的名称。</li>
</ul>
<p><strong>Returns: 返回值：</strong></p>
<ul>
<li><code>Self</code> （ <code>Self</code> ）- 图的实例，允许方法链式调用。</li>
</ul>
<br>
<p><code>interrupt</code></p>
<p>LangGraph 中的 <code>interrupt</code> 函数通过在特定节点暂停图、向人类展示信息，并使用他们的输入继续图来启用人类在循环中的工作流程。此功能适用于审批、编辑或收集额外输入等任务。 <code>interrupt</code> 函数与 <code>Command</code> 对象一起使用，以人类提供的值继续图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">human_approval</span>(<span class="params">state: State</span>) -&gt; Command[<span class="type">Literal</span>[<span class="string">&quot;some_node&quot;</span>, <span class="string">&quot;another_node&quot;</span>]]:</span><br><span class="line">    is_approved = interrupt(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;question&quot;</span>: <span class="string">&quot;Is this correct?&quot;</span>,</span><br><span class="line">            <span class="comment"># Surface the output that should be</span></span><br><span class="line">            <span class="comment"># reviewed and approved by the human.</span></span><br><span class="line">            <span class="string">&quot;llm_output&quot;</span>: state[<span class="string">&quot;llm_output&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_approved:</span><br><span class="line">        <span class="keyword">return</span> Command(goto=<span class="string">&quot;some_node&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Command(goto=<span class="string">&quot;another_node&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the node to the graph in an appropriate location</span></span><br><span class="line"><span class="comment"># and connect it to the relevant nodes.</span></span><br><span class="line">graph_builder.add_node(<span class="string">&quot;human_approval&quot;</span>, human_approval)</span><br><span class="line">graph = graph_builder.<span class="built_in">compile</span>(checkpointer=checkpointer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># After running the graph and hitting the interrupt, the graph will pause.</span></span><br><span class="line"><span class="comment"># Resume it with either an approval or rejection.</span></span><br><span class="line">thread_config = &#123;<span class="string">&quot;configurable&quot;</span>: &#123;<span class="string">&quot;thread_id&quot;</span>: <span class="string">&quot;some_id&quot;</span>&#125;&#125;</span><br><span class="line">graph.invoke(Command(resume=<span class="literal">True</span>), config=thread_config)</span><br></pre></td></tr></table></figure>
<br>
<p><strong>案例代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    messages: Annotated[<span class="built_in">list</span>, add_messages]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工具：通过interrupt与人类交互</span></span><br><span class="line"><span class="meta">@tool</span></span><br><span class="line"><span class="comment"># Note that because we are generating a ToolMessage for a state update, we</span></span><br><span class="line"><span class="comment"># generally require the ID of the corresponding tool call. We can use</span></span><br><span class="line"><span class="comment"># LangChain&#x27;s InjectedToolCallId to signal that this argument should not</span></span><br><span class="line"><span class="comment"># be revealed to the model in the tool&#x27;s schema.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">human_assistance</span>(<span class="params"></span></span><br><span class="line"><span class="params">    name: <span class="built_in">str</span>, birthday: <span class="built_in">str</span>, tool_call_id: Annotated[<span class="built_in">str</span>, InjectedToolCallId]</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Request assistance from a human.&quot;&quot;&quot;</span></span><br><span class="line">    human_response = interrupt(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;question&quot;</span>: <span class="string">&quot;Is this correct?&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: name,</span><br><span class="line">            <span class="string">&quot;birthday&quot;</span>: birthday,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># If the information is correct, update the state as-is.</span></span><br><span class="line">    <span class="keyword">if</span> human_response.get(<span class="string">&quot;correct&quot;</span>, <span class="string">&quot;&quot;</span>).lower().startswith(<span class="string">&quot;y&quot;</span>):</span><br><span class="line">        verified_name = name</span><br><span class="line">        verified_birthday = birthday</span><br><span class="line">        response = <span class="string">&quot;Correct&quot;</span></span><br><span class="line">    <span class="comment"># Otherwise, receive information from the human reviewer.</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        verified_name = human_response.get(<span class="string">&quot;name&quot;</span>, name)</span><br><span class="line">        verified_birthday = human_response.get(<span class="string">&quot;birthday&quot;</span>, birthday)</span><br><span class="line">        response = <span class="string">f&quot;Made a correction: <span class="subst">&#123;human_response&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This time we explicitly update the state with a ToolMessage inside</span></span><br><span class="line">    <span class="comment"># the tool.</span></span><br><span class="line">    state_update = &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: verified_name,</span><br><span class="line">        <span class="string">&quot;birthday&quot;</span>: verified_birthday,</span><br><span class="line">        <span class="string">&quot;messages&quot;</span>: [ToolMessage(response, tool_call_id=tool_call_id)],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># We return a Command object in the tool to update our state.</span></span><br><span class="line">    <span class="keyword">return</span> Command(update=state_update)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Modification: tell the LLM which tools it can call</span></span><br><span class="line">tool = TavilySearchResults(max_results=<span class="number">2</span>)</span><br><span class="line">tools = [tool, human_assistance]</span><br><span class="line"></span><br><span class="line">llm = ChatAnthropic(model=<span class="string">&quot;claude-3-5-sonnet-20240620&quot;</span>)</span><br><span class="line">llm_with_tools = llm.bind_tools(tools)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chatbot</span>(<span class="params">state: State</span>):</span><br><span class="line">    message = llm_with_tools.invoke(state[<span class="string">&quot;messages&quot;</span>])</span><br><span class="line">    <span class="comment"># Because we will be interrupting during tool execution,</span></span><br><span class="line">    <span class="comment"># we disable parallel tool calling to avoid repeating any</span></span><br><span class="line">    <span class="comment"># tool invocations when we resume.</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(message.tool_calls) &lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;messages&quot;</span>: [llm_with_tools.invoke(state[<span class="string">&quot;messages&quot;</span>])]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">graph_builder = StateGraph(State)</span><br><span class="line">graph_builder.add_node(<span class="string">&quot;chatbot&quot;</span>, chatbot)</span><br><span class="line"></span><br><span class="line">tool_node = ToolNode(tools=[tool])</span><br><span class="line">graph_builder.add_node(<span class="string">&quot;tools&quot;</span>, tool_node)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">route_tools</span>(<span class="params"></span></span><br><span class="line"><span class="params">    state: State,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Use in the conditional_edge to route to the ToolNode if the last message</span></span><br><span class="line"><span class="string">    has tool calls. Otherwise, route to the end.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(state, <span class="built_in">list</span>):</span><br><span class="line">        ai_message = state[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> messages := state.get(<span class="string">&quot;messages&quot;</span>, []):</span><br><span class="line">        ai_message = messages[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;No messages found in input state to tool_edge: <span class="subst">&#123;state&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(ai_message, <span class="string">&quot;tool_calls&quot;</span>) <span class="keyword">and</span> <span class="built_in">len</span>(ai_message.tool_calls) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;tools&quot;</span>  <span class="comment"># path 函数返回的为节点名称</span></span><br><span class="line">    <span class="keyword">return</span> END  <span class="comment"># path 函数返回的为节点名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The `tools_condition` function returns &quot;tools&quot; if the chatbot asks to use a tool, and &quot;END&quot; if</span></span><br><span class="line"><span class="comment"># it is fine directly responding. This conditional routing defines the main agent loop.</span></span><br><span class="line">graph_builder.add_conditional_edges(</span><br><span class="line">    <span class="string">&quot;chatbot&quot;</span>,</span><br><span class="line">    route_tools,</span><br><span class="line">    <span class="comment"># The following dictionary lets you tell the graph to interpret the condition&#x27;s outputs as a specific node</span></span><br><span class="line">    <span class="comment"># It defaults to the identity function, but if you</span></span><br><span class="line">    <span class="comment"># want to use a node named something else apart from &quot;tools&quot;,</span></span><br><span class="line">    <span class="comment"># You can update the value of the dictionary to something else</span></span><br><span class="line">    <span class="comment"># e.g., &quot;tools&quot;: &quot;my_tools&quot;</span></span><br><span class="line">    <span class="comment"># 可选的路径到节点名称的映射。如果省略，则 `path` 返回的路径应该是节点名称。</span></span><br><span class="line">    &#123;<span class="string">&quot;tools&quot;</span>: <span class="string">&quot;tools&quot;</span>, END: END&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># Any time a tool is called, we return to the chatbot to decide the next step</span></span><br><span class="line">graph_builder.add_edge(<span class="string">&quot;tools&quot;</span>, <span class="string">&quot;chatbot&quot;</span>)</span><br><span class="line">graph_builder.add_edge(START, <span class="string">&quot;chatbot&quot;</span>)</span><br><span class="line"><span class="comment"># graph = graph_builder.compile()</span></span><br><span class="line">memory = MemorySaver()  <span class="comment"># 添加检查点</span></span><br><span class="line">graph = graph_builder.<span class="built_in">compile</span>(checkpointer=memory)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">config = &#123;<span class="string">&quot;configurable&quot;</span>: &#123;<span class="string">&quot;thread_id&quot;</span>: <span class="string">&quot;1&quot;</span>&#125;&#125;</span><br><span class="line">events = graph.stream(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;messages&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">                <span class="string">&quot;content&quot;</span>: (</span><br><span class="line">                    <span class="string">&quot;I&#x27;m learning LangGraph. &quot;</span></span><br><span class="line">                    <span class="string">&quot;Could you do some research on it for me?&quot;</span></span><br><span class="line">                ),</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    config,</span><br><span class="line">    stream_mode=<span class="string">&quot;values&quot;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;messages&quot;</span> <span class="keyword">in</span> event:</span><br><span class="line">        event[<span class="string">&quot;messages&quot;</span>][-<span class="number">1</span>].pretty_print()</span><br></pre></td></tr></table></figure>
<br>
<br>
<h2 id="Agentic-Design-Patterns">Agentic Design Patterns</h2>
<h3 id="Design-Pattern">Design Pattern</h3>
<img src="/2025/04/21/AI-Agent/5.png" class="" title="alt text">
<ul>
<li>Short-term memory: 上下文Context</li>
<li>Long-term memory: 外挂数据库，例如RAG技术</li>
<li>Tool: MCP(function call…)</li>
<li>Planning: Reflection，Self-critics…</li>
</ul>
<br>
<h3 id="Reflection">Reflection</h3>
<ul>
<li>“[Self-Refine: Iterative Refinement with Self-Feedback](<a href="https://arxiv.org/abs/2303.17651?utm_campaign=The">https://arxiv.org/abs/2303.17651?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-9dHVnW1I1bA3sPBbsikjT165Qez3QiiAssknCERwgki818YHG7PyHOQSgg-nxKDa0BuE7B),” Madaan et al. (2023)</li>
<li>“[Reflexion: Language Agents with Verbal Reinforcement Learning](<a href="https://arxiv.org/abs/2303.11366?utm_campaign=The">https://arxiv.org/abs/2303.11366?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-9dHVnW1I1bA3sPBbsikjT165Qez3QiiAssknCERwgki818YHG7PyHOQSgg-nxKDa0BuE7B),” Shinn et al. (2023)</li>
<li>“[CRITIC: Large Language Models Can Self-Correct with Tool-Interactive Critiquing](<a href="https://arxiv.org/abs/2305.11738?utm_campaign=The">https://arxiv.org/abs/2305.11738?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-9dHVnW1I1bA3sPBbsikjT165Qez3QiiAssknCERwgki818YHG7PyHOQSgg-nxKDa0BuE7B),” Gou et al. (2024)</li>
</ul>
<br>
<h3 id="Tool-Use">Tool Use</h3>
<ul>
<li>“[Gorilla: Large Language Model Connected with Massive APIs](<a href="https://arxiv.org/abs/2305.15334?utm_campaign=The">https://arxiv.org/abs/2305.15334?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz–9ARMthd09q0ABUi-abo6BH62BLbcwPo13LrXs9hUezs-L050Ay7b_rHdWuRIqBVOD6k_S),” Patil et al. (2023)</li>
<li>“[MM-REACT: Prompting ChatGPT for Multimodal Reasoning and Action](<a href="https://arxiv.org/abs/2303.11381?utm_campaign=The">https://arxiv.org/abs/2303.11381?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz–9ARMthd09q0ABUi-abo6BH62BLbcwPo13LrXs9hUezs-L050Ay7b_rHdWuRIqBVOD6k_S),” Yang et al. (2023)</li>
<li>“[Efficient Tool Use with Chain-of-Abstraction Reasoning](<a href="https://arxiv.org/abs/2401.17464?utm_campaign=The">https://arxiv.org/abs/2401.17464?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz–9ARMthd09q0ABUi-abo6BH62BLbcwPo13LrXs9hUezs-L050Ay7b_rHdWuRIqBVOD6k_S),” Gao et al. (2024)</li>
</ul>
<br>
<h3 id="Planning">Planning</h3>
<ul>
<li>“[Chain-of-Thought Prompting Elicits Reasoning in Large Language Models](<a href="https://arxiv.org/abs/2201.11903?utm_campaign=The">https://arxiv.org/abs/2201.11903?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8Kh954rkXmE4vgpKvro3Klpjhn7IuT-Y_eXIYtgVIq9PTzwa5zFWX7FZZqv1tuDEEsTDuY),” Wei et al. (2022)</li>
<li>“[HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face](<a href="https://arxiv.org/abs/2303.17580?utm_campaign=The">https://arxiv.org/abs/2303.17580?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8Kh954rkXmE4vgpKvro3Klpjhn7IuT-Y_eXIYtgVIq9PTzwa5zFWX7FZZqv1tuDEEsTDuY),” Shen et al. (2023)</li>
<li>“[Understanding the planning of LLM agents: A survey](<a href="https://arxiv.org/pdf/2402.02716.pdf?utm_campaign=The">https://arxiv.org/pdf/2402.02716.pdf?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8Kh954rkXmE4vgpKvro3Klpjhn7IuT-Y_eXIYtgVIq9PTzwa5zFWX7FZZqv1tuDEEsTDuY),” by Huang et al. (2024)</li>
</ul>
<br>
<h3 id="Multi-Agent-Collaboration">Multi-Agent Collaboration</h3>
<ul>
<li>“[Communicative Agents for Software Development](<a href="https://arxiv.org/abs/2307.07924?utm_campaign=The">https://arxiv.org/abs/2307.07924?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8TZzur2df1qdnGx09b-Fg94DTsc3-xXao4StKvKNU2HR51el3n8yOm0CPSw6GiAoLQNKua),” Qian et al. (2023) (the ChatDev paper)</li>
<li>“[AutoGen: Enabling Next-Gen LLM Applications via Multi-Agent Conversation](<a href="https://arxiv.org/abs/2308.08155?utm_campaign=The">https://arxiv.org/abs/2308.08155?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8TZzur2df1qdnGx09b-Fg94DTsc3-xXao4StKvKNU2HR51el3n8yOm0CPSw6GiAoLQNKua),” Wu et al. (2023)</li>
<li>“[MetaGPT: Meta Programming for a Multi-Agent Collaborative Framework](<a href="https://arxiv.org/abs/2308.00352?utm_campaign=The">https://arxiv.org/abs/2308.00352?utm_campaign=The</a> Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8TZzur2df1qdnGx09b-Fg94DTsc3-xXao4StKvKNU2HR51el3n8yOm0CPSw6GiAoLQNKua),” Hong et al. (2023)</li>
</ul>
<br>
<h2 id="MCP">MCP</h2>
<p>Model Context Protocol</p>
<p>ref: <a href="https://modelcontextprotocol.io/introduction">https://modelcontextprotocol.io/introduction</a></p>
<p>ref: <a href="https://zhuanlan.zhihu.com/p/29001189476">https://zhuanlan.zhihu.com/p/29001189476</a></p>
<img src="/2025/04/21/AI-Agent/v2-2bcd98f6541da0b6f14dc9082ee2dcda_1440w.jpg" class="" title="mcp">
<br>
<p><a href="https://github.com/modelcontextprotocol/python-sdk/tree/main/examples/clients/simple-chatbot/mcp_simple_chatbot">example</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client </span></span><br><span class="line">   ... <span class="comment"># 省略了无关的代码</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 初始化所有的 mcp server</span></span><br><span class="line">    <span class="keyword">for</span> server <span class="keyword">in</span> self.servers:</span><br><span class="line">        <span class="keyword">await</span> server.initialize()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取所有的 tools 命名为 all_tools</span></span><br><span class="line">    all_tools = []</span><br><span class="line">    <span class="keyword">for</span> server <span class="keyword">in</span> self.servers:</span><br><span class="line">        tools = <span class="keyword">await</span> server.list_tools()</span><br><span class="line">        all_tools.extend(tools)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将所有的 tools 的功能描述格式化成字符串供 LLM 使用</span></span><br><span class="line">    <span class="comment"># tool.format_for_llm() 我放到了这段代码最后，方便阅读。</span></span><br><span class="line">    tools_description = <span class="string">&quot;\n&quot;</span>.join(</span><br><span class="line">        [tool.format_for_llm() <span class="keyword">for</span> tool <span class="keyword">in</span> all_tools]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里就不简化了，以供参考，实际上就是基于 prompt 和当前所有工具的信息</span></span><br><span class="line">    <span class="comment"># 询问 LLM（Claude） 应该使用哪些工具。</span></span><br><span class="line">    system_message = (</span><br><span class="line">        <span class="string">&quot;You are a helpful assistant with access to these tools:\n\n&quot;</span></span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;tools_description&#125;</span>\n&quot;</span></span><br><span class="line">        <span class="string">&quot;Choose the appropriate tool based on the user&#x27;s question. &quot;</span></span><br><span class="line">        <span class="string">&quot;If no tool is needed, reply directly.\n\n&quot;</span></span><br><span class="line">        <span class="string">&quot;IMPORTANT: When you need to use a tool, you must ONLY respond with &quot;</span></span><br><span class="line">        <span class="string">&quot;the exact JSON object format below, nothing else:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">        <span class="string">&#x27;    &quot;tool&quot;: &quot;tool-name&quot;,\n&#x27;</span></span><br><span class="line">        <span class="string">&#x27;    &quot;arguments&quot;: &#123;\n&#x27;</span></span><br><span class="line">        <span class="string">&#x27;        &quot;argument-name&quot;: &quot;value&quot;\n&#x27;</span></span><br><span class="line">        <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#125;\n\n&quot;</span></span><br><span class="line">        <span class="string">&quot;After receiving a tool&#x27;s response:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;1. Transform the raw data into a natural, conversational response\n&quot;</span></span><br><span class="line">        <span class="string">&quot;2. Keep responses concise but informative\n&quot;</span></span><br><span class="line">        <span class="string">&quot;3. Focus on the most relevant information\n&quot;</span></span><br><span class="line">        <span class="string">&quot;4. Use appropriate context from the user&#x27;s question\n&quot;</span></span><br><span class="line">        <span class="string">&quot;5. Avoid simply repeating the raw data\n\n&quot;</span></span><br><span class="line">        <span class="string">&quot;Please use only the tools that are explicitly defined above.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: system_message&#125;]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Final... 假设这里已经处理了用户消息输入.</span></span><br><span class="line">        messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将 system_message 和用户消息输入一起发送给 LLM</span></span><br><span class="line">        llm_response = self.llm_client.get_response(messages)</span><br><span class="line"></span><br><span class="line">    ... <span class="comment"># 后面和确定使用哪些工具无关</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># server</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Represents a tool with its properties and formatting.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, name: <span class="built_in">str</span>, description: <span class="built_in">str</span>, input_schema: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name: <span class="built_in">str</span> = name</span><br><span class="line">        self.description: <span class="built_in">str</span> = description</span><br><span class="line">        self.input_schema: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>] = input_schema</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把工具的名字 / 工具的用途（description）和工具所需要的参数（args_desc）转化为文本</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">format_for_llm</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Format tool information for LLM.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            A formatted string describing the tool.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        args_desc = []</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;properties&quot;</span> <span class="keyword">in</span> self.input_schema:</span><br><span class="line">            <span class="keyword">for</span> param_name, param_info <span class="keyword">in</span> self.input_schema[<span class="string">&quot;properties&quot;</span>].items():</span><br><span class="line">                arg_desc = (</span><br><span class="line">                    <span class="string">f&quot;- <span class="subst">&#123;param_name&#125;</span>: <span class="subst">&#123;param_info.get(<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;No description&#x27;</span>)&#125;</span>&quot;</span></span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">if</span> param_name <span class="keyword">in</span> self.input_schema.get(<span class="string">&quot;required&quot;</span>, []):</span><br><span class="line">                    arg_desc += <span class="string">&quot; (required)&quot;</span></span><br><span class="line">                args_desc.append(arg_desc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Tool: <span class="subst">&#123;self.name&#125;</span></span></span><br><span class="line"><span class="string">Description: <span class="subst">&#123;self.description&#125;</span></span></span><br><span class="line"><span class="string">Arguments:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;<span class="built_in">chr</span>(<span class="number">10</span>).join(args_desc)&#125;</span></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<br>
<h2 id="微调数据集构建">微调数据集构建</h2>
<h3 id="Chunking-2">Chunking</h3>
<p>分块方案参考上文</p>
<h3 id="问题创建-问题求解">问题创建&amp;问题求解</h3>
<p>针对于分割好的文本块，通过LLM为其生成对应问题</p>
<br>
<h2 id="KBQA">KBQA</h2>
<p>Knowledge Based Question Answering (KBQA) aims to answer factual questions based on the provided knowledge base (KB).</p>
<p>ref: <a href="https://github.com/RUCAIBox/Awesome-KBQA">https://github.com/RUCAIBox/Awesome-KBQA</a></p>
<br>
<h3 id="Semantic-Parsing-based-Methods">Semantic Parsing-based Methods</h3>
<br>
<h3 id="Information-retrieval-based-Methods">Information retrieval-based Methods</h3>
<br>
<h3 id="Other-Methods">Other Methods</h3>
<br>
<h2 id="RAG">RAG</h2>
<p>技术入门：<a href="https://github.com/fareedkhan-dev/all-rag-techniques">https://github.com/fareedkhan-dev/all-rag-techniques</a></p>
<p><a href="https://github.com/NirDiamant/RAG_Techniques">https://github.com/NirDiamant/RAG_Techniques</a></p>
<h3 id="RAG-Design">RAG Design</h3>
<p>ref: <a href="https://abdullin.com/ilya/how-to-build-best-rag/">https://abdullin.com/ilya/how-to-build-best-rag/</a></p>
<h3 id="Effective-Chunking-Strategies-for-RAG">Effective Chunking Strategies for RAG</h3>
<p><a href="https://docs.cohere.com/page/chunking-strategies">https://docs.cohere.com/page/chunking-strategies</a></p>
<h3 id="Embedding">Embedding</h3>
<p><a href="https://github.com/FlagOpen/FlagEmbedding">https://github.com/FlagOpen/FlagEmbedding</a></p>
<h3 id="Reranker">Reranker</h3>
<p><a href="https://www.pinecone.io/learn/series/rag/rerankers/">https://www.pinecone.io/learn/series/rag/rerankers/</a></p>
<p>好的，我们来完成这三项关于 RAG (Retrieval-Augmented Generation) 扩展方法的详细说明。</p>
<hr>
<h3 id="Extended-Method">Extended Method</h3>
<h4 id="假设性文档嵌入-Hypothetical-Document-Embedding-HDE">假设性文档嵌入 (Hypothetical Document Embedding - HDE)</h4>
<p><strong>核心思想：</strong><br>
与其直接对用户的简短、模糊的查询（Query）进行嵌入，不如先让一个大型语言模型 (LLM) 根据该查询生成一个它认为最理想、最完整的“假设性答案”或“假设性文档”，然后对这个内容更丰富、语义更明确的假设性文档进行嵌入，再用其生成的向量去知识库中进行向量检索。</p>
<p><strong>解决的问题：</strong><br>
它主要解决“<strong>查询与文档之间的语义鸿沟 (Semantic Gap)</strong>”问题。用户的查询通常很短（如“什么是光合作用？”），而知识库中的文档通常很长，包含详细的解释、背景和例子。这两种不同形式的文本在嵌入空间中的向量可能相距甚远，导致检索效果不佳。HDE通过生成一个与目标文档在格式、长度和内容上都更相似的“中间文档”，极大地缩小了这一鸿沟。</p>
<p><strong>工作原理：</strong></p>
<ol>
<li>
<p><strong>接收查询 (Receive Query):</strong> 用户输入一个查询，例如：“如何为我的初创公司进行种子轮融资？”</p>
</li>
<li>
<p><strong>生成假设性文档 (Generate Hypothetical Document):</strong> 系统将该查询发送给一个 LLM，并提示它：“请生成一份详细回答‘如何为我的初创公司进行种子轮融资？’这个问题的文档。”</p>
</li>
<li>
<p><strong>LLM 输出:</strong> LLM 可能会生成如下的假设性文档：</p>
<blockquote>
<p>“为初创公司进行种子轮融资通常涉及几个关键步骤。首先，你需要一个清晰的商业计划书、一个最小可行产品（MVP）和一个有说服力的演讲稿。其次，建立你的投资人网络至关重要，可以从天使投资人和早期风险投资机构开始。在接触投资人时，要清晰地阐述你的市场机会、团队优势和财务预测…”</p>
</blockquote>
</li>
<li>
<p><strong>嵌入假设性文档 (Embed Hypothetical Document):</strong> 系统将这个由 LLM 生成的、内容丰富的假设性文档通过嵌入模型（Embedding Model）转换成一个向量。</p>
</li>
<li>
<p><strong>执行检索 (Perform Retrieval):</strong> 使用这个新生成的向量，在文档/知识库的向量索引中进行相似性搜索，找出与这个“理想答案”最匹配的实际文档。</p>
</li>
<li>
<p><strong>生成最终答案 (Generate Final Answer):</strong> 将检索到的文档和原始查询一起提供给 LLM，生成最终的、有事实依据的答案。</p>
</li>
</ol>
<p><strong>优势：</strong></p>
<ul>
<li><strong>提高检索精度：</strong> 显著改善了查询和文档之间的语义匹配度，能找到更相关的内容。</li>
<li><strong>处理模糊查询：</strong> 对于意图不明确或过于简短的查询，效果提升尤为明显。</li>
</ul>
<p><strong>挑战与考量：</strong></p>
<ul>
<li><strong>增加延迟：</strong> 在检索前增加了一次 LLM 调用，导致整体响应时间变长。</li>
<li><strong>增加成本：</strong> 额外的 LLM 调用会产生额外费用。</li>
<li><strong>依赖生成质量：</strong> 假设性文档的质量直接决定了检索效果的好坏。</li>
</ul>
<hr>
<h4 id="迭代式检索生成-Iterative-Retrieval-Generation-IRG">迭代式检索生成 (Iterative Retrieval Generation - IRG)</h4>
<p><strong>核心思想：</strong><br>
将检索和生成过程从“一次性完成”的线性流程，转变为一个循环、迭代、逐步求精的过程。系统会根据初步生成的答案或中间思考，主动发现知识缺口，并生成新的查询以获取更多信息，直到能够形成一个完整、准确的答案为止。</p>
<p><strong>解决的问题：</strong><br>
它主要解决<strong>复杂、多步骤或需要整合多方面知识的查询 (Complex, Multi-hop Questions)</strong>。对于这类问题，单次检索往往无法获取所有必要的信息。例如，“比较一下《指环王》和《冰与火之歌》在世界构建和角色塑造上的异同？”</p>
<p><strong>工作原理：</strong></p>
<ol>
<li><strong>初始检索 (Initial Retrieval):</strong> 系统接收初始查询，并进行第一次检索，获取一批相关文档。</li>
<li><strong>初步生成与分析 (Initial Generation &amp; Analysis):</strong> LLM 基于第一次检索到的文档，尝试生成答案。在生成过程中，它会识别出当前信息中的不足之处。例如，它可能找到了关于《指环王》世界构建的资料，但缺少《冰与火之歌》角色塑造的细节。</li>
<li><strong>生成新查询 (Generate New Queries):</strong> 基于识别出的知识缺口，系统（或 LLM 本身）会生成一个或多个新的、更具针对性的查询。例如：“《冰与火之歌》中的主要角色塑造技巧”、“《指环王》的魔法系统设定”。</li>
<li><strong>迭代检索 (Iterative Retrieval):</strong> 系统使用这些新查询去知识库中进行新一轮的检索，获取补充信息。</li>
<li><strong>整合与精炼 (Integration &amp; Refinement):</strong> 将所有轮次检索到的文档进行整合，并交由 LLM 进行最终的综合性回答。</li>
<li><strong>循环终止：</strong> 当 LLM 判断信息已经足够全面，或者达到预设的迭代次数时，循环结束。</li>
</ol>
<p><strong>优势：</strong></p>
<ul>
<li><strong>处理复杂问题：</strong> 能够像人类研究员一样，逐步深入，解决需要多方面信息支持的复杂问题。</li>
<li><strong>提高答案的全面性和深度：</strong> 通过补充检索，确保答案覆盖了问题的所有方面。</li>
</ul>
<p><strong>挑战与考量：</strong></p>
<ul>
<li><strong>高延迟和高成本：</strong> 多次检索和生成步骤显著增加了响应时间和计算成本。</li>
<li><strong>逻辑复杂性：</strong> 实现一个有效的迭代循环、判断何时停止以及如何生成有效的后续查询，技术上更具挑战性。</li>
<li><strong>可能陷入无效循环：</strong> 如果后续查询生成得不好，可能会导致检索不到有用信息，陷入低效循环。</li>
</ul>
<hr>
<h4 id="优化稠密加稀疏检索-Optimized-Dense-Sparse-Retrieval">优化稠密加稀疏检索 (Optimized Dense + Sparse Retrieval)</h4>
<p><strong>核心思想：</strong><br>
这是一种混合检索（Hybrid Retrieval）策略，它结合了两种主流检索技术的优点：<strong>稠密检索 (Dense Retrieval)</strong> 和 <strong>稀疏检索 (Sparse Retrieval)</strong>，以实现比单一技术更强大、更鲁棒的检索效果。</p>
<ul>
<li>
<p><strong>稠密检索 (Dense Retrieval):</strong></p>
<ul>
<li><strong>技术:</strong> 基于向量嵌入（Embeddings）和向量相似性搜索（如余弦相似度）。</li>
<li><strong>优点:</strong> 擅长理解<strong>语义和上下文</strong>。能够匹配意思相近但用词不同的查询和文档（例如，查询“美国总统官邸”能匹配到包含“白宫”的文档）。</li>
<li><strong>缺点:</strong> 对于<strong>关键词、专业术语、ID 或缩写</strong>的精确匹配能力较弱。</li>
</ul>
</li>
<li>
<p><strong>稀疏检索 (Sparse Retrieval):</strong></p>
<ul>
<li><strong>技术:</strong> 基于关键词频率和分布的传统信息检索方法（如 BM25、TF-IDF）。</li>
<li><strong>优点:</strong> 擅长<strong>精确匹配关键词</strong>。对于包含特定术语、产品型号（如“iPhone 15 Pro”）或代码标识符的查询，效果极佳。计算速度快，资源消耗低。</li>
<li><strong>缺点:</strong> 无法理解语义。无法匹配同义词或近义词（查询“汽车”无法匹配到包含“automobile”的文档）。</li>
</ul>
</li>
</ul>
<p><strong>工作原理 (优化结合):</strong></p>
<ol>
<li><strong>并行检索 (Parallel Retrieval):</strong> 当用户输入查询时，系统会<strong>同时</strong>使用两种方法进行检索：
<ul>
<li><strong>稠密路径：</strong> 将查询嵌入为向量，在向量数据库中搜索最相似的文档。</li>
<li><strong>稀疏路径：</strong> 对查询进行分词，在倒排索引（如 Elasticsearch）中使用 BM25 算法搜索最相关的文档。</li>
</ul>
</li>
<li><strong>结果融合 (Result Fusion):</strong> 系统会得到两个独立的、按相关性排序的文档列表。下一步是智能地将这两个列表融合成一个最终列表。最常用的融合算法是 <strong>“倒数排序融合” (Reciprocal Rank Fusion - RRF)</strong>。
<ul>
<li><strong>RRF 算法：</strong> 该算法不关心每个检索系统的原始分数（因为它们的量纲不同），只关心文档在各自列表中的<strong>排名 (Rank)</strong>。一个文档的最终分数是它在每个列表中排名的倒数之和。排名越靠前，倒数越大，最终分数也越高。</li>
<li><strong>公式:</strong> <code>RRF_Score(doc) = Σ (1 / (k + rank_i(doc)))</code>，其中 <code>rank_i(doc)</code> 是文档在第 <code>i</code> 个检索结果列表中的排名，<code>k</code> 是一个常数（通常设为60），用于降低低排名文档的影响。</li>
</ul>
</li>
<li><strong>最终排序与截断 (Final Ranking &amp; Truncation):</strong> 根据 RRF 分数对所有文档进行重新排序，并选取排名最高的 Top-K 个文档，用于后续的生成环节。</li>
</ol>
<p><strong>优势：</strong></p>
<ul>
<li><strong>取长补短：</strong> 结合了语义理解和关键词匹配的能力，是目前最有效的通用检索策略之一。</li>
<li><strong>鲁棒性强：</strong> 即使一种检索方法效果不佳，另一种方法仍可能召回相关的文档，大大降低了检索失败的风险。</li>
<li><strong>显著提升相关性：</strong> 在多数场景下，混合检索召回的文档质量远高于任何单一检索方法。</li>
</ul>
<p><strong>挑战与考量：</strong></p>
<ul>
<li><strong>系统复杂性：</strong> 需要同时维护向量数据库和关键词索引两种基础设施。</li>
<li><strong>调优挑战：</strong> 融合策略（如 RRF中的 <code>k</code> 值）或不同检索结果的权重需要进行实验和调优，以达到最佳效果。</li>
</ul>
<h3 id="Improved-RAG">Improved RAG</h3>
<h4 id="GraphRAG">GraphRAG</h4>
<p>ref: <a href="https://x.com/DailyDoseOfDS_/status/1941429358620766553">https://x.com/DailyDoseOfDS_/status/1941429358620766553</a></p>
<img src="/2025/04/21/AI-Agent/image-20250810092707204.png" class="" title="image-20250810092707204">
<p><a href="https://microsoft.github.io/graphrag/">https://microsoft.github.io/graphrag/</a></p>
<ol>
<li>
<p>Source Documents → Text Chunks</p>
<p>To start, the documents in the corpus are split into text chunks. The LLM extracts information from each chunk for downstream processing.</p>
</li>
<li>
<p>Text Chunks → Entities &amp; Relationships</p>
<p>the LLM is prompted（throught few-shot prompt） to extract instances of important entities and the relationships between the entities from a given chunk. Additionally, the LLM generates short descriptions for the entities and relationships</p>
<img src="/2025/04/21/AI-Agent/image-20250604165407470.png" class="" title="image-20250604165407470">
<p>The LLM can also be prompted to extract claims about detected entities. Claims are important factual statements about entities, such as dates, events, and interactions with other entities. As with entities and relationships, in-context learning exemplars can provide domain-specific guidance.</p>
<img src="/2025/04/21/AI-Agent/image-20250604170724823.png" class="" title="image-20250604170724823">
</li>
<li>
<p>Entities &amp; Relationships → Knowledge Graph</p>
<p>In the final step of the knowledge graph extraction process, these instances of entities and relationships become individual nodes and edges in the graph. Entity descriptions are aggregated and summarized for each node and edge. Relationships are aggregated into graph edges, where the number of duplicates for a given relationship becomes edge weights. Claims are aggregated similarly</p>
</li>
<li>
<p>Knowledge Graph → Graph Communities</p>
<p>we use Leiden community detection (Traag et al., 2019) in a hierarchical manner, recursively detecting sub-communities within each detected community until reaching leaf communities that can no longer be partitioned. Each level of this hierarchy provides a community partition that covers the nodes of the graph in a mutually exclusive, collectively exhaustive way, enabling divide-and-conquer global summarization.</p>
</li>
<li>
<p>Graph Communities → Community Summaries</p>
<img src="/2025/04/21/AI-Agent/image-20250604173158175.png" class="" title="image-20250604173158175">
</li>
<li>
<p>Community Summaries → Community Answers → Global Answer</p>
<img src="/2025/04/21/AI-Agent/image-20250604173209083.png" class="" title="image-20250604173209083">
</li>
</ol>
<h4 id="LightRAG">LightRAG</h4>
<p><a href="https://arxiv.org/abs/2410.05779">arxiv.org/abs/2410.05779</a></p>
<p><a href="https://github.com/HKUDS/LightRAG">https://github.com/HKUDS/LightRAG</a></p>
<img src="/2025/04/21/AI-Agent/b2aaf634151b4706892693ffb43d9093.png" class="" title="LightRAG Diagram">
<h2 id="Prompt-Engineering">Prompt Engineering</h2>
<p>ref: <a href="https://dannyzheng.me/2025/02/21/prompt-engineering/#the-prompt-engineering-lifecycle">https://dannyzheng.me/2025/02/21/prompt-engineering/#the-prompt-engineering-lifecycle</a></p>
<img src="/2025/04/21/AI-Agent/prompt_components.png" class="" title="img">
<h3 id="Base-2">Base</h3>
<h4 id="Zero-Shot-Prompting">Zero-Shot Prompting</h4>
<p>Zero-Shot Prompting 是指在不给模型任何示例的情况下，直接提出问题或任务。该方法依赖于模型的预训练知识，适用于模型已广泛学习相关领域信息的情况。例如：</p>
<blockquote>
<p><strong>Prompt</strong>：将下面这句话翻译成英文：我喜欢学习人工智能。<br>
<strong>Output</strong>：I like studying artificial intelligence.</p>
</blockquote>
<p>该方法简单高效，适用于任务明确、模型已具备相关背景知识的场景。</p>
<br>
<h4 id="Few-Shot-Prompting">Few-Shot Prompting</h4>
<p>Few-Shot Prompting 是在提示中提供少量（通常是1-5个）示例，以帮助模型理解任务格式或逻辑。这种方式可以显著提升模型在结构化任务中的表现。例如：</p>
<blockquote>
<p><strong>Prompt</strong>：<br>
翻译下列句子：<br>
例1：我爱编程。 → I love programming.<br>
例2：天气很好。 → The weather is nice.<br>
请翻译：我在看书。<br>
<strong>Output</strong>：I am reading a book.</p>
</blockquote>
<p>Few-Shot Prompting 利用“类比”方式，帮助模型对任务形成更明确的理解。</p>
<br>
<h4 id="Chain-of-Thought-CoT-Prompting">Chain-of-Thought (CoT) Prompting</h4>
<p>ref: <a href="https://dannyzheng.me/2025/02/21/prompt-engineering/#the-prompt-engineering-lifecycle">https://dannyzheng.me/2025/02/21/prompt-engineering/#the-prompt-engineering-lifecycle</a></p>
<blockquote>
<p>CoT tip: Always have LLM output its thinking. Without outputting its thought process, no thinking occurs!</p>
</blockquote>
<ul>
<li>
<p>Basic prompt: Include “Think step-by-step” in your prompt.</p>
<ul>
<li>
<p>Lacks guidance on how to think (which is especially not ideal if a task is very specific to your app, use case, or organization)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Draft personalized emails to donors asking for contributions to this year’s Care for Kids program.</span><br><span class="line"></span><br><span class="line">Program information:</span><br><span class="line">&lt;program&gt;&#123;&#123;PROGRAM_DETAILS&#125;&#125;</span><br><span class="line">&lt;/program&gt;</span><br><span class="line"></span><br><span class="line">Donor information:</span><br><span class="line">&lt;donor&gt;&#123;&#123;DONOR_DETAILS&#125;&#125;</span><br><span class="line">&lt;/donor&gt;</span><br><span class="line"></span><br><span class="line">Think step-by-step before you write the email.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Guided prompt: Outline specific steps for LLM to follow in its thinking process.</p>
<ul>
<li>
<p>Lacks structuring to make it easy to strip out and separate the answer from the thinking.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Draft personalized emails to donors asking for contributions to this year’s Care for Kids program.</span><br><span class="line"></span><br><span class="line">Program information:</span><br><span class="line">&lt;program&gt;&#123;&#123;PROGRAM_DETAILS&#125;&#125;</span><br><span class="line">&lt;/program&gt;</span><br><span class="line"></span><br><span class="line">Donor information:</span><br><span class="line">&lt;donor&gt;&#123;&#123;DONOR_DETAILS&#125;&#125;</span><br><span class="line">&lt;/donor&gt;</span><br><span class="line"></span><br><span class="line">Think before you write the email. First, think through what messaging might appeal to this donor given their donation history and which campaigns they’ve supported in the past. Then, think through what aspects of the Care for Kids program would appeal to them, given their history. Finally, write the personalized donor email using your analysis.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Structured prompt: Use XML tags like &lt;think&gt; &lt;/think&gt; and &lt;answer&gt; &lt;/answer&gt; to separate reasoning from the final answer.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Draft personalized emails to donors asking for contributions to this year’s Care for Kids program.</span><br><span class="line"></span><br><span class="line">Program information:</span><br><span class="line">&lt;program&gt;&#123;&#123;PROGRAM_DETAILS&#125;&#125;</span><br><span class="line">&lt;/program&gt;</span><br><span class="line"></span><br><span class="line">Donor information:</span><br><span class="line">&lt;donor&gt;&#123;&#123;DONOR_DETAILS&#125;&#125;</span><br><span class="line">&lt;/donor&gt;</span><br><span class="line"></span><br><span class="line">Think before you write the email in &lt;thinking&gt; tags. First, think through what messaging might appeal to this donor given their donation history and which campaigns they’ve supported in the past. Then, think through what aspects of the Care for Kids program would appeal to them, given their history. Finally, write the personalized donor email in &lt;email&gt; tags, using your analysis.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use code (e.g. extract from <code>&lt;answer&gt;</code> tags) to extract the desired answer from the LLM’s response</p>
</blockquote>
</li>
</ul>
<br>
<h4 id="Self-Consistency-Prompting">Self-Consistency Prompting</h4>
<p>Self-Consistency Prompting 是 Chain-of-Thought 的一种增强策略。其核心思想是：在面对复杂推理问题时，通过生成多个不同的推理路径（多次生成），然后对这些路径的最终结果进行投票或汇总，以提高答案的可靠性和稳定性。</p>
<p>例如，对于一道数学题，模型可能在不同尝试中给出不同的思路或答案，但通过“多数投票”可以获得更一致、准确的结果。</p>
<blockquote>
<p><strong>应用示例</strong>：</p>
<ul>
<li>生成5条不同的推理路径</li>
<li>汇总5个最终答案</li>
<li>选择出现频率最高的一个作为最终输出</li>
</ul>
</blockquote>
<p>这种方法特别适合对单次输出不够稳定的任务，比如复杂逻辑、数学题等场景。</p>
<br>
<h4 id="Retrieval-Augmented-Generation-RAG">Retrieval-Augmented Generation (RAG)</h4>
<p>RAG 是将外部知识检索机制（如文档、数据库、搜索引擎）与语言模型生成能力结合起来的一种方法。模型在回答问题前，会先“检索”相关内容，再基于检索结果生成答案。</p>
<p>这种方法克服了大模型“记忆有限”的问题，尤其在处理需要时效性或特定背景知识的任务时非常有效。</p>
<blockquote>
<p><strong>示例流程</strong>：</p>
<ol>
<li>用户提问：“请解释什么是量子纠缠？”</li>
<li>模型调用检索模块，从知识库或网络中找到高相关资料</li>
<li>基于资料，生成符合上下文、准确可靠的回答</li>
</ol>
</blockquote>
<p>RAG 适用于问答系统、知识密集型对话系统、企业内部知识库应用等场景。</p>
<br>
<h3 id="Medprompt">Medprompt</h3>
<p>MedPrompt is composed of the following prompting techniques:</p>
<ul>
<li>Dynamic few-shot selection: instead of using static few-shot examples, Medprompt selects few-shot examples dynamically based on the question.</li>
<li>Self-generated chain of thought.</li>
<li>Choice shuffle ensembling: performs choice shuffle and self-consistency prompting.</li>
</ul>
<img src="/2025/04/21/AI-Agent/Medqa-comp.png" class="" title="img">
<h2 id="其他">其他</h2>
<h3 id="RAG总结">RAG总结</h3>
<p><a href="https://holistic-authority-5c2.notion.site/RAG-1e3f66b636ba80f1b425dc15d7fae04c">https://holistic-authority-5c2.notion.site/RAG-1e3f66b636ba80f1b425dc15d7fae04c</a></p>
<h3 id="Cursor实现每秒-1000-tokens-的文件编辑">Cursor实现每秒 1000 tokens 的文件编辑</h3>
<p><a href="https://web.archive.org/web/20240605010559/https://www.cursor.com/blog/instant-apply">https://web.archive.org/web/20240605010559/https://www.cursor.com/blog/instant-apply</a></p>
<p>第一阶段 - 规划（Planning）：使用 GPT 或 Claude 等强大模型 通过聊天界面理解用户需求，制定编辑计划</p>
<p>第二阶段 - 代码生成（Code Generation）：同样使用 Claude/GPT 等大模型 根据规划生成具体的代码内容和编辑指令 输出类似&quot;在这个位置添加这段代码&quot;的详细变更描述</p>
<p>第三阶段 - 快速应用（Fast Apply）：使用 Cursor 自己训练的 Llama-3-70b-ft 模型 专门负责将第二阶段生成的代码变更快速、准确地应用到实际文件中 通过 speculative edits 技术实现 ~1000 tokens/秒的文件重写速度</p>
<p>关键点：前两个阶段：Claude/GPT 负责思考和生成代码内容 第三个阶段：Cursor 自训练模型负责高速执行文件操作</p>
<p>为什么需要第三阶段的专门模型？ 1. 速度瓶颈：Claude/GPT 在文件编辑时太慢，会打断编程流程 2. 技术限制：无法在第三方 API 中实现 speculative edits 优化 3. 准确性问题：大模型在 diff 格式上容易出错，经常有语法错误或&quot;懒惰&quot;行为 4. 成本控制：避免每次文件操作都调用昂贵的商业 API 这种设计让大模型专注于它们擅长的推理和代码生成，而让专门优化的模型处理精确、高速的文件编辑操作。</p>
<br>
<h3 id="幻觉处理">幻觉处理</h3>
<p><a href="https://cvs-health.github.io/uqlm/latest/index.html">https://cvs-health.github.io/uqlm/latest/index.html</a></p>
<p>黑盒评分器</p>
<img src="/2025/04/21/AI-Agent/black_box_graphic.png" class="" title="_images&#x2F;black_box_graphic.png">
<p>白盒评分器</p>
<img src="/2025/04/21/AI-Agent/white_box_graphic.png" class="" title="_images&#x2F;white_box_graphic.png">
<p>LLM评分</p>
<img src="/2025/04/21/AI-Agent/judges_graphic.png" class="" title="_images&#x2F;judges_graphic.png">
<p>集成评分器</p>
<img src="/2025/04/21/AI-Agent/uqensemble_generate_score.png" class="" title="_images&#x2F;uqensemble_generate_score.png">
<br>
<p>GPT记忆</p>
<p>ref: <a href="https://macro.com/app/md/54115a42-3409-4f5b-9120-f144d3ecd23a">https://macro.com/app/md/54115a42-3409-4f5b-9120-f144d3ecd23a</a></p>
<img src="/2025/04/21/AI-Agent/GsmyMNLasAQ_DY6" class="" title="img">
<img src="/2025/04/21/AI-Agent/GsmySEdaQAACdBZ" class="" title="img">
<br>]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>Python, Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer-Network</title>
    <url>/2025/02/19/Computer-Network/</url>
    <content><![CDATA[<p>computer network</p>
<span id="more"></span>
<h1>Computer Network</h1>
<h2 id="UDP">UDP</h2>
<h3 id="QUIC">QUIC</h3>
<p><strong>重传：</strong></p>
<ul>
<li>
<p>QUIC下的每个数据包的Packet Number唯一，丢包重传包的Packet Number与原始包不一样；</p>
</li>
<li>
<p>允许乱序确认接收；</p>
</li>
</ul>
<p>乱序接收到ACK即可将窗口向右移动至最大ACK处，最终窗口卡在没有收到ACK的丢包处，发现丢包；</p>
<p><strong>流量控制：</strong></p>
<img src="/2025/02/19/Computer-Network/839501cffa7146cbb8d992264594e61d.png" class="" title="Connection 流量控制">
<p>每个stream一个滑动窗口，不同stream间窗口独立，实现stream内有序，stream间乱序</p>
<p><strong>拥塞控制：</strong></p>
<p>应用层控制</p>
<h2 id="TCP">TCP</h2>
<h3 id="三次握手-四次挥手">三次握手&amp;四次挥手</h3>
<p>三次握手</p>
<p><strong>首要原因：防止「历史连接」初始化了连接</strong></p>
<p>考虑场景：服务器与旧的SYN请求建立连接</p>
<img src="/2025/02/19/Computer-Network/fe898053d2e93abac950b1637645943f.png" class="" title="两次握手无法阻止历史连接">
<p><strong>次要原因：同步双方初始序列号</strong></p>
<p>两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p><strong>次要原因：资源浪费</strong></p>
<p>两次握手中，服务端不知道客户端是否收到了自己发送的ACK报文，必须假设其收到了并建立连接</p>
<p>四次挥手：双方各一个 FIN + ACK</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<p>客户端发送FIN包表示不再发送数据，但仍可接收</p>
<p>服务端发送ACK包表示收到</p>
<p>服务端发送FIN包表示自己侧数据已完成处理，开始关闭</p>
<p>客户端发送ACK表示收到，自己延时关闭；</p>
<blockquote>
<p>为什么不是三次？</p>
<p>因为服务端在收到客户端想要关闭的请求时，自己可能仍在处理数据，没办法立刻关闭</p>
<p>如果服务端可以立即关闭，则可以当场回复FIN+ACK，实现三次挥手关闭连接</p>
</blockquote>
<h3 id="可靠传输">可靠传输</h3>
<p>TCP 重传、滑动窗口流量控制、拥塞控制</p>
<h4 id="重传">重传</h4>
<p>服务端返回ACK = x，x为服务端希望收到的最新包</p>
<blockquote>
<p>例如，客户端一次发送id范围为(100, 500)的数据包，服务端返回ACK = 501</p>
</blockquote>
<p><strong>超时重传</strong></p>
<p><code>RTO(ReTransmission Timeout)</code>  &gt; <code>RTT(Round-Trip Time)</code></p>
<ul>
<li>数据包丢失，客户端发送丢失</li>
<li>确认应答丢失，服务端发送丢失</li>
</ul>
<p><strong>快速重传</strong></p>
<p>连续收到3个相同id的ACK，立刻重传该id对应数据包</p>
<p><strong>SACK(Selective Acknowledge)重传</strong></p>
<p>额外为TCP头部附加SACK字段</p>
<p>SACK字段指出大于ACK的，已经收到的包的范围</p>
<h4 id="滑动窗口与流量控制">滑动窗口与流量控制</h4>
<p>TCP所有包必须顺序确认，丢包将导致窗口不滑动；</p>
<p><strong>发送方窗口</strong></p>
<p>处于窗口内的数据直接发送，等待ACK；</p>
<p>接收到最大ACK后，移动窗口左端到最大ACK值处</p>
<img src="/2025/02/19/Computer-Network/19.jpg" class="" title="SND.WND、SND.UN、SND.NXT">
<p><strong>接收方窗口</strong></p>
<img src="/2025/02/19/Computer-Network/20.jpg" class="" title="接收窗口">
<p>通过接收端/发送端窗口大小变化实现流量控制</p>
<h4 id="拥塞控制">拥塞控制</h4>
<img src="/2025/02/19/Computer-Network/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png" class="" title="快速重传和快速恢复">
<p><strong>慢启动</strong></p>
<p><strong>拥塞避免</strong></p>
<p><strong>快重传</strong></p>
<p><strong>快速恢复</strong></p>
<h3 id="其他">其他</h3>
<h4 id="TCP沾包">TCP沾包</h4>
<p>沾包：多个数据包处于一个滑动窗口内，被一同发送，导致无法区分包的开始/结束；</p>
<p>拆包：单个数据包大于一个滑动窗口的大小，被拆成多个发送；</p>
<blockquote>
<p>UDP包的消息头包含了UDP长度</p>
</blockquote>
<p>解决方法</p>
<ul>
<li>强制为每个包补齐窗口长度</li>
<li>在包的末尾手动添加分隔符</li>
<li>在包的头部手动添加长度指示信息</li>
</ul>
<p>http解决沾包问题</p>
<p>使用Content-Length来标识body的长度</p>
<p>使用Transfer-Encoding: chunked，按照chunked协议分批读取数据</p>
<p>http请求报文格式</p>
<p>1）请求行：以\r\n结束；<br>
2）请求头：以\r\n结束；<br>
3）\r\n；<br>
3）数据；</p>
<p>http响应报文格式<br>
1）响应行：以\r\n结束；<br>
2）响应头：以\r\n结束；<br>
3）\r\n；<br>
4）数据；</p>
<h2 id="HTTP">HTTP</h2>
<h3 id="HTTP1-1">HTTP1.1</h3>
<p><strong>长连接</strong></p>
<p>建立TCP连接后保持</p>
<p><strong>管道网络传输</strong></p>
<p>在同一个TCP连接下，连续发送多个HTTP请求；要求对每一个请求进行回应；</p>
<p>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。</p>
<blockquote>
<p>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞；请求的队头阻塞是指，请求后必须等待收到响应才能发送新请求；</p>
<p>实际上，HTTP 管道化技术不是默认开启，后续对HTTP 1.1 的讨论基于管道化技术没有开启</p>
</blockquote>
<p><strong>Host字段</strong></p>
<p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。</p>
<p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>
<p>此外，服务器应该接受以绝对路径标记的资源请求。</p>
<p><strong>Chunked Transfer Coding</strong></p>
<p>HTTP/1.1将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。</p>
<p>这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。</p>
<p><strong>Cache</strong></p>
<p>HTTP/1.1在1.0的基础上加入了一些Cache的新特性，当缓存对象的Age超过Expire时变为Stable对象，Cache不需要直接抛弃Stable对象，而是与源服务器进行重新激活。</p>
<h3 id="HTTP2-0">HTTP2.0</h3>
<img src="/2025/02/19/Computer-Network/25-HTTP2.png" class="" title="HTT&#x2F;1 ~ HTTP&#x2F;2">
<p><strong>HTTP2.0和HTTP1.X相比的新特性</strong></p>
<ul>
<li><strong>二进制帧</strong>，<code>HTTP1.x</code>的解析是基于文本格式</li>
<li><strong>并发传输</strong>，一个 TCP 连接包含 多个 stream，每个 stream 包含多个 Message，每个 Message 包含多个 Frame</li>
<li><strong>头部压缩</strong>，HPACK 算法压缩头部</li>
<li><strong>服务端主动推送</strong></li>
</ul>
<img src="/2025/02/19/Computer-Network/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpeg" class="" title="img">
<p><strong>数据流</strong></p>
<p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。</p>
<p>因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>每个请求或回应的所有数据包，称为一个数据流（Stream）。</p>
<p>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p>
<p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p>
<p>同一个stream上的帧可以保证顺序性，将http报文拆成帧后考虑在同一个stream上传输？</p>
<p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别</strong></p>
<ul>
<li>HTTP/1.1的Pipeling为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；</li>
<li>HTTP2.0多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行</li>
</ul>
<p>存在问题：tcp链接产生的阻塞</p>
<img src="/2025/02/19/Computer-Network/http2%E9%98%BB%E5%A1%9E.jpeg" class="" title="img">
<h3 id="HTTP3-0">HTTP3.0</h3>
<img src="/2025/02/19/Computer-Network/fh5fm7pgm2.png" class="" title="img">
<p><strong>使用UDP协议</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc8e97afd2124bddb52ee4f1911fa2da~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"></p>
<p>HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</p>
<p>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<ul>
<li>HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li>
<li>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li>
</ul>
<p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
<p>QUIC协议-基于UDP的可靠传输协议</p>
<ul>
<li>
<p>无队头阻塞；</p>
<img src="/2025/02/19/Computer-Network/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" class="" title="img">
</li>
<li>
<p>更快的连接建立；</p>
<img src="/2025/02/19/Computer-Network/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png" class="" title="TCP HTTPS（TLS&#x2F;1.3） 和 QUIC HTTPS">
</li>
<li>
<p>连接迁移；</p>
</li>
</ul>
<h2 id="HTTPS">HTTPS</h2>
<p>服务端返回客户端的认证内容为</p>
<p>服务器公钥 + 签名（CA使用CA的私钥对服务器公钥进行的计算的结果）</p>
<p>客户端使用预先保存的CA的公钥对签名进行解密，对比解密结果与公钥是否一致</p>
<img src="/2025/02/19/Computer-Network/wangluo-45917c49-bb08-4f88-84d2-5e8ae53acc7c.png" class="" title="img">
<p><strong>HTTPS流程</strong></p>
<p>TCP(3) + TLS(4)</p>
<img src="/2025/02/19/Computer-Network/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="HTTPS 连接建立过程">
<ul>
<li>Client发起一个HTTPS的请求</li>
<li>Server把事先配置好的公钥证书返回给客户端。</li>
<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书），如果验证通过则继续，不通过则显示警告信息。</li>
<li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li>
<li>Server使用自己的私钥解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li>
<li>Server使用对称密钥加密明文内容A，发送给Client。</li>
<li>Client使用对称密钥解密响应的密文，得到明文内容A。</li>
<li>Client再次发起HTTPS的请求，使用对称密钥加密请求的明文内容B，然后Server使用对称密钥解密密文，得到明文内容B。</li>
</ul>
<h2 id="DNS">DNS</h2>
<p>流程</p>
<ol>
<li>
<p><strong>本地主机查询 (Local Host File Check):</strong> 首先会检查本地的 hosts 文件 (位于不同操作系统上的不同位置，例如 Windows 的 C:\Windows\System32\drivers\etc\hosts 或 Linux/macOS 的 /etc/hosts) 是否包含 <a href="http://www.example.com">www.example.com</a> 的 IP 地址。 如果找到，则跳过后面的步骤，直接使用该 IP 地址。 这是一个优先于 DNS 查询的优化机制。</p>
</li>
<li>
<p><strong>递归查询本地 DNS 服务器 (Recursive Query to Local DNS Resolver):</strong> 如果 hosts 文件中没有找到，会向配置好的 <strong>本地 DNS 服务器 (Local DNS Resolver)</strong> 发送一个 <strong>递归查询 (Recursive Query)</strong>。 本地 DNS 服务器通常由 ISP (互联网服务提供商) 提供，也可能是手动配置的 (例如，Google Public DNS 或 Cloudflare DNS)。 “递归”意味着本地 DNS 服务器将负责完成整个解析过程，并最终返回 IP 地址。</p>
</li>
<li>
<p><strong>递归查询根 DNS 服务器 (Recursive Query to Root DNS Servers):</strong> 如果本地 DNS 服务器不知道 <a href="http://www.example.com">www.example.com</a> 的 IP 地址，它会联系其中一个 <strong>根 DNS 服务器 (Root DNS Servers)</strong>。 根 DNS 服务器知道所有顶级域名 (TLD) 服务器的地址。 全球共有 13 组根 DNS 服务器，它们具有不同的物理位置，并使用任播 (Anycast) 技术以提高可用性和效率。 本地 DNS 服务器会询问根服务器 <a href="http://www.example.com">www.example.com</a> 的 IP 地址。 根服务器<strong>不会直接返回 IP 地址</strong>，而是返回负责 .com 域的 <strong>TLD DNS 服务器</strong>的地址。</p>
</li>
<li>
<p><strong>递归查询 TLD DNS 服务器 (Recursive Query to TLD DNS Servers):</strong> 本地 DNS 服务器收到 .com TLD 服务器的地址后，会联系该 TLD 服务器，询问 <a href="http://www.example.com">www.example.com</a> 的 IP 地址。 .com TLD 服务器<strong>也不会直接返回 IP 地址</strong>，而是返回负责 <a href="http://example.com">example.com</a> 域的 <strong>权威 DNS 服务器 (Authoritative DNS Servers)</strong> 的地址。</p>
</li>
<li>
<p><strong>递归查询权威 DNS 服务器 (Recursive Query to Authoritative DNS Servers):</strong> 本地 DNS 服务器收到 <a href="http://example.com">example.com</a> 域的权威 DNS 服务器地址后，会联系这些权威 DNS 服务器，询问 <a href="http://www.example.com">www.example.com</a> 的 IP 地址。 <strong>权威 DNS 服务器拥有 <a href="http://example.com">example.com</a> 域的 DNS 记录</strong>，并知道 <a href="http://www.example.com">www.example.com</a> 的 IP 地址。 它会将这个 IP 地址返回给本地 DNS 服务器。</p>
<blockquote>
<p>例如，假设 <a href="http://example.com">example.com</a> 的权威 DNS 服务器有以下 DNS 记录：</p>
<ul>
<li><strong><a href="http://example.com">example.com</a></strong> -&gt; 192.0.2.1</li>
<li><strong><a href="http://bbb.example.com">bbb.example.com</a></strong> -&gt; 192.0.2.2</li>
<li><strong><a href="http://aaa.example.com">aaa.example.com</a></strong> -&gt; 192.0.2.3</li>
</ul>
<p>当本地 DNS 服务器查询 <a href="http://bbb.example.com">bbb.example.com</a> 时，权威 DNS 服务器会返回 192.0.2.2。同样，当查询 <a href="http://aaa.example.com">aaa.example.com</a> 时，权威 DNS 服务器会返回 192.0.2.3。</p>
</blockquote>
</li>
<li>
<p><strong>缓存与返回 (Caching and Return):</strong> 本地 DNS 服务器将收到的 IP 地址缓存起来，以便下次有人请求 <a href="http://www.example.com">www.example.com</a> 时，它可以直接返回该 IP 地址，而无需再次执行上述步骤。 缓存时间由 DNS 记录的 <strong>TTL (Time To Live)</strong> 值决定。 最后，本地 DNS 服务器将 IP 地址返回给你的电脑。</p>
</li>
<li>
<p><strong>连接服务器 (Connect to Server):</strong> 你的电脑现在有了 <a href="http://www.example.com">www.example.com</a> 的 IP 地址，可以使用该 IP 地址连接到网站服务器，并获取网页内容。</p>
</li>
</ol>
<h2 id="Cookie-Session-Token">Cookie &amp; Session &amp; Token</h2>
<p><strong>Cookie</strong></p>
<p>HTTP 1.1 出现</p>
<p>Cookie是服务器发送到用户浏览器并保存在用户浏览器的数据(服务端生成后不保存)</p>
<p>后续用户在访问同一服务器时，会在请求头中添加Cookie</p>
<p><strong>服务器返回报文</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>
<p><strong>客户端请求报文</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，客户端可以修改保存在本地的 Cookie，因此服务器需要采取一些措施来确保 Cookie 的有效性和安全性。</p>
</blockquote>
<p><strong>Session</strong></p>
<p>Session存储于服务端，可以使用文件，数据库，内存保存；</p>
<p>流程</p>
<ul>
<li>用户登录后，服务器为每个用户生成一个Session ID，保存在服务器；</li>
<li>服务器发送返回报文，Set-Cookie: Session ID;</li>
<li>用户在后续请求中携带Cookie（值为Session ID）发生至服务器</li>
<li>服务器取出报文中的Cookie字段，并检查保存Session ID的数据库进行对比，确定用户身份</li>
</ul>
<p><strong>Token</strong></p>
<p>Token为服务器在验证用户身份后，生成并通过<strong>报文体</strong>携带返回给用户的数据；</p>
<p>客户端在后续的访问中，通过在请求头添加 <strong>Authorization</strong> 字段携带 Token 信息;</p>
<p><strong>！！！服务器不需要存储 Session 数据！！！</strong></p>
<p><strong>所有信息都包含在 Token 中，Token 中包含所有必要信息，减少数据库查询。因此，JWT 一旦签发，无法直接撤销，除非使用黑名单机制或设置较短的过期时间。</strong></p>
<p><strong>服务器返回报文</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端请求报文</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /protected-resource HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JWT</p>
<p>JWT**（JSON Web Token）** 是一种开放标准（RFC 7519），用于在网络应用间安全地传递信息。JWT 是一个自包含的 Token，包含用户信息、签名和可选的其他元数据。</p>
<p>JWT 由三部分组成，用 <code>.</code> 分隔：</p>
<ul>
<li>
<p>Header：包含 Token 的类型（JWT）和签名算法（如 HMAC SHA256 或 RSA）。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Payload：包含用户信息（如用户 ID、角色）和其他数据（如过期时间）。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1516242622</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Signature</strong>：对 Header 和 Payload 的签名，用于验证 Token 的完整性和真实性。</p>
</li>
</ul>
<p>最终的 JWT 是一个 Base64Url 编码的字符串，格式如下：</p>
<p><code>Header.Payload.Signature</code></p>
<p>注意，JWT 由三部分组成：<strong>Header</strong>、<strong>Payload</strong> 和 <strong>Signature</strong>。其中：</p>
<ul>
<li><strong>Header</strong> 和 <strong>Payload</strong> 是 <strong>Base64Url 编码的明文</strong>，可以被任何人解码查看。</li>
<li><strong>Signature</strong> 是对 Header 和 Payload 的签名，用于验证数据的完整性和真实性。</li>
</ul>
<p>由于签名所使用的密钥仅服务器持有，因此可以通过该密钥确定签名的真实性</p>
</blockquote>
<h2 id="IO">IO</h2>
<h3 id="同步IO">同步IO</h3>
<p><strong>同步阻塞IO</strong></p>
<p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p>
<p><strong>同步非阻塞IO</strong></p>
<p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。</p>
<p><strong>同步多路复用IO</strong></p>
<p>多个同步阻塞IO，任一就绪-返回</p>
<p>流程的多路复用IO实现主要包括四种: <code>select</code>、<code>poll</code>、<code>kqueue</code></p>
<p><code>epoll</code></p>
<h3 id="异步IO">异步IO</h3>
<p>相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。</p>
<p><strong>异步多路复用IO</strong></p>
<h3 id="select-poll-epoll">select, poll &amp; epoll</h3>
<p><code>select</code></p>
<p>位图+轮询 监控 文件描述符 集合</p>
<p><code>select</code> 是一种经典的 I/O 多路复用技术，它允许程序监视多个文件描述符（FD），并在这些文件描述符上发生 I/O 操作时得到通知。它的工作原理和实现可以总结如下：</p>
<ul>
<li>
<p><strong>工作方式</strong>：<code>select</code> 使用一个固定大小的位图（bitmap），标记哪些文件描述符需要检查。程序通过 <code>select()</code> 系统调用来监视这些文件描述符的状态变化（如是否可读、是否可写）。</p>
</li>
<li>
<p><strong>阻塞/非阻塞</strong>：<code>select</code> 可以设置为阻塞模式（一直等待直到有数据可用）或非阻塞模式（即不阻塞，立即返回）。</p>
</li>
<li>
<p><strong>文件描述符上限</strong>：<code>select</code> 在每次调用时，都需要传入一个文件描述符集合。由于它使用一个位图来表示文件描述符，因此其最大的文件描述符数量受到操作系统的限制，通常为 1024（可以通过修改系统配置增大，但通常仍有限制）。</p>
</li>
<li>
<p>适用于小规模的文件描述符管理，容易实现，但由于它使用位图，文件描述符数目过多时会导致性能下降。</p>
</li>
<li>
<p>由于每次都需要遍历所有的文件描述符，它的性能在大量文件描述符时可能非常低效。</p>
</li>
</ul>
<p><code>poll</code></p>
<p>链表+轮询 监控 文件描述符 集合</p>
<p><code>poll</code> 是对 <code>select</code> 的改进，解决了 <code>select</code> 存在的一些缺点，特别是在文件描述符上限和灵活性方面。</p>
<ul>
<li>
<p><strong>工作方式</strong>：<code>poll</code> 也用来监视多个文件描述符，但是它不像 <code>select</code> 使用位图，而是使用链表（每个文件描述符一个 <code>pollfd</code> 结构体），其中每个元素包含文件描述符和该描述符的状态信息（如是否可读、是否可写等）。</p>
</li>
<li>
<p><strong>没有上限限制</strong>：与 <code>select</code> 的 1024 文件描述符的限制不同，<code>poll</code> 的文件描述符数目不受固定上限的限制，实际上只受系统内存限制。</p>
</li>
<li>
<p><strong>性能问题</strong>：虽然 <code>poll</code> 提高了灵活性，解决了文件描述符上限的问题，但它仍然需要遍历所有文件描述符，性能在大规模应用时依然较差。</p>
</li>
<li>
<p>相对于 <code>select</code>，<code>poll</code> 更加灵活，没有文件描述符的数量限制，但仍然是线性扫描的方式，性能在大量文件描述符时依然不佳。</p>
</li>
</ul>
<p><code>epoll</code></p>
<p>链表+事件回调 监控 文件描述符 集合</p>
<p><code>epoll</code> 是 Linux 下特有的一种高效的 I/O 多路复用机制，它比 <code>select</code> 和 <code>poll</code> 在处理大量文件描述符时具有更高的效率。</p>
<ul>
<li>
<p><strong>工作方式</strong>：<code>epoll</code> 提供了一种事件驱动的机制，注册感兴趣的文件描述符，当文件描述符发生事件时，<code>epoll</code> 通过回调函数通知应用程序。这使得它避免了每次都需要遍历所有文件描述符的低效问题。</p>
</li>
<li>
<p><strong>事件驱动</strong>：<code>epoll</code> 使用事件驱动模型，只关心发生事件的文件描述符。当事件发生时，内核会将文件描述符加入就绪队列，应用程序可以通过 <code>epoll_wait</code> 函数获取所有就绪的文件描述符，避免了像 <code>select</code> 和 <code>poll</code> 一样每次都遍历所有文件描述符。</p>
</li>
<li>
<p><strong>性能</strong>：<code>epoll</code> 在处理大量文件描述符时具有显著的性能优势，因为它采用了基于内存的事件回调机制，可以更高效地通知应用程序哪些文件描述符准备好进行 I/O 操作。</p>
</li>
<li>
<p><strong>支持边缘触发（Edge Triggered）和水平触发（Level Triggered）</strong>：<code>epoll</code> 提供了两种触发模式，边缘触发和水平触发，提供更多的灵活性和控制。</p>
</li>
<li>
<p><code>epoll</code> 是在处理大量文件描述符时，性能最优的 I/O 多路复用技术。它基于事件驱动，避免了每次遍历所有文件描述符的低效操作，并提供了高效的通知机制。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>udp, tcp, http</tag>
      </tags>
  </entry>
  <entry>
    <title>Database-Learning-Record</title>
    <url>/2024/08/10/Database-Learning-Record/</url>
    <content><![CDATA[<p>MySQL和Redis数据库相关学习记录</p>
<span id="more"></span>
<h1>Database Learning Record</h1>
<h2 id="SQL">SQL</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="operator">&lt;</span>cte_name<span class="operator">&gt;</span> <span class="keyword">AS</span> ( <span class="operator">&lt;</span>cte_query<span class="operator">&gt;</span> ) [, <span class="operator">&lt;</span>cte_name<span class="operator">&gt;</span> <span class="keyword">AS</span> ( <span class="operator">&lt;</span>cte_query<span class="operator">&gt;</span> )]...  <span class="comment">-- Common Table Expressions (可选)</span></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span> <span class="operator">|</span> <span class="keyword">ALL</span>] <span class="operator">&lt;</span>select_list<span class="operator">&gt;</span>  <span class="comment">-- 选择哪些列</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>view_name<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>joined_tables<span class="operator">&gt;</span>  <span class="comment">-- 从哪个表/视图/连接结果中选择</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>search_condition<span class="operator">&gt;</span>  <span class="comment">-- 过滤行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>grouping_columns<span class="operator">&gt;</span>  <span class="comment">-- 分组行</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>group_condition<span class="operator">&gt;</span>  <span class="comment">-- 过滤分组后的行</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>ordering_columns<span class="operator">&gt;</span> [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]  <span class="comment">-- 排序结果</span></span><br><span class="line">LIMIT <span class="operator">&lt;</span>row_count<span class="operator">&gt;</span> <span class="keyword">OFFSET</span> <span class="operator">&lt;</span><span class="keyword">offset</span><span class="operator">&gt;</span>  <span class="comment">-- 限制返回的行数 (某些数据库使用不同的语法，例如 TOP)</span></span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>] <span class="operator">&lt;</span>another_select_statement<span class="operator">&gt;</span>  <span class="comment">-- 合并多个查询结果 (可选)</span></span><br><span class="line"><span class="keyword">INTERSECT</span> <span class="operator">&lt;</span>another_select_statement<span class="operator">&gt;</span>  <span class="comment">-- 返回多个查询结果的交集 (可选)</span></span><br><span class="line"><span class="keyword">EXCEPT</span> <span class="operator">|</span> MINUS <span class="operator">&lt;</span>another_select_statement<span class="operator">&gt;</span>  <span class="comment">-- 返回第一个查询结果中存在但第二个查询结果中不存在的行 (可选)</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> <span class="operator">&lt;</span>column_list<span class="operator">&gt;</span>]  <span class="comment">-- 锁定选定的行以进行更新 (可选)</span></span><br></pre></td></tr></table></figure>
<p>顺序：</p>
<p>1.FROM 获得表格（在此处进行JOIN联结表与表）</p>
<p>2.WHERE 筛选行</p>
<p>3.GROUP 将行组成组</p>
<p>4.HAVING 二次过滤</p>
<p>5.ORDER BY排序</p>
<p>…</p>
<p>-1. SELECT 确定返回列</p>
<p><strong>WHERE</strong></p>
<blockquote>
<p>where可以筛查符合目标的行，<strong>被筛列可以不在select中</strong></p>
<p>where确定输入数据行，select确定返回列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> device_id <span class="keyword">FROM</span> user_profile <span class="keyword">WHERE</span> gpa <span class="operator">&gt;</span> <span class="number">3.5</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>比较运算符:</strong></p>
<ul>
<li><strong><code>=</code>:</strong> 等于</li>
<li><strong><code>!=</code> 或 <code>&lt;&gt;</code>:</strong> 不等于</li>
<li><strong><code>&gt;</code>:</strong> 大于</li>
<li><strong><code>&lt;</code>:</strong> 小于</li>
<li><strong><code>&gt;=</code>:</strong> 大于等于</li>
<li><strong><code>&lt;=</code>:</strong> 小于等于</li>
</ul>
<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;Electronics&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>逻辑运算符:</strong></p>
<ul>
<li><strong><code>AND</code>:</strong> 两个条件都必须为真</li>
<li><strong><code>OR</code>:</strong> 至少一个条件为真</li>
<li><strong><code>NOT</code>:</strong>  取反条件</li>
</ul>
<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">60000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;Electronics&#x27;</span> <span class="keyword">OR</span> category <span class="operator">=</span> <span class="string">&#x27;Books&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> <span class="keyword">NOT</span> country <span class="operator">=</span> <span class="string">&#x27;USA&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong><code>BETWEEN</code> 运算符:</strong></p>
<p>检查值是否在指定范围内。</p>
<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong><code>LIKE</code> 运算符:</strong></p>
<p>用于模式匹配。</p>
<blockquote>
<p>SQL <code>LIKE</code> 运算符用于模式匹配，允许你搜索包含特定字符序列的数据。<code>LIKE</code> 运算符通常与通配符一起使用，以创建更灵活的搜索模式。以下是常用的 <code>LIKE</code> 通配符：</p>
<ul>
<li>
<p><strong><code>%</code> (百分号):</strong> 匹配任意字符序列（包括空序列）。它可以用于匹配字符串的开头、结尾或中间的任意部分。</p>
<ul>
<li><strong>示例:</strong>
<ul>
<li><code>LIKE 'A%'</code>: 匹配以 “A” 开头的任何字符串，例如 “Apple”、“Airplane”、“A”。</li>
<li><code>LIKE '%e'</code>: 匹配以 “e” 结尾的任何字符串，例如 “Apple”、“Orange”、“e”。</li>
<li><code>LIKE '%app%'</code>: 匹配包含 “app” 的任何字符串，例如 “Apple”、“Application”、“Happy”。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>_</code> (下划线):</strong> 匹配任何单个字符。</p>
<ul>
<li><strong>示例:</strong>
<ul>
<li><code>LIKE 'A_'</code>: 匹配以 “A” 开头且后面跟着一个任意字符的字符串，例如 “Ab”、“Ac”、“A1”。</li>
<li><code>LIKE '_pple'</code>: 匹配以任意字符开头且后面跟着 “pple” 的字符串，例如 “Apple”、“ipple”。</li>
<li><code>LIKE 'a__le'</code>: 匹配以 “a” 开头，后面跟着两个任意字符，再跟着 “le” 的字符串，例如 “apple”、“azble”。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>[]</code> (方括号):</strong> 匹配指定集合中的任何单个字符。</p>
<ul>
<li><strong>示例:</strong>
<ul>
<li><code>LIKE '[ABC]%'</code>: 匹配以 “A”、“B” 或 “C” 开头的任何字符串。</li>
<li><code>LIKE 'h[aeiou]t'</code>: 匹配 “hat”、“het”、“hit”、“hot” 或 “hut”。</li>
<li><code>LIKE '[A-Z]%'</code>: 匹配以任何大写字母开头的字符串。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>[^]</code> (方括号加脱字符):</strong> 匹配不在指定集合中的任何单个字符。</p>
<ul>
<li><strong>示例:</strong>
<ul>
<li><code>LIKE '[^ABC]%'</code>: 匹配不以 “A”、“B” 或 “C” 开头的任何字符串。</li>
<li><code>LIKE 'h[^aeiou]t'</code>: 匹配以 “h” 开头，第二个字符不是元音字母，以 “t” 结尾的字符串。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>转义字符:</strong></p>
<p>如果需要在 <code>LIKE</code> 模式中匹配通配符字符本身（例如，你想查找包含 “%” 的字符串），你需要使用转义字符。 你可以在 <code>LIKE</code> 子句中使用 <code>ESCAPE</code> 关键字来指定转义字符为<code>!</code>。</p>
<ul>
<li><strong>示例:</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> product_name <span class="keyword">LIKE</span> <span class="string">&#x27;%10\% off%&#x27;</span>; <span class="comment">-- 错误，会将 &quot;%&quot; 视为通配符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> product_name <span class="keyword">LIKE</span> <span class="string">&#x27;%10!% off%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;!&#x27;</span>;  <span class="comment">-- 正确，使用 &quot;!&quot; 作为转义字符，查找包含 &quot;10% off&quot; 的字符串</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>ESCAPE '!'</code>  指定 “!” 作为转义字符。 因此，<code>!%</code> 被解释为字面上的 “%” 字符，而不是通配符。</p>
<p><strong>结合使用:</strong></p>
<ul>
<li><strong>示例:</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;[a-z]%@[a-z]%.[a-z]%&#x27;</span>;  <span class="comment">-- 匹配简单的电子邮件地址格式</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong><code>IN</code> 运算符:</strong></p>
<p>检查值是否在指定的值列表中。</p>
<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="keyword">IN</span> (<span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Books&#x27;</span>, <span class="string">&#x27;Clothing&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong><code>IS NULL</code> 运算符:</strong></p>
<p>检查值是否为 NULL。</p>
<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> email <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><strong><code>IS NOT NULL</code> 运算符:</strong></p>
<p>检查值是否不为 NULL。</p>
<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>其他运算符:</p>
<p>一些数据库系统还支持其他运算符，例如：</p>
<ul>
<li><strong><code>EXISTS</code>:</strong> 检查子查询是否返回任何行。</li>
<li><strong><code>ANY</code> / <code>SOME</code> / <code>ALL</code>:</strong>  与子查询一起使用，比较值与子查询返回的所有值。</li>
</ul>
<p><code>GROUP BY [column]</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CustomerID, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> OrderCount</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CustomerID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Region, Product, <span class="built_in">SUM</span>(Sales) <span class="keyword">AS</span> TotalSales</span><br><span class="line"><span class="keyword">FROM</span> Sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Region, Product;</span><br></pre></td></tr></table></figure>
<p>当使用 GROUP BY 子句时，SELECT 列表中只能包含以下两类列：</p>
<ol>
<li>出现在 GROUP BY 子句中的列。</li>
<li>使用聚合函数（如 COUNT、SUM、AVG、MAX、MIN 等）的列。</li>
</ol>
<p>GROUP BY 子句可以按多列进行分组， <strong>每种组合形成一行</strong>。</p>
<p><strong>函数</strong></p>
<p><strong>标量函数 (Scalar Functions):</strong> 标量函数对每一行输入都返回一个单一的值。 大多数字符串函数、数值函数、日期函数以及一些其他函数（如 COALESCE 和 NULLIF）都属于标量函数。</p>
<p><strong>数值函数:</strong></p>
<ul>
<li><strong>ABS:</strong> 返回数值的绝对值。</li>
<li><strong>ROUND:</strong> 将数值四舍五入到指定的小数位数。</li>
<li><strong>TRUNC 或 TRUNCATE:</strong> 截断数值到指定的小数位数。</li>
<li><strong>CEIL 或 CEILING:</strong> 返回大于或等于指定数值的最小整数。</li>
<li><strong>FLOOR:</strong> 返回小于或等于指定数值的最大整数。</li>
<li><strong>MOD:</strong> 返回两个数值相除的余数。</li>
<li><strong>POWER:</strong> 返回一个数值的指定次幂。</li>
<li><strong>SQRT:</strong> 返回数值的平方根。</li>
</ul>
<p><strong>聚合函数:</strong>  聚合函数对一组值进行计算并返回一个单一的值</p>
<ul>
<li><strong>COUNT:</strong> 计算行数。
<ul>
<li><strong>COUNT(*):</strong> 计算表中的所有行数，包括包含 NULL 值的行。它本质上是计算表中的总行数。</li>
<li><strong>COUNT(column):</strong> 计算指定列中非 NULL 值的行数。如果指定列中的某个值为 NULL，则该行不会被计入。</li>
</ul>
</li>
<li><strong>SUM:</strong> 计算数值的总和。</li>
<li><strong>AVG:</strong> 计算数值的平均值。</li>
<li><strong>MAX:</strong> 返回最大值。</li>
<li><strong>MIN:</strong> 返回最小值。</li>
</ul>
<p><strong>LIMIT 1:</strong></p>
<p>LIMIT约束返回值结果数量</p>
<p><strong>子查询</strong></p>
<blockquote>
<p>推荐使用子查询</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> region, total_sales</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> region, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line">    <span class="keyword">FROM</span> sales</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> region</span><br><span class="line">) <span class="keyword">AS</span> regional_sales</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total_sales <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, last_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>
<p><code>union</code></p>
<p>合并查询结果</p>
<ul>
<li><strong>UNION</strong>: 会自动去除合并结果集中的重复行，只保留唯一的行。 这涉及到额外的排序和去重操作，因此性能相对较差。</li>
<li><strong>UNION ALL</strong>: 简单地将所有 SELECT 语句的结果集合并，保留所有行，包括重复的行。 性能较高，因为它避免了去重操作。</li>
</ul>
<blockquote>
<p><strong>列的数量必须相同</strong>： 所有 SELECT 语句必须返回相同数量的列。</p>
<p><strong>对应列的数据类型必须兼容</strong>： 每个 SELECT 语句中对应位置的列的数据类型必须兼容（可以隐式转换），以便可以合并到一个列中。</p>
<p><strong>列名可以不同，但结果集会采用第一个 SELECT 语句的列名</strong>： 合并后的结果集会使用第一个 SELECT 语句中的列名作为最终的列名。 如果需要指定不同的列名，可以在第一个 SELECT 语句中使用 AS 别名。</p>
</blockquote>
<h2 id="SQL执行流程">SQL执行流程</h2>
<img src="/2024/08/10/Database-Learning-Record/db-mysql-sql-8.png" class="" title="img">
<img src="/2024/08/10/Database-Learning-Record/db-mysql-sql-14.png" class="" title="sqlworkflow">
<p>app 使用数据库连接池连接数据库</p>
<p>数据库线程接收连接，得到sql语句</p>
<p>sql语句解析</p>
<p>sql语句查询优化</p>
<p>执行器调用存储引擎的接口去完成 SQL 的执行</p>
<blockquote>
<p>进入存储引擎</p>
</blockquote>
<p>MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中</p>
<p>在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</p>
<p>innodb 会在 Buffer Pool 中执行更新操作</p>
<p>更新后的数据会记录在 redo log buffer 中</p>
<p>完成以后就可以提交事务，在提交的同时会做以下三件事</p>
<ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
<h2 id="property">property</h2>
<h3 id="数据库事务的-ACID-特性">数据库事务的 ACID 特性</h3>
<p>ACID 是数据库事务的四个重要特性，它们保证了事务的可靠性和一致性。</p>
<p><strong>1. 原子性 (Atomicity)</strong></p>
<ul>
<li><strong>定义:</strong> 一个事务的所有操作要么全部成功执行，要么全部不执行，不会出现部分成功部分失败的情况。</li>
<li><strong>作用:</strong> 保证数据库状态的一致性，即使事务执行过程中发生错误，数据库也能回滚到事务开始前的状态，就像什么都没发生过一样。</li>
<li><strong>举例:</strong> 转账操作需要从账户 A 扣款并向账户 B 加款，这两个操作必须作为一个整体执行，要么都成功，要么都失败。如果只扣款成功而加款失败，就会导致数据不一致。</li>
</ul>
<p><strong>2. 一致性 (Consistency)</strong></p>
<ul>
<li><strong>定义:</strong> 事务执行前后，数据库必须保持一致的状态，满足所有预定义的约束和规则。</li>
<li><strong>作用:</strong> 保证数据库数据的完整性和正确性，防止数据出现逻辑上的错误。</li>
<li><strong>举例:</strong> 银行账户的余额不能小于零。如果一个事务导致账户余额变为负数，则该事务违反了一致性约束，数据库会回滚事务，保持数据一致性。</li>
</ul>
<p><strong>3. 隔离性 (Isolation)</strong></p>
<ul>
<li><strong>定义:</strong> 多个事务并发执行时，彼此之间相互隔离，互不干扰，就像每个事务都是独立执行的一样。</li>
<li><strong>作用:</strong> 防止并发事务之间的数据冲突，保证每个事务都能看到一致的数据。</li>
<li><strong>举例:</strong> 用户 A 和用户 B 同时读取账户 C 的余额，然后分别进行转账操作。隔离性保证了用户 A 和用户 B 的操作不会相互影响，每个用户都能看到正确的账户余额。</li>
</ul>
<p><strong>4. 持久性 (Durability)</strong></p>
<ul>
<li><strong>定义:</strong> 一旦事务提交成功，其对数据库的修改将永久保存，即使数据库发生故障也不会丢失。</li>
<li><strong>作用:</strong> 保证数据的可靠性和安全性，即使系统崩溃，数据也能恢复到最新状态。</li>
<li><strong>举例:</strong> 用户 A 成功转账后，即使数据库突然断电，转账操作的结果也不会丢失，数据库重启后，账户 A 和账户 B 的余额仍然会反映转账后的状态。</li>
</ul>
<h3 id="隔离级别">隔离级别</h3>
<p><strong>1. Read Uncommitted (读未提交)</strong></p>
<ul>
<li><strong>特点:</strong> 事务可以读取到其他未提交事务的数据。</li>
<li><strong>问题:</strong>
<ul>
<li><strong>脏读 (Dirty Read):</strong> 事务 A 读取了事务 B 未提交的数据，如果事务 B 回滚，事务 A 读取的数据就是无效的。</li>
</ul>
</li>
<li><strong>应用场景:</strong> 几乎没有实际应用场景，因为脏读会导致数据严重不一致。</li>
</ul>
<p><strong>2. Read Committed (读已提交)</strong></p>
<ul>
<li><strong>特点:</strong> 事务只能读取到其他已提交事务的数据。</li>
<li><strong>问题:</strong>
<ul>
<li><strong>不可重复读 (Non-repeatable Read):</strong> 同一个事务内多次读取同一数据，读取到的结果可能不同，因为其他事务可能已经修改并提交了该数据。</li>
</ul>
</li>
<li><strong>应用场景:</strong> 大多数数据库默认的隔离级别，可以避免脏读，但存在不可重复读的问题。</li>
</ul>
<p><strong>3. Repeatable Read (可重复读)</strong></p>
<ul>
<li><strong>特点:</strong> 同一个事务内多次读取同一数据，读取到的结果相同，即使其他事务已经修改并提交了该数据。</li>
<li><strong>问题:</strong>
<ul>
<li><strong>幻读 (Phantom Read):</strong> 事务 A 读取某个范围的数据，事务 B 在该范围内插入或删除了数据，导致事务 A 再次读取时，发现结果集发生了变化。</li>
</ul>
</li>
<li><strong>应用场景:</strong> MySQL InnoDB 引擎默认的隔离级别，可以避免脏读和不可重复读，但存在幻读的问题。</li>
</ul>
<p><strong>4. Serializable (串行化)</strong></p>
<ul>
<li><strong>特点:</strong> 所有事务串行执行，相当于只有一个事务在执行，避免了所有并发问题。</li>
<li><strong>问题:</strong> 并发性能极低，因为所有事务都需要排队执行。</li>
<li><strong>应用场景:</strong> 对数据一致性要求极高的场景，例如金融交易。</li>
</ul>
<h2 id="MVCC">MVCC</h2>
<h3 id="基本概念">基本概念</h3>
<p>事务隔离级别实现：通过向<strong>普通行</strong>引入隐藏列的方式实现</p>
<p>UNDO Log</p>
<ul>
<li><strong>针对单个行的undo log：</strong> 对于数据库的每一行数据，UNDO日志会记录对该行数据的每一次修改之前的值，比如针对某行数据的UPDATE操作，会记录修改之前该行数据的完整内容。这些UNDO日志条目会通过类似链表的方式连接起来。 新的修改产生新的UNDO日志条目，指向之前的UNDO日志条目，形成一个历史链。</li>
<li><strong>针对整个事务的undo log：</strong> 对于整个事务来说，事务开始的时候，会记录一个特殊的UNDO日志条目，这个条目可以理解为整个事务的链表头。 事务中，每一个操作产生的UNDO日志条目会链接到这个链表上。 这样，就可以通过这个链表，按照操作相反的顺序，撤销事务中所有的修改。</li>
</ul>
<p>例如：</p>
<ol>
<li><strong>对于 insert 操作:</strong>
<ul>
<li>Undo Log 会记录下如何撤销 insert 操作的信息。 通常，这会包括删除刚刚创建的行的必要信息（例如：表名、行的唯一标识符）。</li>
<li>Undo Log 实际上存储的是删除该行的操作。</li>
</ul>
</li>
<li><strong>对于 update 操作:</strong>
<ul>
<li>Undo Log 会记录被修改行的原始值（修改前的完整数据）。</li>
<li>Undo Log 会记录修改发生所在的表、行标识符以及被修改的字段。</li>
<li>Undo Log 中会包含指向前一个版本 Undo Log 的指针，形成一个链。</li>
</ul>
</li>
<li><strong>事务的链式结构:</strong>
<ul>
<li>事务开始时，会创建一个 “事务开始” Undo Log 条目。</li>
<li>该事务内的所有 CREATE 和 CHANGE 操作的 Undo Log 条目都会链接到这个 “事务开始” 条目，形成一个链。 这个链保证了可以按照相反的顺序撤销事务中的所有操作。</li>
</ul>
</li>
</ol>
<p><a href="https://www.cnblogs.com/cswiki/p/15338928.html">https://www.cnblogs.com/cswiki/p/15338928.html</a></p>
<p>字段</p>
<ul>
<li>DB_TRX_ID: 存储修改该行的事务id</li>
<li>DB_ROLL_PTR: 新数据存储指向旧数据列的指针（update）</li>
<li>ROW_ID: 无主键id时启用</li>
</ul>
<img src="/2024/08/10/Database-Learning-Record/20210924000726.png" class="" title="img">
<p><strong>ReadView：判断当前事务能够看见哪些版本的</strong></p>
<ul>
<li><code>m_ids</code>：生成 ReadView 时有哪些事务在执行但是还没提交的（称为 ”<strong>活跃事务</strong>“），这些活跃事务的 id 就存在这个字段里</li>
<li><code>min_trx_id</code>：m_ids 里最小的值，<strong>当前事务启动时最大trx_id的已提交事务</strong></li>
<li><code>max_trx_id</code>：生成 ReadView 时下一个会启动事务的 ID 的值（事务 ID 是递增分配的，越后面申请的事务 ID 越大）</li>
<li><code>creator_trx_id</code>：当前创建 ReadView 事务的 ID</li>
</ul>
<p>事务A(trx_id = 100)，小于min_trx_id，事务B可以看见事务A的修改</p>
<p>事务C(trx_id = 300)，位于(min_trx_id, max_trx_id)之中，事务B不能看见事务C的修改（insert，update），通过undo log查到小于min_trx_id版本的值</p>
<p>事务D(trx_id = 500)，大于max_trx_id，事务B不能看见事务D的修改</p>
<img src="/2024/08/10/Database-Learning-Record/20210924205057.png" class="" title="img">
<h3 id="MVCC与幻读">MVCC与幻读</h3>
<p>通过MVCC实现快照读（select  * from table where …）</p>
<p>通过间隙锁实现当前读（select … for update）</p>
<h2 id="MySQL-Struc">MySQL Struc</h2>
<img src="/2024/08/10/Database-Learning-Record/image-20240919111718667.png" class="" title="image-20240919111718667">
<h3 id="基本信息">基本信息</h3>
<p>页 作为 B树的节点</p>
<p>B树的节点，每个节点均包含数条数据</p>
<p>页中 行的主键作为B树节点的key</p>
<img src="/2024/08/10/Database-Learning-Record/image-20240919155834155.png" class="" title="image-20240919155834155">
<p>B+树</p>
<p>将原B树的 <strong>非叶子节点的数据行</strong> 存放在 <strong>叶子节点</strong>，原 <strong>非叶子节点的数据行</strong> 数据区域变更为保存目标页地址 -&gt; 稳定查询次数</p>
<p><strong>非叶子节点</strong>由于不再保存真实数据，可保存条目增加 -&gt; 树高度降低</p>
<p>叶子节点通过指针连接 -&gt; 范围查询</p>
<img src="/2024/08/10/Database-Learning-Record/image-20240919160103358.png" class="" title="image-20240919160103358">
<p><strong>Buffer Pool</strong></p>
<p>存储页</p>
<h3 id="Undo-Log">Undo Log</h3>
<p><strong>Undo Log 刷盘</strong></p>
<p>在 MySQL 中，<code>UNDO LOG</code> 默认是存储在 <code>InnoDB</code> 的表空间中的，具体来说，它存储在 <strong>Undo Tablespace</strong> 中。<code>UNDO LOG</code> 并不是直接存储在内存中，而是会定期刷盘到磁盘上，以确保事务的持久性和一致性。</p>
<p>在 MySQL 5.7 及更高版本中，<code>UNDO LOG</code> 默认存储在独立的 Undo Tablespace 中（而不是在系统表空间中），并且这些 Undo Tablespace 文件会定期刷盘到磁盘上。</p>
<p><strong>内存中的 UNDO LOG 如何清理？</strong></p>
<p>内存中的 <code>UNDO LOG</code> 主要通过以下机制进行清理：</p>
<ol>
<li><strong>事务提交或回滚</strong>：当一个事务提交或回滚时，相关的 <code>UNDO LOG</code> 会被标记为可清理状态。事务提交后，<code>UNDO LOG</code> 不再需要用于回滚，因此可以被清理。</li>
<li><strong>Purge 线程</strong>：MySQL 有一个后台的 <strong>Purge 线程</strong>，负责清理不再需要的 <code>UNDO LOG</code>。Purge 线程会定期扫描 <code>UNDO LOG</code>，并清理那些已经不再被任何活动事务引用的 <code>UNDO LOG</code> 记录。</li>
<li><strong>Undo Tablespace 回收</strong>：当 <code>UNDO LOG</code> 被清理后，相关的空间会被回收，以便后续的事务可以复用这些空间。MySQL 会自动管理 Undo Tablespace 的大小，确保不会无限增长。</li>
<li><strong>Undo Log 的轮转</strong>：MySQL 会定期轮转 <code>UNDO LOG</code>，即当某个 Undo Tablespace 中的 <code>UNDO LOG</code> 记录不再需要时，MySQL 会将其标记为可重用，并在需要时覆盖这些空间。</li>
</ol>
<h3 id="redo-log-和-binlog">redo log 和 binlog</h3>
<img src="/2024/08/10/Database-Learning-Record/wal.png" class="" title="img">
<p>事务开始时，记录对数据库的修改，同时写入redo log和Undo log，如果发生崩溃，可通过redo log重放恢复到崩溃前状态</p>
<p>redo log 和 binlog 均需要持久化到磁盘</p>
<blockquote>
<p>redo log在磁盘上是顺序写，效率高于修改数据后直接写磁盘时的随机写；</p>
<p>因此，修改数据直接修改位于Buffer Pool中的脏页，通过追加写redo log刷盘</p>
</blockquote>
<p>redo log非直接写入磁盘，相似的，redolog先写入redo log buffer，在以下时机刷入磁盘：</p>
<ul>
<li>MySQL正常关闭时刷入磁盘</li>
<li>当redo log buffer中记录量大于redo log buffer总容量的一半时刷入磁盘</li>
<li>Innodb后台线程每1秒执行刷入磁盘</li>
<li>事务提交时刷入磁盘（参数innodb_flush_log_at_trx_commit控制）</li>
</ul>
<p>文件系统中存在两个redo log file，redo log buffer刷盘时，环形写入redo log file0和redo log file1；</p>
<p>check point表示buffer pool中脏页已刷盘，不需要重放的数据。如果write pos追上check point，则MySQL会强制暂停开始将buffer pool脏页刷盘；</p>
<img src="/2024/08/10/Database-Learning-Record/checkpoint.png" class="" title="img">
<p>事务每条语句会产生一条 binlog 记录到 binlog buffer；当事务提交时，写 binlog buffer 到磁盘；</p>
<p>binlog 只记录对数据库的更新操作</p>
<p><strong>对比</strong></p>
<p>适用对象</p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎均可使用</li>
<li>redo log 是 MySQL 存储引擎实现的日志</li>
</ul>
<p>文件格式</p>
<ul>
<li>binlog 存在 3 种格式：STATEMENT(修改操作), ROW(修改结果), MIXED，为二进制文件形式</li>
<li>redolog 存储执行过的 DML 语句</li>
</ul>
<p>写入方式</p>
<ul>
<li>binlog 追加写，写满了创建新文件</li>
<li>redo log 循环写，写满从头开始循环</li>
</ul>
<h3 id="主索引与辅助索引"><strong>主索引与辅助索引</strong></h3>
<p><strong>是否需要建立索引以及在哪些列上建立索引通常由程序员手动指定</strong>。虽然一些数据库系统（如 MySQL）可能自动为主键和唯一键创建索引，但其他索引需要开发人员根据实际查询需求来手动设计和创建。</p>
<p>当为其他列创建索引时，<strong>数据库会额外创建一棵新的 B+ 树</strong>，用于存储该列的索引结构。</p>
<p><strong>创建表时，主索引和辅助索引的结构：</strong></p>
<ul>
<li>在使用 InnoDB 存储引擎时：
<ul>
<li>主索引实际上就是数据本身，数据按照主键的顺序存储。</li>
<li>辅助索引是单独的结构，它存储了对应的列值（即索引列值）和主键值的映射关系。</li>
</ul>
</li>
<li>辅助索引并不是单独存储“完整数据行”，它仅包含辅助索引列和主键值。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 主索引</span></span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    INDEX idx_name (name) <span class="comment">-- 辅助索引</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在此表中：</p>
<ul>
<li>主索引：<code>id</code> 直接存储了完整的数据行。</li>
<li>辅助索引 <code>idx_name</code>：存储了 <code>name</code> 列及其对应的主键值 <code>id</code>。</li>
</ul>
<hr>
<p><strong>查询过程：</strong> 当执行以下查询时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查询过程如下：</p>
<ol>
<li>MySQL 使用辅助索引 <code>idx_name</code>，找到 <code>name = 'Alice'</code> 对应的主键值 <code>id</code>（假如为 <code>10</code>）。</li>
<li>根据找到的主键值 <code>id = 10</code>，再到主索引（即主键 <code>id</code> 对应的聚簇索引）中找到完整的数据行。</li>
</ol>
<p>这种过程叫做 <strong>回表操作</strong>，因为查询先通过辅助索引，再“回到”主索引获取数据。</p>
<hr>
<p><strong>主索引 vs 辅助索引的查询效率</strong></p>
<ul>
<li>如果 <code>WHERE</code> 子句使用主键（如 <code>id = 10</code>），直接通过主索引找到数据行，<strong>无需回表</strong>，查询效率最高。</li>
<li>如果 <code>WHERE</code> 子句使用的是辅助索引列（如 <code>name = 'Alice'</code>），需要回表查找完整数据行，效率相对稍低。</li>
<li>如果查询只涉及辅助索引的列（如 <code>SELECT name FROM students WHERE name = 'Alice'</code>），MySQL 可能会 <strong>覆盖索引</strong>，直接从辅助索引中返回结果，无需回表。</li>
</ul>
<h3 id="联合索引与优化">联合索引与优化</h3>
<p>联合索引核心：</p>
<p>（a,b,c）a全局有序，在a相同的情况下b有序，ab相同情况下c有序</p>
<p><strong>联合索引</strong>将多个列的值按照一定的顺序拼接在一起，作为 B+ 树中每个节点的 <code>key</code>。树节点按照索引列的顺序存储，先比较第一个列（即主列）的值，如果相同，再比较第二个列的值，以此类推。</p>
<blockquote>
<p>索引列的顺序很重要，应按照查询条件的常用模式设计，以充分利用左前缀原则。</p>
<p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<hr>
<p>著作权归@pdai所有 原文链接：<a href="https://pdai.tech/md/db/sql-mysql/sql-mysql-index-improve-mt.html">https://pdai.tech/md/db/sql-mysql/sql-mysql-index-improve-mt.html</a></p>
</blockquote>
<p><strong>示例：</strong></p>
<p>假设表 <code>payment</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> payment (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    staff_id <span class="type">INT</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建多列索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_customer_staff <span class="keyword">ON</span> payment (customer_id, staff_id);</span><br></pre></td></tr></table></figure>
<p>索引内容（B+ 树的 <code>key</code>）可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(customer_id, staff_id) -&gt; id</span><br><span class="line">(101, 1) -&gt; 10</span><br><span class="line">(101, 2) -&gt; 11</span><br><span class="line">(102, 1) -&gt; 12</span><br></pre></td></tr></table></figure>
<p><strong>B+ 树节点存储：</strong></p>
<p>每个节点的 <code>key</code> 是 <code>(customer_id, staff_id)</code> 的组合值，而 <code>value</code> 是主键 <code>id</code> 或行的物理指针。</p>
<ul>
<li>比如对于 <code>(101, 1)</code>，<code>key</code> 是 <code>101</code> 和 <code>1</code> 的组合，<code>value</code> 是主键 <code>id</code> 或行的物理指针。</li>
</ul>
<p><strong>前缀索引</strong></p>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，使用前缀索引可以降低索引的存储空间，同时提升查询效率。</p>
<ul>
<li>
<p>全列索引（索引整个 <code>email</code> 列）可能占用大量空间，特别是对于长字符串。</p>
</li>
<li>
<p>前缀索引通过截取前 N 个字符，既能节省空间又能加速匹配。</p>
</li>
<li>
<p>前缀长度应根据选择性确定，避免索引过短导致大量重复值。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设表 emails 中 email 列为 VARCHAR(255)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emails (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    content TEXT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建前缀索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_email_prefix <span class="keyword">ON</span> emails (email(<span class="number">10</span>)); <span class="comment">-- 只索引前 10 个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emails <span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;example%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>MySQL 不使用索引的情况：</strong></p>
<ul>
<li>索引列被计算或函数包裹。</li>
<li>复合索引不符合最左前缀原则。</li>
<li>存在范围查询阻断索引匹配。</li>
<li>列的区分度过低或隐式类型转换。</li>
</ul>
<p><strong>索引的使用场景</strong></p>
<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li>
<li>对于中到大型的表，索引就非常有效。</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
<p>著作权归@pdai所有 原文链接：<a href="https://pdai.tech/md/db/sql-mysql/sql-mysql-b-tree.html">https://pdai.tech/md/db/sql-mysql/sql-mysql-b-tree.html</a></p>
<p><strong>自适应哈希索引 (Adaptive Hash Index, AHI)</strong></p>
<ol>
<li><strong>监控热点页:</strong> InnoDB 引擎会监控索引页的访问频率。当某个索引页被频繁访问，达到预设阈值后，会被认为是热点页。</li>
<li><strong>创建哈希索引:</strong> InnoDB 引擎会自动为热点页创建哈希索引，并将哈希索引存储在内存的哈希表中。</li>
<li><strong>加速查询:</strong> 当执行查询时，InnoDB 引擎会先查找哈希索引。如果找到匹配项，可以直接定位到对应的索引页，避免了 B-tree 索引的多次查找，从而提升查询效率。</li>
</ol>
<p><strong>Undo Buffer &amp;&amp; Undo Tablespace</strong></p>
<p>Undo Log 记录了事务中每一个数据修改操作的反向操作，例如：</p>
<ul>
<li>插入操作的 Undo Log 记录了删除相应记录的操作。</li>
<li>更新操作的 Undo Log 记录了将数据恢复到旧值的操作。</li>
<li>删除操作的 Undo Log 记录了插入被删除记录的操作。</li>
</ul>
<p><strong>Undo Log</strong> 主要用于事务回滚和实现 MVCC</p>
<blockquote>
<p><strong>读取一致性 (MVCC)：</strong> 即使事务 A 已经提交，其他未提交的事务或使用了快照读的事务仍然可能需要访问事务 A 修改之前的数据版本。Undo Log 中保留的事务 A 的记录可以用来构建这些旧版本的数据，保证读取一致性。</p>
</blockquote>
<p>Undo Log 存储在 Undo Tablespace 中，可以配置为独立的表空间或 InnoDB 系统表空间的一部分</p>
<p><strong>Redo Log Buffer &amp;&amp;  Redo Log Files</strong></p>
<p>Redo Log 记录了数据库的物理修改，例如：</p>
<ul>
<li>在哪个数据页修改了哪个字节，修改后的值是什么。</li>
</ul>
<p>当事务修改数据时，先将修改记录写入 Redo Log Buffer, 在事务提交时，将 Redo Log Buffer 中的内容刷新到 Redo Log Files, 数据库崩溃恢复/内存掉电数据清空时，会读取 Redo Log Files，重新执行其中的修改操作，将数据库恢复到崩溃前的最新状态。</p>
<p><strong>Redo Log 的作用是保证已提交事务的持久性，而不是未提交事务的恢复。</strong></p>
<p>Redo Log 存储在 Redo Log Files 中，通常是两个或多个循环使用的文件。</p>
<h2 id="MySQL存储引擎">MySQL存储引擎</h2>
<p>MyISAM 存储引擎 和 InnoDB 存储引擎</p>
<p>InnoDB 存储引擎：</p>
<ul>
<li>B+树索引的叶子节点保存数据本身；</li>
<li>支持事务，外键约束</li>
<li>更新密集，</li>
</ul>
<blockquote>
<p>外键约束：在表B中指定某字段为外键后（表A的主键），插入数据时必须是表A中存在的值；外键不一定非要引用其他表的<strong>主键</strong>。虽然通常情况下，外键是用来引用其他表的主键或唯一约束（<code>UNIQUE</code>）字段，但外键实际上可以引用表中的任何列，只要该列具有<strong>唯一性约束</strong>，比如<code>UNIQUE</code>或<code>PRIMARY KEY</code>。</p>
<p>如果在外键约束中设置了级联删除，当你在表A中删除某行时，表B中所有引用该行的记录也会被自动删除。如果在外键约束中设置了“置空”操作，当你删除表A中的记录时，表B中所有引用该记录的外键字段会被置为<code>NULL</code>。这意味着表B中不再关联任何表A中的行，但表B中的其他数据仍然存在。</p>
</blockquote>
<p>MyISAM 存储引擎：</p>
<ul>
<li>B+树索引的叶子节点保存数据的物理地址；</li>
<li>MyISAM表无法处理事务</li>
<li>MyISAM存储引擎在筛选大量数据时非常迅速，并发插入特性允许同时选择和插入数据。</li>
</ul>
<h2 id="MySQL主从复制">MySQL主从复制</h2>
<p>MySQL的主从复制为BinLog</p>
<img src="/2024/08/10/Database-Learning-Record/master-slave.png" class="" title="mysqlms">
<p>主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> : 负责将主服务器上的数据更改写入二进制日志中。</li>
<li><strong>I/O 线程</strong> : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li>
<li><strong>SQL 线程</strong> : 负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<p><strong>流程</strong></p>
<ol>
<li><strong>主数据库</strong>接收到一个写操作（如 INSERT、UPDATE、DELETE）时，会将这个操作记录到二进制日志（Binary Log）中，将数据修改的操作按顺序记录下来。</li>
<li><strong>从数据库</strong> IO 线程会自动连接<strong>主数据库</strong>，从二进制日志中读取操作信息，记录到中继日志（Relay Log）中。</li>
<li>从数据库的 SQL 线程会定期从中继日志中获取同步数据，写入到从数据库中。</li>
</ol>
<p><strong>Bin Log 日志格式</strong></p>
<p>Binary Log 二级制日志，它总共有以下三种格式（不同的日志格式决定了不同的主从同步效果）：</p>
<ol>
<li>STATEMENT 格式（语句模式，出现在 MySQL 5.1 之前）：在这种格式下，binlog 记录的是执行的 SQL 语句的文本。
<ol>
<li>优点：日志文件通常较小，复制效率较高。</li>
<li>缺点：在某些情况下，由于数据库环境的差异（如表结构、字符集等），在从服务器上重放这些 SQL 语句可能会导致不一致的结果。例如，获取当前时间的函数或存储过程等，可能会导致数据不一致。</li>
</ol>
</li>
<li>ROW 格式（行模式，诞生于 MySQL 5.1）：在这种格式下，binlog 记录的是每一行数据更改的具体内容。
<ol>
<li>优点：能够精确地记录数据的变化，避免了 STATEMENT 格式中的环境依赖问题，提供了更强的一致性保证。</li>
<li>缺点：日志文件可能会比 STATEMENT 格式大，因为记录了每一行的详细变化。此外，ROW 格式的日志在进行大量数据更新时可能会导致更高的 I/O 开销。</li>
</ol>
</li>
<li>MIXED 格式（混合模式）：在这种格式下，binlog 可以根据具体的 SQL 语句和操作自动选择使用 STATEMENT 或 ROW 格式。
<ol>
<li>优点：结合了 STATEMENT 和 ROW 格式的优点，能够在保证一致性的同时尽可能地优化日志大小和复制性能。</li>
<li>缺点：由于混合使用了两种格式，可能需要更复杂的管理和监控。在某些特定情况下，MIXED 格式可能无法达到最优的性能或一致性。</li>
</ol>
</li>
</ol>
<p><strong>主从复制模式</strong></p>
<p>MySQL 中主要有以下两种主从复制的模式，分别是异步复制和半同步复制。</p>
<ol>
<li>异步复制：MySQL 主从复制中最常见和默认的模式。在异步复制模式中，主服务器将数据修改操作记录到二进制日志（Binary Log）中，并由<strong>从服务器</strong>的IO线程读取<strong>主服务器</strong>日志。从服务器接收到二进制日志后，会异步地应用这些日志进行数据复制。
<ol>
<li>优点：它的优点是及时响应给使用者，主服务器不会受到从服务器的影响而等待确认，可以提高主服务器的性能。</li>
<li>缺点：由于是异步复制，可能存在数据传输的延迟，且从服务器上的复制过程是不可靠的。如果主服务器故障，尚未应用到从服务器的数据可能会丢失。</li>
</ol>
</li>
<li>半同步复制：半同步复制是 MySQL 主从复制中的一种增强模式。在半同步复制模式中，主服务器将数据修改操作记录到二进制日志，并等待至少一个从服务器确认已接收到并应用了这些日志后才继续执行后续操作。
<ol>
<li>优点：可以提供更高的数据一致性和可靠性，确保至少一个从服务器与主服务器保持同步。如果主服务器故障，已经确认接收并应用到从服务器的数据不会丢失。</li>
<li>缺点：由于半同步复制需要等待从服务器的确认，因此相对于异步复制，会增加一定的延迟，可能会影响主服务器的性能。</li>
</ol>
</li>
</ol>
<p>如果对数据一致性和可靠性要求较高，可以考虑使用半同步复制；如果对延迟和主服务器性能要求较高，可以继续使用异步复制，根据实际需求调整复制模式。</p>
<h2 id="MySQL锁">MySQL锁</h2>
<h3 id="表级锁">表级锁</h3>
<p>意向锁</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>作用对象</th>
<th>主要用途</th>
<th>是否冲突</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IS 锁</strong></td>
<td>表级</td>
<td>表示事务要在某些行加 <strong>S 锁</strong></td>
<td><strong>不与 IS 或 IX 冲突</strong>，但与 <strong>表级 X 锁</strong> 冲突</td>
</tr>
<tr>
<td><strong>IX 锁</strong></td>
<td>表级</td>
<td>表示事务要在某些行加 <strong>X 锁</strong></td>
<td><strong>不与 IS 或 IX 冲突</strong>，但与 <strong>表级 S/X 锁</strong> 冲突</td>
</tr>
<tr>
<td><strong>S 锁</strong></td>
<td>行级</td>
<td>允许读取但不允许修改该行</td>
<td><strong>与 X 锁冲突</strong></td>
</tr>
<tr>
<td><strong>X 锁</strong></td>
<td>行级</td>
<td>允许读写该行，其他事务不能访问</td>
<td><strong>与 S/X 锁冲突</strong></td>
</tr>
</tbody>
</table>
<p>意向锁用于，当某个事务尝试对表进行加锁时，不需要遍历查找该表的行级锁加锁情况</p>
<h3 id="行级锁">行级锁</h3>
<p>行级锁分为</p>
<ul>
<li>X行级锁</li>
<li>S行级锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... lock in share mode </span><br></pre></td></tr></table></figure>
<p>获取S锁 (next-key lock)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... for update </span><br><span class="line"></span><br><span class="line">update ... </span><br><span class="line"></span><br><span class="line">delete ...</span><br></pre></td></tr></table></figure>
<p>获取X锁 (next-key lock)</p>
<blockquote>
<p>insert … 语句插入受阻时获取插入意向锁</p>
<p>插入意向锁为一种特殊的间隙锁，即插入意向锁与插入意向锁不互斥，与其他类型锁互斥</p>
<p>场景：如果被插区间存在间隙锁，获取意向锁；</p>
</blockquote>
<p>行级锁分为</p>
<ul>
<li>
<p>next-key lock（临键锁 = 记录锁+间隙锁）<strong>左开右闭</strong></p>
</li>
<li>
<p>记录锁</p>
</li>
<li>
<p>间隙锁 <strong>左开右开</strong></p>
</li>
</ul>
<blockquote>
<p>间隙锁不互斥，包括区间覆盖</p>
</blockquote>
<h3 id="锁对象">锁对象</h3>
<p>基于索引加锁</p>
<p>使用主键索引查询时，仅在在主键索引（聚簇索引）上加锁</p>
<p>使用非主键索引查询时，在二级索引上加锁，同时加锁主键索引</p>
<p>不使用索引会导致锁全表</p>
<h2 id="索引">索引</h2>
<p>主索引，即聚簇索引（也称聚集索引，clustered index）</p>
<p>辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）。</p>
<img src="/2024/08/10/Database-Learning-Record/db-mysql-index-1.png" class="" title="index">
<p>如上图，<strong>主键索引的叶子节点保存的是真正的数据。而辅助索引叶子节点的数据区保存的是主键索引关键字的值</strong>。</p>
<p>假如要查询name = C 的数据，其搜索过程如下：a) 先在辅助索引中通过C查询最后找到主键id = 9; b) 在主键索引中搜索id为9的数据，最终在主键索引的叶子节点中获取到真正的数据。所以通过辅助索引进行检索，需要检索两次索引。</p>
<p>之所以这样设计，一个原因就是：如果和MyISAM一样在主键索引和辅助索引的叶子节点中都存放数据行指针，一旦数据发生迁移，则需要去重新组织维护所有的索引。</p>
<p>ref: <a href="https://pdai.tech/md/interview/x-interview.html#_8-2-mysql">https://pdai.tech/md/interview/x-interview.html#_8-2-mysql</a></p>
<br>
<p><strong>索引失效场景</strong></p>
<ul>
<li>
<p>使用左或者左右模糊搜素，例如，<code>like %xx</code>, <code>like %xx%</code></p>
</li>
<li>
<p>对索引列使用函数/表达式计算</p>
</li>
<li>
<p>对索引隐式类型转化（例如，String转int，发生了函数计算）</p>
</li>
<li>
<p>联合索引非最左匹配</p>
</li>
<li>
<p>WHERE 子句使用 OR，存在 OR 的字段不是索引列</p>
</li>
</ul>
<br>
<p><strong>索引构建原则</strong></p>
<p>最左前缀匹配原则</p>
<blockquote>
<p>注意，假如说联合索引为 (a,b,c)，执行查询 <code>where b = 1 and a = 2</code>，将使用索引！SQL优化器会重排序where语句中约束的位置</p>
<p>执行查询 <code>where a = 1 and c = 3</code> ，会发生索引截断：</p>
<p>对于 MySQL 5.5 ，将通过 a 在联合索引查找到主键值，回表，获取数据行，对数据行进行 c 的筛选；</p>
<p>对于 MySQL 5.6 ~，将进行索引下推；引擎层直接筛选出满足 a 和 c 条件的数据行</p>
</blockquote>
<p>选择区分度高的列作为索引</p>
<p>索引列不能参与计算</p>
<blockquote>
<p>索引的B+树中保存的是字段值，如果对字段使用函数，则需要将该字段的值计算为新值，无法使用索引</p>
</blockquote>
<br>
<p><strong>组合索引</strong></p>
<img src="/2024/08/10/Database-Learning-Record/492e0e5857459a335db7c7aea5377791.png" class="" title="combine_index">
<blockquote>
<p>感觉可用理解为，每一个filed均进行hashcode计算，然后加和，然后按照和的大小建立B+树</p>
</blockquote>
<br>
<h3 id="案例">案例</h3>
<p>下面把 <code>SELECT * FROM table LIMIT 1000, 10</code> 的执行过程与关键细节讲清楚（以 MySQL/InnoDB 为例，其他数据库思路相近）：</p>
<ol>
<li>这条 SQL 在干什么</li>
</ol>
<ul>
<li><code>LIMIT 1000, 10</code> = <strong>跳过前 1000 行</strong>，再<strong>取 10 行</strong>。</li>
<li>没有 <code>ORDER BY</code> 就<strong>不保证返回顺序</strong>（通常是所选访问路径的顺序，如聚簇主键顺序），两次执行可能拿到<strong>不一样</strong>的 10 行。</li>
</ul>
<ol start="2">
<li>引擎内部的步骤（简化）</li>
</ol>
<ol>
<li>
<p><strong>解析/优化</strong><br>
语法分析 → 基于统计信息选择访问路径（全表扫描、走某个索引、是否需要回表、是否 filesort 等）。</p>
</li>
<li>
<p><strong>访问路径</strong></p>
<ul>
<li>无 <code>WHERE</code>、无 <code>ORDER BY</code>：通常选<strong>全表顺序读</strong>（InnoDB 聚簇主键顺序）。</li>
<li>有 <code>WHERE</code>：尽量用索引做<strong>范围/等值扫描</strong>；若 <code>SELECT *</code> 且用到二级索引，需要<strong>回表</strong>（根据二级索引的主键值再到聚簇索引取整行）。</li>
<li>有 <code>ORDER BY</code>：若<strong>排序列与方向</strong>与某个索引完全匹配，可<strong>按索引有序扫描</strong>；否则会建临时结构做<strong>filesort</strong>。</li>
</ul>
</li>
<li>
<p><strong>应用 OFFSET / LIMIT</strong><br>
不管访问路径如何，执行器都会先<strong>数到第 1000 行</strong>（满足条件/顺序的行）——这些行<strong>也需要被读到</strong>（可能还要回表），但<strong>直接丢弃不返回</strong>；随后把<strong>接下来的 10 行</strong>返回给客户端。</p>
<blockquote>
<p>成本近似 O(offset + limit)，因此大偏移量会贵在“白读白丢”的 1000 行。</p>
</blockquote>
</li>
<li>
<p><strong>返回结果</strong><br>
服务器通常<strong>流式</strong>逐行返回，不会把全部结果缓存完再发（除非排序/临时表需要）。</p>
</li>
</ol>
<ol start="3">
<li>性能与代价</li>
</ol>
<ul>
<li><strong>大 OFFSET 代价高</strong>：即使只要 10 行，也要读并跳过前 1000 行（且可能每行都要回表）。</li>
<li><strong>SELECT *</strong>：更容易触发<strong>回表</strong>与更大的行拷贝成本；覆盖索引能省回表但前提是查询列都在同一个索引里。</li>
<li><strong>无 ORDER BY</strong>：结果<strong>不稳定</strong>且优化器可能选择不同路径，分页体验不可控。</li>
<li><strong>ORDER BY 不走索引</strong>：会 filesort，可能产生临时表与额外 IO。</li>
</ul>
<br>
<h2 id="SQL优化">SQL优化</h2>
<p>使用 <code>EXPLAIN</code> 优化</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;HR&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p><strong>explain</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">distinct</span> cert.emp_id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         emp.id <span class="keyword">as</span> emp_id,</span><br><span class="line">         emp_cert.id <span class="keyword">as</span> cert_id </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         employee emp </span><br><span class="line">      <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">         emp_certificate emp_cert </span><br><span class="line">            <span class="keyword">on</span> emp.id <span class="operator">=</span> emp_cert.emp_id </span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">         emp.is_deleted<span class="operator">=</span><span class="number">0</span></span><br><span class="line">   ) cert </span><br><span class="line">      <span class="keyword">on</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.emp_id</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">or</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.cert_id</span><br><span class="line">      ) </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>思路：将 cm_log 表与 (emp+emp_cert) cert 表取交集，约束范围并返回emp_id</p>
<blockquote>
<p>显然 (emp+emp_cert) cert 表的行数肯定很多，再和一个没有做值筛选的表进行交集，非常慢</p>
<p>优化思路，将  cm_log 表分别与 emp 表和 emp_cert 表做交集，再union</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>PRIMARY</td>
<td>cl</td>
<td>range</td>
<td>cm_log_cls_id,idx_last_upd_date</td>
<td>idx_last_upd_date</td>
<td>8</td>
<td>NULL</td>
<td>379</td>
<td>Using where; Using temporary</td>
</tr>
<tr>
<td>1</td>
<td>PRIMARY</td>
<td>&lt;derived2&gt;</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>63727</td>
<td>Using where; Using join buffer</td>
</tr>
<tr>
<td>2</td>
<td>DERIVED</td>
<td>emp</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>13317</td>
<td>Using where</td>
</tr>
<tr>
<td>2</td>
<td>DERIVED</td>
<td>emp_cert</td>
<td>ref</td>
<td>emp_certificate_empid</td>
<td>emp_certificate_empid</td>
<td>4</td>
<td><a href="http://meituanorg.emp.id">meituanorg.emp.id</a></td>
<td>1</td>
<td>Using index</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>id = 1 (PRIMARY)</strong>：这是最外层的 SELECT 查询。
<ul>
<li>table = cl：该查询首先访问 cm_log 表（cl）。</li>
<li>type = range：使用了范围扫描，通过索引进行查询。</li>
<li>possible_keys = cm_log_cls_id, idx_last_upd_date：优化器考虑了两个索引 cm_log_cls_id 和 idx_last_upd_date。</li>
<li>key = idx_last_upd_date：最终选择了 idx_last_upd_date 索引。</li>
<li>key_len = 8：使用了索引的全部长度。</li>
<li>rows = 379：估计需要扫描 379 行。</li>
<li>Extra = Using where; Using temporary：Using where 表示在索引扫描后，还需要进行 WHERE 条件的过滤。Using temporary 表示需要使用临时表来处理结果，通常发生在需要排序或者去重操作时，这里很有可能是 distinct 导致。</li>
<li>table = &lt;derived2&gt;：该查询还需要访问 id=2 的子查询产生的结果表，也就是子查询 cert。</li>
<li>type = ALL：对子查询的结果表进行了全表扫描。</li>
<li>rows = 63727：估计需要扫描 63727 行。</li>
<li>Extra = Using where; Using join buffer：Using where 表示需要进行 WHERE 条件的过滤。 Using join buffer 说明 MySQL 使用了 Join Buffer 来加速 Join 过程。</li>
</ul>
</li>
<li><strong>id = 2 (DERIVED)</strong>：这是一个子查询，别名为 cert。
<ul>
<li>table = emp：该子查询首先访问 employee 表（emp）。</li>
<li>type = ALL：对 employee 表进行了全表扫描。</li>
<li>rows = 13317：估计需要扫描 13317 行。</li>
<li>Extra = Using where：表示在全表扫描后，需要进行 WHERE 条件 emp.is_deleted=0 的过滤。</li>
<li>table = emp_cert：该子查询还访问 emp_certificate 表（emp_cert）。</li>
<li>type = ref：使用了 ref 类型的连接，通过索引进行查询。</li>
<li>possible_keys = emp_certificate_empid：优化器考虑了索引 emp_certificate_empid。</li>
<li>key = emp_certificate_empid：最终选择了 emp_certificate_empid 索引。</li>
<li>key_len = 4：使用了索引的全部长度。</li>
<li>ref = <a href="http://meituanorg.emp.id">meituanorg.emp.id</a>：使用 <a href="http://emp.id">emp.id</a> 作为索引的参考值。</li>
<li>rows = 1：估计对于每个 <a href="http://emp.id">emp.id</a>，只需要扫描 emp_certificate 表的 1 行。</li>
<li>Extra = Using index：表示查询可以直接使用索引中的数据，不需要回表查询。</li>
</ul>
</li>
</ul>
<hr>
<p>著作权归@pdai所有 原文链接：<a href="https://pdai.tech/md/db/sql-mysql/sql-mysql-index-improve-mt.html">https://pdai.tech/md/db/sql-mysql/sql-mysql-index-improve-mt.html</a></p>
<p><strong>错误用法</strong>：<code>from_unixtime(create_time) = '2014-05-29'</code></p>
<ul>
<li>这个查询会使用<code>from_unixtime</code>函数对<code>create_time</code>进行转换，然后与字符串<code>'2014-05-29'</code>比较。</li>
<li>问题是，在这种情况下，<code>create_time</code>字段的索引将无法使用，因为<code>from_unixtime(create_time)</code>会使得数据库需要对每个<code>create_time</code>值都进行函数计算，无法直接通过索引定位到对应的记录。</li>
<li>结果是，查询性能会下降，数据库可能需要全表扫描。</li>
</ul>
<p><strong>优化用法</strong>：<code>create_time = unix_timestamp('2014-05-29')</code></p>
<ul>
<li>在这种情况下，查询直接使用<code>create_time</code>字段的原始值进行比较，不需要任何计算或函数调用。</li>
<li>因为<code>create_time</code>列上的索引可以直接用于定位记录，查询性能大大提高。</li>
</ul>
<h2 id="Redis">Redis</h2>
<h3 id="语法">语法</h3>
<p>指令 对象 [value]/[key-value]</p>
<h3 id="数据结构-底层原理">数据结构&amp;底层原理</h3>
<img src="/2024/08/10/Database-Learning-Record/db-redis-object-2-3.png" class="" title="redisds">
<p>redis所有数据结构均为 key - value结构</p>
<p><strong>value为以下结构</strong></p>
<p>String(~)</p>
<img src="/2024/08/10/Database-Learning-Record/raw.png" class="" title="img">
<ul>
<li>int 或者 SDS， SDS由长度（<code>len</code>）、内存空间大小（<code>alloc</code>）、字符串类型（<code>flags</code>）和存储的字节数组（<code>buf</code>）四个部分组成。</li>
</ul>
<p>可用场景：分布式锁，分布式session，原子计数</p>
<p>List(L~)</p>
<p>在Redis 3.2版本后，List数据结构底层实现为 quicklist</p>
<p>3.2版本前</p>
<ul>
<li>压缩列表（列表中单个数据小于64字节，列表中数据个数小于512个）
<ul>
<li>每个元素使用（数据长+数据值）存储，每个元素size不等</li>
<li>不等长元素压缩了存储空间</li>
</ul>
</li>
<li>双向循环列表</li>
</ul>
<p>Hash(H~)</p>
<p>在Reids 7.0后，替换压缩列表为 listpack 结构</p>
<ul>
<li>压缩列表（字典中单个K-V小于64字节，字典中中K-V个数小于512个）</li>
<li>哈希表
<ul>
<li>自动扩容 + 链表</li>
</ul>
</li>
</ul>
<p>可用场景：购物车，对象缓存 (key, [(Field, Value), (Field, Value), …]</p>
<p>Set(S~)</p>
<ul>
<li>整数集合（元素均为整数，元素个数小于512个）</li>
<li>哈希表</li>
</ul>
<p>可用场景：抽奖活动，点赞，共同关注</p>
<p>Sorted Set(Z~)</p>
<p>Redis 7.0后，压缩列表数据结构被废弃，改为 listpack 实现</p>
<ul>
<li>压缩列表（元素size小于64字节，元素个数小于512个）</li>
<li>跳表 + 字典</li>
</ul>
<img src="/2024/08/10/Database-Learning-Record/19063731-d7bc5026051ea412.png" class="" title="skip-pic">
<img src="/2024/08/10/Database-Learning-Record/image-20250306123144745.png" class="" title="image-20250306123144745">
<p>可用场景：排行榜，电话/姓名排序，延迟队列</p>
<p>Bitmap(~BIT)</p>
<ul>
<li>String/bit数组</li>
</ul>
<p>可用场景：签到统计，判断用户登录状态，连续签到用户总数</p>
<p>Geo(GEO)</p>
<h3 id="Redis持久化">Redis持久化</h3>
<p>Redis 的数据持久化机制允许将内存中的数据保存到磁盘文件，以便在服务重启或宕机后可以恢复数据。主要有以下两种机制：</p>
<p><strong>RDB（Redis DataBase）持久化</strong></p>
<p>RDB 是 Redis 的快照方式，定期将内存中的数据以二进制文件的形式保存到磁盘。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li>Redis 会通过 <code>SAVE</code> 或 <code>BGSAVE</code> 命令生成 RDB 文件。
<ul>
<li><code>SAVE</code> 命令：
<ul>
<li>在主线程中完成快照保存操作，阻塞 Redis 的读写。</li>
</ul>
</li>
<li><code>BGSAVE</code> 命令：
<ul>
<li>Redis 创建一个子进程，子进程负责将数据写入 RDB 文件，主线程继续处理客户端请求。</li>
<li>子进程生成快照时使用写时复制（Copy-On-Write, COW）技术，保证数据一致性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>触发方式：</strong></p>
<ul>
<li>
<p>**自动触发：**通过配置文件中的 <code>save</code> 选项设置定期触发规则。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1   # 15 分钟内有 1 次写操作</span><br><span class="line">save 300 10  # 5 分钟内有 10 次写操作</span><br><span class="line">save 60 10000 # 1 分钟内有 10000 次写操作</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>**手动触发：**执行 <code>SAVE</code> 或 <code>BGSAVE</code> 命令。</p>
</li>
</ul>
<p><strong>读写影响：</strong></p>
<ul>
<li>**<code>SAVE</code> 命令：**阻塞主线程，影响读写性能，适合非高负载场景。</li>
<li>**<code>BGSAVE</code> 命令：**使用子进程完成，但可能增加系统 I/O 压力，特别是数据量较大时。</li>
</ul>
<hr>
<p><strong>AOF（Append Only File）持久化</strong></p>
<p>AOF 是 Redis 的日志方式，将每次写操作记录到日志文件中，可以通过重放日志恢复数据。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li>Redis 将每次写操作的命令追加到 AOF 文件末尾。</li>
<li>支持三种同步策略（通过 <code>appendfsync</code> 参数配置）：
<ol>
<li>**always：**每次写操作都同步到磁盘，最安全但性能较差。</li>
<li>**everysec：**每秒同步一次，默认设置，兼顾性能与数据安全。</li>
<li>**no：**由操作系统决定何时同步，性能最好，但可能丢失数据。</li>
</ol>
</li>
</ul>
<p><strong>触发重写：</strong></p>
<ul>
<li>AOF 文件会不断增长，因此需要定期重写（rewrite）以压缩日志。</li>
<li>Redis 通过 <code>BGREWRITEAOF</code> 命令创建子进程完成重写，类似 <code>BGSAVE</code>。</li>
</ul>
<p><strong>读写影响：</strong></p>
<ul>
<li>**追加模式：**性能影响较小，因写操作只需追加日志。</li>
<li>**重写操作：**由子进程完成，主线程继续处理请求，可能增加 I/O 压力。</li>
</ul>
<h3 id="Redis-淘汰机制">Redis 淘汰机制</h3>
<p><strong>Redis 过期键的删除策略</strong></p>
<p>Redis 主要有两种策略来删除过期键：</p>
<ul>
<li><strong>惰性删除（Lazy Deletion）</strong>：当一个键被访问时，Redis 会检查该键是否已经过期。如果已过期，Redis 会删除该键，并返回相应的空值。这种方式只会在键被访问时检查过期情况，并删除过期键，可能会导致一些过期键在一段时间内仍然占用内存。</li>
<li><strong>定期删除（Periodic Deletion）</strong>：Redis 会定期随机检查一部分过期的键，并将其删除。默认情况下，每 100 毫秒 Redis 会随机检查 10 个过期的键进行删除。这种方式不会让过期键永久占用内存，但仍可能存在一些过期键在下一次检查之前不会被删除。</li>
</ul>
<p><strong>内存限制配置</strong></p>
<p>通过参数 <code>maxmemory</code> 设置 Redis 实例的内存上限。可以在配置文件中设置，也可以通过运行时命令动态配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONFIG SET maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Redis 内存淘汰策略</strong></p>
<p>当 Redis 的内存超过最大内存限制（<code>maxmemory</code>）时，会触发内存淘汰机制，通过参数 <code>maxmemory-policy</code> 配置 Redis 的淘汰策略。主要分为以下几种：</p>
<p>不淘汰</p>
<ul>
<li>noeviction （v4.0后默认的）</li>
</ul>
<p>对设置了过期时间的数据中进行淘汰</p>
<ul>
<li>随机：volatile-random</li>
<li>ttl：volatile-ttl</li>
<li>lru：volatile-lru</li>
<li>lfu：volatile-lfu</li>
</ul>
<p>全部数据进行淘汰</p>
<ul>
<li>随机：allkeys-random</li>
<li>lru：allkeys-lru</li>
<li>lfu：allkeys-lfu</li>
</ul>
<blockquote>
<p><strong>LRU 与 LFU 机制</strong></p>
<p>（1）<strong>LRU（Least Recently Used）</strong></p>
<ul>
<li><strong>原理</strong>：淘汰最久未被访问的键。</li>
<li><strong>实现</strong>：Redis 使用一种近似 LRU 算法，通过采样法（默认 5 个键）来选择被淘汰的键。</li>
</ul>
<p>（2）<strong>LFU（Least Frequently Used）</strong></p>
<ul>
<li><strong>原理</strong>：淘汰访问频率最低的键。</li>
<li><strong>实现</strong>：Redis 通过维护一个计数器（<code>counter</code>）跟踪每个键的访问频率，采用递减机制避免计数器无限增长。</li>
</ul>
</blockquote>
<h3 id="Redis高可用">Redis高可用</h3>
<h4 id="持久化">持久化</h4>
<img src="/2024/08/10/Database-Learning-Record/redis-x-rdb-4.jpg" class="" title="redisms">
<ol>
<li>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程; 针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决.</li>
<li>AOF是“写后”日志，Redis先执行命令，把数据<strong>先写入内存，再记录日志</strong>。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。</li>
<li>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</li>
</ol>
<p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>
<hr>
<p>著作权归@pdai所有 原文链接：<a href="https://pdai.tech/md/interview/x-interview.html">https://pdai.tech/md/interview/x-interview.html</a></p>
<p>触发持久化</p>
<p><strong>save命令</strong>：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间<strong>阻塞</strong>，线上环境不建议使用</p>
<p><strong>bgsave命令</strong>：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</p>
<p>RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。</p>
<hr>
<p>著作权归@pdai所有 原文链接：<a href="https://pdai.tech/md/interview/x-interview.html">https://pdai.tech/md/interview/x-interview.html</a></p>
<img src="/2024/08/10/Database-Learning-Record/redis-x-aof-42.jpg" class="" title="bgsavecpow">
<h4 id="集群哨兵">集群哨兵</h4>
<p>主从复制</p>
<p>Redis的主从复制为RDB文件+命令</p>
<img src="/2024/08/10/Database-Learning-Record/db-redis-copy-1.png" class="" title="redisss">
<p>主从库之间采用的是<strong>读写分离</strong>的方式。</p>
<ul>
<li>读操作：主库、从库都可以接收；</li>
<li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li>
</ul>
<p>在2.8版本之前只有全量复制，而2.8版本后有全量和增量复制：</p>
<ul>
<li>
<p><strong>全量（同步）复制</strong>：比如第一次同步时</p>
<img src="/2024/08/10/Database-Learning-Record/db-redis-copy-2.jpg" class="" title="img">
</li>
<li>
<p><strong>增量（同步）复制</strong>：只会把主从库网络断连期间主库收到的命令，同步给从库</p>
<img src="/2024/08/10/Database-Learning-Record/db-redis-copy-3.jpg" class="" title="img">
</li>
</ul>
<p><strong>哨兵</strong></p>
<p><strong>哨兵集群组建</strong></p>
<img src="/2024/08/10/Database-Learning-Record/db-redis-sen-6.jpg" class="" title="img">
<p><strong>监控过程</strong></p>
<img src="/2024/08/10/Database-Learning-Record/db-redis-sen-7.jpg" class="" title="img">
<p><strong>库离线判断</strong></p>
<ul>
<li><strong>主观下线</strong>：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</li>
<li><strong>客观下线</strong>：有哨兵集群共同决定Redis节点是否下线；</li>
</ul>
<p>当某个哨兵（如下图中的哨兵2）判断主库“主观下线”后，就会给其他哨兵发送 <code>is-master-down-by-addr</code> 命令。接着，其他哨兵会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。</p>
<p>如果赞成票数（这里是2）是大于等于哨兵配置文件中的 <code>quorum</code> 配置项（比如这里如果是quorum=2）, 则可以判定<strong>主库客观下线</strong>了。</p>
<hr>
<p>著作权归@pdai所有 原文链接：<a href="https://pdai.tech/md/interview/x-interview.html">https://pdai.tech/md/interview/x-interview.html</a></p>
<img src="/2024/08/10/Database-Learning-Record/db-redis-sen-2.jpg" class="" title="img">
<blockquote>
<p><strong>Redis 哨兵的选举机制是什么样的？</strong></p>
<p>Redis 哨兵（Sentinel）是 Redis 集群中负责监控、通知、自动故障转移和服务发现的组件。它的选举机制是确保在主节点（Master）故障时，能够自动选举一个新的主节点，并促使系统恢复正常运行。</p>
<ul>
<li><strong>哨兵的选举机制是什么样的</strong>？</li>
</ul>
<p>哨兵的选举机制其实很简单，就是一个Raft选举算法： <strong>选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举</strong></p>
<p>Raft算法可以参看这篇文章<a href="">分布式算法 - Raft算法</a></p>
<ul>
<li>任何一个想成为 主节点 的节点，要满足两个条件：
<ul>
<li>第一，拿到半数以上的赞成票；</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li>
</ul>
</li>
</ul>
<p>以 3 个哨兵为例，假设此时的 quorum 设置为 2，那么，任何一个想成为主节点 只要拿到 2 张赞成票，就可以了。</p>
<p><a href="#redis-1%E4%B8%BB4%E4%BB%8E-5%E4%B8%AA%E5%93%A8%E5%85%B5-%E5%93%A8%E5%85%B5%E9%85%8D%E7%BD%AEquorum%E4%B8%BA2-%E5%A6%82%E6%9E%9C3%E4%B8%AA%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C-%E5%BD%93%E4%B8%BB%E5%BA%93%E5%AE%95%E6%9C%BA%E6%97%B6-%E5%93%A8%E5%85%B5%E8%83%BD%E5%90%A6%E5%88%A4%E6%96%AD%E4%B8%BB%E5%BA%93-%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF-%E8%83%BD%E5%90%A6%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2">#</a>Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主库“客观下线”？能否自动切换？</p>
<p>经过实际测试：</p>
<p>1、哨兵集群可以判定主库“客观下线”。由于quorum=2，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了quorum的值，因此，<strong>哨兵集群可以判定主库为“客观下线”</strong>。</p>
<p>2、<strong>但哨兵不能完成主从切换</strong>。哨兵标记主库“客观下线后”，在选举“主节点”时，一个节点必须拿到超过多数的选票(5/2+1=3票)。但目前只有2个哨兵活着，无论怎么投票，一个节点最多只能拿到2票，永远无法达到<code>N/2+1</code>选票的结果。</p>
</blockquote>
<p><strong>故障转移</strong></p>
<img src="/2024/08/10/Database-Learning-Record/db-redis-sen-4.png" class="" title="img">
<h3 id="Lua脚本-与-Redis事务">Lua脚本 与 Redis事务</h3>
<p><strong>Lua脚本</strong>：</p>
<ul>
<li>Redis 在执行 Lua 脚本时，保证脚本中的所有命令在一个原子操作内完成。即使脚本包含多个 Redis 命令，这些命令也不会被其他客户端的命令插入。</li>
<li>Redis 使用单线程模型，Lua 脚本执行期间不会有其他命令被执行，因此具备天然的原子性。</li>
</ul>
<p><strong>事务（MULTI/EXEC）</strong>：</p>
<ul>
<li>Redis 事务中的命令从 MULTI 到 EXEC 的提交过程被称为事务块。但 Redis 不保证事务中的命令是完全原子的。</li>
<li>如果事务中的某些命令失败（例如操作数据类型错误），事务中其他命令仍会执行。</li>
<li>事务本质上是批量发送命令，但它不提供类似 Lua 的原子性保障。</li>
</ul>
<blockquote>
<p>“事务本质上是批量发送命令”，这意味着如果多个客户端向redis服务端发送事务块，由于一个redis服务端执行命令是单线程的，<strong>有很大可能这多个客户端的事务块中的命令是交错执行的</strong>，没有保证原子性</p>
</blockquote>
<h3 id="Redis-分布式锁"><strong>Redis 分布式锁</strong></h3>
<p><strong>场景</strong></p>
<p>假设在一个电商系统中，多个服务实例同时对商品库存进行扣减操作，为了防止超卖问题，需要引入分布式锁来保证同一时间只有一个实例可以操作某件商品的库存。</p>
<p><strong>实现</strong></p>
<p>使用 Redis 的 <code>SET</code> 指令实现分布式锁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 Redis</span></span><br><span class="line">redis_client = redis.StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, decode_responses=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">acquire_lock</span>(<span class="params">lock_key, lock_value, expire_time</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    尝试获取锁</span></span><br><span class="line"><span class="string">    :param lock_key: 锁的键</span></span><br><span class="line"><span class="string">    :param lock_value: 锁的唯一标识值（通常用 UUID）</span></span><br><span class="line"><span class="string">    :param expire_time: 锁的过期时间（单位：秒）</span></span><br><span class="line"><span class="string">    :return: True 获取成功，False 获取失败</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> redis_client.<span class="built_in">set</span>(lock_key, lock_value, ex=expire_time, nx=<span class="literal">True</span>)  // 使用SETNX实现</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">release_lock</span>(<span class="params">lock_key, lock_value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    释放锁</span></span><br><span class="line"><span class="string">    :param lock_key: 锁的键</span></span><br><span class="line"><span class="string">    :param lock_value: 锁的唯一标识值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">        return redis.call(&quot;DEL&quot;, KEYS[1])</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">        return 0</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    redis_client.<span class="built_in">eval</span>(script, <span class="number">1</span>, lock_key, lock_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：使用锁</span></span><br><span class="line">lock_key = <span class="string">&quot;product_123_lock&quot;</span></span><br><span class="line">lock_value = <span class="string">&quot;unique_id_456&quot;</span>  <span class="comment"># 通常用 UUID 生成</span></span><br><span class="line">expire_time = <span class="number">10</span>  <span class="comment"># 锁的过期时间为 10 秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> acquire_lock(lock_key, lock_value, expire_time):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;获取锁成功，处理逻辑...&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">5</span>)  <span class="comment"># 模拟业务逻辑</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        release_lock(lock_key, lock_value)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;锁已释放&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;获取锁失败，稍后再试&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong></p>
<ol>
<li>SET 命令的参数：
<ul>
<li><code>NX</code> 表示当键不存在时才设置。</li>
<li><code>EX</code> 表示设置键的过期时间。</li>
</ul>
</li>
<li>使用 Lua 脚本保证释放锁的原子性。</li>
<li>锁的 <code>value</code> 必须唯一，用于避免误释放其他线程的锁。</li>
</ol>
<h3 id="Redis-分布式会话"><strong>Redis 分布式会话</strong></h3>
<p><strong>场景</strong></p>
<p>在分布式系统中，用户的会话信息（如登录状态）需要共享在多个实例之间。Redis 是常用的分布式会话存储解决方案。</p>
<p><strong>实现</strong></p>
<p>假设用户登录系统后，生成一个会话 ID（如 <code>session_id</code>），将用户信息存储到 Redis 中。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 Redis</span></span><br><span class="line">redis_client = redis.StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, decode_responses=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_session</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建会话</span></span><br><span class="line"><span class="string">    :param user_id: 用户 ID</span></span><br><span class="line"><span class="string">    :return: session_id</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    session_id = <span class="built_in">str</span>(uuid.uuid4())  <span class="comment"># 生成唯一会话 ID</span></span><br><span class="line">    session_key = <span class="string">f&quot;session:<span class="subst">&#123;session_id&#125;</span>&quot;</span></span><br><span class="line">    session_data = &#123;<span class="string">&quot;user_id&quot;</span>: user_id, <span class="string">&quot;login_time&quot;</span>: time.time()&#125;</span><br><span class="line">    redis_client.hmset(session_key, session_data)</span><br><span class="line">    redis_client.expire(session_key, <span class="number">3600</span>)  <span class="comment"># 设置过期时间为 1 小时</span></span><br><span class="line">    <span class="keyword">return</span> session_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_session</span>(<span class="params">session_id</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取会话信息</span></span><br><span class="line"><span class="string">    :param session_id: 会话 ID</span></span><br><span class="line"><span class="string">    :return: 会话数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    session_key = <span class="string">f&quot;session:<span class="subst">&#123;session_id&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> redis_client.hgetall(session_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_session</span>(<span class="params">session_id</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    删除会话</span></span><br><span class="line"><span class="string">    :param session_id: 会话 ID</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    session_key = <span class="string">f&quot;session:<span class="subst">&#123;session_id&#125;</span>&quot;</span></span><br><span class="line">    redis_client.delete(session_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：创建和获取会话</span></span><br><span class="line">user_id = <span class="number">101</span></span><br><span class="line">session_id = create_session(user_id)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;新会话创建成功：<span class="subst">&#123;session_id&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取会话</span></span><br><span class="line">session_data = get_session(session_id)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;会话数据：<span class="subst">&#123;session_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除会话</span></span><br><span class="line">delete_session(session_id)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;会话已删除&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong></p>
<ol>
<li><strong>会话 ID</strong>：每个用户对应一个唯一会话 ID，可通过 <code>uuid</code> 生成。</li>
<li><strong>会话存储格式</strong>：通常使用 Redis 的哈希结构（<code>HSET</code>）存储用户数据。</li>
<li><strong>会话过期时间</strong>：通过 <code>EXPIRE</code> 设置会话的有效期，超时后自动清除。</li>
</ol>
<h2 id="Redis-分布式锁-2">Redis 分布式锁</h2>
<table>
<thead>
<tr>
<th>分类</th>
<th>方案</th>
<th>实现原理</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于数据库</td>
<td>基于mysql 表唯一索引</td>
<td>1.表增加唯一索引 2.加锁：执行insert语句，若报错，则表明加锁失败 3.解锁：执行delete语句</td>
<td>完全利用DB现有能力，实现简单</td>
<td>1.锁无超时自动失效机制，有死锁风险 2.不支持锁重入，不支持阻塞等待 3.操作数据库开销大，性能不高</td>
</tr>
<tr>
<td>基于MongoDB findAndModify原子操作</td>
<td>1.加锁：执行findAndModify原子命令查找document，若不存在则新增 2.解锁：删除document</td>
<td>实现也很容易，较基于MySQL唯一索引的方案，性能要好很多</td>
<td>1.大部分公司数据库用MySQL，可能缺乏相应的MongoDB运维、开发人员 2.锁无超时自动失效机制</td>
<td></td>
</tr>
<tr>
<td>基于分布式协调系统</td>
<td>基于ZooKeeper</td>
<td>1.加锁：在/lock目录下创建临时有序节点，判断创建的节点序号是否最小。若是，则表示获取到锁；否，则则watch /lock目录下序号比自身小的前一个节点 2.解锁：删除节点</td>
<td>1.由zk保障系统高可用 2.Curator框架已原生支持系列分布式锁命令，使用简单</td>
<td>需单独维护一套zk集群，维保成本高</td>
</tr>
<tr>
<td>基于缓存</td>
<td>基于redis命令</td>
<td>1. 加锁：执行setnx，若成功再执行expire添加过期时间 2. 解锁：执行delete命令</td>
<td>实现简单，相比数据库和分布式系统的实现，该方案最轻，性能最好</td>
<td>1.setnx和expire分2步执行，非原子操作；若setnx执行成功，但expire执行失败，就可能出现死锁 2.delete命令存在误删除非当前线程持有的锁的可能 3.不支持阻塞等待、不可重入</td>
</tr>
<tr>
<td>基于缓存</td>
<td>基于redis Lua脚本能力</td>
<td>1. 加锁：执行SET lock_name random_value EX seconds NX 命令  2. 解锁：执行Lua脚本，释放锁时验证random_value  – ARGV[1]为random_value, KEYS[1]为lock_nameif redis.call(“get”, KEYS[1]) == ARGV[1] then  return redis.call(“del”,KEYS[1])else  return 0end</td>
<td>同上；实现逻辑上也更严谨，除了单点问题，生产环境采用用这种方案，问题也不大。</td>
<td>不支持锁重入，不支持阻塞等待</td>
</tr>
</tbody>
</table>
<p><strong>Redisson 分布式重入锁用法</strong></p>
<p>Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：</p>
<p><strong>底层原理</strong>：Redisson 使用 Redis 实现分布式锁。通过 Redis 的 <code>SETNX</code> 命令（SET if Not eXists）和键值过期机制，确保即使某个客户端崩溃，锁也会自动过期，不会导致死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.构造redisson实现分布式锁必要的Config</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:5379&quot;</span>).setPassword(<span class="string">&quot;123456&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2.构造RedissonClient</span></span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"><span class="comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.尝试获取锁</span></span><br><span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><br><span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rLock.tryLock((<span class="type">long</span>)waitTimeout, (<span class="type">long</span>)leaseTime, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;aquire lock fail&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redis-与-数据库-数据一致性">Redis 与 数据库 数据一致性</h2>
<p>假设 redis，数据库 存在相同数据</p>
<p><strong>方案 1：删缓存写数据库</strong></p>
<img src="/2024/08/10/Database-Learning-Record/ed50ea3d-77c9-42fc-bafe-6a5d1349cacb" class="" title="img">
<p>存在图中所示问题</p>
<p><strong>方案 2：写数据库，删缓存</strong></p>
<img src="/2024/08/10/Database-Learning-Record/cff9f70e-fa29-4188-873f-7daabc142dab" class="" title="img">
<p><strong>流程：</strong></p>
<ul>
<li>直接修改数据库中的数据</li>
<li>数据库完成修改后，删除redis中数据----（分界线：此动作前后查询到的数据发生变化）</li>
<li>访问redis发生缺失时，触发miss并查询数据库新数据，然后写入redis</li>
</ul>
<p>方案2可能存在的问题：</p>
<p>假设A请求更新了数据库，还未情况缓存的情况下，B请求拿到的是缓存内的旧数据，因为A还没来得及把新的数据填充到缓存。</p>
<p>极端条件</p>
<img src="/2024/08/10/Database-Learning-Record/03971152-0047-4160-a366-599329148f02" class="" title="img">
<p>如图</p>
<p>删除Redis中缓存时失败</p>
<ul>
<li>获取不到 Redis 连接，因为单个 Redis 节点的连接有限，如果用完了则无法获取，进而报错。</li>
<li>如果 Redis 服务器宕机或网络不可用，将导致无法执行任何 Redis 操作。</li>
<li>由于网络故障或延迟，可能导致 Redis 操作失败。</li>
</ul>
<p>解决方案：</p>
<p>方案1：redis中数据均设置较短的过期时长，删除失败等待其过期</p>
<p>方案2：若删除失败，将Redis Key写入待删除数据库表中，通过定时任务扫描待删除表，尝试再次删除</p>
<p><strong>方案3：缓存双删</strong></p>
<img src="/2024/08/10/Database-Learning-Record/01b1956b-a3b0-451a-83bb-7117859ef9b5" class="" title="img">
<p>可能存在问题：无法保证第二次删除在读请求回写缓存之后</p>
<p>通过引入消息队列/延迟队列实现</p>
<img src="/2024/08/10/Database-Learning-Record/885e438e-cf54-41f6-880e-faf36e72cd57" class="" title="img">
<p><strong>方案4：Binlog 配合 MQ 实现缓存一致性</strong></p>
<img src="/2024/08/10/Database-Learning-Record/f2993d30-3803-4543-97db-f98cdca3a493" class="" title="img">
<h2 id="分库分表相关">分库分表相关</h2>
<blockquote>
<p>流程：单表 -&gt; 读写分离 -&gt; 分表 -&gt; 分库</p>
</blockquote>
<p><strong>场景</strong></p>
<p>分库：数据库连接可用量不够</p>
<p>分表：单表过大</p>
<p><strong>分库分表方法</strong></p>
<p>垂直分：按列，domain划分</p>
<ul>
<li>按照业务相关内容，划分为用户表，订单表，…</li>
</ul>
<p>水平分：按行，范围划分</p>
<ul>
<li>按照覆盖范围，例如，将用户名 HashCode 取 10 的余数划分</li>
</ul>
<p>分库分表框架</p>
<p>ShardingSphere</p>
<p>通过框架进行分片：user_0, user_1, user_2 …</p>
<blockquote>
<p>就是分出来的各个表，使用 hash code 取模</p>
</blockquote>
<p>分片键：</p>
<ul>
<li>经常访问的数据需放在同一个分片上</li>
<li>数据均匀的分布在各分片上</li>
<li>分片键应该不可变</li>
</ul>
<h2 id="缓存穿透，缓存雪崩，缓存击穿">缓存穿透，缓存雪崩，缓存击穿</h2>
<p><strong>缓存穿透</strong></p>
<p>客户端请求缓存和数据库中不存在的数据，导致所有的请求都打到数据库上</p>
<p>考虑限流 + 暂存不存在数据到缓存 + 布隆过滤器（布隆过滤器将维护所有合法key）</p>
<p><strong>缓存击穿</strong></p>
<p>缓存过期 / 缓存被不正常移除，导致查询命中数据库</p>
<p>判断热点数据过期逻辑是否合适</p>
<p><strong>缓存雪崩</strong></p>
<p>缓存大面积过期 / 缓存大量被移除，导致大量查询命中数据库</p>
<p>缓存预热 + 重设热点数据过期时间（例如，加入随机过期时间）+ 加入同步锁</p>
<h2 id="缓存可用性">缓存可用性</h2>
<p>提高Redis可用性：Redis集群架构 + 主从哨兵</p>
<p>减少对Redis依赖：加入本地缓存 Guava</p>
<p>业务降级：限流</p>
<h2 id="count-与-count-1">count(*) 与 count(1)</h2>
<p><code>count()</code> 用于统计复合条件的记录中，函数指定参数不为null的记录的数量</p>
<p><strong>性能排序</strong></p>
<p>count(*) = count(1) &gt; count(主键字段) &gt; count(字段)</p>
<p>count(1) 表示 在表中，使 <code>1</code> 这个表达式不为NULL的记录的数量</p>
<p>count(*) = count(0)</p>
<h2 id="一致性哈希">一致性哈希</h2>
<p>一致性哈希算法就很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。</p>
<p><strong>一致哈希算法是对 2^32 进行取模运算，是一个固定的值</strong>。</p>
<p>对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；</p>
<p>当对数据进行存储或访问时，对数据进行哈希映射；</p>
<p><strong>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</strong>。</p>
<p>例如，对于某数据A，进行哈希映射后位于哈希环的某位置；从该位置出发，沿着哈希环顺时针找到第一个节点，保存到该节点</p>
<p>存在节点不均匀问题</p>
<p>解决方案：使用虚拟节点均匀分布在哈希环上， 真实节点分散的映射到虚拟节点</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL, Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Learning-Record</title>
    <url>/2024/07/28/Android-Learning-Record/</url>
    <content><![CDATA[<p>Android学习记录</p>
<span id="more"></span>
<h1>Android Learning Record</h1>
<h2 id="Android程序">Android程序</h2>
<h3 id="View">View</h3>
<p><strong>dp 和 sp</strong></p>
<p><strong>dp (Density-independent Pixel - 密度无关像素)</strong></p>
<ul>
<li><strong>定义:</strong> dp 是一个基于屏幕密度的抽象单位。它代表了在 160 dpi (dots per inch) 屏幕上一个物理像素的长度。</li>
<li><strong>用途:</strong> 主要用于定义 View 的尺寸和间距，例如按钮的宽度、边距、内边距等。</li>
<li><strong>优势:</strong> 使用 dp 可以保证应用在不同屏幕密度的设备上保持一致的显示效果。系统会根据设备的屏幕密度自动将 dp 值转换为对应的像素值。</li>
<li><strong>示例:</strong>
<ul>
<li>android:layout_width=“100dp” 表示该 View 的宽度为 100dp，在不同密度的屏幕上，系统会将其转换为对应的像素值，以保持相同的物理尺寸。</li>
</ul>
</li>
</ul>
<p><strong>sp (Scale-independent Pixel - 缩放无关像素)</strong></p>
<ul>
<li><strong>定义:</strong> sp 与 dp 类似，也是一个基于屏幕密度的抽象单位。不同之处在于，sp 还受到用户字体大小设置的影响。</li>
<li><strong>用途:</strong> 主要用于定义文字大小。</li>
<li><strong>优势:</strong> 使用 sp 可以根据用户的字体大小偏好自动调整文字大小，提高应用的可访问性。</li>
<li><strong>示例:</strong>
<ul>
<li>android:textSize=“18sp” 表示该 TextView 的文字大小为 18sp，如果用户在系统设置中调整了字体大小，该 TextView 的文字大小也会随之改变。</li>
</ul>
</li>
</ul>
<p><strong>layout_gravity 和 gravity</strong></p>
<p><strong>layout_gravity</strong></p>
<ul>
<li><strong>作用目标:</strong> layout_gravity 属性用于控制 <strong>当前 View 在其父布局中的对齐方式</strong>。</li>
<li><strong>适用范围:</strong> 该属性只能应用于 <strong>ViewGroup 的子 View</strong>，因为它需要依赖于父布局的特性才能生效。</li>
<li><strong>常见取值:</strong>
<ul>
<li>top、bottom、left、right：分别表示顶部对齐、底部对齐、左侧对齐、右侧对齐。</li>
<li>center：表示水平和垂直居中对齐。</li>
<li>center_horizontal、center_vertical：分别表示水平居中对齐、垂直居中对齐。</li>
<li>start、end：分别表示在当前语言环境下，内容开始的方向对齐、内容结束的方向对齐。</li>
<li>可以使用 | 符号组合多个值，例如 android:layout_gravity=“bottom|right” 表示右下角对齐。</li>
</ul>
</li>
</ul>
<p><strong>gravity</strong></p>
<ul>
<li>
<p><strong>作用目标:</strong> gravity 属性用于控制 <strong>当前 View 中的内容对齐方式</strong>。</p>
</li>
<li>
<p><strong>适用范围:</strong> 该属性可以应用于 <strong>任何 View</strong>，因为它控制的是 View 自身内容的显示方式。</p>
</li>
<li>
<p><strong>常见取值:</strong></p>
<ul>
<li>与 layout_gravity 的取值基本相同，例如 top、bottom、left、right、center 等等。</li>
</ul>
</li>
</ul>
<p><strong>padding 与 margin</strong></p>
<ul>
<li>
<p><strong>padding(内边距)：</strong></p>
<ul>
<li>使视图的内容与其边界保持一定的距离。</li>
<li>使 TextView 中的文字距离 TextView 的边界 10dp，设置 android:padding=“10dp”。</li>
<li>padding 就像是在视图内部加了一圈空白边框，使得内容不会紧贴着视图边界。</li>
</ul>
</li>
<li>
<p><strong>margin(外边距)：</strong></p>
<ul>
<li>控制视图在布局中的位置，或者让视图之间保持一定的距离。</li>
<li>使两个 Button 之间保持 20dp 的距离，就可以为其中一个 Button 设置 android:layout_marginRight=“20dp”，或者为另一个 Button 设置 android:layout_marginLeft=“20dp”。</li>
<li><strong>margin 就像是在视图外部加了一圈透明边框，使得视图与其他视图之间保持一定的距离。</strong></li>
</ul>
</li>
</ul>
<p>margin和padding作用对象都是自身，非其他视图</p>
<p><strong>ConstrainLayout</strong></p>
<ul>
<li>
<p><strong>android:layout_width=“0dp”:</strong> 在 ConstraintLayout 中，将视图的宽度设置为 0dp 是一个特殊的用法。它表示该视图的宽度应该 <strong>匹配约束条件</strong>。在这个例子中，Button 的左右两边分别被约束到了 login_container 的左右两边 (app:layout_constraintEnd_toEndOf=“@id/login_container” 和 app:layout_constraintStart_toStartOf=“@id/login_container”)，因此 Button 的宽度会扩展到与 login_container 的宽度相同。</p>
</li>
<li>
<p><strong>app:layout_margin…</strong>: 这是一组专门用于 ConstraintLayout 的 margin 属性，用于设置视图与其约束目标之间的距离。例如：</p>
<ul>
<li>app:layout_marginStart：设置视图与其约束目标的起始边距（取决于布局方向，可能是左边距或右边距）。</li>
<li>app:layout_marginEnd：设置视图与其约束目标的结束边距。</li>
<li>app:layout_marginTop：设置视图与其约束目标的顶部边距。</li>
<li>app:layout_marginBottom：设置视图与其约束目标的底部边距。</li>
</ul>
</li>
</ul>
<p><strong>RecyclerView</strong></p>
<p>onCreateViewHolder触发时机</p>
<ul>
<li><strong>首次加载 RecyclerView 时：</strong> 当 RecyclerView 第一次被加载到屏幕上时，onCreateViewHolder 方法会被调用，用于创建 ViewHolder 实例。此时，RecyclerView 需要根据你的布局文件实例化 ViewHolder，并将它们缓存起来以备后用。</li>
<li><strong>缓存中没有可用的 ViewHolder 时：</strong> 当用户滚动 RecyclerView，需要显示新的 item，而缓存中没有可用的 ViewHolder 时，onCreateViewHolder 会被调用以创建新的 ViewHolder。</li>
</ul>
<p>onBindViewHolder触发时机</p>
<ul>
<li><strong>首次加载 RecyclerView 时：</strong> 在 onCreateViewHolder 创建了 ViewHolder 后，onBindViewHolder 方法会被立即调用，用于将数据绑定到 ViewHolder 上。</li>
<li><strong>用户滚动 RecyclerView，新的 item 需要显示时：</strong> 当用户滚动 RecyclerView，新的 item 进入屏幕时，onBindViewHolder 会被调用，将对应位置的数据绑定到复用的 ViewHolder 上。</li>
<li><strong>调用 notifyDataSetChanged() 等方法刷新 RecyclerView 时：</strong> 当你更新了数据源并调用 notifyDataSetChanged()、notifyItemInserted() 等方法刷新 RecyclerView 时，onBindViewHolder 会被调用，以更新 ViewHolder 的数据。</li>
</ul>
<p><strong>LayoutInflater</strong></p>
<p>LayoutInflater 是与 Context 绑定的，而 Activity 本身就是一个 Context。每个 Activity 都会持有自己唯一的 LayoutInflater 对象，用于加载布局文件。</p>
<p>该 Activity 中所有的 Fragment 和 RecyclerView 所使用的 LayoutInflater 对象为 Activity 对应的 Context LayoutInflater 对象</p>
<p>**ViewBinding 与 ViewHolder **</p>
<p>在启用ViewBinding后，ViewBinding 会为每个 XML 布局文件生成一个绑定类</p>
<p>针对每个xml文件，将使用(xml的驼峰文件名+Bindng)作为java文件名的方式，生成对应的java类</p>
<p>xml对应生成的 ViewBinding 类：</p>
<p><strong>根视图属性 (<code>root</code>)</strong>:</p>
<ul>
<li>每个生成的 ViewBinding 类都有一个 <code>root</code> 属性，表示布局的根视图（通常是最外层的 <code>ViewGroup</code>），通过 <code>getRoot()</code> 获取，为 View 类型。</li>
</ul>
<p><strong>每个视图的属性 (<code>views</code>)</strong> :</p>
<ul>
<li>对于布局中的每个视图，ViewBinding 类会生成一个相应的属性。这些属性的名称是基于视图的 <code>id</code> 自动生成的，格式为 <code>viewId</code>，其中 <code>viewId</code> 是 XML 布局中视图的 <code>android:id</code> 属性。</li>
</ul>
<p><strong><code>inflate</code> 方法</strong>:</p>
<ul>
<li>ViewBinding 类提供静态 <code>inflate</code> 方法，用于将布局文件转换为相应的视图层次结构，并返回 ViewBinding 类的实例。
<ul>
<li><code>inflate</code> 方法调用 LayoutInflater 将布局文件转换为对应的 View 层级结构。</li>
<li><code>inflate</code> 方法将 View 实例绑定到 Binding 对象的属性中。</li>
</ul>
</li>
</ul>
<p><strong><code>bind</code> 方法</strong>:</p>
<ul>
<li>ViewBinding 类还提供一个静态 <code>bind</code> 方法，用于将现有的视图（比如已经通过 <code>setContentView()</code> 加载的视图）绑定到 ViewBinding 类上。</li>
</ul>
<p>ViewHolder在创建时，通过 new Viewholder(binding) 创建，实际上是将 binding.root 赋值给了 ViewHolder.itemView</p>
<blockquote>
<p>ViewHolder 像是视图的“控制器”: ViewHolder 对根视图 (itemView) 进行了一次封装，但它更像是 MVC 模式中的 Controller，负责管理视图的生命周期、数据绑定、事件处理等逻辑。</p>
<p>ViewHolder 像是视图的“访问器”: ViewBinding 是对 View 树进行了一次包装，但它更像是提供了 类型安全、便捷 的方式来访问视图。</p>
</blockquote>
<h3 id="Context">Context</h3>
<ul>
<li><strong>资源访问:</strong> 获取字符串、颜色、尺寸、图片等资源。</li>
<li><strong>组件启动:</strong> 启动 Activity、Service、BroadcastReceiver 等组件。</li>
<li><strong>系统服务获取:</strong> 获取布局服务 (LayoutInflater)、包管理器 (PackageManager)、通知服务 (NotificationManager) 等系统服务。</li>
<li><strong>文件操作:</strong> 访问设备存储、缓存目录等。</li>
<li><strong>数据库操作:</strong> 使用 SQLite 数据库。</li>
<li><strong>网络操作:</strong> 发送网络请求。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字符串资源</span></span><br><span class="line"><span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> context.getString(R.string.app_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取颜色资源</span></span><br><span class="line"><span class="type">int</span> <span class="variable">primaryColor</span> <span class="operator">=</span> context.getColor(R.color.colorPrimary);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 Activity</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(context, SecondActivity.class);</span><br><span class="line">context.startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取布局加载器</span></span><br><span class="line"><span class="type">LayoutInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> LayoutInflater.from(context);</span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.my_layout, parent, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取包管理器</span></span><br><span class="line"><span class="type">PackageManager</span> <span class="variable">packageManager</span> <span class="operator">=</span> context.getPackageManager();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取通知服务</span></span><br><span class="line"><span class="type">NotificationManager</span> <span class="variable">notificationManager</span> <span class="operator">=</span> </span><br><span class="line">    (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br></pre></td></tr></table></figure>
<p><strong>ContextImpl与ContextWrapper</strong></p>
<p>Context类为抽象类，其中<strong>ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类</strong>。ContextWrapper在初始化时会创建ContextImpl对象，ContextImpl对象实现了Context中方法。</p>
<blockquote>
<p>所以说getApplication()和getApplicationContext()获取到的都是Appliction对象，但是在使用 getApplicationContext() 应该是使用Appliction对象的基类ContextImpl对象</p>
</blockquote>
<p>应用程序中拥有Context的对象：1 + numActivity + numService</p>
<ul>
<li>
<p><strong>Application:</strong> 继承自ContextWrapper</p>
</li>
<li>
<p><strong>Activity:</strong> 继承于ContextWrapper的子类ContextThemeWrapper类，</p>
</li>
<li>
<p><strong>Service:</strong> 继承于ContextWrapper类</p>
</li>
<li>
<p><strong>BroadcastReceiver:</strong> 非继承，通过其他传入获得</p>
</li>
<li>
<p><strong>ContentProvider:</strong> 非继承，通过其他传入获得</p>
</li>
</ul>
<p>启动其他Activity和弹出Dialog必须使用Activity的Context</p>
<ul>
<li>基于某Activity的Context启动的Activity将在此Activity基础上形成任务栈（即Activity栈），如果使用非Activity的Context启动Activity，必须指定该Activity的启动方式为 <code>FLAG_ACTIVITY_NEW_TASK</code></li>
<li>View.getContext返回的是设置该View布局的Activity对象的Context</li>
</ul>
<h2 id="Android">Android</h2>
<h3 id="四大组件">四大组件</h3>
<p>Activity（活动）、Service（服务）、BroadcastReceiver（广播接收器）和 ContentProvider（内容提供者）</p>
<h3 id="持久化">持久化</h3>
<p><strong>文件存储</strong></p>
<p><strong>SharedPreference - DataStore</strong></p>
<p>key - value</p>
<p><strong>SQLite</strong></p>
<p>数据库</p>
<h3 id="Adapter">Adapter</h3>
<p><code>Adapter</code> 负责：</p>
<ul>
<li>从数据源获取数据</li>
<li>创建 <code>View</code> 并将数据绑定到 <code>View</code> 上</li>
<li>通过 <code>notifyDataSetChanged()</code> 动态更新 UI</li>
</ul>
<p>View → adapter → data</p>
<h3 id="Activity与Fragment生命周期">Activity与Fragment生命周期</h3>
<img src="/2024/07/28/Android-Learning-Record/activity_lifecycle.png" class="" title="image1.png">
<p>单个Activity:</p>
<p>应用开启时：onCreate() -&gt; onStart() -&gt; onResume();</p>
<p>按下返回键：onPause() -&gt; onStop() -&gt; onDestory();</p>
<p>多个Activity之间交互时：</p>
<p>从第一个Activity启动第二个Activity时：</p>
<table>
<thead>
<tr>
<th>FirstActivity</th>
<th>SecondActivity</th>
</tr>
</thead>
<tbody>
<tr>
<td>onPause()</td>
<td></td>
</tr>
<tr>
<td></td>
<td>onCreate()</td>
</tr>
<tr>
<td></td>
<td>onStart()</td>
</tr>
<tr>
<td></td>
<td>onResume()</td>
</tr>
<tr>
<td>onStop()</td>
<td></td>
</tr>
</tbody>
</table>
<p>按下锁屏键时</p>
<table>
<thead>
<tr>
<th>SecondActivity</th>
</tr>
</thead>
<tbody>
<tr>
<td>onPause()</td>
</tr>
<tr>
<td>onStop()</td>
</tr>
</tbody>
</table>
<p>屏幕解锁</p>
<table>
<thead>
<tr>
<th>SecondActivity</th>
</tr>
</thead>
<tbody>
<tr>
<td>onRestart()</td>
</tr>
<tr>
<td>OnStart()</td>
</tr>
<tr>
<td>OnResume()</td>
</tr>
</tbody>
</table>
<p>按下返回键 / SecondActivity调用 <code>finish()</code></p>
<table>
<thead>
<tr>
<th>FirstActivity</th>
<th>SecondActivity</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>onPause()</td>
</tr>
<tr>
<td>onRestart()</td>
<td></td>
</tr>
<tr>
<td>onStart()</td>
<td></td>
</tr>
<tr>
<td>onResume()</td>
<td></td>
</tr>
<tr>
<td></td>
<td>onStop()</td>
</tr>
<tr>
<td></td>
<td>onDestory()</td>
</tr>
</tbody>
</table>
<p>Fragment</p>
<p>在创建的过程中，是Activity带领Fragment执行生命周期中的方法，所以生命周期方法的执行顺序是这样的：</p>
<p>1.Activity–onCreate();</p>
<p>2.Fragment–onAttach();</p>
<p>3.Fragment–onCreate();</p>
<p>4.Fragment–onCreateView();</p>
<p>5.Fragment–onActivityCreated();</p>
<p>接着是这样的：</p>
<p>6.Activity–onStart();</p>
<p>7.Fragment–onStart();</p>
<p>8.Activity–onResume();</p>
<p>9.Fragment–onResume();</p>
<p>我们知道，无论对于Activity还是对于Fragment，onResume这个生命周期都是他们执行时间最长的，当我们的Activity或者Fragment打开之后，它就一直处于这个生命周期中。</p>
<p>当销毁的时候，春江水暖鸭先知，当然是Fragment先感知到，于是销毁的时候就是Fragment带领Activity：</p>
<p>10.Fragment–onPause();</p>
<p>11.Activity–onPause();</p>
<p>12.Fragment–onStop();</p>
<p>13.Activity–onStop();</p>
<p>14.Fragment–onDestroyView();</p>
<p>15.Fragment–onDestroy();</p>
<p>16.Fragment–onDetach();</p>
<p>17.Activity–onDestroy();</p>
<p>上面这个顺序有一个前提，就是我们所有的日志打印代码都是紧挨着super方法写。因为如果我们如果把Fragment写在了布局文件中，同时又在Activity的onCreate()方法中的setContentView之后打印日志，那么我们看到的生命周期的执行顺序就会有所不同，不过只是细微的差别，这点大家自己研究，道理也很好明白。</p>
<p>总之一句话，在创建的过程中，是Activity带领着Fragment，在销毁的过程中，是Fragment带领着Activity。</p>
<p>文章来源: <a href="http://wangsong.blog.csdn.net">wangsong.blog.csdn.net</a>，作者：_江南一点雨，版权归原作者所有，如需转载，请联系作者。</p>
<h3 id="智能指针">智能指针</h3>
<p>为了解决手动内存管理带来的问题而设计的。它们通过引用计数来跟踪有多少个指针指向同一个对象。</p>
<ul>
<li>当你创建一个指向对象的智能指针时，对象的引用计数加 1。</li>
<li>当智能指针超出作用域或被赋值为其他值时，引用计数减 1。</li>
<li>当引用计数变为 0 时，智能指针会自动销毁对象，释放内存。</li>
</ul>
<p><strong>循环引用问题</strong>： 对象A中存在智能指针指向对象B，对象B中存在智能指针指向对象A；</p>
<p>由于智能指针的引用计数始终不为0，对象A和对象B将始终不能被释放。</p>
<p><strong>解决方案</strong>：使用弱引用；对某对象使用弱引用将不增加引用计数。</p>
<h3 id="Java层与Native层">Java层与Native层</h3>
<p><strong>流程</strong></p>
<p><strong>1. Java 层调用 native 方法：</strong></p>
<ul>
<li>当 Java 代码执行到 native 方法调用时，例如 System.loadLibrary(“mylib”); 或调用某个 native 方法，JVM 会暂停当前 Java 方法的执行。</li>
</ul>
<p><strong>2. 检查方法表：</strong></p>
<ul>
<li>JVM 会先检查该 native 方法是否已经链接到对应的 native 函数。</li>
<li>每个类都有一个方法表（<strong>methodTable</strong>），存储了该类的所有方法信息，包括 native 方法。</li>
<li>如果方法表中已经有该 native 方法的入口地址，说明已经完成链接，可以直接跳转到步骤 6 执行 native 代码。</li>
</ul>
<p><strong>3. 加载动态链接库：</strong></p>
<ul>
<li>如果方法表中没有找到 native 方法的入口地址，说明该 native 方法还没有链接。</li>
<li>JVM 会调用 System.loadLibrary() 方法加载指定的动态链接库 (例如 <a href="http://libmylib.so">libmylib.so</a>)。</li>
<li>动态链接库加载后，会被映射到进程的地址空间。</li>
</ul>
<p><strong>4. 查找 JNI_OnLoad 函数：</strong></p>
<ul>
<li>JVM 会在加载的动态链接库中查找名为 JNI_OnLoad 的函数。</li>
<li>这个函数是可选的，如果存在，JVM 会调用它。</li>
<li>JNI_OnLoad 函数可以进行一些初始化工作，例如注册 native 方法。</li>
</ul>
<p><strong>5. 注册 native 方法：</strong></p>
<ul>
<li>如果动态链接库中存在 JNI_OnLoad 函数，并且该函数调用了 RegisterNatives 方法，那么 JVM 会根据 RegisterNatives 提供的参数，将 Java native 方法与动态链接库中的 native 函数进行关联。</li>
<li>JVM 会更新方法表，将 native 方法的入口地址设置为对应的 native 函数地址。</li>
</ul>
<p><strong>6. 执行 native 代码：</strong></p>
<ul>
<li>现在，JVM 已经找到了 native 方法对应的 native 函数地址。</li>
<li>JVM 将控制权转移到 native 函数，并将必要的参数传递给 native 函数。
<ul>
<li><strong>参数转换：</strong> Java 和 native 代码使用不同的数据类型，因此 JVM 需要将 Java 参数转换为 native 函数能够理解的数据类型。 例如，将 Java 的 String 类型转换为 C 的 char* 类型。</li>
<li><strong>压入 JNIEnv 指针：</strong> JVM 会将 JNIEnv 指针作为第一个参数压入 native 方法栈。 JNIEnv 指针指向一个线程局部变量，包含了大量的 JNI 函数指针，native 函数可以通过这些函数与 JVM 进行交互。</li>
<li><strong>压入 jclass 或 jobject 引用：</strong> 对于非静态 native 方法，JVM 还会将调用该方法的 Java 对象的引用 (jobject) 压入 native 方法栈。 对于静态 native 方法，则会将该方法所属类的引用 (jclass) 压入 native 方法栈。</li>
</ul>
</li>
<li>native 函数执行完毕后，将结果返回给 JVM。</li>
</ul>
<p><strong>7. 返回 Java 层：</strong></p>
<ul>
<li>JVM 恢复 Java 方法的执行，并使用 native 函数返回的结果继续执行后续的指令。</li>
</ul>
<blockquote>
<p><strong>JNIEnv</strong> 仅用于访问 <strong>JVM 自带的 JNI 函数</strong></p>
<p><strong>程序员自行加载的 JNI 函数</strong> 通过JVM查类的<strong>methodTable</strong>获取JNI函数入口</p>
<p><strong>so 库中的 native 函数:</strong></p>
<ul>
<li>这些函数是由开发者使用 C/C++ 等 native 语言编写的，用于实现特定的功能，例如访问硬件、调用第三方库等。</li>
<li>这些函数需要通过 JNI_OnLoad 和 RegisterNatives 注册到 JVM，才能被 Java 代码调用。</li>
</ul>
<p><strong>JVM 自身实现的 JNI 函数:</strong></p>
<ul>
<li>这些函数是 JVM 内部实现的，用于处理 Java 和 native 代码之间的交互，例如创建 Java 对象、调用 Java 方法、处理异常等等。</li>
<li>这些函数不需要开发者手动注册，它们是 JVM 的一部分，可以直接通过 JNIEnv 指针访问。</li>
</ul>
<p>– NewStringUTF 函数： 这个函数用于创建一个新的 Java 字符串对象，它是 JVM 自身实现的 JNI 函数，你可以在 jni.h 头文件中找到它的声明。<br>
– FindClass 函数： 这个函数用于查找指定的 Java 类，它也是 JVM 自身实现的 JNI 函数。<br>
– CallObjectMethod 函数： 这个函数用于调用 Java 对象的实例方法，它也是 JVM 自身实现的 JNI 函数。</p>
</blockquote>
<p><strong>Java函数，native函数与JNI函数</strong></p>
<p>native函数</p>
<p>即为标准c/c++函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算两个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印字符串到控制台</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JNI函数：可供Java语言调用的，非Java语言实现函数（服务于Java的C函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Java 字符串的长度</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_com_example_MyClass_getStringLength</span><span class="params">(JNIEnv *env, jobject thiz, jstring str)</span> </span>&#123;  <span class="comment">// JNIEXPORT 和 JNICALL 是平台相关的宏定义</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* nativeStr = env-&gt;<span class="built_in">GetStringUTFChars</span>(str, <span class="number">0</span>);</span><br><span class="line">  jint len = <span class="built_in">strlen</span>(nativeStr); </span><br><span class="line">  env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(str, nativeStr);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java函数调用JNI函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJavaClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;my_native_lib&quot;</span>); <span class="comment">// 加载 Native 库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 native 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">getSumFromNative</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyJavaClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyJavaClass</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> obj.getSumFromNative(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用 native 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Sum from Native: &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JNI 函数 (C++)</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL </span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_MyJavaClass_getSumFromNative</span><span class="params">(JNIEnv *env, jobject thiz, jint a, jint b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算 a 和 b 的和</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>native函数调用Java函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JNI 函数 (C++)</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL </span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_MyNativeClass_callJavaMethod</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;  <span class="comment">// 实际上普通的C函数就可以使用JNIEnv调用java函数，这里写成JNI函数是为了使用Java访问该函数再调用其他的java函数</span></span><br><span class="line">    <span class="comment">// 获取 Java 类</span></span><br><span class="line">    jclass cls = env-&gt;<span class="built_in">GetObjectClass</span>(thiz); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Java 方法的 ID</span></span><br><span class="line">    jmethodID mid = env-&gt;<span class="built_in">GetMethodID</span>(cls, <span class="string">&quot;printMessage&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Java 字符串</span></span><br><span class="line">    jstring message = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello from Native!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Java 方法</span></span><br><span class="line">    env-&gt;<span class="built_in">CallVoidMethod</span>(thiz, mid, message); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNativeClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message from Native: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常见内存泄露情况">常见内存泄露情况</h3>
<p><strong>非静态的内部类默认持有外部类的引用</strong></p>
<p>将一个长时间运行的（匿名）内部类对象传递给其他对象，而这些对象的生命周期比外部类更长，就会导致外部类无法被垃圾回收，从而造成内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_leaky);</span><br><span class="line"></span><br><span class="line">        textView = findViewById(R.id.text_view);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>); <span class="comment">// 模拟耗时 10 秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 尝试更新 UI，但此时 Activity 可能已经销毁</span></span><br><span class="line">                textView.setText(<span class="string">&quot;更新 UI&quot;</span>); <span class="comment">// 这里会造成内存泄漏</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案，使用静态内部类 + 弱引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyHandler</span> <span class="variable">mMyHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Activity&gt; mReference;</span><br><span class="line"></span><br><span class="line">        MyHandler(Activity reference) &#123;</span><br><span class="line">            mReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(reference);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="type">MainActivity</span> <span class="variable">activity</span> <span class="operator">=</span> (MainActivity) mReference.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">                activity.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        mMyHandler.removeCallbacksAndMessages(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>匿名内部类与匿名函数 (Lambda 表达式)</strong></p>
<p><strong>匿名内部类</strong></p>
<p><strong>定义：</strong></p>
<ul>
<li>匿名内部类是<strong>没有名字的类定义</strong>，通常在需要使用类的地方直接定义和实例化。</li>
<li>必须继承一个类或实现一个接口。</li>
</ul>
<p><strong>语法：</strong></p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口() &#123;</span><br><span class="line">    <span class="comment">// 类体，可以包含成员变量、方法、构造函数等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个实现 Runnable 接口的匿名内部类</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名内部类执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;按钮被点击了！ (普通类)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;点击我&quot;</span>);</span><br><span class="line">        <span class="type">MyButtonListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyButtonListener</span>();</span><br><span class="line">        button.addActionListener(listener); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;点击我&quot;</span>);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;按钮被点击了！ (匿名内部类)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匿名函数 (Lambda 表达式)</strong></p>
<p><strong>定义：</strong></p>
<ul>
<li>Lambda 表达式是 Java 8 引入的一种<strong>简洁的函数式编程语法</strong>。</li>
<li>可以看作是<strong>匿名函数</strong>，可以直接传递给需要函数式接口作为参数的方法。</li>
</ul>
<p><strong>语法：</strong></p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(参数列表) -&gt; &#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表可以省略类型，如果只有一个参数，括号也可以省略。</li>
<li>如果函数体只有一行代码，花括号也可以省略。</li>
</ul>
<p><strong>示例：</strong></p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式创建 Runnable 实例</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Lambda 表达式执行中...&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>静态变量持有对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(context);  <span class="comment">// 静态变量持有context对象，导致Activity对象无法被GC</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Message">Message</h3>
<h4 id="Handler，Looper与MessageQueue">Handler，Looper与MessageQueue</h4>
<p><strong>Message</strong></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240813144056439.png" class="" title="image-20240813144056439">
<ul>
<li>obtain(): 若sPool中存在msg，取出并返回；否则new返回</li>
<li>obtain(h: Handler): 调用obtain()并指定msg的target为Handler</li>
<li>obtain(h: Handler, callback: Runnable): 额外指定callback</li>
</ul>
<p><strong>Looper&amp;MessageQueue</strong></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240813145303945.png" class="" title="image-20240813145303945">
<img src="/2024/07/28/Android-Learning-Record/image-20240813145313326.png" class="" title="image-20240813145313326">
<p>主线程有且只有一个 Looper，它是在应用启动时由系统自动创建并启动的。</p>
<p>子线程默认没有Looper，需要手动创建和启动。</p>
<p>Looper与MessageQueue</p>
<ul>
<li>
<p>每个 Looper 都会关联一个唯一的 MessageQueue。Looper 对象创建时，会创建一个 MessageQueue 对象。</p>
</li>
<li>
<p>MessageQueue 就像一个消息容器，负责存储消息。当我们使用 Handler 发送消息时，消息并不会直接被处理，而是会被添加到 Looper 关联的 MessageQueue 中。</p>
</li>
<li>
<p>Looper 通过一个无限循环不断地从 MessageQueue 中读取消息。当 Looper 发现 MessageQueue 中没有消息可处理时，就会判断是否有 IdleHandler 需要执行；若没有， Looper 就会进入休眠状态，等待新的消息到来。</p>
</li>
<li>
<p>当 Looper 从 MessageQueue 中读取到消息后，会根据消息的 target 属性（即发送消息时使用的 Handler 对象），将消息分发给对应的 Handler 进行处理。</p>
</li>
</ul>
<p><strong>一个线程最多一个Looper！！！</strong></p>
<blockquote>
<p>如何保证一个线程最多一个Looper？</p>
<p>ThreadLocal是一个线程内部的数据存储类，当某个线程调用prepare方法的时候，会首先通过ThreadLocal检查这个线程是否已经创建了Looper,如果还没创建，则实例化Looper并将实例化后的Looper保存到ThreadLocal中，而如果ThreadLocal中已经保存了Looper，则会抛出一个RuntimeException的异常。那么意味着在一个线程中最多只能调用一次prepare方法，这样就保证了Looper的唯一性。</p>
</blockquote>
<p><strong>Handler</strong></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240813144733590.png" class="" title="image-20240813144733590">
<p>Handler不会被默认创建，需手动创建</p>
<p><strong>多个 Handler 可绑定同一个 Looper</strong>，在创建 Handler 时，若未指定 Looper，则默认绑定当前线程的 Looper</p>
<p>使用 Handler 对象的 send 或 post 方法，向 Handler 对象绑定的 Looper 对应的 MessageQueue 发送Msg。<strong>若发送的为runnable，handler会将其封装为Message。</strong></p>
<p>Looper.loop() 方法不断从 MessageQueue 中取出消息。</p>
<p>Looper 取出消息后，会根据 Message.target 属性找到当初发送该消息的 Handler。</p>
<p><strong>Handler 处理消息:</strong> Handler 接收到 Looper 派发的消息后，执行以下逻辑：</p>
<ul>
<li>
<p>检查 Message 是否携带 Callback，若有则调用 Callback.run() 处理消息。</p>
</li>
<li>
<p>若 Message 没有 Callback，则检查Handler自身是否设置了默认的 mCallback，若有则调用 mCallback.handleMessage() 处理消息。</p>
</li>
<li>
<p>若以上两种 Callback 都没有，则调用自身 handleMessage() 方法处理消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="comment">// msg.callback.run() msg处理次序1</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;  <span class="comment">// msg处理次序2</span></span><br><span class="line">            <span class="comment">// mCallback.handleMessage(msg)</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// msg处理次序3</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意1：进行Msg处理（调用 handleMessage 方法）的是Handler所绑定的Looper所在的线程，即消息发送到哪个消息队列，该队列所在线程就进行消息处理</strong></p>
<p><strong>注意2：主线程的大部分时间都在 Looper 的循环中度过，所有的操作，包括生命周期方法调用、UI 更新、事件处理等，都是作为消息被 Looper 依次处理的，每个消息的处理都是短暂的。一个消息处理完毕后，Looper 立即处理下一个消息或等待新消息。</strong></p>
<p>在通常情况下，主线程创建 Handler 对象并绑定mainLooper，子线程使用该 Handler 对象发送信息到主线程的MessageQueue ，当 Looper 从 MessageQueue 中读取到消息后，调用发送该 Msg 的 Handler handleMessage 方法处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler networkHandler;</span><br><span class="line">    <span class="keyword">private</span> Handler uiHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建处理网络请求的 Handler</span></span><br><span class="line">        networkHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 处理网络请求结果</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) msg.obj;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;网络请求结果: &quot;</span> + result, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建处理用户输入事件的 Handler</span></span><br><span class="line">        uiHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 处理用户输入事件</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> (String) msg.obj;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;用户输入: &quot;</span> + input, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟网络请求</span></span><br><span class="line">        simulateNetworkRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟用户输入事件</span></span><br><span class="line">        simulateUserInput();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">simulateNetworkRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送网络请求结果</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">            message.obj = <span class="string">&quot;成功!&quot;</span>;</span><br><span class="line">            networkHandler.sendMessage(message);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">simulateUserInput</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 发送用户输入事件</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        message.obj = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">        uiHandler.sendMessageDelayed(message, <span class="number">3000</span>); <span class="comment">// 延迟 3 秒发送</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>runOnUiThread()</p>
<p>Android 应用中的 UI 元素（例如按钮、文本框、图片等）都是运行在主线程中，这个主线程也被称为 UI 线程。如果在后台线程（非 UI 线程）中执行耗时操作（例如网络请求、文件读写），操作完成后如果需要更新 UI，就不能直接在后台线程中进行。这是因为 Android 规定只能在 UI 线程中更新 UI 元素。</p>
<p>runOnUiThread() 方法的作用是将一段代码逻辑放入 UI 线程的消息队列中，等待 UI 线程空闲时执行。这样就保证了更新 UI 的操作一定会在 UI 线程中进行，避免了线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">runOnUiThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(), <span class="string">&quot;This is a Toast message&quot;</span>, Toast.LENGTH_SHORT).show();  <span class="comment">// Toast必须放在Ui线程执行哦</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>IdleHandler</strong></p>
<p><strong>消息队列中有消息</strong>: Looper 会取出消息并分发给对应的 Handler 处理。</p>
<p><strong>消息队列为空</strong>: Looper 会检查是否有 IdleHandler 需要执行。如果有，就依次执行 IdleHandler 的 queueIdle() 方法；如果没有，Looper 就会进入休眠状态，等待新的消息到来。</p>
<p>queueIdle() 方法的返回值是一个boolean值，返回true会将IdleHandler保留，否则会将其移除。重写Idle的 queueIdle 方法实现在消息队列为空时进行的任务。</p>
<p>在MessageQueue中维护了一个IdleHandler集合<code>mIdleHandlers</code>，并且提供了添加IdleHandler和移除IdleHandler的方法。可以通过 <code>Looper.myQueue().addIdleHandler(new Idler())</code> 添加一个IdleHandler。</p>
<p><strong>HandlerThread</strong></p>
<p>自带 Looper 的线程，启动后会自动创建并运行 Looper 的消息循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.HandlerThread;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerThread mCompressThread;</span><br><span class="line">    <span class="keyword">private</span> Handler mCompressHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 HandlerThread</span></span><br><span class="line">        mCompressThread = <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;CompressThread&quot;</span>);</span><br><span class="line">        mCompressThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Handler，绑定到 HandlerThread 的 Looper</span></span><br><span class="line">        mCompressHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mCompressThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟图片压缩操作</span></span><br><span class="line">                <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> (Bitmap) msg.obj;</span><br><span class="line">                compressImage(bitmap);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务完成，计数器减一</span></span><br><span class="line">                ((CountDownLatch) msg.getData().getParcelable(<span class="string">&quot;latch&quot;</span>)).countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟添加多个图片压缩任务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">imageCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(imageCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; imageCount; i++) &#123;</span><br><span class="line">            <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher_background);</span><br><span class="line">            addTaskToQueue(bitmap, latch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;所有图片压缩任务已完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加压缩任务到消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTaskToQueue</span><span class="params">(Bitmap bitmap, CountDownLatch latch)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        message.obj = bitmap;</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        data.putParcelable(<span class="string">&quot;latch&quot;</span>, latch);</span><br><span class="line">        message.setData(data);</span><br><span class="line">        mCompressHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟图片压缩操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">compressImage</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="number">80</span>, baos);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            Log.d(TAG, <span class="string">&quot;图片压缩完成，线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 退出 HandlerThread</span></span><br><span class="line">        mCompressThread.quitSafely();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步屏障">同步屏障</h4>
<p><a href="https://juejin.cn/post/6924733444509892622">图示Android系统原理之Handler同步屏障（二）答：Demo工程中详细演示了插入屏障消息的方式。插入和移除屏障消 - 掘金</a></p>
<p>输入事件/invalidate方法请求屏幕刷新后，会产生同步屏障，屏蔽同步消息的处理，直到一下次Vsync信号到达→Choreographer撤销同步屏障，执行measure, layout, draw</p>
<h3 id="进程间交互">进程间交互</h3>
<p>平时我们所熟知的前端（Web\Android\iOS）通过网络与服务器通信是客户端-服务端模式的体现，而在Android Framework中，四大组件的创建、生命周期也是通过这样的模式进行通信：</p>
<ul>
<li>服务器端(server)指的就是SystemServer进程，这个进程提供了很多服务，比如AMS、PMS、WMS等等，所有的APP进程都可以与其通信。</li>
<li>客户端(client)指的就是各个独立的APP进程。</li>
</ul>
<p>Android开发中，我们可以通过Package包名和Activity类名，来打开一个APP。实际上，项目里的业务代码startActivity()方法并不是直接创建进程、拉起APP的。而是通过一系列的调用，把请求传递给SystemServer的AMS。AMS收到来自客户端的请求后，再通知zygote进程来fork一个新进程，来开启我们的目标APP。APP中所有Activity的生命周期过程，都由AMS（SystemServer进程）统一调度，并在APP自身进程中具体完成。</p>
<p>这个过程涉及到3个进程：APP进程、SystemServer进程、Zygote进程。</p>
<ul>
<li>APP进程与SystemServer进程通过Binder机制，进行跨进程通信。</li>
<li>SystemServer进程与Zygote进程通过Socket，进行跨进程通信。</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240723153011448-1722133358773.png" class="" title="image-20240723153011448">
<h4 id="AIDL与Binder">AIDL与Binder</h4>
<p><strong>Android Interface Definition Language</strong></p>
<p>仅当需要在<strong>不同应用间通过 IPC 方式访问服务（在服务中进行多线程处理）时</strong>才有必要使用 AIDL。若<strong>无需跨越不同应用，同应用内执行并发 IPC，则应通过实现 Binder</strong> 来创建接口；又或者<strong>只想执行 IPC，但不需要处理多线程时使用 Messenger</strong> 来实现接口。</p>
<p>server进程与client进程交互</p>
<p><strong>普通方式</strong></p>
<p>server进程：</p>
<p>继承Service，实现onBinder并返回Binder对象；</p>
<p>需在该Binder对象中实现onTransact(…)和服务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> REQUEST_CODE=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Binder</span> <span class="variable">mBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binder</span>() &#123;</span><br><span class="line">        <span class="comment">// 透过匿名内部类方式继承Binder并实现服务方法，该方式存在内存泄露</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, <span class="meta">@NonNull</span> Parcel data, <span class="meta">@Nullable</span> Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            <span class="keyword">if</span> (code == REQUEST_CODE) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> data.readString();</span><br><span class="line">                <span class="comment">// 根据姓名查询学生成绩并将成绩写入到返回数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">studentGrade</span> <span class="operator">=</span> getStudentGrade(name);</span><br><span class="line">                <span class="keyword">if</span> (reply != <span class="literal">null</span>)</span><br><span class="line">                    reply.writeInt(studentGrade);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 服务方法：根据姓名查询学生成绩</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;         </span><br><span class="line">            <span class="keyword">return</span> StudentMap.getStudentGrade(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>client进程：</p>
<p>通过bindService(intent, mServiceConnection, xxx)绑定服务，</p>
<p>mServiceConnection对象中实现onServiceConnected和onServiceDisconnected方法，方法中获得server进程返回的Binder对象</p>
<p>调用Binder对象的onTransact方法得到结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinderActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="comment">// 远程服务的Binder代理</span></span><br><span class="line">    <span class="keyword">private</span> IBinder mRemoteBinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取远程服务的Binder代理</span></span><br><span class="line">            mRemoteBinder = iBinder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> &#123;</span><br><span class="line">            mRemoteBinder = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_binder);</span><br><span class="line">        <span class="comment">// 绑定服务</span></span><br><span class="line">        findViewById(R.id.btn_bind_service).setOnClickListener(view -&gt; bindGradeService());</span><br><span class="line">        <span class="comment">// 查询学生成绩</span></span><br><span class="line">        findViewById(R.id.btn_find_grade).setOnClickListener(view -&gt; getStudentGrade(<span class="string">&quot;Anna&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定远程服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindGradeService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> <span class="string">&quot;android.intent.action.server.gradeservice&quot;</span>;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(action);</span><br><span class="line">        intent.setPackage(getPackageName());</span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从远程服务查询学生成绩</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">int</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRemoteBinder == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Need Bind Remote Server...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mRemoteBinder.transact(REQUEST_CODE, data, reply, <span class="number">0</span>);</span><br><span class="line">            grade = reply.readInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用ServiceConnection对象的原因</p>
<ul>
<li>绑定服务是一个异步操作，服务进程的连接和启动都需要时间。</li>
<li>如果客户端进程同步等待服务连接，可能会导致 UI 线程阻塞，造成 ANR (Application Not Responding)。</li>
<li><code>ServiceConnection</code>  提供了一种异步回调机制，当服务连接成功或断开时，系统会自动回调 <code>ServiceConnection</code>  中的 <code>onServiceConnected()</code>  和 <code>onServiceDisconnected()</code>  方法，通知客户端进程。默认情况下，bindService() 方法是在主线程中调用的，因此 ServiceConnection 的回调方法也会在主线程中执行。</li>
<li>这样，客户端进程就可以在 <code>onServiceConnected()</code>  方法中获取到服务的代理对象，并在 <code>onServiceDisconnected()</code>  方法中处理服务断开的情况，而无需阻塞等待。</li>
</ul>
<p>客户端调用Binder对象的transact方法中转</p>
<ul>
<li>客户端调用的是 Binder 代理对象（客户端内的binder对象）的 transact()。这个方法会将请求发送给 Binder 驱动。</li>
<li>Binder 驱动收到请求后，会找到对应的服务端 Binder 对象，并在服务端进程调用 <strong>服务端 Binder 对象</strong> 的 onTransact() 方法。</li>
</ul>
<p><strong>xxxbinder.transact() 方法是一个同步方法，这意味着在默认情况下，客户端进程会在调用 transact() 方法后阻塞，直到服务端进程完成请求并返回结果。</strong></p>
</blockquote>
<p><strong>代理模式</strong></p>
<p>server进程：</p>
<p>引入服务方法端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGradeInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入xxxBinder继承一般Binder类并实现服务端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> <span class="keyword">implements</span> <span class="title class_">IGradeInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StudentMap.getStudentGrade(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, <span class="meta">@NonNull</span> Parcel data, <span class="meta">@Nullable</span> Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">if</span> (code == REQUEST_CODE) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> data.readString();</span><br><span class="line">            <span class="type">int</span> <span class="variable">studentGrade</span> <span class="operator">=</span> getStudentGrade(name);</span><br><span class="line">            <span class="keyword">if</span> (reply != <span class="literal">null</span>)</span><br><span class="line">                reply.writeInt(studentGrade);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端继承Service，实现onBinder并返回xxxBinder对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> REQUEST_CODE=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Binder</span> <span class="variable">mBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GradeBinder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client进程：</p>
<p>引入服务方法端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGradeInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现服务接口得到代理Binder类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinderProxy</span> <span class="keyword">implements</span> <span class="title class_">IGradeInterface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mBinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BinderProxy</span><span class="params">(IBinder binder)</span> &#123;</span><br><span class="line">        mBinder = binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 通过Binder查询成绩</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">int</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBinder == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Need Bind Remote Server...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mBinder.transact(REQUEST_CODE, data, reply, <span class="number">0</span>);</span><br><span class="line">            grade = reply.readInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 实例化Binder代理类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IGradeInterface <span class="title function_">asInterface</span><span class="params">(IBinder iBinder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (iBinder == <span class="literal">null</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 始终返回 BinderProxy 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BinderProxy</span>(iBinder); </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主activity中通过ServiceConnection对象的onServiceConnected方法从服务端得到返回的Binder对象，转成代理类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> &#123;</span><br><span class="line">      	<span class="comment">// 连接服务成功，根据是否跨进程获取BinderProxy或者GradeBinder实例</span></span><br><span class="line">        mBinderProxy = BinderProxy.asInterface(iBinder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> &#123;</span><br><span class="line">        mBinderProxy = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关于 onTransact()/transact(…) 方法：</strong></p>
<ul>
<li>虽然客户端代码中没有直接调用 transact(…) 方法，但实际上，客户端的BinderProxy 的 getStudentGrade() 方法内部会调用 mBinder.transact(…)，最终还是会走到服务端的 onTransact() 方法。</li>
<li>代理模式只是隐藏了底层的通信细节，让客户端代码看起来像是在调用本地方法一样，但实际上跨进程通信仍然是通过 transact() 和 onTransact() 方法来完成的。</li>
</ul>
</blockquote>
<p><strong>AIDL</strong></p>
<blockquote>
<p>类似于代理模式，AIDL 会自动生成类似于所写的 <code>IGradeInterface</code>、服务端<code>GradeBinder</code>、客户端<code>BinderProxy</code>  这样的代码结构，从而简化了 Binder 通信的开发。</p>
</blockquote>
<p>server进程：</p>
<p>创建AIDL文件，将暴露给客户端的<strong>接口在这个AIDL文件中声明</strong>，</p>
<ul>
<li>在服务端项目的 src/main 目录下创建一个名为 aidl 的文件夹（如果还没有的话）。</li>
<li>在 aidl 文件夹内创建一个与你的包名相同的文件夹，例如 com/example/gradeservice。</li>
<li>在该包名文件夹下创建一个名为 IGradeService.aidl 的文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IGradeService.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.gradeservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IGradeService</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Service中实现这个AIDL接口并创建<strong>Service用来监听客户端的连接请求</strong>。</p>
<ul>
<li>Rebuild 项目。Android Studio 会自动根据 AIDL 文件生成对应的 Java 接口文件（IGradeService.java）。</li>
<li>创建一个名为 GradeService 的 Service 类，并实现 IGradeService.Stub 抽象类。</li>
<li>在 GradeService 中实现 getStudentGrade() 方法，提供具体的业务逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GradeService.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.gradeservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IGradeService.<span class="type">Stub</span> <span class="variable">mBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IGradeService</span>.Stub() &#123; <span class="comment">// 实现接口IGradeService的binder类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            <span class="keyword">return</span> StudentMap.getStudentGrade(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client进程：</p>
<p>引入AIDL</p>
<ul>
<li>将服务端的 IGradeService.aidl 文件 <strong>原封不动地</strong> 复制到客户端项目的 src/main/aidl/com/example/gradeservice/ 目录下。</li>
</ul>
<p><strong>绑定服务端的Service</strong>，绑定成功后，将<strong>服务端返回的Binder对象转成AIDL接口所属的类型</strong>，调用AIDL接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.gradeservice.IGradeService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">BaseViewBindingActivity</span>&lt;ActivityBinderBinding&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IGradeService mBinderProxy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> &#123;</span><br><span class="line">          	<span class="comment">// 透过服务端返回的binder对象转换为代理binder对象</span></span><br><span class="line">            mBinderProxy = IGradeService.Stub.asInterface(iBinder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> &#123;</span><br><span class="line">            mBinderProxy = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        binding.btnBindService.setOnClickListener(view -&gt; bindGradeService());</span><br><span class="line">      	<span class="comment">// 查询学生成绩</span></span><br><span class="line">        binding.btnFindGrade.setOnClickListener(view -&gt; getStudentGrade(<span class="string">&quot;Anna&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 绑定服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindGradeService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> <span class="string">&quot;android.intent.action.server.aidl.gradeservice&quot;</span>;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(action);</span><br><span class="line">        intent.setPackage(getPackageName());</span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 查询成绩</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            grade = mBinderProxy.getStudentGrade(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ToastUtils.showShort(<span class="string">&quot;Anna grade is &quot;</span> + grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Binder实现">Binder实现</h4>
<p><a href="https://www.cnblogs.com/samchen2009/p/3316001.html">https://www.cnblogs.com/samchen2009/p/3316001.html</a></p>
<p><a href="https://sharrychoo.github.io/blog/android-source/dc-binder1">https://sharrychoo.github.io/blog/android-source/dc-binder1</a></p>
<p>进程使用Binder与System_Server通信，例如：AlarmManagerService、BluetoothService 和 BatteryService，</p>
<p><strong>Binder结构</strong></p>
<p><strong>device_node</strong>: Binder设备节点。</p>
<p><strong>global_state</strong>: 全局状态信息，包括上下文管理器、进程计数、线程计数等。</p>
<p><strong>binder_procs</strong>: 使用Binder的进程列表，每个<strong>binder_proc</strong>包含：</p>
<ul>
<li>nodes: 红黑树，用于存储该进程创建的所有 Binder 对象。
<ul>
<li><strong>Binder 对象:</strong> 提供特定功能的接口，例如 MediaPlayerService、ActivityManagerService 等系统服务。进程每提供一种服务就有一个binder对象。</li>
</ul>
</li>
<li>refs: 记录其他进程对该进程中 Binder 对象的引用。
<ul>
<li><strong>Binder 引用对象:</strong> 代表对一个 Binder 对象的引用，可以在进程间传递，例如客户端进程持有的服务端 Binder 对象的引用。</li>
</ul>
</li>
<li>buffers: 管理 Binder 通信过程中使用到的内存缓冲区。</li>
<li>binder_thread: binder_thread 结构体指针数组，存储了该进程所有 Binder 线程的信息。</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240806112818621.png" class="" title="image-20240806112818621">
<p><strong>Binder源码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">	<span class="comment">// 用于将该 binder_proc 结构体插入到一个哈希链表中。该哈希链表存储了系统中所有的 binder_proc 结构体，方便查找。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line">	<span class="comment">// 红黑树的根节点。该红黑树存储了该进程中所有的 binder_thread 结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">	<span class="comment">// 红黑树的根节点。该红黑树存储了该进程中所有的 binder_node 结构体，用于管理 Binder 实体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动函数映射。定义了 Binder 驱动的文件操作函数集。每个成员都是一个函数指针，指向处理特定文件操作的函数。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册驱动参数结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> =</span> &#123;</span><br><span class="line">	.minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    <span class="comment">// 驱动名称</span></span><br><span class="line">	.name = <span class="string">&quot;binder&quot;</span>,</span><br><span class="line">	.fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// binder_open : 处理 open 系统调用的函数，用于打开 Binder 设备文件。</span></span><br><span class="line"><span class="comment">// binder_mmap: 处理 mmap 系统调用的函数，用于将 Binder 驱动的内存映射到用户空间。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span>&#123;......&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span>&#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">binder_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 创建名为binder的单线程的工作队列</span></span><br><span class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">&quot;binder&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 注册驱动，misc设备其实也就是特殊的字符设备</span></span><br><span class="line">    ret = misc_register(&amp;binder_miscdev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 驱动注册函数</span></span><br><span class="line">device_initcall(binder_init);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Binder 通信流程:</strong></p>
<p><strong>Main_MediaServer.cpp</strong></p>
<p>Server获得ProcessState实例，使用该实例创建线程池</p>
<p>Server调用<code>defaultServiceManager()</code>获得 IServiceManager，即BpBinder，对应ServiceManager的客户端Binder</p>
<p><strong>ProcessState.cpp</strong></p>
<p>ProcessState的构造函数初始化</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240806155020313.png" class="" title="image-20240806155020313">
<img src="/2024/07/28/Android-Learning-Record/image-20240806155033149.png" class="" title="image-20240806155033149">
<p><code>open_driver()</code>函数打开了设备 <code>/dev/binder</code> ，并设置该进程在Binder中的线程池</p>
<blockquote>
<p>每个使用Binder的进程都在Binder驱动中有自己的线程池，该线程用于信息的处理</p>
</blockquote>
<p>然后，调用<code>mmap(...)</code>创建内存映射，即为下图中的Server进程中操作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240805194744173.png" class="" title="image-20240805194744173">
<p><strong>IServiceManager.cpp</strong></p>
<p>返回BpBinder(handler)，即 IServiceManager</p>
<h4 id="Message跨进程通信">Message跨进程通信</h4>
<h4 id="Socket">Socket</h4>
<img src="/2024/07/28/Android-Learning-Record/image-20240721155920403-1722133033018.png" class="" title="image-20240721155920403">
<h3 id="View与事件分发机制">View与事件分发机制</h3>
<h4 id="事件分发流程">事件分发流程</h4>
<p>参考链接：<a href="https://juejin.cn/post/6931914294980411406">https://juejin.cn/post/6931914294980411406</a></p>
<p>每次进行事件传递的是单个事件，即 ACTION_DOWN, ACTION_MOVE, ACTION_UP, 并非事件序列</p>
<p>case 1: -&gt; dispatch -&gt; dispatch -&gt; InterceptTouchEvent -&gt; TouchEvent - &gt; TouchEvent</p>
<p>case 2: -&gt; dispatch -&gt; dispatch -&gt; TouchEvent - &gt; TouchEvent</p>
<p>case 3: -&gt; dispatch -&gt; dispatch -&gt; TouchEvent</p>
<ol>
<li>
<p><strong>事件传递：</strong> 当用户触摸屏幕时，系统会将事件封装成 MotionEvent 对象，并将其传递给当前 Activity 的 dispatchTouchEvent(…) 方法。</p>
</li>
<li>
<p><strong>分发：</strong> Activity 会将事件传递给其根视图ViewGroup（通常是 DecorView）的 dispatchTouchEvent(…) 方法。ViewGroup和View将继续调用dispatchTouchEvent(…) 方法分发该动作。</p>
</li>
</ol>
<ul>
<li>如果返回 true，则表示<strong>当前事件在此 View 及其子 View 中被处理</strong>，后续事件序列将被继续下发。</li>
<li>如果返回 false，则表示<strong>当前事件在此 View 及其子 View 中未被处理</strong>，后续事件序列将不会到达此View</li>
</ul>
<ol start="3">
<li><strong>拦截：</strong> ViewGroup 在接收到事件后，会调用自身的 onInterceptTouchEvent() 方法判断是否拦截该事件。</li>
</ol>
<ul>
<li>如果返回 true，则表示拦截该事件，事件将由 ViewGroup 自身处理，调用自身的 onTouchEvent() 方法。
<ul>
<li>如果返回 false，则表示不拦截该事件，事件将继续传递给其子 View 或 ViewGroup 进行分发。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>
<p><strong>处理：</strong> View 和 ViewGroup 接收到事件后，会调用自身的 onTouchEvent() 方法进行处理。 ACTION_DOWN 事件在处理后，将归属于该View进行完整事件序列处理。</p>
<ul>
<li>如果返回 true，则表示该事件被消费，事件传递结束。</li>
<li>如果返回 false，则表示该事件没有被消费，事件将回传给父 View 的 onTouchEvent() 方法进行处理。</li>
</ul>
</li>
<li>
<p><strong>事件回传：</strong> 如果事件没有被任何 View 消费，最终会回到 Activity 的 onTouchEvent() 方法进行处理。</p>
</li>
</ol>
<blockquote>
<p><strong>事件传递方向：</strong></p>
<ul>
<li>向下传递（分发）： 事件是从根视图 (DecorView) 开始，沿着视图树 <strong>逐层向下</strong> 分发，直到传递到最终处理该事件的子视图或被某个 ViewGroup 拦截。</li>
<li>向上回传： 如果事件没有被任何子视图消费，则会 <strong>原路返回</strong>，沿着视图树 <strong>逐层向上</strong> 回传，直到被某个 View 或 ViewGroup 处理或最终到达 Activity。</li>
</ul>
<p><strong>事件拦截</strong></p>
<p>在正常情况下，一个事件序列只应该由单独一个 View 或者 ViewGroup 进行处理。这意味着， 哪个 View 消费了 ACTION_DOWN 事件，哪个 View 就会接管整个事件序列的处理，不再经过其他事件</p>
<ol>
<li>
<p>拦截&amp;处理：整个事件序列将直接传递给该ViewGroup处理，不再经过其他事件</p>
</li>
<li>
<p>拦截&amp;不处理：后续事件序列将不会再传递给该 ViewGroup，而是直接交给其父视图处理</p>
</li>
</ol>
<p>ext：若所有View和ViewGroup均不处理 ACTION_DOWN 事件，后续事件序列将直接由Activity处理；</p>
</blockquote>
<p><strong>坐标系</strong></p>
<p><strong>屏幕坐标系</strong>： Raw 以屏幕左上角作为坐标原点，水平向右方向为 X 轴正轴方向，竖直向下方向为 Y 轴正轴方向。</p>
<p><strong>View 坐标系</strong>： 默认 以 View 所在的 ViewGroup 的左上角作为坐标原点，水平向右方向为 X 轴正轴方向，竖直向下方向为 Y 轴正轴方向。View 类包含了以下几个方法用于获取其相对父容器 ViewGroup 的距离：</p>
<ul>
<li>getLeft()。View 左侧到 ViewGroup 左侧之间的距离</li>
<li>getTop()。View 顶部到 ViewGroup 顶部之间的距离</li>
<li>getRight()。View 右侧到 ViewGroup 左侧之间的距离</li>
<li>getBottom()。View 底部到 ViewGroup 顶部之间的距离</li>
</ul>
<p>参考链接：<a href="https://juejin.cn/post/6931914294980411406">https://juejin.cn/post/6931914294980411406</a></p>
<p><strong>事件序列</strong></p>
<p>一个触摸事件序列，指的是从手指触摸屏幕开始，到手指离开屏幕结束，期间产生的一系列事件。</p>
<p>这个序列包含如下三个阶段：</p>
<ol>
<li><strong>按下（ACTION_DOWN）：</strong> 手指触碰屏幕的瞬间触发。</li>
<li><strong>移动（ACTION_MOVE）：</strong> 手指在屏幕上滑动时，会多次触发该事件。</li>
<li><strong>抬起（ACTION_UP）：</strong> 手指离开屏幕的瞬间触发。</li>
</ol>
<p><strong>Mutil View</strong></p>
<blockquote>
<p>核心：(ViewGroup)DispatchTouchEvent() -&gt; (ViewGroup)onInterceptTouchEvent()  -&gt; {(ViewGroup)onTouchEvent()} -&gt; (View)DispatchTouchEvent() -&gt;  (View)onTouchEvent()</p>
<p>DispatchTouchEvent 返回 True 事件被消费</p>
<p>onInterceptTouchEvent 返回 True 事件被拦截，调用当前级的onTouch()</p>
<p>onTouchEvent() 返回 True 事件被消费</p>
<p>Activity: DispatchTouchEvent + onTouchEvent</p>
<p>ViewGroup: DispatchTouchEvent + onInterceptTouchEvent + onTouchEvent</p>
<p>View: DispatchTouchEvent + onTouchEvent</p>
</blockquote>
<p><strong>View</strong></p>
<p>Android 界面中所有可视化元素的基类，代表一个矩形区域，负责自身内容的绘制、事件处理以及布局等。<strong>常见子类：</strong> TextView、Button、ImageView、EditText 等。</p>
<ul>
<li>
<p>DispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 用于表示当前 View 是否消费了该事件</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> event.getActionMasked();</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">//View启用&amp;&amp;handleScrollBarDragging返回true</span></span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在OnTouchListener&amp;&amp;View启用&amp;&amp;OnTouchListener返回true</span></span><br><span class="line">        <span class="comment">//OnTouchListener优先级高于onClickListener！！</span></span><br><span class="line">        <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">           result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//result仍为false&amp;&amp;自身onTouchEvent消费动作事件</span></span><br><span class="line">        <span class="comment">// onClickListener在onTouchEvent方法中被调用的</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ···</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>OnTouchEvent</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 事件可点击判断</span></span><br><span class="line">    <span class="comment">// CLICKABLE、LONG_CLICKABLE、CONTEXT_CLICKABLE对应着：可点击、可长按点击、可上下文点击</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">clickable</span> <span class="operator">=</span> ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">          || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">          || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">// 如果当前 View 处于禁用状态 DISABLED 的话，当前 View 是否会消耗触摸事件都由 clickable 来决定，</span></span><br><span class="line">        <span class="keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TouchDelegate 可以用于改变 View 的触摸区域，例如将一个较小的 View 的触摸区域扩大。</span></span><br><span class="line">    <span class="comment">// 如果设置了 TouchDelegate，调用 TouchDelegate 的 onTouchEvent 方法处理触摸事件</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可点击 OR View为工具提示</span></span><br><span class="line">    <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">// 判断是否取得焦点</span></span><br><span class="line">        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPerformClick == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPerformClick = <span class="keyword">new</span> <span class="title class_">PerformClick</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// PerformClick 对象添加到消息队列中</span></span><br><span class="line">            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">               <span class="comment">// 如果无法将 PerformClick 对象添加到消息队列中，则直接调用 performClickInternal 方法执行点击事件。performClickInternal() 方法是 View 类中的一个私有方法，它会执行实际的点击操作，例如调用 OnClickListener 的 onClick() 方法等。</span></span><br><span class="line">               performClickInternal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>ViewGroup</strong></p>
<p>继承自 View，但它本身是一个容器，可以包含多个子 View，并负责管理这些子 View 的布局和事件分发。<strong>常见子类：</strong>  LinearLayout、RelativeLayout、FrameLayout、ConstraintLayout 等。</p>
<ul>
<li>
<p>DispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">     ···</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">  </span><br><span class="line">         <span class="comment">// 新的事件序列</span></span><br><span class="line">         <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">             <span class="comment">// 清除旧事件引用</span></span><br><span class="line">             cancelAndClearTouchTargets(ev);</span><br><span class="line">             resetTouchState();</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">         <span class="comment">// 新事件序列 或 存在旧事件引用</span></span><br><span class="line">         <span class="comment">// 存在旧事件引用意味着有子View消费了当前事件序列的ACTION_DOWN</span></span><br><span class="line">         <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">         <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                 || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 子View可以请求父View不拦截</span></span><br><span class="line">             <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                 <span class="comment">// 调用onInterceptTouchEvent判断是否拦截</span></span><br><span class="line">                 intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                 ev.setAction(action);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 子View请求父View不拦截</span></span><br><span class="line">                 intercepted = <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             intercepted = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">         ···</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">             <span class="type">View</span> <span class="variable">childWithAccessibilityFocus</span> <span class="operator">=</span> ev.isTargetAccessibilityFocus()</span><br><span class="line">                     ? findChildWithAccessibilityFocus() : <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">             <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                     || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                     || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                 <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionIndex</span> <span class="operator">=</span> ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                 <span class="keyword">final</span> <span class="type">int</span> <span class="variable">idBitsToAssign</span> <span class="operator">=</span> split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                         : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line">  </span><br><span class="line">                 <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                 <span class="comment">// have become out of sync.</span></span><br><span class="line">                 removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line">  </span><br><span class="line">                 <span class="comment">// 遍历子View找到ACTION_DOWN落点</span></span><br><span class="line">                 <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childrenCount</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">                 <span class="keyword">if</span> (newTouchTarget == <span class="literal">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                     ···</span><br><span class="line">                     <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                         ···</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     ···</span><br><span class="line">                 &#125;</span><br><span class="line">	   ···</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 动作未被子类消费 或 被拦截</span></span><br><span class="line">             handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                     TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// </span></span><br><span class="line">             <span class="type">TouchTarget</span> <span class="variable">predecessor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">             <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> mFirstTouchTarget;</span><br><span class="line">             <span class="keyword">while</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">next</span> <span class="operator">=</span> target.next;</span><br><span class="line">                 <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                     handled = <span class="literal">true</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">cancelChild</span> <span class="operator">=</span> resetCancelNextUpFlag(target.child)</span><br><span class="line">                             || intercepted;</span><br><span class="line">                     <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                             target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                         handled = <span class="literal">true</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (predecessor == <span class="literal">null</span>) &#123;</span><br><span class="line">                             mFirstTouchTarget = next;</span><br><span class="line">                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                             predecessor.next = next;</span><br><span class="line">                         &#125;</span><br><span class="line">                         target.recycle();</span><br><span class="line">                         target = next;</span><br><span class="line">                         <span class="keyword">continue</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 predecessor = target;</span><br><span class="line">                 target = next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">···</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="literal">null</span>) &#123;</span><br><span class="line">         mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> handled;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>PhoneWindow与DecorView</strong></p>
<ul>
<li>每个 Activity 都对应一个 PhoneWindow，即每个 Activity 实例均包含了一个 PhoneWindow 对象</li>
<li>每个 PhoneWindow 都对应一个 DecorView，DecorView 依靠 PhoneWindow 作为构造参数之一来实例化</li>
<li>DecorView 是 FrameLayout 的子类，是 Activity 视图树的根视图，我们平时调用 setContentView 所添加的 View 就对应 DecorView 的 ContentParent 区域</li>
<li>在这三者中 DecorView 会最先接收到触摸事件，DecorView 作为视图树的根视图，就负责向其内部 View 下发触摸事件</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Activity</span><br><span class="line">│</span><br><span class="line">└── PhoneWindow</span><br><span class="line">    │</span><br><span class="line">    └── DecorView (继承FrameLayout)</span><br><span class="line">		│</span><br><span class="line">		└── LinearLayout</span><br><span class="line">                │</span><br><span class="line">                ├── TitleBar/ActionBar</span><br><span class="line">                │</span><br><span class="line">                └── ContentView (setContentView(..))</span><br><span class="line">                    │</span><br><span class="line">                    └── ... 其他 View</span><br></pre></td></tr></table></figure>
<blockquote>
<p>StatusBar (状态栏) 不属于 当前Activity，位于屏幕最上方</p>
<p>TitleBar/ActionBar 属于 DecorView，位于 StatusBar (状态栏) 下方</p>
</blockquote>
<img src="/2024/07/28/Android-Learning-Record/944365-34992eb46bdf93e7.png" class="" title="image-20240812184518922">
<p>参考链接：<a href="https://juejin.cn/post/6931914294980411406">https://juejin.cn/post/6931914294980411406</a></p>
<blockquote>
<p>硬件 -&gt; WindowManager -&gt; ViewRoot(ViewRootImpl类，连接层) -&gt; DecorView -&gt; Activity-PhoneWindow-DecorView -&gt; ViewGroup -&gt; View</p>
<p>这三者之间的联系又是怎样的呢？这样兜兜转转一圈，其实就是 DecorView 先将事件传给了 Activity，Activity 又传给了 PhoneWindow，PhoneWindow 又将事件传给了 DecorView，DecorView 最后又按照 ViewGroup 默认的方式进行事件分发，看起来就是在绕圈，这样设计的意义是什么呢？</p>
<p>其实，DecorView 作为触摸事件的第一个接收者，是触摸事件从系统下发到 Activity 之间的一个沟通桥梁，而开发者可以直接接触并继承的是 Activity。DecorView 需要先将事件转发给最外层的 Activity，使得开发者可以通过重写 dispatchTouchEvent 和 onTouchEvent 方法以达到对当前屏幕触摸事件进行拦截的目的。DecorView 作为 View 树的根节点，从 PhoneWindow 接收到事件后，又负责将将事件事件分发给子 View，从而将整个事件链给串联了起来</p>
</blockquote>
<img src="/2024/07/28/Android-Learning-Record/image-20240831191655656.png" class="" title="image-20240831191655656">
<img src="/2024/07/28/Android-Learning-Record/image-20240831192314544.png" class="" title="image-20240831192314544">
<p>Activity 创建 时：</p>
<p>​	创建PhoneWindow对象(Window对象实现)；</p>
<p>​	PhoneWindow.setCallback(this)</p>
<p>​	PhoneWindow.setWindowManger(…)</p>
<p>Activity setContentView 时：</p>
<p>​	setContentView</p>
<p>​		-&gt; installDecor()</p>
<p>​			-&gt; generateDecor() -&gt;new DecorView(getContext(), -1)</p>
<p>​			    generateLayout(mDecor)</p>
<p>​	InitWindowDecorActionBar</p>
<p><strong>message，handler与View交互案例</strong></p>
<ol>
<li>触摸事件的产生：<br>
当用户触摸屏幕时，Android系统的底层（Input系统）会捕获这个物理事件。</li>
<li>事件的初步处理：<br>
这个触摸事件首先被封装成一个原始的输入事件（Input Event）。</li>
<li>事件分发到应用：<br>
系统将这个事件分发给当前激活的应用程序。</li>
<li>转化为消息：<br>
在应用程序这一层，这个输入事件被转换成一个消息（Message），并被添加到主线程的消息队列（MessageQueue）中。</li>
<li>Looper处理消息：<br>
主线程的Looper从消息队列中取出这个消息，并将其分发给适当的Handler处理。</li>
<li>ViewRootImpl的角色：<br>
在大多数情况下，这个Handler是与ViewRootImpl关联的。ViewRootImpl是连接WindowManager和DecorView的纽带。</li>
<li>事件的向下分发：<br>
ViewRootImpl接收到消息后，会调用DecorView的dispatchTouchEvent()方法，开始事件的向下分发过程。</li>
<li>到达目标View：<br>
事件会沿着View层级树向下传递，直到到达你点击的按钮（Button）。</li>
<li>OnClickListener的调用：<br>
如果按钮设置了OnClickListener，其onClick()方法会在这个分发过程中被调用。</li>
</ol>
<p>参考：<a href="https://www.jianshu.com/p/38015afcdb58">https://www.jianshu.com/p/38015afcdb58</a></p>
<p>Activity事件分发</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240831145006895.png" class="" title="image-20240831145006895">
<p>ViewGroup事件分发</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240831150437519.png" class="" title="image-20240831150437519">
<p>拦截发生时，调用自己的没有被重写的dispatchTouchEvent()处理事件；</p>
<p>例外：</p>
<p>若ViewGroup拦截了中间事件（即没有拦截ACTION_DOWN，拦截了ACTION_MOVE），此时第一个被拦截的事件将成为ACTION_CANCEL传递至ViewGroup的子ViewC，后续事件将进入ViewGroup的没有重写的dispatchTouchEvent()，且ViewC也将不再接受到后续事件；</p>
<blockquote>
<p>ViewGroup父类dispatchTouchEvent()说明：</p>
<p>ViewGroup继承于View，其为包含其他View的特殊的View；ViewGroup继承View后重写了父类的dispatchTouchEvent()方法</p>
<p>此处执行ViewGroup父类dispatchTouchEvent()即为调用父类的没有被重写的View.dispatchTouchEvent()</p>
</blockquote>
<p>View事件分发</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240831152442110.png" class="" title="image-20240831152442110">
<p><strong>View触摸事件优先级高于点击事件！！</strong></p>
<p><strong>View中若控件可点击(Clickable)，则View.dispatchTouchEvent(…)—&gt;View.onTouchEvent(…)一定返回true；若不可点击，则一定返回false！！！</strong></p>
<p>在不设置触摸事件监听器的情况下，View和ViewGroup均默认使用onTouchEvent()处理事件；</p>
<p>PS: 可以同时触发<strong>触摸事件监听器</strong>和<strong>点击事件监听器</strong></p>
<blockquote>
<p>Touch处理所有点击事件，即：</p>
<ul>
<li><strong>MotionEvent.ACTION_DOWN</strong>: 手指初次接触到屏幕的瞬间。</li>
<li><strong>MotionEvent.ACTION_MOVE</strong>: 手指在屏幕上滑动时，会持续触发此事件。</li>
<li><strong>MotionEvent.ACTION_UP</strong>: 手指离开屏幕的瞬间。</li>
<li><strong>MotionEvent.ACTION_CANCEL</strong>: 触摸事件被系统取消，例如突然弹出对话框。</li>
<li><strong>MotionEvent.ACTION_POINTER_DOWN</strong>: 多点触控时，另一只手指触碰屏幕。</li>
<li><strong>MotionEvent.ACTION_POINTER_UP</strong>: 多点触控时，其中一只手指离开屏幕。</li>
</ul>
<p>Click处理一个完整的点击操作（按下/抬起），即：</p>
<ul>
<li>ACTION_DOWN -&gt; ACTION_UP</li>
</ul>
</blockquote>
<h4 id="滑动冲突与解决">滑动冲突与解决</h4>
<p>假设存在一个包含 <code>ScrollView</code> 的布局，而 <code>ScrollView</code> 内部嵌套了一个 <code>RecyclerView</code>。两者都有滑动能力，<code>ScrollView</code> 用于垂直滚动，<code>RecyclerView</code> 用于显示列表项，并且本身支持垂直滑动。这种布局会容易发生滑动冲突。</p>
<p><strong>外部拦截法</strong>：父容器去控制事件的拦截，若事件是父容器需要的，则进行拦截，不需要的则向下传递。</p>
<p><strong>父视图强制拦截事件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父视图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScrollView</span> <span class="keyword">extends</span> <span class="title class_">ScrollView</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsScrolling;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyScrollView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否是滑动事件，若是则拦截</span></span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            <span class="comment">// 如果子视图有滑动需求，父视图就不再拦截</span></span><br><span class="line">            <span class="keyword">if</span> (mIsScrolling) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不拦截，交给子视图</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            mIsScrolling = <span class="literal">true</span>;  <span class="comment">// 滑动时，设置为正在滚动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>父视图通过横向移动距离/纵向移动距离拦截事件</strong></p>
<p>作者：parting_soul<br>
链接：<a href="https://juejin.cn/post/6844903806308712456">https://juejin.cn/post/6844903806308712456</a><br>
来源：稀土掘金</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父视图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewPager</span> <span class="keyword">extends</span> <span class="title class_">ViewPager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mLastX;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mLastY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="comment">//一些ViewPager拖拽的标志位要设置，必调super，否则看不到效果</span></span><br><span class="line">        <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isIntercepted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">if</span> (needEvent(ev)) &#123;</span><br><span class="line">                    isIntercepted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        mLastX = (<span class="type">int</span>) ev.getX();</span><br><span class="line">        mLastY = (<span class="type">int</span>) ev.getY();</span><br><span class="line"></span><br><span class="line">        LogUtils.d(<span class="string">&quot; lastX = &quot;</span> + mLastX + <span class="string">&quot; lastY = &quot;</span> + mLastY);</span><br><span class="line">        <span class="keyword">return</span> isIntercepted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">needEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="comment">//水平滚动距离大于垂直滚动距离则将事件交由ViewPager处理</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(ev.getX() - mLastX) &gt; Math.abs(ev.getY() - mLastY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>内部拦截法</strong>：ViewGroup默认情况下不拦截事件，由子View去控制事件的处理，若子View需要此事件，则自己处理，否则交由父容器处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子视图</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">//禁止父容器拦截事件</span></span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (当期View不需要此事件) &#123;</span><br><span class="line">                <span class="comment">// 允许父容器拦截事件</span></span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父视图</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="RecyclerView与ListView缓存机制">RecyclerView与ListView缓存机制</h3>
<p>ListView的缓存分为两级</p>
<p>ListView存在内部类 RecycleBin，RecycleBin存在对象Active View和Scrap View</p>
<ul>
<li>
<p>Active View</p>
</li>
<li>
<p>Scrap view</p>
</li>
</ul>
<p>Active View是在屏幕内的ItemView，当列表数据发生变化时，屏幕内的数据可以直接拿来复用，无须进行数据绑定。</p>
<p>Scrap view是在屏幕外的ItemView，这里所有的缓存的数据都是’脏的’，也就是数据需要重新绑定，也就是说屏幕外的所有数据在进入屏幕的时候需要执行 <code>getView()</code> 方法。</p>
<p>ListView缓存机制：</p>
<p>在mActiveViews缓存集合中查找，成功返回itemView，失败进入下一级缓存；</p>
<p>下一级缓存mScrapViews中进行查找，成功返回itemView，失败创建CreateView。</p>
<p>RecyclerView 的缓存分为四级</p>
<ul>
<li>
<p>AttachedScrap</p>
</li>
<li>
<p>CachedViews</p>
</li>
<li>
<p>ViewCacheExtension</p>
</li>
<li>
<p>RecycledViewPool</p>
</li>
</ul>
<p>Scrap 对应 ListView 的 Active View，为屏幕内缓存数据；</p>
<blockquote>
<p>ChangedScrap内ViewHolder在复用时，需调用 onBindViewHolder(ViewHolder viewHolder, int position) 方法将数据绑定在 ViewHolder 对象中。</p>
</blockquote>
<p>CachedViews 为最近移出屏幕的 ViewHolder，默认大小是2个；当其容量满时且出现新的数据添加时，会根据FIFO原则，原 ViewHolder 移出并放到下一级缓存。</p>
<p>CachedViews 里面的数据是干净的，也就是携带了原来的 ViewHolder 的所有数据信息，数据可以直接来拿来复用。需要注意的是，CachedViews 是根据 position 来寻找数据的，这个 postion 是根据第一个或者最后一个可见的 item 的 position 以及用户操作行为（上拉还是下拉）。</p>
<blockquote>
<p>例：当前屏幕内第一个可见的 item 的 position 是1，用户进行了一个下拉操作，那么当前预测的 position 就相当于（1-1=0），也就是 position = 0 的那个 item 要被拉回到屏幕，此时 RecyclerView 就从 Cache 里面找 position=0 的数据，如果找到了就直接拿来复用。</p>
</blockquote>
<p>ViewCacheExtension 是 google 留给开发者自己来自定义缓存的</p>
<p>RecycledViewPool 对比于 Cache 默认缓存数量是2个，当 Cache 缓存满了以后会根据 FIFO 把 Cache 中的 ViewHolder 移出并缓存到 RecycledViewPool 中，RecycledViewPool 默认缓存数为5。</p>
<p>RecycledViewPool 与 Cache 相比不同的是，从 Cache 里面移出的 ViewHolder 在存入 RecycledViewPool 之前，该 ViewHolder 的数据会被全部重置，相当于一个新的 ViewHolder ；同时 Cache 是根据 position 来获取 ViewHolder，而 RecycledViewPool 是根据 itemType 获取的，如果没有重写 <code>getItemType()</code> 方法，itemType 就是默认的。由于 RecycledViewPool 缓存的 ViewHolder 是全新的，所以取出来的时候需要执行 <code>onBindViewHolder()</code> 方法。</p>
<p>RecyclerView的复用整体流程：</p>
<p>首先会去 Scrap 这个集合 mAttachedScrap 中找是否有 ViewHolder，有就复用 ViewHolder，没有就去下一级缓存集合 mCachedViews 中查找，找到就直接复用，没有就去下一级缓存自定义的 mViewCacheExtension 这个类中查找，但是基本很少用，没找到就去下一级 RecyclerViewPool 中查找，找到就直接复用，没找到就会调用我们在adapter中重写的方法 onCreateViewHolder 新建。</p>
<p><strong>每当 RecyclerView 的子项出现在屏幕上时或将要出现在屏幕上时，系统会按照如下的顺序调用函数</strong></p>
<p>1 调用 getItemCount() 方法获取子项的数量。</p>
<p>2 调用 onCreateViewHolder(ViewGroup parent, int viewType) 方法加载每一个子项的布局</p>
<p>3 构造一个 ViewHolder 对象。</p>
<p>4 调用 onBindViewHolder(ViewHolder viewHolder, int position) 方法将数据绑定在 ViewHolder 对象中。</p>
<p><strong>每个子项在创建的时候会重复循环上面4个步骤，直到所有的子项加载完</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc27655e1184f1fa60b1b8ac4ed4a3b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="recyclerView"></p>
<p>通过mAttachedScrap、mCachedViews及mViewCacheExtension获取的ViewHolder不需要重新创建布局(<code>onCreateViewHolder()</code>)及绑定数据(<code>onBindViewHolder()</code>)；通过缓存池mRecyclerPool获取的ViewHolder不需要重新创建布局，但是需要重新绑定数据；如果上述缓存中都没有获取到目标ViewHolder，那么就会回调Adapter#onCreateViewHolder创建布局，以及回调Adapter#onBindViewHolder来绑定数据。</p>
<p>作者：<em>小马快跑</em><br>
链接：<a href="https://juejin.cn/post/7229895703392518205">https://juejin.cn/post/7229895703392518205</a></p>
<h3 id="屏幕刷新">屏幕刷新</h3>
<p>画面撕裂：Display在读取buffer内数据时，被读取数据被CPU/GPU修改，导致当前画面左上部分和右下部分来自不同帧</p>
<p>双缓冲（显示器使用Frame Buffer，CPU/GPU使用Back Buffer）</p>
<p>BackBuffer的数据就绪后，写数据到FrameBuffer，防止画面撕裂</p>
<p><a href="https://juejin.cn/post/7163858831309537294">&quot;一文读懂&quot;系列：Android屏幕刷新机制为什么要学习屏幕刷新知识？ 很多同学觉得屏幕刷新绘制知识点对他们开发不重要， - 掘金</a></p>
<p>作者：胡飞洋链接：<a href="https://juejin.cn/post/6863756420380196877%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://juejin.cn/post/6863756420380196877来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
<p>VSync(垂直同步):</p>
<p>垂直同步利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。</p>
<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。此个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p>
<p>以时间的顺序来看下将会发生的过程：</p>
<ol>
<li>Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，且在Display显示下一帧前完成</li>
<li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li>
<li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li>
<li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li>
<li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li>
</ol>
<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p>
<p>原因是 第2帧的CPU/GPU计算 没能在VSync信号到来前完成 。</p>
<p><strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。</p>
<p><strong>VSync同步使得CPU/GPU充分利用了16.6ms时间，减少jank。</strong></p>
<p>问题又来了，如果界面比较复杂，CPU/GPU的处理时间较长 超过了16.6ms呢？</p>
<ol>
<li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li>
<li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li>
<li>当下一个VSync出现时，CPU/GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>
</ol>
<p><strong>三缓存</strong></p>
<p>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p>
<ol>
<li>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU/GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</li>
<li>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</li>
</ol>
<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong></p>
<p><strong>谷歌在4.1之后对屏幕绘制与刷新过程引入了Project Butter（黄油工程），系统在收到VSync信号之后，马上进行CPU的绘制以及GPU的buffer写入</strong>。</p>
<h3 id="View绘制流程">View绘制流程</h3>
<img src="/2024/07/28/Android-Learning-Record/944365-c1adb9dd2d22c056.png" class="" title="image-20240831192540253">
<img src="/2024/07/28/Android-Learning-Record/944365-858de1faa38df1b2.png" class="" title="image-20240831192606617">
<p>View绘制流程</p>
<p>创建Activity调用onCreate方法，方法内调用handleResumeActivity(…)</p>
<p>handleResumeActivity(…)调用performResumeActivity(token, clearHide)，获得ActivityClientRecord r</p>
<p>通过r获取DecorView和WindowManager</p>
<p>使用WindowManager执行方法addView</p>
<p>addView方法创建ViewRootImpl实例，<em>把DecorView加载到Window中</em></p>
<p>绘制会从根视图ViewRoot的performTraversals()方法开始，从上到下遍历整个视图树，每个View控件负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。</p>
<p>performTraversals {getRootMeasureSpec + performMeasure + performLayout + performDraw}</p>
<p>绘制流程从根视图 <code>ViewRootImpl</code> 的 <code>performTraversals()</code> 方法开始，按照 <strong>Measure → Layout → Draw</strong> 的顺序，自顶向下遍历整个视图树进行绘制。每个 <code>View</code> 负责绘制自身，而 <code>ViewGroup</code> 还需要通知其子 <code>View</code> 进行测量、布局和绘制操作。</p>
<p><code>performTraversals()</code> 方法依次执行以下步骤：</p>
<ol>
<li><strong>获取根视图的 MeasureSpec</strong>（<code>getRootMeasureSpec</code>）</li>
<li><strong>执行测量流程</strong>（<code>performMeasure</code>）</li>
<li><strong>执行布局流程</strong>（<code>performLayout</code>）</li>
<li><strong>执行绘制流程</strong>（<code>performDraw</code>）</li>
</ol>
<p><strong>测量（performMeasure）</strong></p>
<p>视图的测量流程是一个 <strong>递归</strong> 过程：</p>
<ul>
<li><code>ViewGroup</code> 递归调用子 <code>View</code> 的 <code>measure()</code> 方法，子 <code>View</code> 再根据父 <code>View</code> 传递的 <code>MeasureSpec</code> 计算自身的尺寸。</li>
<li><code>MeasureSpec</code> 计算规则：
<ul>
<li><strong>对于 <code>DecorView</code>（根视图）</strong>：<code>MeasureSpec</code> 由窗口尺寸和 <code>LayoutParams</code> 共同决定。</li>
<li><strong>对于普通 <code>View</code></strong>：<code>MeasureSpec</code> 由父视图的 <code>MeasureSpec</code> 和 <code>LayoutParams</code> 共同决定。</li>
</ul>
</li>
<li><code>MeasureSpec</code> 由两部分组成：
<ul>
<li>模式（Mode）：
<ul>
<li><code>EXACTLY</code>（精确模式）：View 的尺寸已经确定，使用指定的值。</li>
<li><code>AT_MOST</code>（最大模式）：View 的最大尺寸由 <code>MeasureSpec</code> 限制，实际大小不能超过此值。</li>
<li><code>UNSPECIFIED</code>（未指定模式）：View 的大小不受限制，通常用于 <code>ScrollView</code> 这类场景。</li>
</ul>
</li>
<li><strong>大小（Size）</strong>：具体的数值。</li>
</ul>
</li>
</ul>
<p><strong>布局（performLayout）</strong></p>
<ul>
<li><code>ViewGroup</code> 递归调用子 <code>View</code> 的 <code>layout()</code> 方法，子 <code>View</code> 再根据父 <code>View</code> 分配的位置和自身的测量结果，确定自己的最终位置。</li>
<li><strong><code>layout(left, top, right, bottom)</code></strong> 方法用于确定 <code>View</code> 的摆放位置。</li>
<li><code>ViewGroup</code> 需要遍历所有子 <code>View</code> 并调用它们的 <code>layout()</code> 方法，以确保每个 <code>View</code> 在正确的位置上。</li>
</ul>
<p><strong>绘制（performDraw）</strong></p>
<p>绘制流程同样是一个 <strong>递归</strong> 过程，每个 <code>View</code> 负责绘制自身，而 <code>ViewGroup</code> 还需要通知子 <code>View</code> 进行绘制。</p>
<p><strong>绘制的6个步骤</strong></p>
<ol>
<li>绘制 <code>View</code> 的背景
<ul>
<li>调用 <code>drawBackground(canvas)</code> 方法，如果 <code>View</code> 设置了背景，则会先绘制背景。</li>
</ul>
</li>
<li>如果需要的话，保存 <code>Canvas</code> 的图层，为 <code>fading</code> 做准备
<ul>
<li>主要用于 <code>FadingEdge</code>（渐变边缘效果），如果 <code>View</code> 具有 <code>fading edge</code>，则会保存 <code>Canvas</code> 以便后续恢复。</li>
</ul>
</li>
<li>绘制 <code>View</code> 的内容
<ul>
<li>调用 <code>onDraw(canvas)</code>，绘制 <code>View</code> 的主体内容（如 <code>TextView</code> 绘制文本、<code>ImageView</code> 绘制图片等）。</li>
</ul>
</li>
<li>绘制 <code>View</code> 的子 <code>View</code>
<ul>
<li>如果当前 <code>View</code> 是 <code>ViewGroup</code>，会遍历所有子 <code>View</code> 并调用 <code>drawChild(canvas, child, drawingTime)</code> 递归绘制。</li>
</ul>
</li>
<li>如果需要的话，绘制 <code>View</code> 的 <code>fading</code> 边缘并恢复 <code>Canvas</code>
<ul>
<li>处理 <code>FadingEdge</code>，绘制 <code>View</code> 边缘的渐变效果，并恢复 <code>Canvas</code> 以保证后续绘制不受影响。</li>
</ul>
</li>
<li>绘制 <code>View</code> 的装饰（如滚动条等）
<ul>
<li>如果 <code>View</code> 需要滚动条，则会在 <code>dispatchDraw()</code> 之后绘制滚动条。</li>
</ul>
</li>
</ol>
<h3 id="Gradle">Gradle</h3>
<p>每个 Gradle 项目都由一个或多个 Project 构成，每个 Project 又都由 Task 构成。一个 <code>build.gradle</code>文件便是对一个 Project 对象的配置。在 Android 项目中，根目录会存在一个<code>build.gradle</code>文件，每个模块下也会有一个<code>build.gradle</code>文件。</p>
<p><strong>闭包</strong></p>
<p><strong>封装代码块</strong>: 就像普通的函数一样，闭包封装了一段可以执行的代码块。</p>
<p><strong>访问外部作用域</strong>: 闭包最关键的特点是，它可以“捕获”并访问定义它所在的外部作用域（也称为词法作用域）中的变量，即使在定义作用域之外执行也是如此。</p>
<p><strong>作为对象传递</strong>: 闭包可以像普通变量一样被传递、存储和返回，因为它本质上是一个对象。这可以防止外部对象被垃圾回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，返回一个闭包</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 定义在外部函数作用域</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 返回一个闭包</span></span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个计数器</span></span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="title function_">makeCounter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个计数器都拥有独立的 count 变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter1</span>()); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter1</span>()); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter2</span>()); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>
<p><strong>Gradle Wrapper</strong></p>
<p>Gradle 包装器。为了应对团队开发中 Gradle 环境和版本的差异会对编译结果带来的不确定性，使用 Gradle Wrapper，它是一个脚本，可以指定构建版本、快速运行项目，从而达到标准化、提到开发效率。Android Studio 新建项目时自带 Gradle Wrapper，因此 Android 开发者很少单独下载安装 Gradle</p>
<p><strong>常见文件</strong></p>
<p><strong><code>build.gradle</code></strong></p>
<ul>
<li>
<p>定义项目的构建配置，包括依赖项、插件、任务等。</p>
</li>
<li>
<p><strong>类型:</strong></p>
<ul>
<li>
<p><strong>顶层 <code>build.gradle</code> (Project):</strong></p>
<ul>
<li>
<p><strong>作用:</strong> 配置整个项目的全局设置</p>
</li>
<li>
<p><strong>代码示例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span> <span class="comment">// 用于声明项目需要使用的Gradle插件。这些插件直接影响项目的构建过程和可用任务。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildscript &#123;  <span class="comment">// 用于声明构建脚本自身需要的依赖。这些依赖通常是Gradle插件，它们在构建过程中被使用，但不直接成为项目的一部分。</span></span><br><span class="line">    repositories &#123;  </span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">  dependencies &#123;  </span><br><span class="line">        classpath <span class="string">&quot;com.android.tools.build:gradle:7.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123; <span class="comment">// 通常用于定义共享的配置和仓库, 不推荐在这里声明具体的项目依赖</span></span><br><span class="line">    repositories &#123;  </span><br><span class="line">      google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>模块级 <code>build.gradle</code> (Module):</strong></p>
<ul>
<li>
<p><strong>作用:</strong> 配置特定模块的构建选项</p>
</li>
<li>
<p><strong>代码示例 (Android 应用模块):</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">  plugins &#123;</span><br><span class="line">      id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">      id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">31</span>  <span class="comment">// 指定用于编译应用的Android SDK版本</span></span><br><span class="line">      </span><br><span class="line">      defaultConfig &#123;</span><br><span class="line">          applicationId <span class="string">&quot;com.example.myapp&quot;</span></span><br><span class="line">          minSdkVersion <span class="number">21</span>  <span class="comment">// 指定您希望应用支持的最低 Android 版本。设置 minSdk 可限制哪些设备可以安装您的应用。</span></span><br><span class="line">          targetSdkVersion <span class="number">31</span>  <span class="comment">// 如果设备搭载的 Android 版本高于 targetSdk，Android 会以兼容模式运行您的应用</span></span><br><span class="line">          versionCode <span class="number">1</span></span><br><span class="line">          versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">          <span class="comment">// 借助 compileSdk，您可以访问新 API</span></span><br><span class="line">  		<span class="comment">// targetSdk 用于设置应用的运行时行为</span></span><br><span class="line">  		<span class="comment">// targetSdk必须小于或等于 compileSdk</span></span><br><span class="line">          </span><br><span class="line">          testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      buildTypes &#123;  <span class="comment">// 定义不同的构建类型。这里配置了release构建类型,启用了代码混淆。</span></span><br><span class="line">          release &#123;</span><br><span class="line">              minifyEnabled <span class="literal">true</span></span><br><span class="line">              proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      compileOptions &#123;  <span class="comment">// 设置Java编译选项。</span></span><br><span class="line">          sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">          targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      kotlinOptions &#123;  <span class="comment">// 设置Kotlin编译选项。</span></span><br><span class="line">          jvmTarget = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  dependencies &#123;</span><br><span class="line">      implementation <span class="string">&#x27;androidx.core:core-ktx:1.7.0&#x27;</span></span><br><span class="line">      implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.4.1&#x27;</span></span><br><span class="line">      implementation <span class="string">&#x27;com.google.android.material:material:1.5.0&#x27;</span></span><br><span class="line">      implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:2.1.3&#x27;</span></span><br><span class="line">      testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">      androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span></span><br><span class="line">      androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Plugins是用于Gradle的，Dependencies是用于java/kotlin项目的</p>
<p>通过引入不同的Plugins，可以构建不同语言的项目，比如说java语言编写的android项目，kotlin语言编写的android项目，混合Java和Kotlin的Android项目，Flutter项目…</p>
<p>Dependencies 主要是指项目所需的外部库或模块，如Java库，Kotlin库</p>
</blockquote>
<p><strong><code>gradle.properties</code></strong></p>
<ul>
<li>
<p><strong>作用:</strong> 配置全局 Gradle 设置，影响所有使用该 Gradle 版本的项目。</p>
</li>
<li>
<p><strong>示例:</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.gradle.daemon</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">org.gradle.parallel</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">android.useAndroidX</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>gradle-wrapper.properties</code></strong></p>
<ul>
<li>
<p><strong>作用:</strong> 配置 Gradle Wrapper，确保项目使用特定版本的 Gradle 进行构建。</p>
</li>
<li>
<p><strong>示例:</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">gradle-wrapperdistributionBase</span>=<span class="string">GRADLE_USER_HOME</span></span><br><span class="line"><span class="attr">distributionPath</span>=<span class="string">wrapper/dists</span></span><br><span class="line"><span class="attr">distributionUrl</span>=<span class="string">https\://services.gradle.org/distributions/gradle-7.4.2-bin.zip</span></span><br><span class="line"><span class="attr">zipStoreBase</span>=<span class="string">GRADLE_USER_HOME</span></span><br><span class="line"><span class="attr">zipStorePath</span>=<span class="string">wrapper/dists</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>gradle-wrapper</p>
<p>gradle-wrapper就像python的vir_env/miniconda，为每个项目提供了相互独立的gradle环境。通过读取配置文件中gradle的版本，为每个项目自动的下载和配置gradle</p>
<ol>
<li>当执行 gradlew 脚本时，它会读取 gradle-wrapper.properties 文件中的配置信息。</li>
<li>如果本地没有找到指定的 Gradle 版本，Gradle Wrapper 会自动从 distributionUrl 下载并缓存到本地。</li>
<li>下载完成后，Gradle Wrapper 会使用指定的 Gradle 版本执行构建任务。</li>
</ol>
</blockquote>
<p><strong><code>settings.gradle</code></strong></p>
<ul>
<li>
<p><strong>作用:</strong> 此设置文件会定义项目级代码库设置，并告知 Gradle 在构建应用时应将哪些模块包含在内。多模块项目需要指定应包含在最终 build 中的每个模块。</p>
</li>
<li>
<p><strong>示例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pluginManagement &#123;  <span class="comment">// 集中管理插件版本：项目中使用的所有的使用于 Gradle 的插件版本 与 配置插件获取仓库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * pluginManagement.repositories 代码块配置了 Gradle 用于</span></span><br><span class="line"><span class="comment">      * 搜索或下载 Gradle 插件及其传递依赖项的仓库。Gradle 预先配置了对远程仓库的支持，</span></span><br><span class="line"><span class="comment">      * 例如 JCenter、Maven Central 和 Ivy。您也可以使用本地仓库或定义自己的远程仓库。</span></span><br><span class="line"><span class="comment">      * 下面的代码将 Gradle 插件门户、Google 的 Maven 仓库和 Maven 中央仓库定义为</span></span><br><span class="line"><span class="comment">      * Gradle 应该用来查找其依赖项的仓库。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencyResolutionManagement &#123;  <span class="comment">// 集中管理项目依赖项（Java 库、Android 库等），获取仓库与配置依赖解析规则</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 您可以在 dependencyResolutionManagement.repositories 代码块中配置</span></span><br><span class="line"><span class="comment">      * 项目中所有模块使用的仓库和依赖项，例如您用于创建应用程序的库。但是，您应该</span></span><br><span class="line"><span class="comment">      * 在每个模块级别的 build.gradle 文件中配置模块特定的依赖项。对于新项目，</span></span><br><span class="line"><span class="comment">      * Android Studio 默认包含 Google 的 Maven 仓库和 Maven 中央仓库，</span></span><br><span class="line"><span class="comment">      * 但它不会配置任何依赖项（除非您选择需要某些依赖项的模板）。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)  <span class="comment">// 这意味着 Gradle 将只在 settings.gradle.kts 文件中定义的仓库中查找依赖项，而不会在项目模块的 build.gradle 文件中定义的仓库中查找。</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;&#125;  <span class="comment">// 声明依赖版本，但不会将依赖添加到任何模块，仅用于版本约束。</span></span><br><span class="line">    resolutionStrategy &#123;</span><br><span class="line">        <span class="comment">// 强制使用 2.0.0 版本的 Gson 库</span></span><br><span class="line">        force(<span class="string">&quot;com.google.code.gson:gson:2.0.0&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">rootProject.name = <span class="string">&quot;My Application&quot;</span>  <span class="comment">// 设置项目的根模块名称为 &quot;My Application&quot;。</span></span><br><span class="line">include <span class="string">&#x27;:app&#x27;</span>  <span class="comment">// 这意味着项目中存在一个名为 &quot;app&quot; 的子目录，其中包含一个模块级别的 build.gradle 文件，用于配置该模块的构建设置。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>build.gradle</code> allprojects {} 中的 <code>settings.gradle</code> dependencies {} 的区别</p>
<ul>
<li>dependencyResolutionManagement {} 中的 dependencies {} 仅声明依赖版本，不添加依赖。</li>
<li>allprojects {} 中的 dependencies {} 会将依赖添加到所有模块。</li>
</ul>
</blockquote>
<p><strong><code>local.properties</code></strong></p>
<ul>
<li>
<p><strong>作用:</strong> 为构建系统配置本地环境属性，例如 SDK 和 NDK 路径。由Android Studio自动生成</p>
</li>
<li>
<p><strong>示例:</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## This file is automatically generated by Android Studio.</span></span><br><span class="line"><span class="comment"># Do not modify this file -- YOUR CHANGES WILL BE ERASED!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Local properties for the project.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sdk.dir</span>=<span class="string">/Users/username/Library/Android/Sdk</span></span><br><span class="line"><span class="attr">ndk.dir</span>=<span class="string">/Users/username/Library/Android/Sdk/ndk</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>multiDexKeep.pro</code>&amp;<code>proguard-rules.pro</code></strong>: 可选的混淆文件，用于配置放置在主 Dex 的类、声明避免混淆的类</p>
<p><strong>常见块</strong></p>
<p><strong><code>buildscript</code> 块</strong>:</p>
<ul>
<li><strong>作用</strong>: 配置 Gradle 构建系统本身所需的依赖和仓库。</li>
<li><strong>出现位置</strong>: 顶层 <code>build.gradle</code> 文件。</li>
</ul>
<p><strong>代码案例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google() <span class="comment">// Google Maven 仓库</span></span><br><span class="line">        mavenCentral() <span class="comment">// Maven 中央仓库</span></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;com.android.tools.build:gradle:7.2.1&quot;</span> <span class="comment">// Android Gradle 插件</span></span><br><span class="line">        classpath <span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.7.10&quot;</span> <span class="comment">// Kotlin Gradle 插件 (如果使用 Kotlin)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>allprojects</code> 块</strong>:</p>
<ul>
<li><strong>作用</strong>: 配置所有子项目/模块通用的选项，例如仓库、插件版本等。</li>
<li><strong>出现位置</strong>: 顶层 <code>build.gradle</code> 文件。</li>
</ul>
<p><strong>代码案例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        <span class="comment">// 添加其他需要的仓库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>plugins</code> 块</strong>:</p>
<ul>
<li><strong>作用</strong>: 声明和应用插件，用于扩展 Gradle 的功能。</li>
<li><strong>出现位置</strong>: 顶层或模块级 <code>build.gradle</code> 文件。</li>
</ul>
<p><strong>代码案例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span> version <span class="string">&#x27;7.2.1&#x27;</span> apply <span class="literal">false</span> <span class="comment">// 应用 Android Application 插件 (仅在模块级应用)</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.kotlin.android&#x27;</span> version <span class="string">&#x27;1.7.10&#x27;</span> apply <span class="literal">false</span> <span class="comment">// 应用 Kotlin Android 插件 (仅在模块级应用)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>android</code> 块</strong>:</p>
<ul>
<li><strong>作用</strong>: 配置 Android 项目相关的构建选项。</li>
<li><strong>出现位置</strong>: 模块级 <code>build.gradle</code> 文件。</li>
</ul>
<p><strong>代码案例:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">33</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.myapp&quot;</span></span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">33</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dependencies</code> 块: 声明项目的依赖项。</p>
<p><code>repositories</code>: 定义 Gradle 查找依赖项的仓库地址。</p>
<p><code>task</code>: 定义 Gradle 任务，用于执行特定的构建操作。</p>
<p><code>ext</code>: 定义额外的属性，可以在构建脚本中使用。</p>
<h3 id="Android启动">Android启动</h3>
<p>Android系统启动过程中，会先启动linux内核，然后加载init.rc文件，启动init进程。然后，init进程通过解析init.rc文件fork生成Zygote进程，该进程也是Android系统的首个Java进程。之后Zygote进程负责孵化System Server进程和APP进程。</p>
<p><img src="Android-learning-record/image-20240714103234291.png" alt="image-20240714103234291"></p>
<h4 id="Init进程">Init进程</h4>
<p>设置子进程退出信号处理函数</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240731155705321.png" class="" title="image-20240731155705321">
<blockquote>
<p>本进程在接受到子进程退出信号后，调用sigchld_handler函数</p>
</blockquote>
<p>创建文件夹与挂载设备</p>
<p>将标准输入、标准输出和标准错误重定向到 <code>/dev/null</code> 和 将<code>init</code> 进程的日志输出设置为 <code>/dev/__kmsg__</code></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240731160912852.png" class="" title="image-20240731160912852">
<blockquote>
<p>重定向标准输入/输出/错误的方式是通过修改进程的文件描述符表</p>
<p>int dup2(int oldfd, int newfd)：通过将旧文件描述符复制到新文件描述符位置（即将oldfd内容写入newfd在文件描述符表中所在的位置），若新文件描述符已打开，则将其关闭并复制，使得后续访问文件描述符表对应位置的时候被重定向到修改后位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">// 读写方式打开 /dev/null</span></span><br><span class="line"><span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    dup2(fd, <span class="number">0</span>); <span class="comment">// 重定向标准输入到 /dev/null</span></span><br><span class="line">    dup2(fd, <span class="number">1</span>); <span class="comment">// 重定向标准输出到 /dev/null</span></span><br><span class="line">    dup2(fd, <span class="number">2</span>); <span class="comment">// 重定向标准错误到 /dev/null</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        close(fd); <span class="comment">// 关闭多余的文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解析<code>init.rc</code>文件</p>
<p>获取硬件名并根据硬件名解析<code>init.&lt;硬件名&gt;.rc</code>文件</p>
<p>从文件中获得<code>early-init</code>阶段需要执行的动作，将动作添加到一个执行队列的尾部并执行队列中的所有动作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240731162932328.png" class="" title="image-20240731162932328">
<blockquote>
<p>动作一般是函数指针，执行动作时通过函数指针执行函数</p>
</blockquote>
<p>获得 <code>device</code>, <code>property</code>, <code>keychord</code>的文件描述符</p>
<p>加载文件作为系统的开机画面</p>
<p>判断系统是否在QEMU虚拟机运行，执行？操作</p>
<p>设置系统属性</p>
<p>执行位于<code>init</code>阶段的动作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240801102057483.png" class="" title="image-20240801102057483">
<p>启动属性服务</p>
<p>创建socket</p>
<p>执行 <code>early-boot</code> 和 <code>boot</code> 阶段动作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240801102304897.png" class="" title="image-20240801102304897">
<p>创建文件描述符数组，将<code>device</code>, <code>property</code>, <code>signal_recv</code>,<code>keychord</code>的文件描述符写入，添加期望动作。</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240801102823567.png" class="" title="image-20240801102823567">
<img src="/2024/07/28/Android-Learning-Record/image-20240801102846996.png" class="" title="image-20240801102846996">
<p>循环，清空接收动作；开始监视文件描述符传入信息，并根据传入信息执行对应动作</p>
<img src="/2024/07/28/Android-Learning-Record/image-20240801103107985.png" class="" title="image-20240801103107985">
<blockquote>
<p>poll() 函数监视多个文件描述符(实际上监视的是文件描述符对应的文件表项的<code>f_flags</code>属性)，等待它们中的任何一个变为可读、可写或发生错误。在其变化时，revent将记录该变化。</p>
</blockquote>
<h4 id="Zygote进程">Zygote进程</h4>
<p><strong>App_main.cpp</strong></p>
<p>对传入参数进行统计与设置</p>
<p>创建<code>AppRuntime</code>，并设置成员值</p>
<p>判断条件，修改进程名与执行<code>runtime.start(...)</code></p>
<p><strong>AndroidRuntime.cpp</strong></p>
<p><code>runtime.start(...)</code></p>
<ul>
<li>创建虚拟机<code>AndroidRuntime:startVm(...)</code></li>
<li>注册JNI函数<code>AndroidRuntime:startReg(...)</code></li>
<li>使用注册JNI函数的<code>JNIEnv</code>调用Java函数，进入Java</li>
</ul>
<p><code>AndroidRuntime:startVm(...)</code></p>
<ul>
<li>设置虚拟机参数</li>
<li>调用<code>JNI_CreateJavaVM(...)</code>创建虚拟机并得到当前线程的<code>JNIEnv</code></li>
</ul>
<p><code>AndroidRuntime:startReg(...)</code></p>
<ul>
<li>调用<code>register_jni_procs(...)</code>注册JNI函数</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240805152408375.png" class="" title="image-20240805152408375">
<img src="/2024/07/28/Android-Learning-Record/image-20240805152418585.png" class="" title="image-20240805152418585">
<blockquote>
<p>注册JNI函数即将该函数指针写入指定java类的方法表(Method Table)中，在java类使用该方法时，可以直接查方法表得到该函数的地址并访问/使用</p>
</blockquote>
<p><strong>ZygoteInit.java</strong></p>
<p>调用<code>registerZygoteSocket()</code>注册zygote的socket</p>
<p>调用<code>preloadClasses()</code>&amp;<code>preloadResource()</code>预加载类和资源</p>
<p>调用<code>startSystemServer()</code>启动system_server进程</p>
<p>调用<code>runSelectLoopMode()</code>函数</p>
<p>调用<code>caller.run()</code>函数</p>
<p><code>registerZygoteSocket()</code></p>
<ul>
<li>创建服务端Socket</li>
</ul>
<p><code>preloadClasses()</code>&amp;<code>preloadResource()</code></p>
<ul>
<li>加载资源</li>
</ul>
<p><code>startSystemServer()</code></p>
<ul>
<li>fork子进程，创建system_server进程</li>
</ul>
<p><code>runSelectLoopMode()</code></p>
<ul>
<li>处理客户连接和客户请求</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240805193239427.png" class="" title="image-20240805193239427">
<p>-&gt; <code>runOnce()</code></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240805193517661.png" class="" title="image-20240805193517661">
<img src="/2024/07/28/Android-Learning-Record/image-20240805193529451.png" class="" title="image-20240805193529451">
<h4 id="SystemServer进程">SystemServer进程</h4>
<ul>
<li>由Zygote进程fork生成，SystemServer是Zygote孵化的第一个进程。</li>
<li>负责启动、管理整个Java Framework，系统里面重要的服务都是在这个进程里面开启的，比如ActivityManagerService、WindowManagerService。</li>
</ul>
<p><strong>ActivityManagerService.java</strong></p>
<p>函数<code>startProcessLocked(...)</code>中调用<code>Process.start()</code>启动Process</p>
<p><strong>Process.java</strong></p>
<p><code>Process.start()</code></p>
<ul>
<li>调用<code>startViaZygote(...)</code></li>
</ul>
<p><code>startViaZygote(...)</code></p>
<ul>
<li>参数处理</li>
<li>调用<code>zygoteSendArgsAndGetPid(参数)</code></li>
</ul>
<p><code>zygoteSendArgsAndGetPid(...)</code></p>
<ul>
<li>判断是否存在与zygote通信的Socket，并创建连接</li>
<li>发送请求参数到Zygote并获取返回结果pid</li>
</ul>
<h4 id="APP进程">APP进程</h4>
<ul>
<li>Zygote进程在App层中孵化出的第一个进程是Launcher进程，即手机的桌面APP。</li>
<li>Zygote还会孵化出Browser、Email、Phone等APP进程，每个APP至少运行在一个进程上。</li>
<li>所有APP进程都由Zygote进程fork生成。</li>
</ul>
<img src="/2024/07/28/Android-Learning-Record/image-20240805193338222.png" class="" title="image-20240805193338222">
<p>上接<code>runOnce()</code></p>
<img src="/2024/07/28/Android-Learning-Record/image-20240805193638556.png" class="" title="image-20240805193638556">
<h3 id="常用框架">常用框架</h3>
<h4 id="Glide">Glide</h4>
<h4 id="okHttp">okHttp</h4>
<p>待完成</p>
<h4 id="Retrofit">Retrofit</h4>
<p>待完成</p>
<h4 id="RxJava">RxJava</h4>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android, Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ_in_evolutionary</title>
    <url>/2025/07/27/MQ-in-evolutionary/</url>
    <content><![CDATA[<p>MQ evolution</p>
<span id="more"></span>
<h1>消息队列模型演进</h1>
<h2 id="生产者-消费者模型">生产者-消费者模型</h2>
<p>它构成了所有现代消息队列系统的内核，是理解一切复杂模型的起点。</p>
<ul>
<li>
<p><strong>原始模型</strong></p>
<ul>
<li><strong>一个生产者 (Producer)</strong>：负责创建数据（消息），并将其放入一个共享的缓冲区。</li>
<li><strong>一个消费者 (Consumer)</strong>：负责从共享缓冲区中取出数据并进行处理。</li>
<li><strong>一个有界队列 (Bounded Queue)</strong>：作为生产者和消费者之间的“传送带”，容量有限。它是解耦二者的关键，允许它们以不同的速率工作。</li>
<li><strong>阻塞机制 (Blocking)</strong>：实现异步协作的核心。
<ul>
<li>当<strong>队列满</strong>时，生产者写入时<strong>被阻塞</strong>，直到消费者取走数据腾出空间。</li>
<li>当<strong>队列空</strong>时，消费者读取时<strong>被阻塞</strong>，直到生产者放入新的数据。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>核心价值</strong></p>
<ol>
<li><strong>解耦 (Decoupling)</strong>：生产者和消费者仅与队列交互，互不感知对方的存在。</li>
<li><strong>削峰填谷 (Peak Shaving)</strong>：队列作为缓冲区，能平滑处理瞬时流量洪峰（如秒杀、大促），消费者可以按自身能力平稳消费，防止系统被压垮。</li>
<li><strong>异步 (Asynchrony)</strong>：生产者发送消息后无需等待消费者处理完毕，即可继续执行其他任务，提升系统响应速度。</li>
</ol>
</li>
</ul>
<h2 id="吞吐量-Competing-Consumers-Partition">吞吐量 (Competing Consumers &amp; Partition)</h2>
<p><strong>核心诉求：如何让多个消费者协同工作，线性提升整个系统的处理能力？</strong></p>
<ul>
<li>
<p><strong>模型描述：竞争消费者模式 (Competing Consumers)</strong></p>
<ul>
<li>一个生产者向一个队列中持续写入消息。</li>
<li>多个<strong>同类型</strong>的消费者从<strong>同一个队列</strong>中读取消息。</li>
<li>一条消息只会被<strong>其中一个</strong>消费者获取并处理，消费者之间形成<strong>竞争关系</strong>。</li>
</ul>
</li>
<li>
<p><strong>带来的特性</strong></p>
<ul>
<li><strong>优点：负载均衡 (Load Balancing)</strong>。消息被自动分发到不同的消费者，处理能力得以水平扩展。</li>
<li><strong>新挑战：顺序性丢失 (Message Disorder)</strong>。由于消息被分发给不同消费者并行处理，无法保证相关消息（如同一订单的“创建”、“付款”、“发货”）的<strong>处理顺序</strong>。</li>
</ul>
</li>
<li>
<p><strong>解决方案：分区 (Partition)</strong><br>
为了在提升吞吐量的同时，兼顾特定场景的顺序性，引入了<strong>分区</strong>概念。</p>
<ul>
<li><strong>原理</strong>：将一个逻辑上的队列（Topic/Queue）在物理上划分为多个独立的子队列（Partition）。这就像将一条单车道公路，拓宽成多车道的并行高速公路。
<ul>
<li>生产者发送消息时，可指定一个<strong>分区键 (Partition Key)</strong>（如 <code>order_id</code>）。</li>
<li>消息系统通过哈希等算法，确保<strong>相同键的消息总是被路由到同一个分区</strong>。</li>
</ul>
</li>
<li><strong>效果</strong>：
<ul>
<li><strong>分区内绝对有序</strong>：每个分区内的消息是严格先进先出的。</li>
<li><strong>消费者与分区绑定</strong>：系统通常会将一个分区在同一时间只分配给消费组内的一个消费者。这样，同一订单的所有消息都会进入同一个分区，并由同一个消费者按顺序处理。</li>
<li><strong>兼顾吞吐与顺序</strong>：不同分区的消息可以被不同消费者并行处理，完美地平衡了吞吐量和局部顺序性的需求。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>典型实现</strong>：<strong>Kafka</strong> 的 Partition 机制是该模式的业界标杆。</p>
</blockquote>
</li>
</ul>
<br>
<h2 id="一对多的消息广播-Publish-Subscribe-Topic">一对多的消息广播 (Publish/Subscribe &amp; Topic)</h2>
<p><strong>核心诉求：一条消息如何被多个不同的下游系统独立消费？</strong></p>
<ul>
<li>
<p><strong>模型描述：发布/订阅模式 (Publish/Subscribe)</strong></p>
<ul>
<li>生产者（Publisher）发布某一类型的消息，不关心谁来消费。</li>
<li>多个<strong>不同类型</strong>的消费者（Subscriber），它们各自有不同的业务逻辑，但都对同一条消息感兴趣。</li>
<li>当一条消息产生时，它需要被<strong>广播</strong>给所有订阅了它的消费者，每个消费者都会收到一个<strong>消息的副本</strong>并独立处理。</li>
</ul>
</li>
<li>
<p><strong>新挑战：广播难题</strong></p>
<ul>
<li>如果继续使用单一队列（竞争消费模式），一个消费者取走消息后，其他消费者就无法再获得，无法满足广播需求。这好比“食堂打饭”，一份菜只能被一个人打走。</li>
<li>我们需要一种“报纸订阅”的模式：报社印刷一次，所有订阅者都能收到一份报纸。</li>
</ul>
</li>
<li>
<p><strong>解决方案：主题 (Topic) 与订阅 (Subscription)</strong></p>
<ul>
<li><strong>原理</strong>：
<ul>
<li><strong>生产者 (Publisher)</strong> 将消息发送到一个逻辑上的消息类别——<strong>主题 (Topic)</strong>。</li>
<li><strong>消费者 (Subscriber)</strong> 不再直接监听队列，而是<strong>订阅 (Subscribe)</strong> 它们感兴趣的主题。</li>
<li>消息系统负责将发布到某个主题的每条消息，<strong>复制并分发</strong>给所有订阅了该主题的消费者（或消费组）。</li>
</ul>
</li>
<li><strong>效果</strong>：
<ul>
<li><strong>彻底解耦</strong>：生产者和消费者通过主题解耦，彼此完全独立。</li>
<li><strong>高扇出能力 (High Fan-out)</strong>：一条消息可以被任意数量、不同目的的下游系统独立消费。例如，一个订单创建成功后，可以同时通知库存系统、营销系统和数据分析系统，各自独立处理。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>典型实现</strong>：<strong>RabbitMQ</strong> 中的 Fanout Exchange、<strong>Kafka</strong> 和 <strong>RocketMQ</strong> 中的 Topic 都实现了此模式。</p>
<p>消费者组对应于topic</p>
</blockquote>
</li>
</ul>
<br>
<h2 id="可靠性-ACK-Persistence">可靠性 (ACK &amp; Persistence)</h2>
<p><strong>核心诉求：如何在任何一个环节（网络、硬件、程序）发生故障时，消息都不丢失？</strong></p>
<ul>
<li>
<p><strong>场景描述</strong><br>
在现实世界中，消息传递的每个环节都可能出错，导致消息丢失：</p>
<ul>
<li><strong>生产者 -&gt; Broker</strong>：发送过程中网络中断。</li>
<li><strong>Broker 内部</strong>：消息还未落盘，Broker 宕机。</li>
<li><strong>Broker -&gt; 消费者</strong>：消费者处理消息期间自身崩溃。</li>
</ul>
</li>
<li>
<p><strong>核心解决方案：确认与重试 (Acknowledgement &amp; Retry)</strong><br>
消息的接收方在成功处理后，向发送方回送一个<strong>确认信号 (ACK)</strong>。若发送方未在规定时间内收到ACK，则认为投递失败，并进行<strong>重试</strong>。该机制贯穿消息传递的全链路。</p>
</li>
<li>
<p><strong>演进方案与特性</strong></p>
<h4 id="生产者-Broker-可靠性：发送方确认-Publisher-Confirms">生产者 -&gt; Broker 可靠性：发送方确认 (Publisher Confirms)</h4>
<ul>
<li><strong>原理</strong>：Broker 成功接收并持久化消息后，才向生产者发送 ACK。若生产者未收到 ACK，则重发。</li>
<li><strong>效果</strong>：保证消息从生产者可靠地到达 Broker。</li>
<li><strong>副作用</strong>：可能产生<strong>重复消息</strong>。这就要求消费者必须具备<strong>幂等性</strong>。</li>
</ul>
<h4 id="Broker-自身可靠性：持久化与集群-Persistence-Clustering">Broker 自身可靠性：持久化与集群 (Persistence &amp; Clustering)</h4>
<ul>
<li><strong>原理</strong>：
<ul>
<li><strong>持久化 (Persistence)</strong>：Broker 将消息写入硬盘，防止进程或服务器重启导致数据丢失。</li>
<li><strong>集群/复制 (Replication)</strong>：Broker 以集群形式部署，消息会从主节点（Leader）复制到多个从节点（Follower）。只有当指定数量的副本同步完成后，才向生产者发送 ACK。</li>
</ul>
</li>
<li><strong>效果</strong>：提供<strong>高可用性</strong>和<strong>数据冗余</strong>，防止单点故障。</li>
</ul>
<h4 id="Broker-消费者可靠性：消费方确认-Consumer-Acknowledgement">Broker -&gt; 消费者可靠性：消费方确认 (Consumer Acknowledgement)</h4>
<ul>
<li><strong>原理</strong>：Broker 将消息投递给消费者后，会等待消费者的 ACK。消费者在<strong>完成所有业务逻辑</strong>后，才发送 ACK。若 Broker 未收到 ACK（例如消费者崩溃），它会将该消息<strong>重新投递</strong>给另一个健康的消费者。</li>
<li><strong>效果</strong>：保证消息最终一定会被成功消费，实现了<strong>至少一次消费 (At-least-once Delivery)</strong>。</li>
<li><strong>副作用</strong>：同样可能产生<strong>重复消费</strong>，再次强调了消费者<strong>幂等性</strong>的重要性。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>幂等性 (Idempotency)</strong><br>
指对同一个操作执行一次和执行多次，产生的结果完全相同。它是实现可靠消息系统的<strong>消费端必须遵循的核心设计原则</strong>，用于从容应对重复消息，避免“一笔订单支付两次”等严重问题。</p>
</blockquote>
<br>
<h2 id="业务与消息的原子性绑定-Transactional-Messages">业务与消息的原子性绑定 (Transactional Messages)</h2>
<p><strong>核心诉求：如何保证本地数据库操作和消息发送这两个动作，要么都成功，要么都失败？</strong></p>
<ul>
<li>
<p><strong>场景：数据一致性难题</strong><br>
在下单流程中，你需要：1. 在数据库中创建订单记录；2. 发送“订单已创建”消息。</p>
<ul>
<li><strong>先写库，后发消息</strong>：写库成功后，应用崩溃，消息未发出 -&gt; 数据不一致。</li>
<li><strong>先发消息，后写库</strong>：消息发送成功后，数据库写入失败 -&gt; 数据不一致。</li>
</ul>
</li>
<li>
<p><strong>解决方案：借鉴两阶段提交的事务消息</strong><br>
通过引入“半消息 (Half-Message)”机制，将一次发送拆分为两个阶段。</p>
<ul>
<li><strong>原理</strong>：
<ol>
<li><strong>发送半消息 (Prepare)</strong>：生产者先向 Broker 发送一条对消费者<strong>不可见</strong>的“半消息”。</li>
<li><strong>执行本地事务</strong>：生产者收到 Broker 对半消息的确认后，执行本地数据库操作。</li>
<li><strong>二次确认 (Commit/Rollback)</strong>：
<ul>
<li>本地事务<strong>成功</strong>，生产者向 Broker 发送 <strong>Commit</strong>，Broker 使该消息对消费者可见。</li>
<li>本地事务<strong>失败</strong>，生产者向 Broker 发送 <strong>Rollback</strong>，Broker 删除该半消息。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>关键保险丝：事务状态回查</strong></p>
<ul>
<li><strong>问题</strong>：如果生产者在执行完本地事务后、发送二次确认前宕机怎么办？</li>
<li><strong>方案</strong>：Broker 会定期向生产者<strong>回查</strong>这些“半消息”对应的本地事务状态。</li>
<li><strong>生产者责任</strong>：生产者必须提供一个回查接口，在该接口中查询本地数据库，并根据事务的最终状态（成功/失败）告知 Broker 应该 Commit 还是 Rollback。</li>
</ul>
</li>
<li>
<p><strong>效果</strong></p>
<ul>
<li><strong>最终一致性 (Eventual Consistency)</strong>：虽有延迟，但保证了本地操作与消息发送的最终结果一致，是分布式事务的经典解决方案。</li>
<li><strong>应用层解耦</strong>：将复杂的分布式协调逻辑下沉到消息中间件，简化了应用开发。</li>
</ul>
<blockquote>
<p><strong>典型实现</strong>：<strong>Apache RocketMQ</strong> 对事务消息提供了业界领先的原生支持，是其核心亮点之一。</p>
</blockquote>
</li>
</ul>
<br>
<h2 id="失败与异常-Dead-Letter-Queue">失败与异常 (Dead-Letter Queue)</h2>
<p><strong>核心诉求：当一条消息持续消费失败时，如何避免它阻塞整个队列，并能对其进行追踪和处理？</strong></p>
<ul>
<li>
<p><strong>场景：“毒丸”消息 (Poison Pill Message)</strong><br>
某些消息因自身格式错误或触发了代码 Bug，导致消费者<strong>反复消费失败</strong>。若消息队列的重试机制不断重投这条“毒丸”，会：</p>
<ol>
<li><strong>阻塞队列</strong>：在顺序消费场景下，卡住后续所有正常消息的处理。</li>
<li><strong>浪费资源</strong>：消费者不断进行无效的尝试和报错。</li>
</ol>
</li>
<li>
<p><strong>解决方案：死信队列 (Dead-Letter Queue, DLQ)</strong><br>
为这些“毒丸”消息提供一个专门的“收容所”。</p>
<ul>
<li><strong>原理</strong>：
<ol>
<li><strong>设置重试阈值</strong>：为业务队列配置一个最大重试次数。</li>
<li><strong>指定死信队列</strong>：创建一个普通队列作为死信队列。</li>
<li><strong>自动路由</strong>：当某条消息的重试次数达到阈值后，Broker 会停止向原队列投递，而是将其<strong>自动路由到指定的死信队列</strong>中，并附加上失败原因、时间等元数据。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>效果</strong></p>
<ol>
<li><strong>保障主流程可用性</strong>：将问题消息隔离，确保正常消息的处理流程不受影响，极大提升系统健壮性。</li>
<li><strong>问题追溯与告警</strong>：运维人员可以监控死信队列，一旦有消息进入，立即触发告警。开发人员可根据死信信息快速定位问题，进行修复。</li>
<li><strong>人工干预成为可能</strong>：修复问题后，可以将死信消息重新发送回原队列进行处理，实现数据恢复。</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>典型实现</strong>：<strong>RabbitMQ</strong> 的 Dead Letter Exchange 是经典实现。<strong>RocketMQ</strong> 也原生支持。<strong>Kafka</strong> 通常需要通过自定义逻辑或社区方案实现。</p>
</blockquote>
<br>
]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine-Learning</title>
    <url>/2025/04/22/Machine-Learning/</url>
    <content><![CDATA[<p>Machine Learning</p>
<p>施工中…</p>
<span id="more"></span>
<h1>Machine-Learning</h1>
<p>ref: <a href="https://ailearning.apachecn.org/">https://ailearning.apachecn.org/</a></p>
<p>ref: <a href="https://developers.google.com/machine-learning">https://developers.google.com/machine-learning</a></p>
<h2 id="机器学习基本概念">机器学习基本概念</h2>
<h3 id="监督学习">监督学习</h3>
<p><strong>分类算法（Classification Algorithms）</strong></p>
<ul>
<li><strong>任务目标</strong>：预测一个<strong>离散的类别标签</strong>（如是否患病、邮件是否是垃圾邮件）</li>
<li><strong>常见算法包括</strong>：
<ul>
<li>逻辑回归（Logistic Regression）</li>
<li>K近邻（K-Nearest Neighbors）</li>
<li>决策树（Decision Tree）</li>
<li>随机森林（Random Forest）</li>
<li>支持向量机（SVM）</li>
<li>梯度提升树（XGBoost, LightGBM）</li>
<li>神经网络（用于图像分类、文本分类等）</li>
</ul>
</li>
</ul>
<p><strong>回归算法（Regression Algorithms）</strong></p>
<ul>
<li><strong>任务目标</strong>：预测一个<strong>连续值</strong>（如房价、股票价格、温度）</li>
<li><strong>常见算法包括</strong>：
<ul>
<li>线性回归（Linear Regression）</li>
<li>岭回归 / 套索回归（Ridge / Lasso）</li>
<li>决策树回归（Decision Tree Regression）</li>
<li>随机森林回归（Random Forest Regressor）</li>
<li>支持向量回归（SVR）</li>
<li>神经网络（用于非线性回归任务）</li>
</ul>
</li>
</ul>
<br>
<h3 id="非监督学习">非监督学习</h3>
<ul>
<li>
<p>无标签数据，目标是发现数据的结构、规律、分布</p>
</li>
<li>
<p><strong>常见算法包括</strong>：</p>
<p><strong>聚类（Clustering）</strong></p>
<ul>
<li>K-Means, DBSCAN, 层次聚类</li>
<li>例子：客户画像、文档聚类</li>
</ul>
<p><strong>降维（Dimensionality Reduction）</strong></p>
<ul>
<li>PCA, t-SNE, UMAP</li>
<li>例子：可视化高维数据、数据压缩</li>
</ul>
<p><strong>异常检测（Anomaly Detection）</strong></p>
<ul>
<li>Isolation Forest, 一类SVM</li>
<li>例子：信用卡欺诈检测、工业设备故障</li>
</ul>
</li>
</ul>
<br>
<h3 id="强化学习">强化学习</h3>
<p>Q-Learning, SARSA（基于值）</p>
<p>Policy Gradient, Actor-Critic（基于策略）</p>
<br>
<h3 id="训练、验证、测试集">训练、验证、测试集</h3>
<br>
<h3 id="过拟合与欠拟合">过拟合与欠拟合</h3>
<br>
<h3 id="模型评估指标">模型评估指标</h3>
<p>精度、召回率、F1、AUC等</p>
<br>
<br>
<h2 id="常用算法">常用算法</h2>
<h3 id="监督学习-2">监督学习</h3>
<h4 id="线性回归">线性回归</h4>
<p><strong>回归</strong></p>
<p>通过 （Feature，Label）训练函数，通过特征输入预测标签</p>
<p>一般的，线性回归模型的方程为<br>
$$<br>
y’ = b + w_1x_1<br>
$$<br>
其中：</p>
<ul>
<li>y′ 是预测的标签，即输出。</li>
<li>b 是模型的偏差。偏差与线性代数方程中的 y 截距的概念相同。在机器学习中，偏差有时称为 w0。偏差是模型的参数，在训练期间计算得出。</li>
<li>w1 是特征的权重。权重与线性代数方程中的斜率 m 的概念相同。权重是模型的参数，在训练期间计算得出。</li>
<li>x1 是特征，即输入。</li>
</ul>
<p>多项式回归模型的方程为<br>
$$<br>
y’ = b + \sum_i w_i x_i<br>
$$<br>
符号含义相似。</p>
<br>
<p>损失函数选择平方损失函数（也称为 L2 损失函数），表示为<br>
$$<br>
Loss = \sum_{(x,y) \in D} (y - y’)^2<br>
$$<br>
其中：</p>
<ul>
<li>$(x,y) \in D$ 是包含多个有标签样本的数据集，这些样本为 $(x,y)$ 对。</li>
</ul>
<p>一般的，有四种主要的损失函数，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">损失类型</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">L1 损失</td>
<td style="text-align:left">预测值与实际值之间差异的绝对值的总和。</td>
<td style="text-align:left">$\sum</td>
</tr>
<tr>
<td style="text-align:left">平均绝对误差 (MAE)</td>
<td style="text-align:left">一组示例的 L1 损失的平均值。</td>
<td style="text-align:left">$\frac{1}{N} \sum</td>
</tr>
<tr>
<td style="text-align:left">L2 损失</td>
<td style="text-align:left">预测值与实际值之间的平方差的总和。</td>
<td style="text-align:left">$\sum(y − y’)^2$</td>
</tr>
<tr>
<td style="text-align:left">均方误差 (MSE)</td>
<td style="text-align:left">一组示例的 L2 损失的平均值。</td>
<td style="text-align:left">$\frac{1}{N} \sum(y − y’)^2$</td>
</tr>
</tbody>
</table>
<p>其中，$y$ 为真实数据（监督学习中的训练集数据）， $y’$ 为模型预测值</p>
<p>L1 损失函数和 L2 损失函数（或 MAE 和 MSE）之间的功能差异在于平方。当预测值与标签之间的差异较大时，平方会使损失变得更大。当差异很小（小于 1）时，平方会使损失更小。</p>
<br>
<h4 id="逻辑回归">逻辑回归</h4>
<p><strong>分类</strong></p>
<p>逻辑回归的方程为<br>
$$<br>
y’ = \frac{1}{1 + e^{-z}}<br>
$$<br>
其中：</p>
<ul>
<li><em>z</em> 是线性方程的输出</li>
</ul>
<p>逻辑回归模型的线性组件表示为：<br>
$$<br>
z = b + \sum_i w_i x_i<br>
$$<br>
其中：</p>
<ul>
<li><em>z</em> 是线性方程的输出（也称为 对数几率。</li>
<li><em>b</em> 是偏差。</li>
<li>w 的值是模型学习的权重。</li>
<li>x 的值是特定样本的特征值。</li>
</ul>
<br>
<p>逻辑回归的损失函数是 对数损失函数。通过 对数损失方程式会返回变化幅度的对数， 而不只是从数据到预测的距离。对数损失的计算公式为 如下：<br>
$$<br>
Loss = \sum_{(x,y) \in D} -y\log(y’) - (1-y)\log(1-y’)<br>
$$<br>
其中：</p>
<ul>
<li>$(x,y) \in D$ 是包含多个有标签样本的数据集，这些样本为 $(x,y)$ 对。</li>
<li>$y$ 是有标签样本中的标签。由于这是逻辑回归， $y$ 的每个值都必须为 0 或 1。</li>
<li>$y′$ 是模型的预测结果（介于 0 和 1 之间），给定集合 $x$ 中的功能。</li>
</ul>
<br>
<p>补充</p>
<hr>
<p><strong>逻辑回归模型的本质</strong>可以概括为：</p>
<p>逻辑回归假设的是因变量的“对数几率（log odds）”与自变量之间存在线性关系。</p>
<hr>
<p><strong>逻辑回归要解决什么问题？</strong></p>
<p>逻辑回归主要用于<strong>分类问题</strong>，特别是<strong>二分类问题</strong>，比如预测某人是否患病、某封邮件是否是垃圾邮件等。</p>
<ul>
<li>因变量 $y$ 只能取两个值，通常设为 0 和 1。</li>
<li>输入的是一个或多个自变量（特征） $x_1, x_2, \dots, x_n$。</li>
</ul>
<p>我们希望建一个模型，输出：</p>
<p>$P(y = 1 \mid \mathbf{x})$</p>
<p>也就是，给定自变量 $\mathbf{x}$，预测 $y = 1$ 的概率。</p>
<hr>
<p><strong>为什么不能直接用线性模型？</strong></p>
<p>最初的想法可能是用线性回归：</p>
<p>$P(y = 1 \mid \mathbf{x}) = \beta_0 + \beta_1 x_1 + \dots + \beta_n x_n$</p>
<p><strong>但这不合理</strong>，因为：</p>
<ul>
<li>概率值必须在 $[0,1]$ 区间；</li>
<li>而线性函数的值可以任意大或任意小。</li>
</ul>
<p>所以我们需要一种变换，既能处理线性组合，又能保证输出落在 $[0,1]$ 区间。</p>
<p><strong>引入几率（Odds）和对数几率（Log Odds）</strong></p>
<ul>
<li>
<p>几率定义为：</p>
<p>$\text{Odds} = \frac{P(y=1)}{P(y=0)} = \frac{p}{1-p}$</p>
</li>
<li>
<p>对数几率（log odds）：</p>
<p>$\log\left(\frac{p}{1-p}\right)$</p>
</li>
</ul>
<p>对数几率是从概率空间映射到 $(-\infty, +\infty)$，适合做线性建模。</p>
<p><strong>逻辑回归模型的核心假设</strong></p>
<p>逻辑回归的核心假设是：</p>
<p>$\log\left(\frac{p}{1-p}\right) = \beta_0 + \beta_1 x_1 + \dots + \beta_n x_n$</p>
<p>也就是说：</p>
<blockquote>
<p><strong>自变量的线性组合影响的是“对数几率”，而不是概率本身。</strong></p>
</blockquote>
<p><strong>通过变换得到 Sigmoid 函数（逻辑函数）</strong></p>
<p>从上面的等式出发，解出 $p$（即 $P(y=1)$）：</p>
<p>$$\frac{p}{1-p} = e^{\beta_0 + \beta_1 x_1 + \dots + \beta_n x_n} \Rightarrow p = \frac{1}{1 + e^{-(\beta_0 + \beta_1 x_1 + \dots + \beta_n x_n)}}$$</p>
<p>这个形式就是著名的 <strong>Sigmoid 函数</strong>：</p>
<p>$p = \sigma(z) = \frac{1}{1 + e^{-z}}, \quad z = \beta_0 + \beta_1 x_1 + \dots + \beta_n x_n$</p>
<p>逻辑回归不是对“概率”建模，而是对“对数几率”建模。</p>
<ul>
<li>
<p><strong>本质假设：</strong></p>
<p>$\log\left(\frac{p}{1-p}\right) = \text{线性函数}$</p>
</li>
<li>
<p>这样做的好处：</p>
<ul>
<li>保证概率值在 $[0,1]$</li>
<li>模型保持线性模型的优雅（便于解释、训练）</li>
</ul>
</li>
</ul>
<br>
<h4 id="K近邻">K近邻</h4>
<p><strong>分类</strong></p>
<p>k 近邻算法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。</p>
<p>k 近邻算法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其 k 个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻算法不具有显式的学习过程。</p>
<img src="/2025/04/22/Machine-Learning/knn-1-movie.png" class="" title="电影视频案例">
<p>流程：</p>
<ol>
<li>假设有一个带有标签的样本数据集（训练样本集），其中包含每条数据与所属分类的对应关系。</li>
<li>输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较。
<ol>
<li>计算新数据与样本数据集中每条数据的距离。</li>
<li>对求得的所有距离进行排序（从小到大，越小表示越相似）。</li>
<li>取前 k （k 一般小于等于 20 ）个样本数据对应的分类标签。</li>
</ol>
</li>
<li>求 k 个数据中出现次数最多的分类标签作为新数据的分类。</li>
</ol>
<br>
<h4 id="决策树">决策树</h4>
<p><strong>分类或回归</strong></p>
<p>决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程。它可以认为是 if-then 规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。<br>
决策树学习通常包括 3 个步骤: 特征选择、决策树的生成和决策树的修剪。</p>
<p>流程：</p>
<p>def createBranch():<br>
检测数据集中的所有数据的分类标签是否相同:<br>
If so return 类标签<br>
Else:<br>
寻找划分数据集的最好特征（划分之后信息熵最小，也就是信息增益最大的特征）<br>
划分数据集<br>
创建分支节点<br>
for 每个划分的子集<br>
调用函数 createBranch （创建分支的函数）并增加返回结果到分支节点中<br>
return 分支节点</p>
<br>
<h4 id="随机森林">随机森林</h4>
<p><strong>分类</strong></p>
<p><strong>随机森林（Random Forest）</strong> 是集成学习方法的一种，它通过构建多个决策树并进行投票（分类）或平均（回归）来提升模型的准确率与鲁棒性。</p>
<br>
<h4 id="支持向量机">支持向量机</h4>
<p><strong>分类</strong></p>
<p>支持向量机是一种强大的分类和回归算法，核心思想是：<strong>寻找一个最优的超平面，将不同类别的样本最大间隔分开</strong>。</p>
<ul>
<li>对于线性可分问题，SVM 通过最大化边界间隔实现分类。</li>
<li>对于线性不可分问题，SVM 使用核函数（如 RBF、Polynomial）将数据映射到高维空间，在高维空间中实现线性可分。</li>
<li><strong>支持向量</strong> 是位于分类边界上的样本点，对模型的决策起关键作用。</li>
</ul>
<p>SVM 的损失函数通常是<strong>合页损失（Hinge Loss）</strong>，其形式如下：</p>
<p>$$<br>
Loss = \sum_{i=1}^N \max(0, 1 - y_i(w^T x_i + b))<br>
$$</p>
<p>其中 $y_i$ 为真实标签（取值为 ±1），$x_i$ 为输入特征，$w$ 和 $b$ 为模型参数。</p>
<br>
<h3 id="非监督学习-2">非监督学习</h3>
<h4 id="K-means-聚类">K-means 聚类</h4>
<p><strong>聚类</strong></p>
<p>流程</p>
<ul>
<li>创建 k 个点作为起始质心（通常是随机选择）</li>
<li>当任意一个点的簇分配结果发生改变时（不改变时算法结束）
<ul>
<li>对数据集中的每个数据点
<ul>
<li>对每个质心
<ul>
<li>计算质心与数据点之间的距离</li>
</ul>
</li>
<li>将数据点分配到距其最近的簇</li>
</ul>
</li>
<li>对每一个簇, 计算簇中所有点的均值并将均值作为质心</li>
</ul>
</li>
</ul>
<br>
<h4 id="SVD">SVD</h4>
<p><strong>降维</strong></p>
<p>奇异值分解</p>
<br>
<h4 id="PCA">PCA</h4>
<p><strong>降维</strong></p>
<p>流程</p>
<ol>
<li>找出第一个主成分的方向，也就是数据 <code>方差最大</code> 的方向。</li>
<li>找出第二个主成分的方向，也就是数据 <code>方差次大</code> 的方向，并且该方向与第一个主成分方向 <code>正交(orthogonal 如果是二维空间就叫垂直)</code>。</li>
<li>通过这种方式计算出所有的主成分方向。</li>
<li>通过数据集的协方差矩阵及其特征值分析，我们就可以得到这些主成分的值。</li>
<li>一旦得到了协方差矩阵的特征值和特征向量，我们就可以保留最大的 N 个特征。这些特征向量也给出了 N 个最重要特征的真实结构，我们就可以通过将数据乘上这 N 个特征向量 从而将它转换到新的空间上。</li>
</ol>
<br>
<h4 id="Isolation-Forest">Isolation Forest</h4>
<br>
<h3 id="其他">其他</h3>
<p>贝叶斯分类器（朴素贝叶斯等）</p>
<br>
<p>异常检测（Isolation Forest, One-Class SVM）</p>
<br>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/2025/03/28/Netty/</url>
    <content><![CDATA[<p>Netty</p>
<span id="more"></span>
<h1>Netty&amp;Rela</h1>
<h2 id="Proactor-Reactor">Proactor &amp; Reactor</h2>
<h3 id="Proactor">Proactor</h3>
<p>主动执行者</p>
<ol>
<li><strong>异步操作</strong>：应用程序发起I/O操作后立即返回，不阻塞</li>
<li><strong>完成通知</strong>：当I/O操作完成后，系统通知应用程序</li>
<li><strong>事件分离</strong>：由专门的组件（如事件循环）负责分发完成事件</li>
<li><strong>回调处理</strong>：预先注册的回调函数处理完成事件</li>
</ol>
<h3 id="Reactor">Reactor</h3>
<p>反应器</p>
<ol>
<li><strong>事件驱动</strong>：应用程序注册感兴趣的事件（如可读、可写）</li>
<li><strong>同步非阻塞</strong>：使用非阻塞I/O，但同步等待事件就绪</li>
<li><strong>事件分离</strong>：由专门的组件（如事件循环）负责检测和分发事件</li>
<li><strong>回调处理</strong>：预先注册的事件处理器处理就绪事件</li>
</ol>
<h3 id="Diff">Diff</h3>
<ul>
<li><strong>Reactor</strong>：同步非阻塞模式，关注&quot;何时可读/可写&quot;, 非阻塞I/O, 应用程序主动读取/写入数据</li>
<li><strong>Proactor</strong>：异步模式，关注&quot;读/写已完成&quot;,  异步I/O, 操作系统完成I/O后通知应用程序</li>
</ul>
<p><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</p>
<p><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p>
<h2 id="Java-IO">Java IO</h2>
<p>适用场景区别</p>
<ol>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li>
<li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li>
<li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li>
</ol>
<h3 id="BIO">BIO</h3>
<img src="/2025/03/28/Netty/chapter02_01.png" class="" title="img">
<p>在Java的BIO（Blocking I/O）模型中，当用户发送数据到服务器的socket内核缓冲区后，用户进程是通过<strong>阻塞式系统调用</strong>的方式从内核缓冲区读取数据的。具体到代码：</p>
<ol>
<li><strong>关键点分析</strong>：<br>
• <code>inputStream.read(bytes)</code> 是一个<strong>阻塞调用</strong>，它会一直等待，直到内核缓冲区中有数据到达（或连接关闭）。<br>
• 当客户端发送数据时，数据会先被内核接收并存入socket的接收缓冲区，然后内核会唤醒被阻塞的<code>read()</code>系统调用，将数据从内核缓冲区复制到用户空间（即你的<code>bytes</code>数组）。</li>
<li><strong>详细流程</strong>：<br>
• <strong>数据到达</strong>：客户端发送的数据通过TCP协议栈到达服务器的网卡，内核将数据存入该socket对应的接收缓冲区。<br>
• <strong>唤醒进程</strong>：内核会通知（唤醒）正在阻塞等待<code>read()</code>的线程，此时<code>read()</code>会返回可读的字节数（<code>read &gt; 0</code>）。<br>
• <strong>数据拷贝</strong>：<code>read()</code>内部会触发系统调用（如Linux的<code>recv()</code>），将数据从内核缓冲区复制到Java进程的<code>bytes</code>数组中。</li>
<li><strong>BIO的特点</strong>：<br>
• 每个连接需要一个独立线程处理，<code>read()</code>会阻塞线程直到数据就绪。<br>
• 内核缓冲区的存在使得即使进程没有及时调用<code>read()</code>，数据也不会丢失（缓冲区未满时）。</li>
</ol>
<p><strong><code>serverSocket.accept()</code> 的行为</strong></p>
<ul>
<li><strong>作用</strong>：监听指定的端口（这里是6666），等待客户端发起TCP连接请求。</li>
<li><strong>阻塞性</strong>：这是一个<strong>阻塞调用</strong>，如果没有客户端连接，线程会一直卡在这里，直到有新的连接到达。</li>
<li>连接建立：当客户端（如Socket或telnet）发起连接时，操作系统内核会完成TCP三次握手，然后将这个新连接交给accept()方法。
<ul>
<li>此时，<code>accept()</code>会返回一个新的<code>Socket</code>对象（即代码中的<code>socket</code>），代表与客户端的独立连接。</li>
<li><strong>注意</strong>：此时连接已建立（TCP握手完成），但客户端可能还没有发送任何数据。</li>
</ul>
</li>
</ul>
<p><strong><code>inputStream.read()</code> 的行为</strong></p>
<ul>
<li><strong>作用</strong>：从已建立的连接中读取客户端发送的数据。</li>
<li>阻塞性：这也是一个阻塞调用，如果客户端没有发送数据，线程会卡在read()方法，直到：
<ol>
<li>客户端发送数据 → 数据到达内核缓冲区 → <code>read()</code>返回读取的字节数（<code>read &gt; 0</code>）。</li>
<li>客户端关闭连接 → <code>read()</code>返回<code>-1</code>（表示EOF）。</li>
<li>发生异常（如连接重置）。</li>
</ol>
</li>
</ul>
<p>主线程监听是否有连接请求，接收连接后将任务交由线程池中线程处理</p>
<p>任务线程负责对连接进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">newCachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//我们重写</span></span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">&quot;read....&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, read));<span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NIO">NIO</h3>
<img src="/2025/03/28/Netty/chapter02_02.png" class="" title="img">
<img src="/2025/03/28/Netty/chapter03_01.png" class="" title="img">
<p>特性</p>
<ol>
<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>
<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>
<li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li>
<li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li>
<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>
<li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li>
<li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>
</ol>
<h4 id="Selector">Selector</h4>
<p>概述</p>
<ol>
<li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li>
<li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li>
</ol>
<p>机制</p>
<ul>
<li><strong>底层依赖操作系统的 I/O 多路复用</strong>（如 Linux 的 <code>epoll</code>、Windows 的 <code>IOCP</code>、macOS 的 <code>kqueue</code>）。
<ul>
<li>当调用 <code>selector.select()</code> 时，JVM 会通过操作系统提供的机制<strong>阻塞等待</strong>，直到至少一个 Channel 有就绪事件（如可读、可写、连接完成等），而不是主动轮询所有 Channel。</li>
<li>这种阻塞是高效的，因为操作系统内核会直接通知哪些 Channel 就绪，避免了用户态的无谓循环。</li>
</ul>
</li>
<li><strong>返回就绪事件后</strong>，Selector 会通过 <code>selectedKeys()</code> 返回一个集合，开发者需要<strong>手动遍历处理这些事件</strong>（这一步是用户态的轮询）。</li>
</ul>
<p><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</p>
<p>SelectionKey</p>
<p>SelectionKey 表示 Selector 和网络通道的注册关系，共四种：</p>
<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
<img src="/2025/03/28/Netty/chapter03_15.png" class="" title="img">
<ol>
<li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li>
<li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li>
<li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li>
<li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li>
<li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li>
<li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li>
<li>可以通过得到的 <code>channel</code>，完成业务处理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端：单线程Reactor，所有操作（I/O + 业务处理）均在Reactor线程完成。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="comment">// 服务端用于监听客户端连接的通道，它不直接与客户端通信，而是接收客户端的连接请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//将该 listenChannel 注册到 selector，监听事件：有新的网络连接可以接收</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();  <span class="comment">// 线程阻塞在 select 方法</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">//有事件处理</span></span><br><span class="line">                    <span class="comment">// 遍历得到 selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//取出 selectionkey</span></span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="comment">//监听到 accept</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">//建立连接</span></span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> listenChannel.accept();</span><br><span class="line">                            <span class="comment">// sc实例直接与客户端通信，用于读取客户端发送的数据或向客户端转发消息</span></span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到 seletor，监听事件：客户端发送的数据</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;<span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">// 处理读(专门写方法..)</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的 key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到 channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建 buffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">//  数据从内核态拷贝到用户态堆内存</span></span><br><span class="line">            <span class="comment">//根据 count 的值做处理</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form客户端:&quot;</span> + msg);</span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key 取出对应的 SocketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">dest</span> <span class="operator">=</span> (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将 msg 存储到 buffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将 buffer 的数据写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">groupChatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;<span class="comment">//服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;<span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器,完成初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//将 channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到 username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//得到一个 Buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove(); <span class="comment">//删除当前的 selectionKey,防止重复操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动客户端</span></span><br><span class="line">        <span class="type">GroupChatClient</span> <span class="variable">chatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>();</span><br><span class="line">        <span class="comment">//启动一个线程,每个 3 秒，读取从服务器发送的数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Channel">Channel</h4>
<ol>
<li>NIO 的通道类似于流，但有些区别如下：
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
</li>
<li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li>
<li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li>
<li>常用的 <code>Channel</code> 类有: <strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong> 。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li>
<li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li>
</ol>
<blockquote>
<p>双向性体现：FileInputStream 和 FileOutputStream 为两个不同的类，FileChannel 为一个类，可实现read和write</p>
<p>实际使用的时候还是需要从FileInputStream 和 FileOutputStream 获取 FileChannel</p>
</blockquote>
<p>从Stream获取Channel</p>
<p>Buffer 的双向读写体现</p>
<ul>
<li><strong>读取阶段</strong>：<code>fileChannel01.read(byteBuffer)</code> 将数据从通道写入 Buffer（此时 Buffer 处于写模式）</li>
<li><strong>写入阶段</strong>：<code>fileChannel02.write(byteBuffer)</code> 将数据从 Buffer 读取到通道（需要先调用 <code>flip()</code> 切换为读模式）</li>
</ul>
<p>关键点在于同一个 <code>ByteBuffer</code> 对象先被用于接收数据（写操作），然后被翻转后用于提供数据（读操作），这体现了 Buffer 的双向性。</p>
<h4 id="Buffer">Buffer</h4>
<img src="/2025/03/28/Netty/chapter03_05.png" class="" title="img">
<p><code>byteBuffer.flip()</code></p>
<ol>
<li><strong>模式切换</strong>：将缓冲区从写模式切换到读模式</li>
<li>重置指针：
<ul>
<li>将 <code>limit</code> 设置为当前 <code>position</code> 值（即写入的最后一个位置）</li>
<li>将 <code>position</code> 重置为 0（准备从头开始读取）</li>
<li><code>mark</code> 被丢弃（如果之前设置了）</li>
</ul>
</li>
</ol>
<p><code>byteBuffer.clear()</code></p>
<p>将缓冲区从读模式切换为写模式，并重置</p>
<p><strong>关键方法对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">position</th>
<th style="text-align:center">limit</th>
<th style="text-align:center">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocate</td>
<td style="text-align:center">创建新缓冲区</td>
<td style="text-align:center">0</td>
<td style="text-align:center">= capacity</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">put()</td>
<td style="text-align:center">写入数据</td>
<td style="text-align:center">增加</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">可能清除</td>
</tr>
<tr>
<td style="text-align:center">flip()</td>
<td style="text-align:center">写→读切换</td>
<td style="text-align:center">0</td>
<td style="text-align:center">=原position</td>
<td style="text-align:center">清除</td>
</tr>
<tr>
<td style="text-align:center">get()</td>
<td style="text-align:center">读取数据</td>
<td style="text-align:center">增加</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">可能清除</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">读→写切换(重置)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">= capacity</td>
<td style="text-align:center">清除</td>
</tr>
<tr>
<td style="text-align:center">rewind()</td>
<td style="text-align:center">重新读取(不改变limit)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">清除</td>
</tr>
<tr>
<td style="text-align:center">compact()</td>
<td style="text-align:center">压缩缓冲区(保留未读数据)</td>
<td style="text-align:center">=剩余数据数</td>
<td style="text-align:center">= capacity</td>
<td style="text-align:center">清除</td>
</tr>
</tbody>
</table>
<h3 id="NIO与零拷贝">NIO与零拷贝</h3>
<p>零拷贝是从操作系统的角度来说的</p>
<p>普通方式</p>
<img src="/2025/03/28/Netty/chapter03_17.png" class="" title="img">
<p>mmap</p>
<p><strong>mmap 的核心机制是通过修改页表，将进程用户态地址空间的一页和内核态地址空间的一页映射到同一个物理内存块（页缓存）来实现的</strong></p>
<p>仍需要一次从kernel buffer复制到socket buffer的过程</p>
<img src="/2025/03/28/Netty/chapter03_18.png" class="" title="img">
<p>sendFile</p>
<p><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</p>
<img src="/2025/03/28/Netty/chapter03_19.png" class="" title="img">
<p>sendFile优化</p>
<p><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</p>
<img src="/2025/03/28/Netty/chapter03_20.png" class="" title="img">
<h3 id="AIO">AIO</h3>
<h2 id="Netty">Netty</h2>
<h3 id="线程模型">线程模型</h3>
<p>传统阻塞 I/O 模型，蓝框线程，黄框对象，白框方法</p>
<img src="/2025/03/28/Netty/chapter05_01.png" class="" title="img">
<p>Reactor 模式，蓝框线程，黄框对象，白框方法</p>
<img src="/2025/03/28/Netty/chapter05_03.png" class="" title="img">
<ul>
<li>
<p><strong>单线程Reactor</strong>：</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_04.png" alt="img"></p>
<ul>
<li><strong>所有操作</strong>（I/O + 业务处理）均在Reactor线程完成。</li>
<li>缺点：业务处理阻塞事件循环（如数据库查询）。</li>
<li>示例：Redis的单线程模型。</li>
</ul>
</li>
<li>
<p><strong>多线程Reactor</strong>：</p>
<img src="/2025/03/28/Netty/chapter05_05.png" class="" title="img">
<ul>
<li><strong>主线程仅处理I/O</strong>（接收连接、读写数据），<strong>业务逻辑交给线程池</strong>。</li>
<li>子线程处理完成后，通常通过回调或队列通知Reactor线程继续I/O操作。</li>
<li>示例：Netty的默认模式、Java NIO的常见实践。</li>
</ul>
</li>
<li>
<p><strong>多Reactor线程</strong>：</p>
<img src="/2025/03/28/Netty/chapter05_06.png" class="" title="img">
<ul>
<li><strong>主Reactor</strong>负责接收连接，<strong>子Reactor线程</strong>（多个）负责已连接套接字的I/O和业务。</li>
<li>示例：Netty的<code>NioEventLoopGroup</code>、Linux下的<code>SO_REUSEPORT</code></li>
</ul>
</li>
</ul>
<h3 id="Netty线程模型">Netty线程模型</h3>
<p>蓝框线程，黄框对象，白框方法</p>
<img src="/2025/03/28/Netty/D693697CEDCDC16AC09A5CF4747129CE.png" class="" title="D693697CEDCDC16AC09A5CF4747129CE">
<p><code>NioEventLoopGroup</code> 可以看作是一个 <strong>线程池</strong>，但它不仅仅是普通的线程池，而是专门为 Netty 的异步 I/O 模型优化的 <strong>事件循环组</strong>。它的主要特点：</p>
<ul>
<li><strong>包含多个 <code>NioEventLoop</code>（事件循环）</strong>：
<ul>
<li>每个 <code>NioEventLoop</code> 是一个独立的线程，负责处理 I/O 事件、任务队列和定时任务。</li>
<li>默认情况下，<code>NioEventLoopGroup</code> 的线程数 = <code>CPU 核心数 × 2</code>（但可以手动指定）。</li>
</ul>
</li>
<li><strong>职责</strong>：
<ul>
<li><strong>BossGroup</strong>（用于服务端）：负责监听和接受新连接（<code>ServerSocketChannel</code>）。</li>
<li><strong>WorkerGroup</strong>（用于服务端/客户端）：负责处理已建立连接的 I/O 读写（<code>SocketChannel</code>）。</li>
</ul>
</li>
</ul>
<p>每个 <code>NioEventLoop</code> 是一个 <strong>单线程的事件循环</strong>，它负责：</p>
<ol>
<li><strong>监听 I/O 事件</strong>（如 <code>OP_ACCEPT</code>、<code>OP_READ</code>、<code>OP_WRITE</code>），为图中的 <code>selector.select()</code> <code>processSelectedKeys()</code>，<code>processSelectedKeys()</code> 根据 <code>selectedKeys</code> 的不同，触发 <code>ChannelPipeline</code> 中的不同方法</li>
<li><strong>执行任务队列中的任务</strong>（如用户提交的 <code>Runnable</code>），为图中的 <code>runAllTasks()</code></li>
<li><strong>处理定时任务</strong>（如 <code>schedule()</code> 提交的延迟任务），为图中的 <code>runAllTasks()</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EventLoop Thread</span><br><span class="line">├── selector.select()          // 轮询 I/O 事件</span><br><span class="line">├── processSelectedKeys()      // 处理 I/O 事件（如读、写、连接接受等）,触发处理器链</span><br><span class="line">│   ├── channelRead()          // 例如处理读事件</span><br><span class="line">│   ├── channelActive()        // 例如处理连接事件</span><br><span class="line">│   ├── handlerAdded()</span><br><span class="line">│   └── handlerRemoved()</span><br><span class="line">└── runAllTasks()              // 执行用户提交的任务（Runnable）</span><br></pre></td></tr></table></figure>
<p>Handler</p>
<ul>
<li><code>handler()</code>：用于处理<strong>服务端Channel本身</strong>的事件（这里是NioServerSocketChannel）</li>
<li><code>childHandler()</code>：用于处理<strong>被接受的客户端连接</strong>（这里是SocketChannel）</li>
</ul>
<p><code>processSelectedKeys()</code> 方法</p>
<p><strong>作用</strong>：</p>
<ul>
<li>处理 <strong>I/O 事件</strong>（如读、写、连接接受等），触发 <strong>ChannelPipeline 中的处理器链</strong>。</li>
<li>当Selector检测到Channel有就绪的I/O事件时，<code>NioEventLoop</code>会调用此方法处理这些事件。</li>
</ul>
<p><strong>与处理器链的关系</strong>：</p>
<ul>
<li>对于每个就绪的Channel事件（如 OP_READ），Netty会调用该Channel的 ChannelPipeline 中的处理器链。
<ul>
<li>例如：数据读取 → 触发<code>ChannelInboundHandler.channelRead()</code>；</li>
<li>连接建立 → 触发<code>ChannelInboundHandler.channelActive()</code>。</li>
</ul>
</li>
<li><strong>空闲检测</strong>（如<code>IdleStateHandler</code>）也是通过<code>processSelectedKeys()</code>触发的，它会检查Channel的读写空闲状态，并触发<code>IdleStateEvent</code>事件。</li>
</ul>
<p><code>runAllTasks()</code> 方法</p>
<p><strong>作用</strong>：</p>
<ul>
<li>执行 <strong>非I/O的异步任务</strong>（如用户提交的<code>Runnable</code>、定时任务、ChannelFuture的回调等）。</li>
<li>这些任务可能是：
<ul>
<li>用户通过<code>eventLoop.execute(task)</code>提交的任务。</li>
<li>Netty内部任务（如Channel关闭后的清理、写刷新等）。</li>
<li>定时任务（如<code>schedule()</code>提交的延迟任务）。</li>
</ul>
</li>
</ul>
<p><strong>与 <code>processSelectedKeys()</code> 的关系</strong>：</p>
<ul>
<li>NioEventLoop 是单线程的，<code>runAllTasks()</code> 和 <code>processSelectedKeys()</code> 两者交替执行，但Netty会<strong>优先保证I/O处理</strong>，限制任务执行时间（默认不超过<code>ioRatio</code>比例）。</li>
</ul>
<p>流程：</p>
<ol>
<li>bossGroup的NioEventLoop接收新连接，创建SocketChannel</li>
<li>将该SocketChannel注册到workerGroup的一个NioEventLoop的Selector上</li>
<li>当该NioEventLoop处理I/O事件(<code>processSelectedKeys()</code>方法)时，会调用pipeline中的处理器链</li>
</ol>
<p>案例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 定义线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); <span class="comment">// 接收连接</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">// 处理I/O</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 配置服务端</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>) <span class="comment">// 连接队列大小</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">// BossGroup的Handler</span></span><br><span class="line">                    .childHandler(</span><br><span class="line">                <span class="comment">// Channel注册到EventLoop后	触发ChannelInitializer.initChannel()</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">// 3. 添加编解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            <span class="comment">// 4. 空闲检测（5秒无读触发）</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">                            <span class="comment">// 5. 自定义处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 方法执行完毕ChannelInitializer自动从Pipeline中移除，仅保留添加的处理器</span></span><br><span class="line">            <span class="comment">// 6. 绑定端口</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server started on port 8080&quot;</span>);</span><br><span class="line">            <span class="comment">// 7. 关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义服务端处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received: &quot;</span> + msg);</span><br><span class="line">        <span class="comment">// 异步任务示例</span></span><br><span class="line">        ctx.channel().eventLoop().execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Async task processed&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        ctx.writeAndFlush(<span class="string">&quot;Response: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理空闲事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Channel idle, closing...&quot;</span>);</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Netty模块">Netty模块</h3>
<h4 id="ChannelFuture">ChannelFuture</h4>
<p>ChannelFuture直接继承自<code>Future&lt;V&gt;</code>接口</p>
<ul>
<li><code>addListener(GenericFutureListener)</code> - 添加监听器</li>
<li><code>channel()</code> - 获取关联的Channel</li>
<li><code>sync()</code> - 等待操作完成，如果失败则抛出异常</li>
<li><code>await()</code> - 等待操作完成，不抛出异常</li>
</ul>
<h4 id="Channel-2">Channel</h4>
<p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p>
<p>Channel的所有行为都会触发事件，由<code>ChannelPipeline</code>中的处理器链处理：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>事件类型</strong></th>
<th style="text-align:center"><strong>触发场景</strong></th>
<th style="text-align:center"><strong>对应方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>channelRegistered</code></td>
<td style="text-align:center">Channel注册到EventLoop时</td>
<td style="text-align:center"><code>handlerAdded()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>channelActive</code></td>
<td style="text-align:center">Channel连接建立/绑定完成</td>
<td style="text-align:center"><code>channelActive()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>channelRead</code></td>
<td style="text-align:center">数据可读时</td>
<td style="text-align:center"><code>channelRead()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>channelInactive</code></td>
<td style="text-align:center">Channel断开连接</td>
<td style="text-align:center"><code>channelInactive()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>exceptionCaught</code></td>
<td style="text-align:center">发生异常时</td>
<td style="text-align:center"><code>exceptionCaught()</code></td>
</tr>
</tbody>
</table>
<p><strong>内存管理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接内存分配（零拷贝优化）</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">directBuf</span> <span class="operator">=</span> channel.alloc().directBuffer();</span><br></pre></td></tr></table></figure>
<ul>
<li>Channel内置<code>ByteBufAllocator</code>，支持堆内/堆外内存分配。</li>
</ul>
<h4 id="ChannelPipeline">ChannelPipeline</h4>
<p>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应</p>
<img src="/2025/03/28/Netty/chapter06_03.png" class="" title="img">
<p><strong>如何触发 ChannelPipeline？</strong></p>
<p>不同事件类型会触发 <code>ChannelPipeline</code> 中的不同方法：</p>
<p><strong>ACCEPT 事件</strong>（服务端）</p>
<ul>
<li>
<p>调用链：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processSelectedKeys() </span><br><span class="line">  → NioMessageUnsafe.read() </span><br><span class="line">    → ServerSocketChannel.accept() </span><br><span class="line">    → pipeline.fireChannelRead() <span class="comment">// 触发ChannelRead事件</span></span><br><span class="line">      → ServerBootstrapAcceptor.channelRead() <span class="comment">// 默认处理器</span></span><br><span class="line">        → 初始化客户端Channel并注册到WorkerGroup</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Pipeline 触发点：</p>
<ul>
<li><code>fireChannelRead()</code>：通知处理器有新连接接入</li>
<li><strong>不直接触发业务处理器</strong>，而是通过 <code>ServerBootstrapAcceptor</code> 处理连接</li>
</ul>
</li>
</ul>
<p><strong>READ 事件</strong>（客户端）</p>
<ul>
<li>
<p>调用链：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processSelectedKeys() </span><br><span class="line">  → NioByteUnsafe.read() </span><br><span class="line">    → SocketChannel.read(ByteBuf) </span><br><span class="line">    → pipeline.fireChannelRead(ByteBuf) <span class="comment">// 触发数据读取事件</span></span><br><span class="line">      → StringDecoder.channelRead()    <span class="comment">// 解码器处理</span></span><br><span class="line">      → MyHandler.channelRead()        <span class="comment">// 业务处理器</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Pipeline 触发点：</p>
<ul>
<li><code>fireChannelRead()</code>：将数据传递给第一个 <code>ChannelInboundHandler</code></li>
<li>数据会依次通过所有入站处理器（如解码器、业务逻辑）</li>
</ul>
</li>
</ul>
<p><strong>WRITE 事件</strong></p>
<ul>
<li>
<p>调用链：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processSelectedKeys() </span><br><span class="line">  → AbstractChannel$AbstractUnsafe.forceFlush()</span><br><span class="line">    → pipeline.fireChannelWritabilityChanged() <span class="comment">// 触发可写状态变化</span></span><br><span class="line">    → outboundBuffer.removeBytes(writtenBytes) <span class="comment">// 更新写指针</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Pipeline 触发点：</p>
<ul>
<li><code>fireChannelWritabilityChanged()</code>：通知处理器写状态变化</li>
<li>通常用于流量控制（如停止写入避免OOM）</li>
</ul>
</li>
</ul>
<hr>
<p><strong>关键结论</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>事件类型</strong></th>
<th style="text-align:center"><strong>是否触发 Pipeline</strong></th>
<th style="text-align:center"><strong>触发的处理器方法</strong></th>
<th style="text-align:center"><strong>典型处理器</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACCEPT</td>
<td style="text-align:center">是（但仅限服务端特殊处理器）</td>
<td style="text-align:center"><code>channelRead()</code></td>
<td style="text-align:center"><code>ServerBootstrapAcceptor</code></td>
</tr>
<tr>
<td style="text-align:center">READ</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>channelRead()</code></td>
<td style="text-align:center"><code>StringDecoder</code>/<code>MyHandler</code></td>
</tr>
<tr>
<td style="text-align:center">WRITE</td>
<td style="text-align:center">是（仅触发写状态变更）</td>
<td style="text-align:center"><code>channelWritabilityChanged()</code></td>
<td style="text-align:center">流量控制处理器</td>
</tr>
<tr>
<td style="text-align:center">CONNECT</td>
<td style="text-align:center">是（客户端连接完成时）</td>
<td style="text-align:center"><code>channelActive()</code></td>
<td style="text-align:center">日志处理器/初始化处理器</td>
</tr>
</tbody>
</table>
<h4 id="ChannelHandler">ChannelHandler</h4>
<p>适配器类在<strong>接口（Handler）和用户实现类</strong>之间架设了一层缓冲，将“必须实现所有方法”的严格接口适配为“按需实现”的灵活方式。</p>
<img src="/2025/03/28/Netty/chapter06_01.png" class="" title="img">
<p>通过继承 <code>ChannelInboundHandlerAdapter</code>重写相应方法实现业务逻辑</p>
<img src="/2025/03/28/Netty/chapter06_02.png" class="" title="img">
<h3 id="Netty零拷贝">Netty零拷贝</h3>
<ol>
<li><strong>直接封装 JDK Channel</strong>：避免抽象层带来的性能损耗。</li>
<li><strong>强制使用 Direct Buffer</strong>：减少内核态到用户态的内存拷贝。</li>
<li><strong>文件传输零拷贝</strong>：利用 <code>sendfile</code> 系统调用。</li>
<li><strong>内存池化技术</strong>：重用已分配的堆外内存。</li>
</ol>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Java, Design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Project</title>
    <url>/2025/02/19/Project/</url>
    <content><![CDATA[<p>Project &amp; related</p>
<span id="more"></span>
<h1>Project</h1>
<h2 id="E-Shop">E-Shop</h2>
<h3 id="责任链模式">责任链模式</h3>
<br>
<h3 id="秒杀场景">秒杀场景</h3>
<p>采用预取-缓冲池思路</p>
<ul>
<li>在秒杀业务开启前，多地的Redis预先从数据库中扣除一定量的库存，保存在Redis中，<strong>修改数据库值</strong></li>
<li>每个service进行秒杀时，使用Lua脚本原子的扣除本地Redis的库存，<strong>不涉及数据库访问</strong></li>
<li>（如果使用本地缓存）每个service考虑预先从本地Redis中取出一定量的库存，进行本地原子扣除；若本地缓存不够，原子的从本地Redis中取出一定量的库存；</li>
<li>秒杀流量下降后（考虑使用延迟队列方式实现延时任务），多地的Redis返还数据库库存，<strong>修改数据库值</strong></li>
</ul>
<br>
<p>lua脚本</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 参数说明：</span></span><br><span class="line"><span class="comment">-- KEYS[1]: 库存 Key (seckill:stock:&#123;商品ID&#125;)</span></span><br><span class="line"><span class="comment">-- KEYS[2]: 用户购买记录 Key (seckill:user:&#123;用户ID&#125;:&#123;商品ID&#125;)</span></span><br><span class="line"><span class="comment">-- ARGV[1]: 用户 ID</span></span><br><span class="line"><span class="comment">-- ARGV[2]: 商品 ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取库存</span></span><br><span class="line"><span class="keyword">local</span> stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>])) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查库存是否大于 0</span></span><br><span class="line"><span class="keyword">if</span> stock &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">-- 库存不足</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查用户是否已购买</span></span><br><span class="line"><span class="keyword">local</span> purchased = redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> purchased <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">-- 用户已购买</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 扣减库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;DECR&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 标记用户已购买</span></span><br><span class="line">redis.call(<span class="string">&#x27;SET&#x27;</span>, KEYS[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<br>
<h2 id="ShortLink">ShortLink</h2>
<p>创新点</p>
<ol>
<li>使用布隆过滤器来判断短链接是否已存在，提高了判断效率，远胜于使用分布式锁搭配查询数据库的方案。</li>
<li>借助 RocketMQ 消息队列的&quot;削峰&quot;特点，实现海量访问短链接场景下的监控信息存储功能，确保系统在高负载情况下仍能正常运行。</li>
<li>优化更新或失效场景下大量请求查询数据库问题，封装缓存不存在读取功能，采用分布式锁互斥策略，减少对数据库的频繁查询。</li>
<li>为保障短链接缓存与数据库之间的数据一致性，采用了通过更新数据库删除缓存的策略，保证了两者之间的数据一致性。</li>
<li>在消息队列消费业务中，我使用 Redis 来完成幂等场景的处理，确保消息在一定时间内仅被消费一次，避免重复处理。</li>
<li>为实现短链接在海量访问场景下的数据修改功能，我使用了 Redisson 分布式读写锁，确保数据修改的安全和一致性。</li>
<li>考虑兼容短链接用户需求，短链接数据分片的基础上增加了路由表，使用户能够方便地分页查看短链接。</li>
<li>使用 Sentinel 进行接口访问的 QPS 限流，以保障短链接系统的稳定运行。当触发限流规则时，系统能够进行降级处理，确保核心功能的可用性。</li>
</ol>
<br>
<h3 id="后端敏感信息返回">后端敏感信息返回</h3>
<p>方案一：</p>
<p>使用Spring AOP对返回信息过滤</p>
<p>方案二：</p>
<p>通过Json序列化，在Spring返回对象的序列化结果时，使用自定义序列化器进行序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneDesensitizationSerializer</span> <span class="keyword">extends</span> <span class="title class_">JsonSerializer</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(String phone, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneDesensitization</span> <span class="operator">=</span> DesensitizedUtil.mobilePhone(phone);</span><br><span class="line">        jsonGenerator.writeString(phoneDesensitization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonSerialize(using = PhoneDesensitizationSerializer.class)</span></span><br><span class="line"><span class="keyword">private</span> String phone;</span><br></pre></td></tr></table></figure>
<br>
<br>
<h3 id="用户会话上下文保存">用户会话上下文保存</h3>
<p>自定义 Servlet 容器 Filter 过滤器，使用ThreadLocal保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤器实现从请求中截取用户名并创建对象保存到当前线程的ThreadLocal对象中</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTransmitFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> httpServletRequest.getHeader(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(username)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> httpServletRequest.getHeader(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">realName</span> <span class="operator">=</span> httpServletRequest.getHeader(<span class="string">&quot;realName&quot;</span>);</span><br><span class="line">            <span class="type">UserInfoDTO</span> <span class="variable">userInfoDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoDTO</span>(userId, username, realName);</span><br><span class="line">            UserContext.setUser(userInfoDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            UserContext.removeUser(); <span class="comment">// 移除ThreadLocal对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文保存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;a href=&quot;https://github.com/alibaba/transmittable-thread-local&quot; /&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserInfoDTO&gt; USER_THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">TransmittableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置用户至上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 用户详情信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(UserInfoDTO user)</span> &#123;</span><br><span class="line">        USER_THREAD_LOCAL.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3 id="流量控制">流量控制</h3>
<p>例如，1秒中允许请求最多 x 次</p>
<p>通过 Redis <code>increment</code> 命令对 与用户名映射的数据 进行递增，超过 x 次就会返回失败；该数据有效期为 1 秒</p>
<br>
<h3 id="布隆过滤器的使用与误判">布隆过滤器的使用与误判</h3>
<p>使用布隆过滤器</p>
<p>位图 + 多个散列函数</p>
<p>例如</p>
<img src="/2025/02/19/Project/image-20250219124534631.png" class="" title="image-20250219124534631">
<br>
<p>布隆过滤器存在误判情况</p>
<p><strong>目标不存在，判定为存在</strong></p>
<blockquote>
<p>不可能情况：目标存在，判定为不存在</p>
<p>布隆过滤器不能进行删除哦</p>
</blockquote>
<p>即 布隆过滤器 会给出</p>
<ul>
<li>不存在</li>
<li>可能存在</li>
</ul>
<p>因此，</p>
<p><strong>查询时</strong>，先通过布隆过滤器判断是否存在，减少数据库查询次数。假阳性可能导致误查询，但不会漏掉真实存在的记录。</p>
<p><strong>插入时</strong>，布隆过滤器应该在数据插入数据库之后更新，以保持一致性。</p>
<p><strong>删除时</strong>，删除操作需要谨慎，布隆过滤器不直接支持删除，操作数据库。</p>
<p><strong>更新时</strong>，先通过布隆过滤器判断是否存在，然后再进行数据库查询与布隆更新。</p>
<br>
<h3 id="短链信息统计">短链信息统计</h3>
<p>相同的用户多次访问相同短链接，使用Cookie记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ShortLinkStatsRecordDTO <span class="title function_">buildLinkStatsRecordAndSetUser</span><span class="params">(String fullShortUrl, ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="type">AtomicBoolean</span> <span class="variable">uvFirstFlag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line">        Cookie[] cookies = ((HttpServletRequest) request).getCookies();</span><br><span class="line">        AtomicReference&lt;String&gt; uv = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个 Runnable 任务 addResponseCookieTask，用于添加响应 Cookie 并处理首次访问的逻辑</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">addResponseCookieTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            uv.set(UUID.fastUUID().toString());</span><br><span class="line">            <span class="type">Cookie</span> <span class="variable">uvCookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;uv&quot;</span>, uv.get());</span><br><span class="line">            uvCookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);</span><br><span class="line">            <span class="comment">// 设置 Cookie 的路径。从 fullShortUrl 中截取第一个 &#x27;/&#x27; 之后的部分作为路径。</span></span><br><span class="line">            <span class="comment">// 比如 fullShortUrl 是 &quot;http://example.com/s/xyz&quot;，那么路径就是 &quot;/s/xyz&quot;</span></span><br><span class="line">            uvCookie.setPath(StrUtil.sub(fullShortUrl, fullShortUrl.indexOf(<span class="string">&quot;/&quot;</span>), fullShortUrl.length()));</span><br><span class="line">            ((HttpServletResponse) response).addCookie(uvCookie);</span><br><span class="line">            <span class="comment">// 设置 uvFirstFlag 为 true，表示是首次访问</span></span><br><span class="line">            uvFirstFlag.set(Boolean.TRUE);</span><br><span class="line">            <span class="comment">// 将用户标识符 uv 添加到 Redis Set 中，用于统计独立访客（UV）。</span></span><br><span class="line">            <span class="comment">// Key 是 SHORT_LINK_STATS_UV_KEY + fullShortUrl。</span></span><br><span class="line">            stringRedisTemplate.opsForSet().add(SHORT_LINK_STATS_UV_KEY + fullShortUrl, uv.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查请求中是否存在 Cookie</span></span><br><span class="line">        <span class="keyword">if</span> (ArrayUtil.isNotEmpty(cookies)) &#123;</span><br><span class="line">            Arrays.stream(cookies)</span><br><span class="line">                    .filter(each -&gt; Objects.equals(each.getName(), <span class="string">&quot;uv&quot;</span>))</span><br><span class="line">                    .findFirst()</span><br><span class="line">                    .map(Cookie::getValue)</span><br><span class="line">                    <span class="comment">// 如果存在名为 &quot;uv&quot; 的 Cookie，则执行以下操作：</span></span><br><span class="line">                    .ifPresentOrElse(each -&gt; &#123;</span><br><span class="line">                        <span class="comment">// 将 Cookie 的值（即已有的用户标识符）设置到 uv 中</span></span><br><span class="line">                        uv.set(each);</span><br><span class="line">                        <span class="comment">// 尝试将用户标识符添加到 Redis Set 中。</span></span><br><span class="line">                        <span class="comment">//  stringRedisTemplate.opsForSet().add() 返回一个 Long 值：</span></span><br><span class="line">                        <span class="comment">//  - 如果添加成功（即该值之前不存在于 Set 中），则返回 1。</span></span><br><span class="line">                        <span class="comment">//  - 如果添加失败（即该值已存在于 Set 中），则返回 0。</span></span><br><span class="line">                        <span class="comment">//  - 如果出现错误，可能返回 null。</span></span><br><span class="line">                        <span class="type">Long</span> <span class="variable">uvAdded</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().add(SHORT_LINK_STATS_UV_KEY + fullShortUrl, each);</span><br><span class="line">                        <span class="comment">// 设置 uvFirstFlag。如果 uvAdded 不为 null 且大于 0，则表示是首次访问，设置为 true；否则为 false。</span></span><br><span class="line">                        uvFirstFlag.set(uvAdded != <span class="literal">null</span> &amp;&amp; uvAdded &gt; <span class="number">0L</span>);</span><br><span class="line">                    &#125;, addResponseCookieTask); <span class="comment">// 如果不存在名为 &quot;uv&quot; 的 Cookie，则执行 addResponseCookieTask（即创建新的 UV 并添加到响应中）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addResponseCookieTask.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">remoteAddr</span> <span class="operator">=</span> LinkUtil.getActualIp(((HttpServletRequest) request));</span><br><span class="line">        <span class="type">String</span> <span class="variable">os</span> <span class="operator">=</span> LinkUtil.getOs(((HttpServletRequest) request));</span><br><span class="line">        <span class="type">String</span> <span class="variable">browser</span> <span class="operator">=</span> LinkUtil.getBrowser(((HttpServletRequest) request));</span><br><span class="line">        <span class="type">String</span> <span class="variable">device</span> <span class="operator">=</span> LinkUtil.getDevice(((HttpServletRequest) request));</span><br><span class="line">        <span class="type">String</span> <span class="variable">network</span> <span class="operator">=</span> LinkUtil.getNetwork(((HttpServletRequest) request));</span><br><span class="line">        <span class="comment">// 尝试将访问者的 IP 地址添加到 Redis Set 中，SHORT_LINK_STATS_UIP_KEY + fullShortUrl 为 Key，Unique IP 为 Value</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">uipAdded</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().add(SHORT_LINK_STATS_UIP_KEY + fullShortUrl, remoteAddr);</span><br><span class="line">        <span class="comment">// 如果 Redis Set 中已经存在该 IP 地址，则 uipAdded 为 null 或 0，否则为新加入的 IP 地址数量 (1)，表示这是一个新 IP</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uipFirstFlag</span> <span class="operator">=</span> uipAdded != <span class="literal">null</span> &amp;&amp; uipAdded &gt; <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ShortLinkStatsRecordDTO.builder()</span><br><span class="line">                .fullShortUrl(fullShortUrl)</span><br><span class="line">                .uv(uv.get())</span><br><span class="line">                .uvFirstFlag(uvFirstFlag.get())</span><br><span class="line">                .uipFirstFlag(uipFirstFlag)</span><br><span class="line">                .remoteAddr(remoteAddr)</span><br><span class="line">                .os(os)</span><br><span class="line">                .browser(browser)</span><br><span class="line">                .device(device)</span><br><span class="line">                .network(network)</span><br><span class="line">                .currentDate(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<br>
<h3 id="缓存击穿防护">缓存击穿防护</h3>
<p>缓存过期时间工具类：</p>
<p>1.如果date超过当前时间一周，那么设置过期时间为一周，并随机一个0~24小时的时间</p>
<p>2.如果date没有超过当前时间一周，那么设置指定的时间</p>
<p>3.如果date为null，则设置过期时间为一周，并随机一个0~24小时的时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ONE_WEEK_MILLIS</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 获取短链接缓存过期时间戳</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> date 日期 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 短链接缓存过期时间戳 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getShortLinkCacheTime</span><span class="params">(Date date)</span> &#123;    </span><br><span class="line">    <span class="comment">// 当前时间    </span></span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();     </span><br><span class="line">    <span class="comment">// 如果 date 为 null，则默认设置为一周后的时间戳，并随机一个 0 ~ 24 小时的时间    </span></span><br><span class="line">    <span class="keyword">if</span> (date == <span class="literal">null</span>) &#123;        </span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, <span class="number">7</span>);        </span><br><span class="line">        <span class="keyword">return</span> calendar.getTimeInMillis() + ThreadLocalRandom.current().nextLong(<span class="number">0</span>, <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>);    </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="type">long</span> <span class="variable">dateMillis</span> <span class="operator">=</span> date.getTime();     <span class="comment">// 检查 date 是否超过一周    </span></span><br><span class="line">    <span class="keyword">if</span> (dateMillis - currentTimeMillis &gt; ONE_WEEK_MILLIS) &#123;        </span><br><span class="line">        <span class="comment">// 如果超过一周，那么将有效时间设置在一周后        </span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, <span class="number">7</span>);        </span><br><span class="line">        <span class="keyword">return</span> calendar.getTimeInMillis() + ThreadLocalRandom.current().nextLong(<span class="number">0</span>, <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        <span class="comment">// 如果没有超过一周，则设置为 date 的时间戳        </span></span><br><span class="line">        <span class="keyword">return</span> dateMillis;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3 id="缓存穿透防护">缓存穿透防护</h3>
<p>redis 保存 无效短链接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">gotoIsNullShortLink</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(String.format(GOTO_IS_NULL_SHORT_LINK_KEY, fullShortUrl));  <span class="comment">// 从redis中获取该短链接是否被标记为null。 用于防止缓存击穿。</span></span><br><span class="line"><span class="keyword">if</span> (StrUtil.isNotBlank(gotoIsNullShortLink)) &#123; <span class="comment">// 如果redis中存在该短链被标记为null。</span></span><br><span class="line">((HttpServletResponse) response).sendRedirect(<span class="string">&quot;/page/notfound&quot;</span>); <span class="comment">// 将用户重定向到一个 &quot;notfound&quot; 页面，表示该短链接URL无效。</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3 id="消息队列更新数据库">消息队列更新数据库</h3>
<br>
<br>
<h3 id="流程">流程</h3>
<h4 id="短链生成流程">短链生成流程</h4>
<img src="/2025/02/19/Project/71DF4D3AC7166BD8DE046102F534D4EB.png" class="" title="71DF4D3AC7166BD8DE046102F534D4EB">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ShortLinkCreateRespDTO <span class="title function_">createShortLink</span><span class="params">(ShortLinkCreateReqDTO requestParam)</span> &#123;</span><br><span class="line">    verificationWhitelist(requestParam.getOriginUrl());</span><br><span class="line">    <span class="type">String</span> <span class="variable">shortLinkSuffix</span> <span class="operator">=</span> generateSuffix(requestParam);</span><br><span class="line">    <span class="type">String</span> <span class="variable">fullShortUrl</span> <span class="operator">=</span> StrBuilder.create(createShortLinkDefaultDomain)</span><br><span class="line">        .append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">        .append(shortLinkSuffix)</span><br><span class="line">        .toString();</span><br><span class="line">    <span class="type">ShortLinkDO</span> <span class="variable">shortLinkDO</span> <span class="operator">=</span> ShortLinkDO.builder()</span><br><span class="line">        .domain(createShortLinkDefaultDomain)</span><br><span class="line">        .originUrl(requestParam.getOriginUrl())</span><br><span class="line">        .gid(requestParam.getGid())</span><br><span class="line">        .createdType(requestParam.getCreatedType())</span><br><span class="line">        .validDateType(requestParam.getValidDateType())</span><br><span class="line">        .validDate(requestParam.getValidDate())</span><br><span class="line">        .describe(requestParam.getDescribe())</span><br><span class="line">        .shortUri(shortLinkSuffix)</span><br><span class="line">        .enableStatus(<span class="number">0</span>)</span><br><span class="line">        .totalPv(<span class="number">0</span>)</span><br><span class="line">        .totalUv(<span class="number">0</span>)</span><br><span class="line">        .totalUip(<span class="number">0</span>)</span><br><span class="line">        .delTime(<span class="number">0L</span>)</span><br><span class="line">        .fullShortUrl(fullShortUrl)</span><br><span class="line">        .favicon(getFavicon(requestParam.getOriginUrl()))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">ShortLinkGotoDO</span> <span class="variable">linkGotoDO</span> <span class="operator">=</span> ShortLinkGotoDO.builder()</span><br><span class="line">        .fullShortUrl(fullShortUrl)</span><br><span class="line">        .gid(requestParam.getGid())</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        baseMapper.insert(shortLinkDO);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DuplicateKeyException ex) &#123;</span><br><span class="line">        <span class="comment">// 加入数据库失败，数据库已存在重复短链</span></span><br><span class="line">        <span class="comment">// 判断布隆中是否存在该短链，不存在则添加</span></span><br><span class="line">        <span class="keyword">if</span> (!shortUriCreateCachePenetrationBloomFilter.contains(fullShortUrl)) &#123;</span><br><span class="line">            shortUriCreateCachePenetrationBloomFilter.add(fullShortUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(String.format(<span class="string">&quot;短链接：%s 生成重复&quot;</span>, fullShortUrl));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将短链-原链加入Redis_ex</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(</span><br><span class="line">        String.format(GOTO_SHORT_LINK_KEY, fullShortUrl),</span><br><span class="line">        requestParam.getOriginUrl(),</span><br><span class="line">        LinkUtil.getLinkCacheValidTime(requestParam.getValidDate()), TimeUnit.MILLISECONDS</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 将短链加入布隆</span></span><br><span class="line">    shortUriCreateCachePenetrationBloomFilter.add(fullShortUrl);</span><br><span class="line">    <span class="keyword">return</span> ShortLinkCreateRespDTO.builder()</span><br><span class="line">        .fullShortUrl(<span class="string">&quot;http://&quot;</span> + shortLinkDO.getFullShortUrl())</span><br><span class="line">        .originUrl(requestParam.getOriginUrl())</span><br><span class="line">        .gid(requestParam.getGid())</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ShortLinkCreateRespDTO <span class="title function_">createShortLinkByLock</span><span class="params">(ShortLinkCreateReqDTO requestParam)</span> &#123;</span><br><span class="line">    verificationWhitelist(requestParam.getOriginUrl());</span><br><span class="line">    String fullShortUrl;</span><br><span class="line">    <span class="comment">// 分布式锁创建短链接</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(SHORT_LINK_CREATE_LOCK_KEY);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shortLinkSuffix</span> <span class="operator">=</span> generateSuffixByLock(requestParam);</span><br><span class="line">        fullShortUrl = StrBuilder.create(createShortLinkDefaultDomain)</span><br><span class="line">            .append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            .append(shortLinkSuffix)</span><br><span class="line">            .toString();</span><br><span class="line">        <span class="type">ShortLinkDO</span> <span class="variable">shortLinkDO</span> <span class="operator">=</span> ShortLinkDO.builder()</span><br><span class="line">            .domain(createShortLinkDefaultDomain)</span><br><span class="line">            .originUrl(requestParam.getOriginUrl())</span><br><span class="line">            .gid(requestParam.getGid())</span><br><span class="line">            .createdType(requestParam.getCreatedType())</span><br><span class="line">            .validDateType(requestParam.getValidDateType())</span><br><span class="line">            .validDate(requestParam.getValidDate())</span><br><span class="line">            .describe(requestParam.getDescribe())</span><br><span class="line">            .shortUri(shortLinkSuffix)</span><br><span class="line">            .enableStatus(<span class="number">0</span>)</span><br><span class="line">            .totalPv(<span class="number">0</span>)</span><br><span class="line">            .totalUv(<span class="number">0</span>)</span><br><span class="line">            .totalUip(<span class="number">0</span>)</span><br><span class="line">            .delTime(<span class="number">0L</span>)</span><br><span class="line">            .fullShortUrl(fullShortUrl)</span><br><span class="line">            .favicon(getFavicon(requestParam.getOriginUrl()))</span><br><span class="line">            .build();</span><br><span class="line">        <span class="type">ShortLinkGotoDO</span> <span class="variable">linkGotoDO</span> <span class="operator">=</span> ShortLinkGotoDO.builder()</span><br><span class="line">            .fullShortUrl(fullShortUrl)</span><br><span class="line">            .gid(requestParam.getGid())</span><br><span class="line">            .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            baseMapper.insert(shortLinkDO);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DuplicateKeyException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(String.format(<span class="string">&quot;短链接：%s 生成重复&quot;</span>, fullShortUrl));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(</span><br><span class="line">            String.format(GOTO_SHORT_LINK_KEY, fullShortUrl),</span><br><span class="line">            requestParam.getOriginUrl(),</span><br><span class="line">            LinkUtil.getLinkCacheValidTime(requestParam.getValidDate()), TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!shortUriCreateCachePenetrationBloomFilter.contains(fullShortUrl)) &#123;</span><br><span class="line">            shortUriCreateCachePenetrationBloomFilter.add(fullShortUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ShortLinkCreateRespDTO.builder()</span><br><span class="line">        .fullShortUrl(<span class="string">&quot;http://&quot;</span> + fullShortUrl)</span><br><span class="line">        .originUrl(requestParam.getOriginUrl())</span><br><span class="line">        .gid(requestParam.getGid())</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不加锁创建短链后缀</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateSuffix</span><span class="params">(ShortLinkCreateReqDTO requestParam)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">customGenerateCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    String shorUri;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (customGenerateCount &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;短链接频繁生成，请稍后再试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">originUrl</span> <span class="operator">=</span> requestParam.getOriginUrl();</span><br><span class="line">        originUrl += UUID.randomUUID().toString();  <span class="comment">// 原链 + 随机数 </span></span><br><span class="line">        shorUri = HashUtil.hashToBase62(originUrl); <span class="comment">// 原链 + 随机数 -&gt; 短链</span></span><br><span class="line">        <span class="comment">// 先查布隆，若可能存在直接下一轮</span></span><br><span class="line">        <span class="keyword">if</span> (!shortUriCreateCachePenetrationBloomFilter.contains(createShortLinkDefaultDomain + <span class="string">&quot;/&quot;</span> + shorUri)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        customGenerateCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shorUri;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加锁创建短链后缀</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateSuffixByLock</span><span class="params">(ShortLinkCreateReqDTO requestParam)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">customGenerateCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    String shorUri;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (customGenerateCount &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;短链接频繁生成，请稍后再试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">originUrl</span> <span class="operator">=</span> requestParam.getOriginUrl();</span><br><span class="line">        originUrl += UUID.randomUUID().toString();</span><br><span class="line">        shorUri = HashUtil.hashToBase62(originUrl);</span><br><span class="line">        LambdaQueryWrapper&lt;ShortLinkDO&gt; queryWrapper = Wrappers.lambdaQuery(ShortLinkDO.class)</span><br><span class="line">            .eq(ShortLinkDO::getGid, requestParam.getGid())</span><br><span class="line">            .eq(ShortLinkDO::getFullShortUrl, createShortLinkDefaultDomain + <span class="string">&quot;/&quot;</span> + shorUri)</span><br><span class="line">            .eq(ShortLinkDO::getDelFlag, <span class="number">0</span>);</span><br><span class="line">        <span class="type">ShortLinkDO</span> <span class="variable">shortLinkDO</span> <span class="operator">=</span> baseMapper.selectOne(queryWrapper);  <span class="comment">// 查数据库看新生成短链是否已存在</span></span><br><span class="line">        <span class="keyword">if</span> (shortLinkDO == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        customGenerateCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shorUri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="优化">优化</h5>
<p>使用三级通道技术</p>
<p>参考京东 <a href="https://juejin.cn/post/7382344353068974115#heading-12">https://juejin.cn/post/7382344353068974115#heading-12</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortLinkGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_KEY</span> <span class="operator">=</span> <span class="string">&quot;shortlink_counter&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_SIZE</span> <span class="operator">=</span> <span class="number">10000</span>;  <span class="comment">// 每次从内存生成10000个短码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ID_LENGTH</span> <span class="operator">=</span> <span class="number">62</span>;   <span class="comment">// 短码的基数，62进制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ID_RANGE</span> <span class="operator">=</span> <span class="number">99999</span>;  <span class="comment">// 最大的5位数范围</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ALPHABET</span> <span class="operator">=</span> <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis; <span class="comment">// Redis客户端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedissonClient redissonClient;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger memoryCounter; <span class="comment">// 内存计数器，用于自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成短链短码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateShortLink</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> getNextId();</span><br><span class="line">        <span class="keyword">return</span> idToShortLink(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存获取自增ID，如果内存已用完则从Redis取号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getNextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> getFromMemory();</span><br><span class="line">        <span class="keyword">if</span> (id == -<span class="number">1</span>) &#123; <span class="comment">// 如果内存号段用完，去Redis获取</span></span><br><span class="line">            id = getFromRedis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存中获取ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getFromMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用AtomicInteger来进行自增，确保线程安全</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> memoryCounter.get();</span><br><span class="line">        <span class="keyword">if</span> (current &gt;= BATCH_SIZE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 内存号段用完，返回-1表示需要从Redis获取新的号段</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> memoryCounter.incrementAndGet(); <span class="comment">// 原子性地自增</span></span><br><span class="line">            <span class="keyword">return</span> current + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Redis中获取自增ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getFromRedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">newId</span> <span class="operator">=</span> jedis.incrBy(REDIS_KEY, BATCH_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (newId &gt; MAX_ID_RANGE) &#123;</span><br><span class="line">            <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(SHORT_LINK_CREATE_LOCK_KEY);</span><br><span class="line">        	lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                jedis.set(REDIS_KEY, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="comment">// 重新获取ID</span></span><br><span class="line">                newId = jedis.incr(REDIS_KEY);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 更新内存计数器，保证每次内存自增时，Redis号段被完全消耗前不会重新获取</span></span><br><span class="line">        memoryCounter.set(<span class="number">0</span>); <span class="comment">// 重置内存计数器</span></span><br><span class="line">        <span class="keyword">return</span> newId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将ID转换为62进制短码</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">idToShortLink</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">shortLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            shortLink.append(ALPHABET.charAt((<span class="type">int</span>) (id % MAX_ID_LENGTH)));</span><br><span class="line">            id /= MAX_ID_LENGTH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shortLink.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>
<h4 id="短链更新流程">短链更新流程</h4>
<img src="/2025/02/19/Project/E68452CA74D6142357E95AD499697CFB.png" class="" title="E68452CA74D6142357E95AD499697CFB">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateShortLink</span><span class="params">(ShortLinkUpdateReqDTO requestParam)</span> &#123;</span><br><span class="line">    verificationWhitelist(requestParam.getOriginUrl());</span><br><span class="line">    <span class="keyword">if</span> (!shortUriCreateCachePenetrationBloomFilter.contains(requestParam.getFullShortUrl())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;短链接记录不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LambdaQueryWrapper&lt;ShortLinkDO&gt; queryWrapper = Wrappers.lambdaQuery(ShortLinkDO.class)</span><br><span class="line">        .eq(ShortLinkDO::getGid, requestParam.getOriginGid())</span><br><span class="line">        .eq(ShortLinkDO::getFullShortUrl, requestParam.getFullShortUrl())</span><br><span class="line">        .eq(ShortLinkDO::getDelFlag, <span class="number">0</span>)</span><br><span class="line">        .eq(ShortLinkDO::getEnableStatus, <span class="number">0</span>);</span><br><span class="line">    <span class="type">ShortLinkDO</span> <span class="variable">hasShortLinkDO</span> <span class="operator">=</span> baseMapper.selectOne(queryWrapper); <span class="comment">// 更新数据库</span></span><br><span class="line">    <span class="keyword">if</span> (hasShortLinkDO == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;短链接记录不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(hasShortLinkDO.getGid(), requestParam.getGid())) &#123; <span class="comment">// 如果更新前后 gid 相同，即更新不换组，直接更新短链接的属性</span></span><br><span class="line">        LambdaUpdateWrapper&lt;ShortLinkDO&gt; updateWrapper = Wrappers.lambdaUpdate(ShortLinkDO.class) <span class="comment">// 构建更新操作的条件</span></span><br><span class="line">            .eq(ShortLinkDO::getFullShortUrl, requestParam.getFullShortUrl())</span><br><span class="line">            .eq(ShortLinkDO::getGid, requestParam.getGid())</span><br><span class="line">            .eq(ShortLinkDO::getDelFlag, <span class="number">0</span>)</span><br><span class="line">            .eq(ShortLinkDO::getEnableStatus, <span class="number">0</span>)</span><br><span class="line">            .set(Objects.equals(requestParam.getValidDateType(), VailDateTypeEnum.PERMANENT.getType()), ShortLinkDO::getValidDate, <span class="literal">null</span>); <span class="comment">// 如果请求参数中的 有效期类型 为 永久，设置DO对象的 有效期 为null</span></span><br><span class="line">        <span class="type">ShortLinkDO</span> <span class="variable">shortLinkDO</span> <span class="operator">=</span> ShortLinkDO.builder() <span class="comment">// 执行更新操作</span></span><br><span class="line">            .domain(hasShortLinkDO.getDomain())</span><br><span class="line">            .shortUri(hasShortLinkDO.getShortUri())</span><br><span class="line">            .favicon(Objects.equals(requestParam.getOriginUrl(), hasShortLinkDO.getOriginUrl()) ? hasShortLinkDO.getFavicon() : getFavicon(requestParam.getOriginUrl())) <span class="comment">// 请求参数中的 长链接 和 当前长链接 是否一致？不一致则更换</span></span><br><span class="line">            .createdType(hasShortLinkDO.getCreatedType())</span><br><span class="line">            .gid(requestParam.getGid())  <span class="comment">// 换组</span></span><br><span class="line">            .originUrl(requestParam.getOriginUrl())  <span class="comment">// 换长链接</span></span><br><span class="line">            .describe(requestParam.getDescribe())   <span class="comment">// 换描述</span></span><br><span class="line">            .validDateType(requestParam.getValidDateType())  <span class="comment">// 换有效类型</span></span><br><span class="line">            .validDate(requestParam.getValidDate())  <span class="comment">// 换有效期</span></span><br><span class="line">            .build();</span><br><span class="line">        baseMapper.update(shortLinkDO, updateWrapper);  <span class="comment">// 使用DO对象对数据库进行更新；更新时包含逻辑：如果请求参数的有效类型为永久，则将有效期置为null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 更新换组</span></span><br><span class="line">        <span class="comment">// 使用 Redisson 分布式读写锁确保并发安全。</span></span><br><span class="line">        <span class="type">RReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> redissonClient.getReadWriteLock(String.format(LOCK_GID_UPDATE_KEY, requestParam.getFullShortUrl()));</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line">        rLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LambdaUpdateWrapper&lt;ShortLinkDO&gt; linkUpdateWrapper = Wrappers.lambdaUpdate(ShortLinkDO.class)</span><br><span class="line">                .eq(ShortLinkDO::getFullShortUrl, requestParam.getFullShortUrl())</span><br><span class="line">                .eq(ShortLinkDO::getGid, hasShortLinkDO.getGid())</span><br><span class="line">                .eq(ShortLinkDO::getDelFlag, <span class="number">0</span>)</span><br><span class="line">                .eq(ShortLinkDO::getDelTime, <span class="number">0L</span>)</span><br><span class="line">                .eq(ShortLinkDO::getEnableStatus, <span class="number">0</span>);</span><br><span class="line">            <span class="type">ShortLinkDO</span> <span class="variable">delShortLinkDO</span> <span class="operator">=</span> ShortLinkDO.builder()</span><br><span class="line">                .delTime(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">            delShortLinkDO.setDelFlag(<span class="number">1</span>);</span><br><span class="line">            baseMapper.update(delShortLinkDO, linkUpdateWrapper);</span><br><span class="line">            <span class="comment">// 将旧的短链接标记为已删除。</span></span><br><span class="line">            <span class="type">ShortLinkDO</span> <span class="variable">shortLinkDO</span> <span class="operator">=</span> ShortLinkDO.builder()</span><br><span class="line">                .domain(createShortLinkDefaultDomain)</span><br><span class="line">                .originUrl(requestParam.getOriginUrl())</span><br><span class="line">                .gid(requestParam.getGid())</span><br><span class="line">                .createdType(hasShortLinkDO.getCreatedType())</span><br><span class="line">                .validDateType(requestParam.getValidDateType())</span><br><span class="line">                .validDate(requestParam.getValidDate())</span><br><span class="line">                .describe(requestParam.getDescribe())</span><br><span class="line">                .shortUri(hasShortLinkDO.getShortUri())</span><br><span class="line">                .enableStatus(hasShortLinkDO.getEnableStatus())</span><br><span class="line">                .totalPv(hasShortLinkDO.getTotalPv())</span><br><span class="line">                .totalUv(hasShortLinkDO.getTotalUv())</span><br><span class="line">                .totalUip(hasShortLinkDO.getTotalUip())</span><br><span class="line">                .fullShortUrl(hasShortLinkDO.getFullShortUrl())</span><br><span class="line">                .favicon(Objects.equals(requestParam.getOriginUrl(), hasShortLinkDO.getOriginUrl()) ? hasShortLinkDO.getFavicon() : getFavicon(requestParam.getOriginUrl()))</span><br><span class="line">                .delTime(<span class="number">0L</span>)</span><br><span class="line">                .build();</span><br><span class="line">            baseMapper.insert(shortLinkDO);</span><br><span class="line">            <span class="comment">// 创建一个新的短链接记录，并将新的属性设置到新记录中。</span></span><br><span class="line">            LambdaQueryWrapper&lt;ShortLinkGotoDO&gt; linkGotoQueryWrapper = Wrappers.lambdaQuery(ShortLinkGotoDO.class)</span><br><span class="line">                .eq(ShortLinkGotoDO::getFullShortUrl, requestParam.getFullShortUrl())</span><br><span class="line">                .eq(ShortLinkGotoDO::getGid, hasShortLinkDO.getGid());</span><br><span class="line">            <span class="type">ShortLinkGotoDO</span> <span class="variable">shortLinkGotoDO</span> <span class="operator">=</span> shortLinkGotoMapper.selectOne(linkGotoQueryWrapper);</span><br><span class="line">            <span class="comment">// 更新 ShortLinkGotoDO 表中的 gid 信息。</span></span><br><span class="line">            shortLinkGotoMapper.delete(linkGotoQueryWrapper);</span><br><span class="line">            shortLinkGotoDO.setGid(requestParam.getGid());</span><br><span class="line">            shortLinkGotoMapper.insert(shortLinkGotoDO);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果短链接的有效期类型、有效期时间或原始 URL 发生变化，则清除 GOTO_SHORT_LINK_KEY 缓存。</span></span><br><span class="line">    <span class="comment">// 如果旧的短链接已过期，并且更新后的短链接是永久有效或者新的有效期在当前时间之后，则清除 GOTO_IS_NULL_SHORT_LINK_KEY 缓存。</span></span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(hasShortLinkDO.getValidDateType(), requestParam.getValidDateType())</span><br><span class="line">        || !Objects.equals(hasShortLinkDO.getValidDate(), requestParam.getValidDate())</span><br><span class="line">        || !Objects.equals(hasShortLinkDO.getOriginUrl(), requestParam.getOriginUrl())) &#123;</span><br><span class="line">        stringRedisTemplate.delete(String.format(GOTO_SHORT_LINK_KEY, requestParam.getFullShortUrl()));</span><br><span class="line">        <span class="type">Date</span> <span class="variable">currentDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">if</span> (hasShortLinkDO.getValidDate() != <span class="literal">null</span> &amp;&amp; hasShortLinkDO.getValidDate().before(currentDate)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(requestParam.getValidDateType(), VailDateTypeEnum.PERMANENT.getType()) || requestParam.getValidDate().after(currentDate)) &#123;</span><br><span class="line">                stringRedisTemplate.delete(String.format(GOTO_IS_NULL_SHORT_LINK_KEY, requestParam.getFullShortUrl()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>redis 与 数据库 数据一致性</p>
<p><strong>采用方案 2：数据库优先，缓存延迟更新</strong></p>
<p><strong>流程：</strong></p>
<ul>
<li>直接修改数据库中的数据</li>
<li>数据库完成修改后，删除redis中数据----（分界线：此动作前后查询到的数据发生变化）</li>
<li>访问redis发生缺失时，触发miss并查询数据库新数据，然后写入redis</li>
</ul>
<br>
<h4 id="短链解析流程">短链解析流程</h4>
<p>redis_ex - bloomFilter - redis_nx - MySQL</p>
<p>超高并发场景！！！</p>
<img src="/2025/02/19/Project/5CF8B7418CDADCA4998A29C7F084CE08.png" class="" title="5CF8B7418CDADCA4998A29C7F084CE08">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreUrl</span><span class="params">(String shortUri, ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serverName</span> <span class="operator">=</span> request.getServerName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">serverPort</span> <span class="operator">=</span> Optional.of(request.getServerPort())</span><br><span class="line">        .filter(each -&gt; !Objects.equals(each, <span class="number">80</span>))</span><br><span class="line">        .map(String::valueOf)</span><br><span class="line">        .map(each -&gt; <span class="string">&quot;:&quot;</span> + each)</span><br><span class="line">        .orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">fullShortUrl</span> <span class="operator">=</span> serverName + serverPort + <span class="string">&quot;/&quot;</span> + shortUri; <span class="comment">// 从报文中读出短链内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalLink</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(String.format(GOTO_SHORT_LINK_KEY, fullShortUrl)); <span class="comment">// 从redis获取原始链</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(originalLink)) &#123;</span><br><span class="line">        shortLinkStats(buildLinkStatsRecordAndSetUser(fullShortUrl, request, response)); <span class="comment">// 记录短链接的访问统计信息。</span></span><br><span class="line">        ((HttpServletResponse) response).sendRedirect(originalLink);  <span class="comment">// 使用HttpServletResponse对象将用户重定向到原始链接URL。  `sendRedirect` 方法会设置 HTTP 响应的状态码为 302 (Found) 或 301 (Moved Permanently)，并在响应头中设置 `Location` 字段为目标 URL。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> shortUriCreateCachePenetrationBloomFilter.contains(fullShortUrl); <span class="comment">// 布隆判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!contains) &#123;  <span class="comment">// 短链不存在</span></span><br><span class="line">        ((HttpServletResponse) response).sendRedirect(<span class="string">&quot;/page/notfound&quot;</span>); <span class="comment">// 将用户重定向到一个 &quot;notfound&quot; 页面，表示该短链接URL无效。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">gotoIsNullShortLink</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(String.format(GOTO_IS_NULL_SHORT_LINK_KEY, fullShortUrl));  <span class="comment">// 从redis中获取该短链接是否被标记为null。 用于防止缓存击穿。</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(gotoIsNullShortLink)) &#123; <span class="comment">// 如果redis中存在该短链被标记为null。</span></span><br><span class="line">        ((HttpServletResponse) response).sendRedirect(<span class="string">&quot;/page/notfound&quot;</span>); <span class="comment">// 将用户重定向到一个 &quot;notfound&quot; 页面，表示该短链接URL无效。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(String.format(LOCK_GOTO_SHORT_LINK_KEY, fullShortUrl));</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 为什么需要做两遍？</span></span><br><span class="line">        <span class="comment">// 假如用户a和用户b均访问短链x，短链仅存在于数据库（redis中不存在，缓存穿透检查不为空）；此时用户a获得锁，并在数据库中查到信息并保存到redis和布隆；用户b获得锁进入，此时redis已包含该链接</span></span><br><span class="line">        originalLink = stringRedisTemplate.opsForValue().get(String.format(GOTO_SHORT_LINK_KEY, fullShortUrl));</span><br><span class="line">        <span class="comment">//   再次尝试从Redis中获取原始链接URL。  这一步是为了防止在获取锁之前，其他线程已经将原始链接URL放入了Redis中。</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(originalLink)) &#123;</span><br><span class="line">            shortLinkStats(buildLinkStatsRecordAndSetUser(fullShortUrl, request, response));</span><br><span class="line">            ((HttpServletResponse) response).sendRedirect(originalLink);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gotoIsNullShortLink = stringRedisTemplate.opsForValue().get(String.format(GOTO_IS_NULL_SHORT_LINK_KEY, fullShortUrl));</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(gotoIsNullShortLink)) &#123;</span><br><span class="line">            ((HttpServletResponse) response).sendRedirect(<span class="string">&quot;/page/notfound&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查表获取短链映射原链</span></span><br><span class="line">        LambdaQueryWrapper&lt;ShortLinkDO&gt; queryWrapper = Wrappers.lambdaQuery(ShortLinkDO.class)</span><br><span class="line">            .eq(ShortLinkDO::getGid, shortLinkGotoDO.getGid())</span><br><span class="line">            .eq(ShortLinkDO::getFullShortUrl, fullShortUrl)</span><br><span class="line">            .eq(ShortLinkDO::getDelFlag, <span class="number">0</span>)</span><br><span class="line">            .eq(ShortLinkDO::getEnableStatus, <span class="number">0</span>);</span><br><span class="line">        <span class="type">ShortLinkDO</span> <span class="variable">shortLinkDO</span> <span class="operator">=</span> baseMapper.selectOne(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span> (shortLinkDO == <span class="literal">null</span> || (shortLinkDO.getValidDate() != <span class="literal">null</span> &amp;&amp; shortLinkDO.getValidDate().before(<span class="keyword">new</span> <span class="title class_">Date</span>()))) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(String.format(GOTO_IS_NULL_SHORT_LINK_KEY, fullShortUrl), <span class="string">&quot;-&quot;</span>, <span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 将该短链接URL标记为null，并将其存储在Redis中，有效期为30分钟。</span></span><br><span class="line">            ((HttpServletResponse) response).sendRedirect(<span class="string">&quot;/page/notfound&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存短链-原链 到 redis_ex</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set( <span class="comment">// 将原始链接URL存储在Redis中，并设置有效期。</span></span><br><span class="line">            String.format(GOTO_SHORT_LINK_KEY, fullShortUrl),</span><br><span class="line">            shortLinkDO.getOriginUrl(),</span><br><span class="line">            LinkUtil.getLinkCacheValidTime(shortLinkDO.getValidDate()), TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 消息队列更新短链访问信息</span></span><br><span class="line">        shortLinkStats(buildLinkStatsRecordAndSetUser(fullShortUrl, request, response));</span><br><span class="line">        ((HttpServletResponse) response).sendRedirect(shortLinkDO.getOriginUrl());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程</p>
<ul>
<li>
<p>检查redis_ex（内存范围）；存在直接返回，不存在进入下一步；</p>
</li>
<li>
<p>bloom判断短链接是否存在（数据库范围），不存在直接返回，可能存在进入下一步；</p>
</li>
<li>
<p>检查redis_nx，存在直接返回，不存在进入下一步；</p>
</li>
<li>
<p>开启分布式锁</p>
<ul>
<li>
<p>二次检查 redis_ex 和 redis_nx 是否存在</p>
</li>
<li>
<p>查询数据库</p>
<ul>
<li>查询表，若不存在或失效添加 redis_nx，返回；若存在进入下一步</li>
<li>将查询结果加入 redis_ex</li>
</ul>
</li>
<li>
<p>将统计状态信息发送到消息队列</p>
</li>
</ul>
</li>
</ul>
<br>
<p>Redis内容</p>
<ul>
<li>布隆过滤器</li>
<li>redis_nx（key: <code>short-link:is-null:goto_&#123;fullShortUrl&#125;</code>, value: <code>-</code>）</li>
<li>redis_ex（key: <code>short-link:goto:&#123;fullShortUrl&#125;</code>, value: <code>originUrl</code>）</li>
</ul>
<br>
<p>Q: 为什么需要做二次检查？</p>
<p>考虑如下场景：</p>
<p>场景1：生成的短链长时间未被使用（redis_ex内短链映射过期），第一次访问</p>
<p>假如用户a和用户b均访问短链x，短链仅存在于数据库（redis_ex不存在，redis_nx不存在）；此时用户a获得锁，并在数据库中查到信息并保存到redis和BloomFilter；用户b获得锁进入，此时redis已包含该链接，应当直接返回，不再查数据库；</p>
<p>场景2：无效短链，第一次访问</p>
<p>假如用户a和用户b均访问短链x，短链存在于数据库且过期（redis_ex不存在，redis_nx不存在）；此时用户a获得锁，在数据库中不能查到信息，保存到 redis_nx；用户b获得锁进入，此时 redis_nx 已指出该链接无效，应当直接返回，不再查数据库；</p>
<br>
<h4 id="短链状态信息更新流程">短链状态信息更新流程</h4>
<br>
<h4 id="可能场景分析">可能场景分析</h4>
<img src="/2025/02/19/Project/0CE3A54805CB047FA700CFDE30A643BA.png" class="" title="0CE3A54805CB047FA700CFDE30A643BA">
<br>
<h2 id="Feed流">Feed流</h2>
<img src="/2025/02/19/Project/njjbtvfwn2.png" class="" title="img">
<p>读扩散（拉模式）：粉丝去发布者的发件箱拉取内容</p>
<p>写扩散（推模式）：发布者向粉丝的收件箱推送内容</p>
<p>读写混合：如图</p>
<br>
<p>推方法：</p>
<p>发布者 发布内容 保存到mysql + redis</p>
<p>每个用户有一个对应的Redis队列，用于存储他们的动态。我们可以使用Redis的LPUSH（列表操作）命令将新的内容推送到用户的feed流队列。</p>
<p>用户上线后从自己的Redis队列获取 RRANGE 数据</p>
<p>优化</p>
<p>使用Redis Pipeline进行批量写入</p>
<p>将内容推送操作放到后台异步执行，而不是在主线程中同步完成。这可以通过消息队列（如RabbitMQ、Kafka）来实现，后台消费者异步处理推送任务。 采用延迟写入策略。可以设置一个延时队列或者利用Redis的Sorted Set来实现。在新动态发布时，动态内容先进入一个延迟队列，系统定期（例如每分钟）再批量将内容推送到用户的feed流。</p>
<p>实现方式： 使用Redis的ZADD命令将消息按照时间戳存入一个有序集合，然后定期从有序集合中取出并推送。</p>
<br>
<p>发件箱</p>
<p>sender_id, message_id, other</p>
<p>收件箱</p>
<p>(receiver_id, sequence_id,) sender_id, message_id, other</p>
<br>
<h2 id="AI-RAG">AI RAG</h2>
<h3 id="Base">Base</h3>
<p>Meta AI 的研究人员引入了一种叫做检索增强生成（Retrieval Augmented Generation，RAG）的方法来完成这类知识密集型的任务。RAG 把一个信息检索组件和文本生成模型结合在一起。RAG 可以微调，其内部知识的修改方式很高效，不需要对整个模型进行重新训练。</p>
<br>
<p>RAG 会接受输入并检索出一组相关/支撑的文档，并给出文档的来源（例如维基百科）。这些文档作为上下文和输入的原始提示词组合，送给文本生成器得到最终的输出。这样 RAG 更加适应事实会随时间变化的情况。这非常有用，因为 LLM 的参数化知识是静态的。RAG 让语言模型不用重新训练就能够获取最新的信息，基于检索生成产生可靠的输出。</p>
<br>
<p>Lewis 等人（2021）提出一个通用的 RAG 微调方法。这种方法使用预训练的 seq2seq 作为参数记忆，用维基百科的密集向量索引作为非参数记忆（使通过神经网络预训练的检索器访问）</p>
<img src="/2025/02/19/Project/FnuC7iOSLJbLu9apUaP886tm7eGD" class="" title="ai-rag-knowledge-1-01.png">
<p>向量数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;doc123&quot;,               // 唯一标识符</span><br><span class="line">    &quot;embedding&quot;: [0.1, 0.2, ...], // 向量</span><br><span class="line">    &quot;text&quot;: &quot;王大瓜，1990年出生&quot;, // 原始文本</span><br><span class="line">    &quot;metadata&quot;: &#123;                 // 元数据</span><br><span class="line">        &quot;knowledge&quot;: &quot;知识库名称&quot;,</span><br><span class="line">        &quot;timestamp&quot;: &quot;2023-10-01&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3 id="访问逻辑">访问逻辑</h3>
<p>执行</p>
<ul>
<li>
<p>加载原始文档</p>
</li>
<li>
<p>使用SentenceSplitter分割文档</p>
</li>
<li>
<p>使用embedding模型将文档向量化</p>
</li>
<li>
<p>构建BM25检索和向量检索数据库</p>
</li>
<li>
<p>保存数据库到指定位置</p>
</li>
</ul>
<p>系统内部流程：</p>
<ul>
<li>
<p>先用LLM对问题进行初步回答</p>
</li>
<li>
<p>将问题和初步回答结合作为检索关键词</p>
</li>
<li>
<p>同时使用BM25和向量召回获取相关文档</p>
</li>
<li>
<p>使用重排器对结果排序</p>
</li>
<li>
<p>构造RAG prompt，包含检索到的文档内容、原问题和LLM初步回答</p>
</li>
<li>
<p>再次调用LLM生成最终回答</p>
</li>
</ul>
<br>
<p>数据流转逻辑</p>
<ol>
<li>
<p>构建阶段：</p>
<p>原始文档 -&gt; 句子分割 -&gt; 向量化 -&gt; 构建BM25和向量索引 -&gt; 保存数据库</p>
</li>
<li>
<p>检索阶段：</p>
<p>用户查询 -&gt; LLM初步回答 -&gt; 多路召回(BM25+向量) -&gt; 重排 -&gt; 构造RAG Prompt -&gt; LLM生成最终回答</p>
</li>
</ol>
<br>
<p>系统特点</p>
<p>轻量级：可以使用小型模型运行</p>
<p>模块化：各个组件可以独立替换</p>
<p>多路召回：结合BM25和向量召回，提高召回质量</p>
<p>重排优化：使用专门的重排模型提高相关性</p>
<p>灵活配置：通过配置文件可以调整各个参数</p>
<p>通过这种方式，TinyRAG实现了在有限资源下的高效知识检索和增强生成能力，可以根据用户需求和硬件条件进行定制化配置。</p>
<br>
<br>
<h2 id="弹幕">弹幕</h2>
<p><strong>技术选型分析</strong></p>
<p><strong>实时通信技术</strong></p>
<p>• <strong>WebSocket协议</strong>：作为核心通信协议，实现客户端与服务器的全双工长连接。相比HTTP轮询，WebSocket显著降低延迟（控制在1秒内），满足实时弹幕推送需求。<br>
• <strong>Netty框架</strong>：用于构建高性能网络服务（如弹幕服务器），支持WebSocket协议实现，提供异步事件驱动模型，优化I/O效率。早期架构中，Netty负责维护TCP连接池，处理10万级并发连接。</p>
<p><strong>分布式架构设计</strong></p>
<p>• <strong>模块解耦</strong>：拆分为Comet（长连接管理）、Logic（业务逻辑处理）、Router（会话存储）、Job（消息分发）、Persistence（持久化）等独立模块，通过Kafka消息队列实现松耦合通信。</p>
<p><strong>高并发处理</strong></p>
<p>• <strong>Kafka消息队列</strong>：作为消息中间件，实现水平扩展的发布/订阅模式，支持每秒千万级弹幕分发。Job模块从Kafka消费消息后，并行推送到所有Comet节点。<br>
• <strong>Redis内存数据库</strong>：存储在线用户会话信息（如用户与Comet节点的映射关系），配合BloomFilter实现快速查询。</p>
<p><strong>优化策略</strong></p>
<p>• <strong>内存优化</strong>：采用栈内存分配、内存池技术，单机承载量从25万（2015年）提升至100万（2016年）在线用户；<br>
• <strong>网络优化</strong>：部署多线IDC+专线网络，解决单点带宽瓶颈，降低跨机房延迟；<br>
• <strong>弹幕合并</strong>：高峰期对相似弹幕内容聚合，减少70%以上冗余数据传输。</p>
<hr>
<p><strong>用户使用全流程分析</strong></p>
<p><strong>连接建立阶段</strong></p>
<ol>
<li><strong>客户端初始化</strong>：用户打开视频时，前端通过WebSocket与Comet节点建立长连接；</li>
<li><strong>身份验证</strong>：Logic模块验证用户身份（账号/IP黑名单过滤）；</li>
<li><strong>会话注册</strong>：Router模块记录用户ID与Comet节点映射关系，存入Redis。</li>
</ol>
<p><strong>弹幕发送阶段</strong></p>
<ol>
<li><strong>用户输入</strong>：前端捕获输入内容，附加视频时间戳、用户ID等元数据；</li>
<li><strong>协议封装</strong>：通过WebSocket发送至Comet节点；</li>
<li><strong>逻辑处理</strong>：<br>
• Logic模块进行敏感词过滤、内容审核（集成机器学习模型）；<br>
• 合法消息写入Kafka指定Topic（按视频ID分区）。</li>
</ol>
<p><strong>消息分发阶段</strong></p>
<ol>
<li><strong>Job消费</strong>：多个Job进程并行消费Kafka消息，根据视频ID路由到对应Comet节点集群；</li>
<li><strong>并行推送</strong>：每个Comet节点通过独立通道向客户端推送消息，避免全局锁竞争；</li>
<li><strong>本地缓存</strong>：Comet节点使用内存池管理待发送消息，减少GC停顿。</li>
</ol>
<p><strong>客户端渲染阶段</strong></p>
<ol>
<li><strong>消息接收</strong>：前端WebSocket监听消息，解析弹幕内容、位置、样式属性；</li>
<li><strong>渲染优化</strong>：<br>
• Canvas/WebGL绘制，支持10万+条弹幕同屏渲染；<br>
• 动态密度控制：根据视频分辨率自动调整弹幕显示区域；</li>
<li><strong>交互处理</strong>：用户点赞/举报操作通过REST API反馈至后端，更新Redis计数。</li>
</ol>
<p><strong>核心挑战与解决方案</strong></p>
<ol>
<li><strong>流量瓶颈</strong>：单机带宽极限约3Gbps（2016年数据），通过边缘节点CDN分发弹幕流量；</li>
<li><strong>消息顺序性</strong>：Kafka分区内保序+客户端本地时间戳排序，解决网络抖动导致的乱序问题；</li>
<li><strong>历史弹幕查询</strong>：采用MongoDB分片存储，按视频ID+时间范围建立组合索引，响应时间&lt;50ms。</li>
</ol>
<br>
<br>
<h2 id="场景问题">场景问题</h2>
<img src="/2025/02/19/Project/Camera_XHS_17416135605101040g2sg315pqsv4ohc0g5oun.jpg" class="" title="Camera_XHS_17416135605101040g2sg315pqsv4ohc0g5oun">
<img src="/2025/02/19/Project/Camera_XHS_17416135708561040g2sg315pqsv4ohc2g5oun.jpg" class="" title="Camera_XHS_17416135708561040g2sg315pqsv4ohc2g5oun">
<img src="/2025/02/19/Project/Camera_XHS_17416135670761040g2sg315pqsv4ohc205oun.jpg" class="" title="Camera_XHS_17416135670761040g2sg315pqsv4ohc205oun">
<img src="/2025/02/19/Project/Camera_XHS_17416135625461040g2sg315pqsv4ohc105oun.jpg" class="" title="Camera_XHS_17416135625461040g2sg315pqsv4ohc105oun">
<img src="/2025/02/19/Project/Camera_XHS_17416135646421040g2sg315pqsv4ohc1g5oun.jpg" class="" title="Camera_XHS_17416135646421040g2sg315pqsv4ohc1g5oun">
<br>
<h3 id="热点数据发现与处理">热点数据发现与处理</h3>
<h4 id="场景分析">场景分析</h4>
<p>Redis 使用 ZSet 保存与更新热key，使用 zadd 方法和 zrange方法完成排序队列和获取</p>
<p>场景：</p>
<p><strong>商品访问时更新排名</strong>：</p>
<ul>
<li>使用 <code>ZADD</code> 命令，将商品的最新访问时间作为 <code>score</code> 添加到有序集合中。</li>
<li>如果商品已存在，则更新 <code>score</code>（即访问时间）。</li>
</ul>
<p><strong>获取前 1000 个商品</strong>：</p>
<ul>
<li>使用 <code>ZRANGE</code> 命令，按照 <code>score</code> 降序获取前 1000 个商品 ID。</li>
</ul>
<p><strong>定期清理并补充商品</strong>：</p>
<ul>
<li>使用 <code>ZREMRANGEBYRANK</code> 删除排名最后的 200 个商品。</li>
<li>从数据库中随机获取 200 个商品，并使用 <code>ZADD</code> 加入有序集合。</li>
</ul>
<p><strong>请求到达时获取商品数据</strong>：</p>
<ul>
<li>先用 <code>ZRANK</code> 确定商品是否在前 1000 名中。</li>
<li>如果命中，则从缓存获取商品详细信息，否则从数据库加载。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisZSetExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_PORT</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PRODUCT_RANK_KEY</span> <span class="operator">=</span> <span class="string">&quot;hot_products&quot;</span>; <span class="comment">// Redis ZSet key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TOP_N</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REMOVE_COUNT</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(REDIS_HOST, REDIS_PORT)) &#123;</span><br><span class="line">            <span class="comment">// 访问商品</span></span><br><span class="line">            accessProduct(jedis, <span class="string">&quot;product_123&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取 Top 1000 商品</span></span><br><span class="line">            Set&lt;String&gt; topProducts = getTopProducts(jedis);</span><br><span class="line">            System.out.println(<span class="string">&quot;Top Products: &quot;</span> + topProducts);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定期清理并补充数据</span></span><br><span class="line">            refreshProductList(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问商品时更新访问时间（作为score）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">accessProduct</span><span class="params">(Jedis jedis, String productId)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 以当前时间戳作为score</span></span><br><span class="line">        jedis.zadd(PRODUCT_RANK_KEY, currentTime, productId);</span><br><span class="line">        <span class="comment">// zadd往有序集合key中加入带分值元素,若元素已存在，则覆盖其原有分值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Updated access time for product: &quot;</span> + productId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Top 1000 商品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title function_">getTopProducts</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.zrevrange(PRODUCT_RANK_KEY, <span class="number">0</span>, TOP_N - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// zrevrange倒序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定期清理并补充商品数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">refreshProductList</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalSize</span> <span class="operator">=</span> jedis.zcard(PRODUCT_RANK_KEY); <span class="comment">// zcard返回有序集合key中元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (totalSize &gt; TOP_N) &#123;</span><br><span class="line">            <span class="comment">// 删除排名靠后的 200 个商品</span></span><br><span class="line">            jedis.zremrangeByRank(PRODUCT_RANK_KEY, <span class="number">0</span>, REMOVE_COUNT - <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Removed least accessed products.&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从数据库中随机获取 200 个商品（模拟）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; REMOVE_COUNT; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">newProduct</span> <span class="operator">=</span> <span class="string">&quot;random_product_&quot;</span> + i;</span><br><span class="line">                <span class="type">double</span> <span class="variable">timeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                jedis.zadd(PRODUCT_RANK_KEY, timeStamp, newProduct);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Added 200 random products from DB.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>访问商品时更新 score</strong></p>
<ul>
<li>访问商品时，调用 <code>zadd</code> 方法，将当前时间戳作为 <code>score</code>，实现越新访问的商品排名越靠前。</li>
</ul>
<p><strong>获取前 1000 个商品</strong></p>
<ul>
<li><code>zrevrange(PRODUCT_RANK_KEY, 0, 999)</code> 获取排名靠前的 1000 个商品。</li>
</ul>
<p><strong>定期清理并补充</strong></p>
<ul>
<li><code>zremrangeByRank(PRODUCT_RANK_KEY, 0, 199)</code> 删除排名最末的 200 个商品。</li>
<li>随机从数据库选 200 个商品，使用 <code>zadd</code> 加入 Redis。</li>
</ul>
<p><strong>查询商品是否命中</strong></p>
<ul>
<li><code>zrank(PRODUCT_RANK_KEY, productId)</code> 确定是否在前 1000 名中。</li>
<li>命中则从缓存获取商品详情，否则从数据库加载。</li>
</ul>
<br>
<p>考虑Redis中热点数据自动续期</p>
<p>使用 Lua 脚本</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> ttl = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> value = redis.call(<span class="string">&#x27;GET&#x27;</span>, key)</span><br><span class="line"><span class="keyword">if</span> value <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, ttl)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>
<br>
<h4 id="热点数据发现">热点数据发现</h4>
<ol>
<li>经验评估</li>
</ol>
<p>对于特定业务场景，我们可以预先评估哪些数据可能成为热点数据，例如秒杀商品、热门商品、大 V 的动态内容等等。</p>
<p>这种方案的优点是实施成本较低，但是由于是基于经验而非实际数据，因此最终的结果可能与实际情况有所偏差。</p>
<ol start="2">
<li>使用 hotkey 命令</li>
</ol>
<p>Redis 从版本 4.0 开始引入了 <code>hotkey</code> 命令，允许通过客户端的 <code>redis-cli --hotkeys</code> 命令扫描库中的所有热点 Key。</p>
<p>这种方案的优点是无需引入其他配置或组件，但缺点是性能较差，尤其在处理大量数据时可能会非常耗时。</p>
<ol start="3">
<li>使用 monitor 命令</li>
</ol>
<p>当通过 <code>MONITOR</code> 命令开启监视器后，Redis 将在执行命令后输出一些相关的信息。结合日志和相关分析工具（如 <code>redis-faina</code>）就可以对其进行统计。</p>
<p>这种方案的缺点在于，开启监控会显著降低 Redis 性能（单个实例会降低差不多 50% 的性能），如果 Redis 实例本身已经承受较大负荷，启用此功能可能会雪上加霜。</p>
<blockquote>
<p>具体参见：<a href="https://redis.io/commands/monitor/">Redis 官网监控 sourl.cn/pDDVv4</a></p>
</blockquote>
<ol start="4">
<li>客户端监控</li>
</ol>
<p>通常情况下，我们会使用客户端（如 Jedis 或 Lettuce）来与 Redis 进行通信。因此，通过在代码中添加一层代理，或使用字节码插桩的方式，我们可以在程序实际请求 Redis 之前上报请求内容，然后通过第三方组件或平台进行分析，以确定哪些 Key 是热 Key。</p>
<p>这种方法的优点在于实施门槛较低，并且由于可以直接在代码里面修改，所以比较灵活。缺点在于二次开发也需要成本，而且在不同的系统中可能无法复用。</p>
<p>当然，目前市场上也有一些带客户端的一站式开源解决方案，比如京东的 <strong>Gitee/hotkey</strong>，也很好地解决了热 Key 问题。</p>
<ol start="5">
<li>代理层监控</li>
</ol>
<p>对于大规模的 Redis 集群（例如各大云商提供的 Redis 服务）的请求通常会经过代理或网关层进行转发。因此，如果代理层可以收集请求信息并上报，那就可以通过分析相关请求信息来确认热 Key。</p>
<p>这种方法与客户端监控相似，但适用范围更广，缺点是引入额外的代理层会增加运维成本，而不是所有集群都支持这种方式。</p>
<blockquote>
<p>此处推荐阅读一下得物技术团队的文章：<a href="https://juejin.cn/post/7202531472720756791">得物热点探测设计与实践</a></p>
</blockquote>
<ol start="6">
<li>服务端监控</li>
</ol>
<p>除了上述方法，还可以尝试在服务端监听端口以抓包分析请求，或直接修改 Redis 源码添加上报功能。这种方法类似于代理层监控，但最大的问题是实施成本较高。</p>
<p>ref: <a href="https://open8gu.com/cache/big-hot-key/gcgigmnixrmu640t/">https://open8gu.com/cache/big-hot-key/gcgigmnixrmu640t/</a></p>
<br>
<h4 id="方案">方案</h4>
<p><strong>数据分片</strong></p>
<p>数据分片是通过将热点数据分散存储在多个Redis节点上，避免单个节点负载过高，是解决热点Key问题最常用的策略。</p>
<p>例如，在Redis Cluster模式下，数据自动按槽位分布在多个节点上，从而实现负载均衡。对于非Cluster模式，可以通过客户端或代理层实现一致性哈希等分片算法，将数据分布在多个Redis实例上。</p>
<br>
<p><strong>读写分离</strong></p>
<p>读写分离可以将读操作与写操作分开处理，降低单个节点的负载。在主从复制模式下，可以将读操作分发到从节点上，从而分担主节点的压力。此外，可以使用代理层如Redis Sentinel或Twemproxy实现自动故障转移和读写分离。</p>
<br>
<p><strong>多级缓存</strong></p>
<p>对于一些热 Key，我们可以考虑使用一些本地缓存工具（比如 Guava 或 Ehcache） 直接将其缓存到 JVM 内存中，从根本上避免对 Redis 造成压力。</p>
<p>不过，这种方案下缓存会占用额外的运行时内存，因此需要有选择进行缓存，以避免占用过多内存资源。并且当与 Redis 缓存共用时，也要考虑数据一致性问题。</p>
<br>
<p><strong>限流与熔断降级</strong></p>
<p>限流是通过控制请求的速率来防止系统过载。在应用层实现限流，可以有效减轻热点Key对Redis的压力。常见的限流算法有漏桶算法和令牌桶算法。</p>
<p>熔断降级是在系统出现问题时，自动降低系统功能的一种策略。在应用层实现熔断降级，可以在Redis出现热点Key问题时，快速降低对Redis的访问压力。熔断降级可以通过开源工具如Hystrix实现。</p>
<p>通过上述策略，可以有效解决Redis的热点Key问题。然而，在实际应用中，需要根据具体业务场景和需求选择合适的策略。接下来，我们将通过实践案例来说明如何解决热点Key问题。</p>
<br>
<br>
<h3 id="冷热数据分离">冷热数据分离</h3>
<p>四级缓存</p>
<p>guava</p>
<p>redis</p>
<p>MySQL</p>
<p>Hadoop</p>
<br>
<h3 id="多级缓存">多级缓存</h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8a949368c524bed93123c832290610b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1244&amp;h=617&amp;s=43089&amp;e=png&amp;b=ffffff" alt="image.png"></p>
<p>Nginx静态缓存 + 进程内缓存 + redis缓存 + MySQL缓存</p>
<br>
<p>本地缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Caffeine 缓存实例</span></span><br><span class="line">Cache&lt;String, String&gt; caffeineCache = Caffeine.newBuilder()</span><br><span class="line"><span class="comment">// 设置缓存项在 5s 后开始自动更新</span></span><br><span class="line">.refreshAfterWrite(<span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line"><span class="comment">// 自定义缓存更新逻辑（即获取新值逻辑）</span></span><br><span class="line">.build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">(String key, String oldValue)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟更新缓存的操作</span></span><br><span class="line">        updateCache(key, oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<br>
<p>本地缓存一致性方案：</p>
<p>MQ</p>
<img src="/2025/02/19/Project/v2-788007b6d898a775abd4889d22892a3d_1440w.jpg" class="" title="img">
<p>Canal + MQ</p>
<img src="/2025/02/19/Project/v2-41835bffd6cf315cffaf8c4e52a94496_1440w.jpg" class="" title="img">
<br>
<br>
<h3 id="分库分表">分库分表</h3>
<p>使用 ShardingSphere</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="type">!SHARDING</span></span><br><span class="line">    <span class="attr">tables:</span></span><br><span class="line">      <span class="attr">t_link:</span></span><br><span class="line">        <span class="attr">actualDataNodes:</span> <span class="string">ds_0.t_link_$&#123;0..15&#125;</span></span><br><span class="line">        <span class="attr">tableStrategy:</span></span><br><span class="line">          <span class="attr">standard:</span></span><br><span class="line">            <span class="attr">shardingColumn:</span> <span class="string">gid</span></span><br><span class="line">            <span class="attr">shardingAlgorithmName:</span> <span class="string">link_table_hash_mod</span></span><br><span class="line">      <span class="attr">t_link_goto:</span></span><br><span class="line">        <span class="attr">actualDataNodes:</span> <span class="string">ds_0.t_link_goto_$&#123;0..15&#125;</span></span><br><span class="line">        <span class="attr">tableStrategy:</span></span><br><span class="line">          <span class="attr">standard:</span></span><br><span class="line">            <span class="attr">shardingColumn:</span> <span class="string">full_short_url</span></span><br><span class="line">            <span class="attr">shardingAlgorithmName:</span> <span class="string">link_goto_table_hash_mod</span></span><br><span class="line">      <span class="attr">t_group:</span></span><br><span class="line">        <span class="attr">actualDataNodes:</span> <span class="string">ds_0.t_group_$&#123;0..15&#125;</span></span><br><span class="line">        <span class="attr">tableStrategy:</span></span><br><span class="line">          <span class="attr">standard:</span></span><br><span class="line">            <span class="attr">shardingColumn:</span> <span class="string">username</span></span><br><span class="line">            <span class="attr">shardingAlgorithmName:</span> <span class="string">group_table_hash_mod</span></span><br><span class="line">    <span class="attr">shardingAlgorithms:</span></span><br><span class="line">      <span class="attr">link_table_hash_mod:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">HASH_MOD</span></span><br><span class="line">        <span class="attr">props:</span></span><br><span class="line">          <span class="attr">sharding-count:</span> <span class="number">16</span></span><br><span class="line">      <span class="attr">link_goto_table_hash_mod:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">HASH_MOD</span></span><br><span class="line">        <span class="attr">props:</span></span><br><span class="line">          <span class="attr">sharding-count:</span> <span class="number">16</span></span><br><span class="line">      <span class="attr">group_table_hash_mod:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">HASH_MOD</span></span><br><span class="line">        <span class="attr">props:</span></span><br><span class="line">          <span class="attr">sharding-count:</span> <span class="number">16</span></span><br><span class="line"> <span class="bullet">-</span> <span class="type">!ENCRYPT</span></span><br><span class="line">    <span class="attr">tables:</span></span><br><span class="line">      <span class="attr">t_user:</span></span><br><span class="line">        <span class="attr">columns:</span></span><br><span class="line">          <span class="attr">phone:</span></span><br><span class="line">            <span class="attr">cipherColumn:</span> <span class="string">phone</span></span><br><span class="line">            <span class="attr">encryptorName:</span> <span class="string">common_encryptor</span></span><br><span class="line">          <span class="attr">mail:</span></span><br><span class="line">            <span class="attr">cipherColumn:</span> <span class="string">mail</span></span><br><span class="line">            <span class="attr">encryptorName:</span> <span class="string">common_encryptor</span></span><br><span class="line">        <span class="attr">queryWithCipherColumn:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">encryptors:</span></span><br><span class="line">      <span class="attr">common_encryptor:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">AES</span></span><br><span class="line">        <span class="attr">props:</span></span><br><span class="line">          <span class="attr">aes-key-value:</span> <span class="string">d6oadClrrb9A3GWo</span></span><br></pre></td></tr></table></figure>
<p><strong>分片：</strong></p>
<p>这个配置文件的作用是将三个表 (t_link, t_link_goto, t_group) 通过哈希取模的方式，各自拆分成 16 个分片，并将这些分片存储在 ds_0 数据源中。每个表的分片键分别是 gid, full_short_url 和 username。 HASH_MOD 算法会计算分片键的哈希值，然后对 16 取模，根据结果将数据路由到对应的分片表。</p>
<p>例如，对于 t_link 表，如果 gid 的哈希值对 16 取模的结果为 5，那么该条数据将被存储到 ds_0.t_link_5 表中。 其他两个表的分片过程类似，只是分片键不同。</p>
<p><strong>加密：</strong> t_user 表的 phone 和 mail 列使用 AES 算法进行加密。加密后的数据直接存储在原列中。queryWithCipherColumn: true 确保在查询 phone 和 mail 列时，查询条件会被自动加密，然后对密文列进行查询。</p>
<br>
<p><strong>分库分表产生的额外表</strong></p>
<p>在分库分表中，假如是通过用户名进行分片的，如果在查询用户信息时不带用户名，将会触发读扩散问题。</p>
<p>由于登录时没有带用户名，导致无法确定用户的分片键，使得系统无法直接锁定用户的数据位于哪个数据库或者哪张表中。为了找到用户的数据，只能对全部的数据库和表进行扫描查询，这就造成了所谓的“读请求扩散”问题。</p>
<p>也就是说，原本读请求可以直接定位到某个数据库某张表，现在却要多处查询，无疑大大增加了系统的查询负载。</p>
<p>一旦出现了读请求扩散问题，势必会导致用户的登录请求响应时间变长，严重的话还可能造成登录超时</p>
<br>
<h2 id="SSO">SSO</h2>
<img src="/2025/02/19/Project/cas-1741240463041.png" class="" title="img">]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2025/04/13/Python/</url>
    <content><![CDATA[<p>Python</p>
<span id="more"></span>
<h1>Python</h1>
<h2 id="Keyword">Keyword</h2>
<h3 id="Colon">Colon</h3>
<p><strong>切片操作（Slice）</strong></p>
<p>冒号用于分隔切片参数的起始、结束和步长。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, Python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本切片</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">2</span>:<span class="number">5</span>])   <span class="comment"># 输出 &quot;llo&quot;（索引 2 到 5-1）</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">3</span>])    <span class="comment"># 输出 &quot;Hel&quot;（从开头到索引 3-1）</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">7</span>:])    <span class="comment"># 输出 &quot;Python&quot;（从索引 7 到末尾）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步长切片</span></span><br><span class="line"><span class="built_in">print</span>(s[::<span class="number">2</span>])   <span class="comment"># 输出 &quot;Hlo yhn&quot;（每隔一个字符取一次）</span></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])  <span class="comment"># 输出 &quot;nohtyP ,olleH&quot;（逆序）</span></span><br></pre></td></tr></table></figure>
<br>
<p><strong>lambda 函数参数与主体分隔</strong></p>
<p>冒号分隔 lambda 函数的参数和表达式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">square = <span class="keyword">lambda</span> x: x ** <span class="number">2</span>  <span class="comment"># 冒号前是参数，后是表达式</span></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">5</span>))  <span class="comment"># 输出 25</span></span><br></pre></td></tr></table></figure>
<br>
<p><strong>类型注解（Type Hints）</strong></p>
<p>Python 3.5+ 中，冒号用于分隔变量名和类型注解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:  <span class="comment"># 参数后冒号分隔类型</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<br>
<h3 id="Index">Index</h3>
<p>正索引从0开始，负索引从-1开始</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])  <span class="comment"># 输出: &quot;a&quot;（第1个元素）</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 输出: &quot;b&quot;（第2个元素）</span></span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">1</span>]) <span class="comment"># 输出: &quot;d&quot;（倒数第1个元素，负索引从-1开始）</span></span><br></pre></td></tr></table></figure>
<br>
<br>
<h2 id="Pytorch">Pytorch</h2>
<h3 id="维度">维度</h3>
<p>张量是有多个“维度”的，每个维度对应一个“方向”：</p>
<ul>
<li><strong>维度 0：</strong> 最外层（最左边的括号）—— 行的个数 → <strong>竖着方向</strong></li>
<li><strong>维度 1：</strong> 每一行里的列数 → <strong>横着方向</strong></li>
<li><strong>维度 2：</strong> 通常是更深一层，比如 RGB 通道、高度、时间帧等</li>
</ul>
<blockquote>
<p>维度的大小 -&gt; 从括号最外层向内增加</p>
<p>在 PyTorch 中，每多一层括号，维度 +1。</p>
</blockquote>
<br>
<h3 id="常用函数">常用函数</h3>
<br>
<p><code>.view()</code> - 改变张量形状（不改变数据）</p>
<p><strong>作用</strong>：重新排列张量的维度，类似于NumPy的<code>reshape</code></p>
<p><strong>特点</strong>：</p>
<ul>
<li>
<p>不改变原始数据，只改变&quot;视图&quot;</p>
</li>
<li>
<p>内存中逐个元素的重排</p>
</li>
<li>
<p>总元素数必须保持不变（各维度乘积相同）</p>
</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个1x6的张量</span></span><br><span class="line">x = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x.shape)  <span class="comment"># torch.Size([1, 6])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重塑为2x3</span></span><br><span class="line">y = x.view(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment"># tensor([[1, 2, 3],</span></span><br><span class="line"><span class="comment">#         [4, 5, 6]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重塑为3x2</span></span><br><span class="line">z = x.view(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="comment"># tensor([[1, 2],</span></span><br><span class="line"><span class="comment">#         [3, 4],</span></span><br><span class="line"><span class="comment">#         [5, 6]])</span></span><br><span class="line">q = self.linear_q(x).view(batch_size, -<span class="number">1</span>, self.heads, self.d_k) </span><br><span class="line"><span class="comment">#  -1 是一个特殊值，表示自动推断该维度的大小，它的作用是让PyTorch根据张量的总元素数量和其他已知维度的大小，自动计算 -1 所在维度的具体值。</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果尝试<code>x.view(4, 2)</code>会报错，因为1×6 ≠ 4×2</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
<th>用途场景</th>
<th>记忆技巧</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.view()</code></td>
<td>快速 reshape，但要求内存连续</td>
<td>高性能操作（如模型推理中）</td>
<td>“原地换角度”</td>
</tr>
<tr>
<td><code>.reshape()</code></td>
<td>通用 reshape，底层自动处理</td>
<td>安全首选，尤其是复杂场景</td>
<td>“随便你换，我来兜底”</td>
</tr>
</tbody>
</table>
<br>
<p><code>.transpose()</code> - 交换两个维度</p>
<p><strong>作用</strong>：交换指定的两个维度<br>
<strong>特点</strong>：</p>
<ul>
<li>
<p>常用于矩阵转置（交换最后两个维度）</p>
</li>
<li>
<p>比<code>.permute()</code>更轻量（只能交换两个维度）</p>
</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个2x3的张量</span></span><br><span class="line">x = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x.shape)  <span class="comment"># torch.Size([2, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转置为3x2</span></span><br><span class="line">y = x.transpose(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># 交换第0和第1维度</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment"># tensor([[1, 4],</span></span><br><span class="line"><span class="comment">#         [2, 5],</span></span><br><span class="line"><span class="comment">#         [3, 6]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在多头注意力中的典型用法</span></span><br><span class="line">q = torch.randn(<span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>)  <span class="comment"># (batch, seq_len, heads, d_k)</span></span><br><span class="line">q = q.transpose(<span class="number">1</span>, <span class="number">2</span>)          <span class="comment"># 变为 (batch, heads, seq_len, d_k)</span></span><br></pre></td></tr></table></figure>
<br>
<p><code>.matmul()</code> - 矩阵乘法</p>
<p><strong>作用</strong>：执行矩阵乘法（支持广播）<br>
<strong>特点</strong>：</p>
<ul>
<li>比<code>torch.mm()</code>更通用（支持高维张量）</li>
<li>自动处理批量维度（非常适合神经网络）</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 矩阵乘法（2D）</span></span><br><span class="line">a = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])  <span class="comment"># 2x2</span></span><br><span class="line">b = torch.tensor([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])  <span class="comment"># 2x2</span></span><br><span class="line">c = torch.matmul(a, b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># tensor([[19, 22],</span></span><br><span class="line"><span class="comment">#         [43, 50]])</span></span><br><span class="line"><span class="comment"># 计算过程：</span></span><br><span class="line"><span class="comment"># 1*5 + 2*7 = 19 | 1*6 + 2*8 = 22</span></span><br><span class="line"><span class="comment"># 3*5 + 4*7 = 43 | 3*6 + 4*8 = 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量矩阵乘法（3D）</span></span><br><span class="line">q = torch.randn(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)  <span class="comment"># 3个5x7矩阵</span></span><br><span class="line">k = torch.randn(<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>)  <span class="comment"># 3个7x2矩阵</span></span><br><span class="line">out = torch.matmul(q, k)   <span class="comment"># 结果为3个5x2矩阵</span></span><br><span class="line"><span class="built_in">print</span>(out.shape)  <span class="comment"># torch.Size([3, 5, 2])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在注意力机制中的应用</span></span><br><span class="line">score = torch.matmul(q, k.transpose(-<span class="number">2</span>, -<span class="number">1</span>))  <span class="comment"># 计算Q和K的点积</span></span><br><span class="line"><span class="comment"># q形状: (batch, seq_len_q, d_k)</span></span><br><span class="line"><span class="comment"># k形状: (batch, seq_len_k, d_k)</span></span><br><span class="line"><span class="comment"># 结果: (batch, seq_len_q, seq_len_k)</span></span><br></pre></td></tr></table></figure>
<br>
<p><code>torch.gather</code></p>
<p><strong>作用：</strong><br>
按照指定的索引，从输入张量中<strong>收集（gather）数据</strong>。</p>
<p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CopyEdit</span><br><span class="line">torch.gather(input, dim, index)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>input</code>: 原始张量</li>
<li><code>dim</code>: 沿哪个维度索引</li>
<li><code>index</code>: 索引张量（大小与返回值一致）</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pythonCopyEditx = torch.tensor([[10, 20], [30, 40]])</span><br><span class="line">index = torch.tensor([[0, 0], [1, 0]])</span><br><span class="line">out = torch.gather(x, 1, index)</span><br><span class="line"># out: tensor([[10, 10],</span><br><span class="line">#              [40, 30]])</span><br></pre></td></tr></table></figure>
<p><strong>记忆方法：</strong><br>
“<strong>gather</strong>” = 收集：像是用 index 张量告诉你：<strong>从哪里把值收集过来</strong>。</p>
<br>
<h3 id="计算图">计算图</h3>
<p>代码</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">x</span> = <span class="number">2.0</span></span><br><span class="line"><span class="attr">w</span> = <span class="number">3.0</span></span><br><span class="line"><span class="attr">b</span> = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">z</span> = w * x + b</span><br><span class="line"><span class="attr">a</span> = ReLU(z)</span><br><span class="line"><span class="attr">L</span> = (a - <span class="number">5</span>)^<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>完整的计算图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">w (Tensor) --&gt; MulBackward0 (w*x)</span><br><span class="line">x (Tensor) --&gt; MulBackward0 (w*x)</span><br><span class="line">(w*x) --&gt; AddBackward0 (z = w*x + b)</span><br><span class="line">b (Tensor) --&gt; AddBackward0 (z = w*x + b)</span><br><span class="line">z --&gt; ReluBackward0 (a = relu(z))</span><br><span class="line">a --&gt; PowBackward0 (L = (a-5)^2)</span><br></pre></td></tr></table></figure>
<br>
<p>每一层参数（如权重 <code>w</code>, 偏置 <code>b</code>）的梯度会保存在对应的Tensor张量对象中的 <code>.grad</code> 属性里。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="comment"># 定义叶子节点（需要梯度）</span></span><br><span class="line">w = torch.tensor([<span class="number">3.0</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([<span class="number">1.0</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向传播（构建计算图）</span></span><br><span class="line">x = torch.tensor([<span class="number">2.0</span>])</span><br><span class="line">y = w * x + b      <span class="comment"># y.grad_fn = AddBackward0</span></span><br><span class="line">loss = (y - <span class="number">5</span>)**<span class="number">2</span>  <span class="comment"># loss.grad_fn = PowBackward0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义优化器（绑定需要更新的参数）</span></span><br><span class="line">optimizer = optim.SGD([w, b], lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向传播（构建计算图）</span></span><br><span class="line">y = w * x + b</span><br><span class="line">loss = (y - <span class="number">5</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看梯度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n反向传播前：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;叶子节点：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;w.grad_fn = <span class="subst">&#123;w.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b.grad_fn = <span class="subst">&#123;b.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;w.grad = <span class="subst">&#123;w.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b.grad = <span class="subst">&#123;b.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n中间节点：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y.grad_fn = <span class="subst">&#123;y.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;loss.grad_fn = <span class="subst">&#123;loss.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y.grad = <span class="subst">&#123;y.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;loss.grad = <span class="subst">&#123;loss.grad&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向传播（计算梯度）</span></span><br><span class="line">loss.backward()  <span class="comment"># 计算 w.grad 和 b.grad</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看梯度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n反向传播后：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;叶子节点：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;w.grad_fn = <span class="subst">&#123;w.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b.grad_fn = <span class="subst">&#123;b.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;w.grad = <span class="subst">&#123;w.grad&#125;</span>&quot;</span>)  <span class="comment"># tensor([4.])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b.grad = <span class="subst">&#123;b.grad&#125;</span>&quot;</span>)  <span class="comment"># tensor([2.])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n中间节点：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y.grad_fn = <span class="subst">&#123;y.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;loss.grad_fn = <span class="subst">&#123;loss.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y.grad = <span class="subst">&#123;y.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;loss.grad = <span class="subst">&#123;loss.grad&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化器更新参数</span></span><br><span class="line">optimizer.step()  <span class="comment"># w = w - lr * w.grad, b = b - lr * b.grad</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n优化器更新后：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;叶子节点：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;w.grad_fn = <span class="subst">&#123;w.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b.grad_fn = <span class="subst">&#123;b.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;w.grad = <span class="subst">&#123;w.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b.grad = <span class="subst">&#123;b.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n中间节点：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y.grad_fn = <span class="subst">&#123;y.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;loss.grad_fn = <span class="subst">&#123;loss.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y.grad = <span class="subst">&#123;y.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;loss.grad = <span class="subst">&#123;loss.grad&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空梯度（避免下次迭代梯度累积）</span></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n清空梯度后：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;叶子节点：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;w.grad_fn = <span class="subst">&#123;w.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b.grad_fn = <span class="subst">&#123;b.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;w.grad = <span class="subst">&#123;w.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b.grad = <span class="subst">&#123;b.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n中间节点：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y.grad_fn = <span class="subst">&#123;y.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;loss.grad_fn = <span class="subst">&#123;loss.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y.grad = <span class="subst">&#123;y.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;loss.grad = <span class="subst">&#123;loss.grad&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n更新后参数：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;w = <span class="subst">&#123;w&#125;</span>&quot;</span>)  <span class="comment"># tensor([2.9600], requires_grad=True)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)  <span class="comment"># tensor([0.9800], requires_grad=True)</span></span><br></pre></td></tr></table></figure>
<p><code>next_functions</code> 是一个 tuple，里面的元素代表了 <code>MulBackward0</code> 的 <strong>输入函数</strong>（上游节点）</p>
<p>PyTorch 中每个计算节点的 <code>grad_fn</code> 是计算图的一部分，它通过 <code>.next_functions</code> 连接上游节点，并在 <code>grad_fn.next_functions._saved_results</code> 中保存前向传播需要的中间变量，反向传播时依此自动计算梯度。</p>
<blockquote>
<p>在 PyTorch 中，<strong>计算图的清理（Graph Cleanup）</strong> 指的是在反向传播完成后，系统自动释放计算图占用的内存，以避免不必要的资源占用。这包括：</p>
<ol>
<li><strong>删除中间变量的梯度计算函数（<code>grad_fn</code>）</strong>
<ul>
<li>在反向传播完成后，PyTorch 会自动销毁计算图（除非显式指定 <code>retain_graph=True</code>）。</li>
<li>这意味着所有中间变量（如 <code>z2</code>、<code>a</code>）的 <code>grad_fn</code> 会被置为 <code>None</code>，从而断开计算图的链接。</li>
</ul>
</li>
<li><strong>释放梯度缓冲区（<code>.grad</code>）</strong>
<ul>
<li>叶子节点（如 <code>w</code>、<code>x</code>、<code>a</code>、<code>b</code>）的梯度（<code>.grad</code>）仍然会保留，除非手动调用 <code>optimizer.zero_grad()</code> 或 <code>tensor.grad = None</code>。</li>
</ul>
</li>
<li><strong>计算图的内存回收</strong>
<ul>
<li>PyTorch 的自动微分引擎（Autograd）会释放计算图占用的内存，避免内存泄漏。</li>
</ul>
</li>
</ol>
</blockquote>
<br>
<h3 id="Tensor计算">Tensor计算</h3>
<p><strong>高维张量的矩阵乘法（如 <code>torch.matmul</code>）</strong></p>
<p><strong>规则</strong>：从右向左对齐维度，按矩阵乘法规则扩展。</p>
<p><strong>(1) 核心思想</strong></p>
<ul>
<li>最后两个维度（<code>行, 列</code>）必须满足矩阵乘法规则：<br>
<code>(..., m, n) * (..., n, p)</code> → <code>(..., m, p)</code><br>
（消去中间的 <code>n</code>）。</li>
<li>其他维度（前面的 <code>...</code>）必须相同或可广播。</li>
</ul>
<p><strong>(2) 示例</strong></p>
<ol>
<li><strong>批量矩阵乘法</strong>：<br>
<code>(2, 3, 4) * (2, 4, 5)</code> → 结果 <code>(2, 3, 5)</code>
<ul>
<li>前导维度 <code>2</code> 相同，</li>
<li>最后两维 <code>(3,4) * (4,5)</code> → <code>(3,5)</code>。</li>
</ul>
</li>
<li><strong>广播矩阵乘法</strong>：<br>
<code>(3, 1, 4) * (1, 4, 5)</code> → 广播为 <code>(3, 1, 4) * (3, 4, 5)</code> → 结果 <code>(3, 1, 5)</code>
<ul>
<li>前导维度 <code>3</code> 和 <code>1</code> 广播为 <code>3</code>，</li>
<li>最后两维 <code>(1,4) * (4,5)</code> → <code>(1,5)</code>。</li>
</ul>
</li>
</ol>
<br>
<h2 id="实例">实例</h2>
<h3 id="手写Ttransformer">手写Ttransformer</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim, num_heads, d_model, dropout=<span class="number">0.1</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            input_dim: 输入维度</span></span><br><span class="line"><span class="string">            num_heads: 注意力头的数量</span></span><br><span class="line"><span class="string">            d_model: 模型维度（必须能被num_heads整除）</span></span><br><span class="line"><span class="string">            dropout: dropout概率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">assert</span> d_model % num_heads == <span class="number">0</span>, <span class="string">&quot;d_model must be divisible by num_heads&quot;</span></span><br><span class="line"></span><br><span class="line">        self.d_model = d_model</span><br><span class="line">        self.num_heads = num_heads</span><br><span class="line">        self.d_k = d_model // num_heads</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义Q、K、V的线性变换层</span></span><br><span class="line">        self.linear_q = nn.Linear(input_dim, d_model)</span><br><span class="line">        self.linear_k = nn.Linear(input_dim, d_model)</span><br><span class="line">        self.linear_v = nn.Linear(input_dim, d_model)</span><br><span class="line">        <span class="comment"># # 合并QKV的线性变换层，减少矩阵乘法次数</span></span><br><span class="line">        <span class="comment"># self.qkv_proj = nn.Linear(input_dim, 3 * d_model)</span></span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line">        self.scale = <span class="number">1.0</span> / math.sqrt(self.d_k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输出线性层</span></span><br><span class="line">        self.out = nn.Linear(d_model, d_model)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, mask=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            x: 输入张量，形状为(batch_size, seq_len, input_dim)</span></span><br><span class="line"><span class="string">            mask: 可选掩码，形状为(batch_size, 1, seq_len, seq_len)或(1, 1, seq_len, seq_len)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            输出张量，形状与输入相同(batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        batch_size, seq_len, _ = x.shape</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 线性变换并分头处理</span></span><br><span class="line">        <span class="comment"># 形状变化: (batch, seq_len, input_dim) -&gt; (batch, seq_len, heads, d_k)</span></span><br><span class="line">        q = self.linear_q(x).view(batch_size, seq_len, self.num_heads, self.d_k)</span><br><span class="line">        k = self.linear_k(x).view(batch_size, seq_len, self.num_heads, self.d_k)</span><br><span class="line">        v = self.linear_v(x).view(batch_size, seq_len, self.num_heads, self.d_k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转置维度，使形状变为(batch, heads, seq_len, d_k)</span></span><br><span class="line">        q = q.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        k = k.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        v = v.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 一次性计算QKV</span></span><br><span class="line">        <span class="comment"># qkv = self.qkv_proj(x)</span></span><br><span class="line">        <span class="comment"># qkv = qkv.view(batch_size, seq_len, 3, self.num_heads, self.d_k)</span></span><br><span class="line">        <span class="comment"># q, k, v = qkv.unbind(2)  # 形状均为(batch_size, seq_len, num_heads, d_k), 表示沿着第3个维度（索引从0开始）拆分张量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 转置维度 (batch_size, num_heads, seq_len, d_k)</span></span><br><span class="line">        <span class="comment"># q = q.transpose(1, 2)</span></span><br><span class="line">        <span class="comment"># k = k.transpose(1, 2)</span></span><br><span class="line">        <span class="comment"># v = v.transpose(1, 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算注意力分数 (batch_size, num_heads, seq_len, seq_len)</span></span><br><span class="line">        scores = torch.matmul(q, k.transpose(-<span class="number">2</span>, -<span class="number">1</span>)) * self.scale</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 应用掩码（如果有）</span></span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            scores = scores.masked_fill(mask == <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算注意力权重</span></span><br><span class="line">        att = torch.softmax(scores, dim=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> self.dropout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            att = self.dropout(att)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 应用注意力权重到V上</span></span><br><span class="line">        output = torch.matmul(att, v)  <span class="comment"># (batch_size, num_heads, seq_len, d_k)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拼接多头结果</span></span><br><span class="line">        output = output.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous()  <span class="comment"># (batch_size, seq_len, num_heads, d_k)</span></span><br><span class="line">        output = output.view(batch_size, seq_len, self.d_model)  <span class="comment"># (batch_size, seq_len, d_model)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最终线性变换</span></span><br><span class="line">        output = self.out(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 测试代码</span></span><br><span class="line">    batch = <span class="number">2</span></span><br><span class="line">    seq_len = <span class="number">5</span></span><br><span class="line">    input_dim = <span class="number">32</span></span><br><span class="line">    num_heads = <span class="number">2</span></span><br><span class="line">    d_model = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建随机输入</span></span><br><span class="line">    x = torch.randn(size=(batch, seq_len, input_dim))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化多头注意力层</span></span><br><span class="line">    attention = MultiHeadAttention(input_dim, num_heads, d_model)</span><br><span class="line">    <span class="built_in">print</span>(attention(x).shape)  <span class="comment"># 输出形状应为(batch, seq_len, d_model)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建下三角掩码（用于解码器自注意力）</span></span><br><span class="line">    attention_mask = torch.tril(torch.ones(seq_len, seq_len)).view(<span class="number">1</span>, <span class="number">1</span>, seq_len, seq_len)</span><br><span class="line">    attention_mask = attention_mask.to(dtype=torch.float32)</span><br><span class="line">    attention_mask = (attention_mask == <span class="number">0</span>)  <span class="comment"># 转换为布尔掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(attention_mask)  <span class="comment"># 打印掩码</span></span><br><span class="line">    <span class="built_in">print</span>(attention(x, attention_mask).shape)  <span class="comment"># 带掩码的输出形状</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper-Reading-Record</title>
    <url>/2025/04/02/Paper-Reading-Record/</url>
    <content><![CDATA[<p>Paper阅读记录</p>
<span id="more"></span>
<h1>Paper-Reading-Record</h1>
<img src="/2025/04/02/Paper-Reading-Record/v2-ee9b5d4a0761d2d1d10acb37cebefba3_1440w.jpg" class="" title="img">
<h2 id="Corpus">Corpus</h2>
<p>corpus 语料库</p>
<p>“conditioning the model” “调节模型”</p>
<p>“word representations” “词向量表示”</p>
<p>“log-bilinear” “对数双线性”</p>
<p>“factored 3-way” “因子分解三向”</p>
<p>modality-biased 模态偏置</p>
<p>Generation and Retrieval 生成和检索</p>
<p>SOTA  “State - Of - The - Art”</p>
<p>lexicon 词汇表</p>
<br>
<p><strong>n-gram</strong>：指连续的 <em>n</em> 个词（或字符）组成的序列。例如：</p>
<ul>
<li><strong>Unigram (1-gram)</strong>: “the”, “cat”, “sat”</li>
<li><strong>Bigram (2-gram)</strong>: “the cat”, “cat sat”</li>
<li><strong>Trigram (3-gram)</strong>: “the cat sat”</li>
</ul>
<br>
<p><strong>BLEU（Bilingual Evaluation Understudy）</strong></p>
<ul>
<li><strong>用途</strong>：机器翻译质量评估指标，通过对比生成文本与人工参考译文的n-gram匹配度计算得分（0-100，越高越好）。</li>
<li><strong>任务</strong>：<code>EN-DE</code>（英译德）和<code>EN-FR</code>（英译法）。</li>
</ul>
<p><strong>FLOPs（Floating Point Operations）</strong></p>
<ul>
<li><strong>用途</strong>：训练成本量化指标，表示模型训练所需浮点运算总量（数值越低，计算效率越高）</li>
</ul>
<br>
<p><strong>Perplexity</strong></p>
<p>困惑度（Perplexity）是评估语言模型性能的核心指标，用于衡量模型对未知数据的预测能力。困惑度反映了模型对测试数据中每个词的预测“不确定程度”。值越低，说明模型预测越准确（即更“不困惑”）。</p>
<p>困惑度的数学表达式为：<br>
$$<br>
\log_2 C(w_{1:n} | x) = -\frac{1}{N} \sum \log_2 P(w_n = i | w_{1:n-1}, x)<br>
$$<br>
其中：</p>
<ul>
<li><strong>$w_{1:n}$</strong>：长度为 n$ 的文本序列（例如句子或词序列）。</li>
<li><strong>$x$</strong>：额外模态的输入（如图像、音频等，在多模态任务中可能作为条件输入）。</li>
<li><strong>$P(w_n = i | w_{1:n-1}, x)$</strong>：模型基于历史序列 $w_{1:n-1}$ 和额外信息 $x$，预测下一个词 $w_n$ 为 $i$ 的概率。</li>
<li><strong>$N$</strong>：序列的总长度（或词数）。</li>
</ul>
<br>
<h2 id="Datasets">Datasets</h2>
<p>image-text descriptions: IAPR TC-12, Attributes Discovery, and the SBU datasets.</p>
<br>
<h2 id="Paper">Paper</h2>
<h3 id="Distribution-Base">Distribution-Base</h3>
<h4 id="CAP">CAP</h4>
<p>CAP twelve years later: How the “rules” have changed</p>
<p><a href="https://ieeexplore.ieee.org/abstract/document/6133253">https://ieeexplore.ieee.org/abstract/document/6133253</a></p>
<p><strong>一致性 (Consistency, C)：</strong></p>
<ul>
<li><strong>含义：</strong> 在分布式系统中，对数据进行读取操作时，所有客户端（或者说从任何节点读取）都能看到相同且最新的数据。就好比系统里只有一份数据，而且这份数据总是最新的。</li>
</ul>
<p><strong>高可用性 (High Availability, A)：</strong></p>
<ul>
<li><strong>含义：</strong> 系统在非故障情况下，应该能够处理所有请求并返回响应（无论是成功还是失败）。换句话说，系统的大部分或全部节点应该始终保持运行状态，并且能够响应来自客户端的请求。特别是对于写入操作，客户端应该总是能够成功地将数据写入系统。</li>
</ul>
<p><strong>网络分区容忍性 (Tolerance to Network Partitions, P)：</strong></p>
<ul>
<li><strong>含义：</strong> 当分布式系统中的节点之间发生网络通信故障时（即网络分区，导致部分节点无法与另一部分节点通信），系统仍然能够正常运行。</li>
</ul>
<p><strong>核心概念总结：</strong></p>
<p>当网络出现分区（P）时，不可能同时拥有完美的“一致性”（C）和完美的“可用性”（A）。你必须在这两者之间做出权衡：</p>
<ul>
<li><strong>CP 系统：</strong> 优先保证一致性，在分区时牺牲可用性。</li>
<li><strong>AP 系统：</strong> 优先保证可用性，在分区时牺牲一致性（意味着可能需要后期处理数据冲突）。</li>
</ul>
<h3 id="LLM-Base">LLM-Base</h3>
<h4 id="Attention">Attention</h4>
<p><strong>Attention is All You Need</strong></p>
<p><a href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a></p>
<br>
<h4 id="GPT">GPT</h4>
<p><a href="https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf">https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf</a></p>
<p>Improving Language Understanding by Generative Pre-Training</p>
<p>GPT是基于Transformer的<strong>Decoder</strong>部分，但移除了交叉注意力。</p>
<ul>
<li><strong>“生成式”</strong>：指的是预训练阶段的任务是语言模型任务，即预测下一个词，这本质上是一种生成文本的能力。</li>
<li><strong>“预训练”</strong>：指的是模型在大量无标签文本数据上，通过上述生成任务进行训练，从而学习到通用的语言表示和能力，这些能力可以在后续的下游任务中进行迁移。</li>
</ul>
<br>
<p><strong>Two Stage Training</strong></p>
<p><strong>Unsupervised pre-training</strong></p>
<ul>
<li>
<p>“Given an unsupervised corpus of tokens $\mathcal{U} = {u_1, \ldots, u_n}$, we use a standard language modeling objective to maximize the following likelihood:”</p>
<p>$L_1(\mathcal{U}) = \sum_i \log P(u_i|u_{i-k}, \ldots, u_{i-1}; \Theta)$</p>
</li>
<li>
<p>“where $k$ is the size of the context window, and the conditional probability $P$ is modeled using a neural network with parameters $\Theta$. These parameters are trained using stochastic gradient descent [51].”</p>
</li>
<li>
<p>“In our experiments, we use a multi-layer <strong>Transformer decoder</strong> [34] for the language model, which is a variant of the transformer [62]. This model applies a multi-headed self-attention operation over the input context tokens followed by position-wise feedforward layers to produce an output distribution over target tokens:”<br>
$h_0 = UW_e + W_p$<br>
$h_l = \text{transformer_block}(h_{l-1}) \forall i \in [1, n]$<br>
$P(u) = \text{softmax}(h_n W_e^T)$</p>
</li>
<li>
<p>“where $U = (u_{-k}, \ldots, u_{-1})$ is the context vector of tokens, $n$ is the number of layers, $W_e$ is the token embedding matrix, and $W_p$ is the position embedding matrix.”</p>
</li>
</ul>
<br>
<p><strong>Supervised fine-tuning</strong></p>
<ul>
<li>
<p>“After training the model with the objective in Eq. 1, we adapt the parameters to the supervised target task.”</p>
</li>
<li>
<p>“We assume a labeled dataset $\mathcal{C}$, where each instance consists of a sequence of input tokens, $x^1, \ldots, x^m$, along with a label $y$.”<br>
这里定义了用于微调的监督数据集 $\mathcal{C}$。数据集中的每个样本都包含一个输入序列（由 $m$ 个 token 组成，$x^1, \ldots, x^m$）以及一个对应的标签 $y$。</p>
</li>
<li>
<p>“The inputs are passed through our pre-trained model to obtain the final transformer block’s activation $h_l^m$, which is then fed into an added linear output layer with parameters $W_y$ to predict $y$:”<br>
这部分是微调的关键机制。</p>
<ol>
<li><strong>输入通过预训练模型：</strong> 将输入序列 $x^1, \ldots, x^m$ 传入预训练好的 Transformer 模型。</li>
<li><strong>获取最终激活：</strong> 从模型中获取<strong>最后一个 Transformer block 的激活 $h_l^m$</strong>。这里的 $h_l^m$ 通常指的是整个输入序列经过最后一层 Transformer block 处理后，<strong>最后一个 token ($x^m$) 对应的隐藏状态（激活值）</strong>。在分类任务中，通常使用序列末尾的隐藏状态作为整个序列的表示。</li>
<li><strong>连接线性输出层：</strong> 将 $h_l^m$ 输入到一个新添加的线性输出层。这个线性层的参数是 $W_y$。</li>
<li><strong>预测标签 $y$：</strong> 通过这个线性层预测标签 $y$。</li>
</ol>
</li>
<li>
<p>$P(y|x^1, \ldots, x^m) = \text{softmax}(h_l^m W_y).$<br>
这个公式描述了在给定输入序列 $x^1, \ldots, x^m$ 的情况下，预测标签 $y$ 的概率。</p>
<ul>
<li>$h_l^m W_y$ 是最后一个 token 的激活 $h_l^m$ 与线性层参数 $W_y$ 的矩阵乘法。这会得到一个与标签类别数量相同维度的向量。</li>
<li><code>softmax</code> 函数将这个向量转换为概率分布，使得所有类别的概率之和为 1。</li>
</ul>
</li>
<li>
<p>“This gives us the following objective to maximize:”<br>
$L_2(\mathcal{C}) = \sum_{(x,y)} \log P(y|x^1, \ldots, x^m).$ (4)<br>
这是监督微调阶段的主要目标函数。</p>
<ul>
<li>它是一个对数似然函数（或交叉熵损失的负值）。</li>
<li>目标是最大化在给定输入序列 $(x^1, \ldots, x^m)$ 的情况下，模型预测正确标签 $y$ 的对数概率之和。</li>
<li>求和遍历了监督数据集 $\mathcal{C}$ 中的所有样本 $(x, y)$。</li>
</ul>
</li>
<li>
<p>“We additionally found that including language modeling as an auxiliary objective to the fine-tuning helped learning by (a) improving generalization of the supervised model, and (b) accelerating convergence. This is in line with prior work [50, 43], who also observed improved performance with such an auxiliary objective.”<br>
这是一个重要的发现和优化策略。作者发现，在微调阶段除了使用监督任务的目标函数 $L_2(\mathcal{C})$，<strong>同时引入语言模型目标 $L_1(\mathcal{C})$ 作为辅助目标</strong>，能够：</p>
<ul>
<li>a) 提高监督模型的泛化能力。</li>
<li>b) 加速收敛。</li>
<li>这与之前的工作（[50, 43]）观察到的结果一致。</li>
</ul>
</li>
<li>
<p>“Specifically, we optimize the following objective (with weight $\lambda$):”<br>
$L_3(\mathcal{C}) = L_2(\mathcal{C}) + \lambda * L_1(\mathcal{C})$<br>
这是最终用于微调的总目标函数。</p>
<ul>
<li>$L_3(\mathcal{C})$ 是 $L_2(\mathcal{C})$（监督任务目标）和 $L_1(\mathcal{C})$（语言模型目标）的加权和。</li>
<li>$\lambda$ 是一个超参数，用于控制语言模型辅助目标的重要性。</li>
<li>这里的 $L_1(\mathcal{C})$ 是在微调数据集 $\mathcal{C}$ 上计算的语言模型损失。这意味着在微调过程中，模型不仅要学习如何完成下游任务，还要继续保持其语言模型的生成能力。</li>
</ul>
</li>
<li>
<p>“Overall, the only extra parameters we require during fine-tuning are $W_y$, and embeddings for delimiter tokens (described below in Section 3.3).”<br>
这句话指出了在微调阶段，除了预训练模型的所有参数外，唯一需要额外添加和训练的参数是：</p>
<ul>
<li>$W_y$：用于监督任务的线性输出层的参数。</li>
<li><strong>分隔符 token 的嵌入</strong>：这在下一节 3.3 中会详细描述，这些特殊 token 用于将输入序列格式化以适应不同的下游任务（例如，分类任务可能需要在序列开头或结尾添加特殊 token）。</li>
</ul>
</li>
</ul>
<br>
<p><strong>Task-specific input transformations</strong></p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250530104004180.png" class="" title="image-20250530104004180">
<ul>
<li>
<p>“For some tasks, like text classification, we can directly fine-tune our model as described above. Certain other tasks, like question answering or textual entailment, have structured inputs such as ordered sentence pairs, or triplets of document, question, and answers. Since our pre-trained model was trained on contiguous sequences of text, we require some modifications to apply it to these tasks.”</p>
<ul>
<li>对于简单的任务（如文本分类），可以直接按照 3.2 节描述的方式微调模型。</li>
<li>但对于更复杂的任务（如问答或文本蕴涵），输入通常是结构化的，例如有序的句子对或文档、问题和答案的三元组。</li>
<li>由于预训练模型是基于连续的文本序列进行训练的，为了适应这些结构化输入，需要进行一些修改。</li>
</ul>
</li>
<li>
<p>“Previous work proposed learning task specific architectures on top of transferred representations [44]. Such an approach re-introduces a significant amount of task-specific customization and does not use transfer learning for these additional architectural components.”</p>
<ul>
<li>以前的工作（如 [44]）通常会在迁移的表示之上构建任务特定的架构。</li>
<li>这种方法会引入大量的任务特定定制，并且这些额外的架构组件无法享受到迁移学习的优势。</li>
</ul>
</li>
<li>
<p>“Instead, we use a traversal-style approach [52], where we convert structured inputs into an ordered sequence that our pre-trained model can process. These input transformations allow us to avoid making extensive changes to the architecture across tasks. We provide a brief description of these input transformations below and Figure 1 provides a visual illustration. All transformations include adding randomly initialized start and end tokens ($\langle s \rangle$, $\langle e \rangle$).”</p>
<ul>
<li>GPT 采用了“遍历式”方法（参考 [52]），即将结构化输入转换成一个有序的序列，使得预训练模型可以直接处理。</li>
<li>这种输入转换避免了对模型架构进行大量的任务间修改，从而保持了架构的统一性。</li>
<li>所有转换都包括添加随机初始化的<strong>开始 token ($\langle s \rangle$)</strong> 和<strong>结束 token ($\langle e \rangle$)</strong>。这些特殊 token 的嵌入在微调阶段也会被训练。</li>
</ul>
</li>
</ul>
<p><strong>Textual entailment (文本蕴涵):</strong><br>
“For entailment tasks, we concatenate the premise $p$ and hypothesis $h$ token sequences, with a delimiter token ($ $$) in between.”</p>
<ul>
<li><strong>任务：</strong> 判断一个“假说（hypothesis）”是否可以从一个“前提（premise）”中推断出来。</li>
<li><strong>输入转换：</strong> 将前提 $p$ 的 token 序列和假说 $h$ 的 token 序列<strong>连接起来</strong>，并在它们之间插入一个<strong>分隔符 token ($$$)</strong>。</li>
<li><strong>格式：</strong> $\langle s \rangle \text{ premise } \text{ $ } \text{ hypothesis } \langle e \rangle$</li>
</ul>
<p><strong>Similarity (相似度):</strong><br>
“For similarity tasks, there is no inherent ordering of the two sentences being compared. To reflect this, we modify the input sequence to contain both possible sentence orderings (with a delimiter in between) and process each independently to produce two sequence representations $h_l^m$ which are added element-wise before being fed into the linear output layer.”</p>
<ul>
<li><strong>任务：</strong> 判断两个句子之间的相似度。</li>
<li><strong>挑战：</strong> 两个句子没有固有的顺序。</li>
<li><strong>输入转换：</strong> 为了解决无序性，模型会生成<strong>两种可能的句子顺序</strong>的输入序列：
<ol>
<li><strong>顺序 1：</strong> 句子 A $\text{ $ }$ 句子 B</li>
<li><strong>顺序 2：</strong> 句子 B $\text{ $ }$ 句子 A</li>
</ol>
</li>
<li><strong>处理方式：</strong>
<ul>
<li>分别将这两个序列独立地传入预训练模型。</li>
<li>得到两个序列的最终表示 $h_l^m$（即每个序列的最后一个 token 的隐藏状态）。</li>
<li>将这两个 $h_l^m$ <strong>进行逐元素相加（element-wise add）</strong>。</li>
<li>将相加后的结果输入到线性输出层进行预测。</li>
</ul>
</li>
<li><strong>格式：</strong>
<ul>
<li>Sequence 1: $\langle s \rangle \text{ sentence}_1 \text{ $ } \text{ sentence}_2 \langle e \rangle$</li>
<li>Sequence 2: $\langle s \rangle \text{ sentence}_2 \text{ $ } \text{ sentence}_1 \langle e \rangle$</li>
<li>然后将两个序列的输出表示相加。</li>
</ul>
</li>
</ul>
<p><strong>Question Answering and Commonsense Reasoning (问答和常识推理):</strong><br>
“For these tasks, we are given a context document $z$, a question $q$, and a set of possible answers ${a_k}$. We concatenate the document context and question with each possible answer, adding a delimiter token in between to get $[z; q; $; a_k]$. Each of these sequences are processed independently with our model and then normalized via a softmax layer to produce an output distribution over possible answers.”</p>
<ul>
<li><strong>任务：</strong> 给定一个文档 $z$、一个问题 $q$ 和一组可能的答案 ${a_k}$，选择正确答案。</li>
<li><strong>输入转换：</strong> 对于每个可能的答案 $a_k$，构造一个独立的输入序列。
<ul>
<li>将<strong>文档上下文 $z$</strong>、<strong>问题 $q$</strong> 和<strong>当前可能的答案 $a_k$</strong> 连接起来。</li>
<li>在文档上下文和问题之间，以及问题和答案之间，都插入一个<strong>分隔符 token ($$$)</strong>。</li>
</ul>
</li>
<li><strong>格式：</strong> $\langle s \rangle \text{ document } \text{ $ } \text{ question } \text{ $ } \text{ answer}_k \langle e \rangle$</li>
<li><strong>处理方式：</strong>
<ul>
<li>对于每个构造的序列（即每个可能的答案），都独立地通过模型进行处理。</li>
<li>得到每个序列的最终表示后，通过 softmax 层归一化，得到每个答案的概率分布。</li>
<li>模型最终选择概率最高的答案。</li>
</ul>
</li>
</ul>
<br>
<br>
<h4 id="BERT">BERT</h4>
<p><strong>BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</strong></p>
<p><a href="https://arxiv.org/abs/1810.04805">https://arxiv.org/abs/1810.04805</a></p>
<p>BERT arch</p>
<p>denote input embedding as $E$, the final hidden vector of the special [CLS] token as $C \in \mathbb{R}^H$, and the final hidden vector for the $i^{\text{th}}$ input token as $T_i \in \mathbb{R}^H$.</p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250530112142071.png" class="" title="image-20250530112142071">
<p>BERT token representation</p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250530110615396.png" class="" title="image-20250530110615396">
<br>
<p><strong>pre-training</strong></p>
<p>$BERT_{BASE}$ was chosen to have the same model size as OpenAI GPT for comparison purposes. Critically, however, the BERT Transformer uses bidirectional self-attention, while the GPT Transformer uses constrained self-attention where every token can only attend to context to its left</p>
<p>BERT是基于Transformer的<strong>Encoder</strong>部分</p>
<p><strong>MLM</strong></p>
<p>“遮蔽语言模型”（MLM）方法</p>
<p>MLM的核心思想是：</p>
<ol>
<li><strong>随机遮蔽（Mask）输入序列中的一部分词语。</strong> 就像在句子中挖空一样。</li>
<li><strong>然后，模型的目标是预测这些被遮蔽的词语是什么。</strong></li>
</ol>
<p>这与传统的“完形填空”（Cloze task）非常相似，即给出一个句子，其中有一些缺失的词，要求填入正确的词。</p>
<p>当模型处理完被遮蔽的输入序列后，对于每个 [MASK] 标记，BERT会输出一个对应的<strong>最终隐藏向量（final hidden vector）</strong>。这个隐藏向量包含了模型对该位置上下文信息的理解。</p>
<p>然后，这个隐藏向量会被送入一个<strong>输出Softmax层</strong>。这个Softmax层的输出维度等于词汇表的大小（vocabulary size）。Softmax会为词汇表中的每个词分配一个概率，表示该词是 [MASK] 位置的正确词的概率。模型会选择概率最高的词作为预测结果。这个过程类似于标准语言模型的预测方式，只是这里只针对被遮蔽的词。</p>
<ul>
<li><strong>遮蔽比例：</strong> 在BERT的所有实验中，每个输入序列中**15%**的WordPiece tokens（BERT使用的子词分词单元）会被随机选中并遮蔽。</li>
<li><strong>与去噪自编码器的区别：</strong> 传统的去噪自编码器（Denoising Auto-encoders）在输入中加入噪声（比如遮蔽），然后模型的目标是<strong>重构整个原始输入</strong>。而BERT的MLM不同，它<strong>只预测被遮蔽的词</strong>，而不是重构整个句子。这使得BERT能够更专注于理解上下文，并预测缺失的信息。</li>
</ul>
<p>MLM确实让BERT获得了双向的上下文理解能力，这是一个巨大的优势。然而，它也带来了一个问题：在预训练阶段，模型会看到特殊的 [MASK] 标记。但在<strong>微调（fine-tuning）阶段</strong>，实际的下游任务（如情感分析、问答、命名实体识别等）的输入数据中<strong>不会出现 [MASK] 标记</strong>。这导致了预训练和微调之间的<strong>不匹配（mismatch）</strong>：模型在预训练时学习了如何处理 [MASK]，但在实际应用中却从未遇到它。这可能会影响模型的性能。</p>
<p>为了缓解上述预训练-微调不匹配问题，BERT引入了一个巧妙的策略：</p>
<ol>
<li><strong>首先，确定要被“遮蔽”的词：</strong> 仍然随机选择**15%**的token位置作为要被预测的“目标”词。假设第i个token被选中。</li>
<li><strong>对这15%的选中词，采取三种不同的处理方式：</strong>
<ul>
<li><strong>80% 的情况：用 [MASK] 替换。</strong> 这是最常见的处理方式，和通常的MLM一样。模型学习了 [MASK] 的上下文表示。</li>
<li><strong>10% 的情况：用一个随机词替换。</strong> 这是一个非常关键的技巧。
<ul>
<li><strong>目的：</strong> 强制模型不仅要依赖 [MASK] 标记来预测，还要学会处理“错误”的输入词。这意味着模型需要利用其<strong>双向上下文</strong>来判断当前词是否合理，并预测出它原来的正确词。这提高了模型的鲁棒性。</li>
</ul>
</li>
<li><strong>10% 的情况：保持不变（不替换）。</strong>
<ul>
<li><strong>目的：</strong> 这迫使模型不仅仅是“填空”，它还需要识别出哪些词是它需要预测的（即使它们没有被替换），并且在没有 [MASK] 标记的情况下也能进行预测。这进一步减少了预训练和微调之间的差异，因为在微调时，模型总是看到“正常的”词，而没有 [MASK]。</li>
</ul>
</li>
</ul>
</li>
<li><strong>预测目标：</strong> 不论上述哪种情况，模型的目标<strong>始终是预测原始的、未被修改的token</strong>。损失函数是<strong>交叉熵损失（cross entropy loss）</strong>，用于衡量模型预测的概率分布与真实词的独热编码（one-hot encoding）之间的差异。</li>
</ol>
<blockquote>
<p><strong>例子：</strong><br>
原始句子：The quick brown fox jumps over the lazy dog.<br>
假设 brown 被选中作为15%要预测的词之一。</p>
<ul>
<li><strong>情况1 (80%): [MASK] 替换</strong>
<ul>
<li>输入：The quick [MASK] fox jumps over the lazy dog.</li>
<li>模型预测：brown</li>
</ul>
</li>
<li><strong>情况2 (10%): 随机词替换</strong>
<ul>
<li>假设随机选择了词 apple。</li>
<li>输入：The quick apple fox jumps over the lazy dog.</li>
<li>模型预测：brown (虽然输入是 apple，但模型需要根据上下文 The quick ___ fox 判断出 apple 是不合理的，并预测原词 brown)</li>
</ul>
</li>
<li><strong>情况3 (10%): 保持不变</strong>
<ul>
<li>输入：The quick brown fox jumps over the lazy dog.</li>
<li>模型预测：brown (即使 brown 没有被遮蔽，模型也需要学会预测它。这有点像一个“自我纠正”机制，或者说，在没有 [MASK] 提示的情况下，模型依然能够识别出某些位置是它需要特别关注和预测的，因为它被标记为“目标预测词”之一。)</li>
</ul>
</li>
</ul>
<p>以 <code>quick</code> 这个词为例：</p>
<ul>
<li><strong>真实标签 (Target):</strong> <code>quick</code>。在one-hot编码中，只有 <code>quick</code> 对应的维度是1，其他都是0。</li>
<li><strong>BERT模型预测概率 (Prediction):</strong> BERT模型对于 <code>[MASK]</code> 位置的输出，经过softmax后，会得到一个关于整个词汇表的概率分布，例如：
<ul>
<li>$P(\text{quick}) = 0.9$</li>
<li>$P(\text{slow}) = 0.05$</li>
<li>$P(\text{brown}) = 0.01$</li>
<li>…</li>
</ul>
</li>
</ul>
<p>交叉熵损失计算将是：<br>
$Loss_{quick} = - (1 \cdot \log(P(\text{quick})) + 0 \cdot \log(P(\text{slow})) + …)$</p>
<p><strong>同理，对 <code>fox</code> 和 <code>lazy</code> 进行计算：</strong></p>
<ul>
<li>
<p><strong>对于 <code>fox</code> (被替换为 <code>apple</code> 的位置):</strong></p>
<ul>
<li>真实标签: <code>fox</code></li>
<li>BERT模型预测概率: $P(\text{fox})$</li>
<li>$Loss_{fox} = - \log(P(\text{fox}))$</li>
</ul>
</li>
<li>
<p><strong>对于 <code>lazy</code> (保持不变的位置):</strong></p>
<ul>
<li>真实标签: <code>lazy</code></li>
<li>BERT模型预测概率: $P(\text{lazy})$</li>
<li>$Loss_{lazy} = - \log(P(\text{lazy}))$</li>
</ul>
</li>
</ul>
<p><strong>总损失：</strong></p>
<p>最终的MLM任务的总损失是所有被预测词的交叉熵损失的<strong>平均值</strong>（或求和，然后除以被预测词的数量）。</p>
<p>$Total Loss = (Loss_{quick} + Loss_{fox} + Loss_{lazy}) / 3$ (假设只有这三个词被预测)</p>
</blockquote>
<br>
<p><strong>NSP</strong></p>
<p>BERT的第一个预训练任务（MLM）主要关注的是<strong>词汇层面的理解和上下文表示</strong>。然而，许多重要的自然语言处理（NLP）下游任务，比如：</p>
<ul>
<li><strong>问答（Question Answering, QA）</strong>：模型需要判断一个句子（问题）和另一个句子（段落中的答案句）之间的关系。</li>
<li><strong>自然语言推理（Natural Language Inference, NLI）</strong>：也称为蕴含识别，模型需要判断一个前提（premise）和一个假设（hypothesis）之间的关系（蕴含、矛盾、中立）。</li>
</ul>
<p>这些任务都要求模型能够理解<strong>两个句子之间的关系</strong>，而不仅仅是单个句子内部的词语关系。传统的语言模型（无论是从左到右还是MLM）并没有直接捕捉这种跨句子的关系。</p>
<p>NSP任务的训练数据生成方式如下：<br>
对于每个训练样本，模型会输入两个句子，我们称之为句子A和句子B。</p>
<ol>
<li><strong>50% 的情况：IsNext (是下一句)</strong>
<ul>
<li>句子B确实是语料库中紧跟在句子A后面的那句话。</li>
<li>这个样本会被标记为 IsNext。</li>
</ul>
</li>
<li><strong>50% 的情况：NotNext (不是下一句)</strong>
<ul>
<li>句子B是语料库中随机选择的另一句话，与句子A没有直接的连续关系。</li>
<li>这个样本会被标记为 NotNext。</li>
</ul>
</li>
</ol>
<p>结构图中的“C”指的是BERT模型在处理多句输入时，用于表示整个输入序列的特殊标记 [CLS] 的最终隐藏向量。在BERT的输入格式中，两个句子A和B会被连接起来，中间用 [SEP] 分隔，开头有 [CLS] 标记。</p>
<p>输入格式大致是：[CLS] Sentence A [SEP] Sentence B [SEP]</p>
<ul>
<li>[CLS] 标记的最终隐藏向量（通常称为 C 或 T_CLS）被认为是包含了整个输入序列（包括两个句子及其关系）的综合信息。</li>
<li>这个 [CLS] 标记对应的隐藏向量会被送入一个简单的分类层（例如一个线性层接Softmax），进行二分类预测：IsNext 或 NotNext。</li>
</ul>
<blockquote>
<p><strong>例子：</strong><br>
对于输入 [CLS] The cat sat on the mat. [SEP] It was a fluffy cat. [SEP]</p>
<ol>
<li>BERT处理整个输入序列。</li>
<li>提取 [CLS] 标记对应的输出向量。</li>
<li>将该向量送入一个分类器。</li>
<li>分类器输出概率：P(IsNext)=0.98, P(NotNext)=0.02。模型预测 IsNext。</li>
</ol>
</blockquote>
<br>
<p><strong>Fine-tuning</strong></p>
<p>BERT直接把两段文本（例如，问题和文章）<strong>拼接</strong>在一起（用特殊分隔符[SEP]隔开），然后一起输入给BERT。BERT的<strong>自注意力机制</strong>神奇之处在于，当它处理这个拼接后的长文本时，它会自动地在问题和文章的词语之间建立起“双向交叉注意力”。也就是说，一个词在问题中，它也会关注文章中的所有词；一个词在文章中，它也会关注问题中的所有词。这一个步骤就完成了传统的“独立编码”和“交叉注意力”两个阶段的工作，简化了模型结构。</p>
<p>对于每个不同的任务，我们只需要把任务对应的输入格式（如单句、句子对）和任务对应的输出要求（如分类结果、词级别标签）接入到预训练好的BERT模型上，然后从头到尾（end-to-end）地微调整个模型的所有参数。</p>
<p>BERT在微调时，根据任务类型利用其输出的不同部分。</p>
<ul>
<li><strong>Token-level tasks (词级别任务)：</strong>
<ul>
<li><strong>用途：</strong> 对于需要对输入文本中的每个词进行判断或标记的任务。</li>
<li><strong>取用输出：</strong> 使用BERT输出的<strong>每个词（token）对应的向量表示</strong>。</li>
<li><strong>举例：</strong>
<ul>
<li><strong>序列标注 (Named Entity Recognition, NER)：</strong> 输入 “张三在纽约工作”。BERT会为&quot;张三&quot;、“在”、“纽约”、&quot;工作&quot;等每个词生成一个向量。然后，将这些向量输入一个线性层，分别预测&quot;张三&quot;是人名（PER）、&quot;纽约&quot;是地名（LOC）。</li>
<li><strong>问答 (Question Answering, QA)：</strong> BERT为文章中的每个词生成向量。这些向量被用于预测答案的起始词和结束词。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Classification tasks (分类任务)：</strong>
<ul>
<li><strong>用途：</strong> 对于需要对整个输入文本（或文本对）进行分类的任务。</li>
<li><strong>取用输出：</strong> 使用BERT输出的**[CLS] token对应的向量表示**。[CLS] token是一个特殊的标记，它的最终向量表示被设计成能够汇聚整个输入序列的语义信息。</li>
<li><strong>举例：</strong>
<ul>
<li><strong>语义蕴含 (Entailment)：</strong> 输入[CLS] 狗在跑 [SEP] 动物在运动 [SEP]。取[CLS]的向量，输入一个分类层，判断属于“蕴含”、“矛盾”还是“中性”。</li>
<li><strong>情感分析 (Sentiment Analysis)：</strong> 输入[CLS] 这部电影太棒了！ [SEP]。取[CLS]的向量，输入一个分类层，判断属于“正面”、“负面”或“中性”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>原始BERT论文中提到的问答任务，特指<strong>问答抽取（Extractive QA）</strong>，而不是问答生成。</p>
</blockquote>
<br>
<p><strong>Training Objectives</strong></p>
<ul>
<li><strong>预训练阶段：</strong> BERT在预训练时学习了两种任务：MLM（Masked Language Model）和NSP（Next Sentence Prediction）。NSP任务的输入就是[CLS] Sentence A [SEP] Sentence B [SEP]，它需要判断Sentence B是否是Sentence A的下一句。这里的Sentence A和Sentence B是任意从语料中抽取的。</li>
<li><strong>到下游任务的映射：</strong>
<ol>
<li><strong>Paraphrasing (复述判断)：</strong> 判断两句话是否表达相同的意思。
<ul>
<li>对应：[CLS] 句子A [SEP] 句子B [SEP]</li>
<li>例如：[CLS] 他买了一辆新车 [SEP] 他购入了一台新轿车 [SEP]</li>
</ul>
</li>
<li><strong>Entailment (语义蕴含)：</strong> 判断一个“假设句”是否能从一个“前提句”中推导出来。
<ul>
<li>对应：[CLS] 假设句 [SEP] 前提句 [SEP]</li>
<li>例如：[CLS] 狗在跑 [SEP] 动物在运动 [SEP] (假设句：狗在跑，前提句：动物在运动。狗在跑蕴含动物在运动)</li>
</ul>
</li>
<li><strong>Question Answering (问答)：</strong>
<ul>
<li>对应：[CLS] 问题 [SEP] 段落 [SEP]</li>
<li>例如：[CLS] 谁是美国第一位总统？ [SEP] 乔治·华盛顿是美国的第一位总统… [SEP]</li>
</ul>
</li>
<li><strong>Degenerate text-∅ pair in text classification or sequence tagging (文本分类或序列标注中的“退化”文本-空对)：</strong> 这句话的意思是，对于只涉及单句的任务，可以把“空”视为第二段文本。
<ul>
<li>对应：[CLS] 句子A [SEP] [SEP] (注意，这里Sentence B实际上是空的，只用了一个[SEP]标记)</li>
<li>例如（情感分析）：[CLS] 这部电影太棒了！ [SEP] (严格来说是[CLS] 这部电影太棒了！ [SEP] [SEP])</li>
<li>例如（命名实体识别）：[CLS] 张三在纽约工作 [SEP]</li>
</ul>
</li>
</ol>
</li>
</ul>
<br>
<p><strong>Inference</strong></p>
<p>BERT的输出一般为<strong>分类任务 (情感分析、语义蕴含)</strong>，**序列标注任务 (命名实体识别)**等</p>
<p>假设我们有一个输入序列：<code>&quot;The dog [MASK] at the cat.&quot;</code><br>
BERT的目标是预测 <code>[MASK]</code> 位置应该填入什么词。</p>
<p><strong>步骤分解：</strong></p>
<ol>
<li>
<p><strong>输入预处理与嵌入：</strong></p>
<ul>
<li>输入序列被标记化为：<code>[&quot;The&quot;, &quot;dog&quot;, &quot;[MASK]&quot;, &quot;at&quot;, &quot;the&quot;, &quot;cat&quot;, &quot;[SEP]&quot;]</code> (通常还会加上 <code>[CLS]</code> 在开头，这里为了简化关注点暂不提)。</li>
<li>每个token（包括 <code>[MASK]</code> token本身）被转换为其对应的词嵌入和位置编码，并相加。</li>
<li>得到一个输入张量，维度为 <code>(1, L, D)</code> (batch_size=1, L=7, D=隐藏层维度，例如768)。</li>
</ul>
</li>
<li>
<p><strong>通过Transformer Encoder层：</strong></p>
<ul>
<li>这个 <code>(1, L, D)</code> 的张量会通过BERT的多个Transformer Encoder层（例如BERT-base有12层，BERT-large有24层）。</li>
<li><strong>关键点在于：</strong> BERT的Encoder层中的自注意力是<strong>双向的</strong>。这意味着当模型处理 <code>[MASK]</code> token时，它<strong>可以同时关注到 <code>[MASK]</code> 前后的所有词</strong>（“The”, “dog”, “at”, “the”, “cat”, “[SEP]”）。</li>
<li>每一层都会对token的表示进行细化和更新，融入更深层次的上下文信息。</li>
</ul>
</li>
<li>
<p><strong>获取 <code>[MASK]</code> token 的最终隐藏状态：</strong></p>
<ul>
<li>经过所有Encoder层后，我们得到一个最终的隐藏状态张量，维度仍然是 <code>(1, L, D)</code>。</li>
<li>我们现在需要从这个张量中，<strong>提取对应 <code>[MASK]</code> token 位置的隐藏状态</strong>。</li>
<li>假设 <code>[MASK]</code> token 在序列中的索引是2。那么我们取出 <code>output_tensor[0, 2, :]</code>，这将得到一个维度为 <code>(D,)</code> 的向量（例如 <code>(768,)</code>）。</li>
<li>这个向量是 <code>[MASK]</code> token 在**充分利用了整个序列（包括其上下文）**信息后所形成的上下文感知表示。</li>
</ul>
</li>
<li>
<p><strong>语言模型头（MLM Head / Decoder Head）：</strong></p>
<ul>
<li>这个 <code>(D,)</code> 向量被送入一个专门用于预测被遮盖词的“语言模型头”。这个头通常包含：
<ul>
<li><strong>一个线性层：</strong> 将 <code>(D,)</code> 向量投影到一个中间维度，例如 <code>(D,) -&gt; (D,)</code>。这层通常是一个非线性激活函数（如 GELU）和一个 Layer Normalization。</li>
<li><strong>另一个线性层：</strong> 将中间维度投影到词汇表大小的维度：<code>(D,) -&gt; (V,)</code>。这个输出就是<strong>逻辑值（logits）</strong>。</li>
</ul>
</li>
<li>这个线性层的权重矩阵维度是 <code>(D, V)</code>。</li>
</ul>
</li>
<li>
<p><strong>Softmax 与预测：</strong></p>
<ul>
<li>对 <code>(V,)</code> 维度的 logits 应用 Softmax 激活函数。这将得到一个概率分布，表示词汇表中每个词是 <code>[MASK]</code> token 的概率。</li>
<li><code>P(word | context) = softmax(logits)</code></li>
<li>模型会选择概率最高的词作为预测结果。</li>
</ul>
</li>
</ol>
<p><strong>举例说明：</strong></p>
<p>输入：<code>&quot;The dog [MASK] at the cat.&quot;</code></p>
<ol>
<li>
<p><strong>输入和嵌入：</strong><br>
<code>[CLS] The dog [MASK] at the cat [SEP]</code><br>
假设 <code>[MASK]</code> 的索引是 3。<br>
<code>E_CLS</code>, <code>E_The</code>, <code>E_dog</code>, <code>E_MASK</code>, <code>E_at</code>, <code>E_the</code>, <code>E_cat</code>, <code>E_SEP</code> (初始嵌入)</p>
</li>
<li>
<p><strong>通过12层BERT Encoder：</strong><br>
每个 token 的表示都会通过多层 Transformer Layer 进行更新。<br>
例如，在第一层，<code>E_MASK</code> 就可以通过双向注意力看到 <code>E_The</code>, <code>E_dog</code>, <code>E_at</code>, <code>E_the</code>, <code>E_cat</code> 等所有其他词的信息。<br>
经过所有层后，我们得到最终的隐藏状态 <code>H</code>：<br>
<code>H = [h_CLS, h_The, h_dog, h_MASK, h_at, h_the, h_cat, h_SEP]</code><br>
其中 <code>h_MASK</code> 此时是一个非常丰富的向量，它已经吸收了 <code>The dog</code> 和 <code>at the cat</code> 的所有上下文信息。</p>
</li>
<li>
<p><strong>提取 <code>h_MASK</code>：</strong><br>
我们取出 <code>h_MASK</code>，其维度是 <code>(D,)</code> (例如 768)。</p>
</li>
<li>
<p><strong>语言模型头：</strong><br>
<code>h_MASK</code> 经过一个 <code>(D, D)</code> 的线性层和一个 <code>(D, V)</code> 的线性层。<br>
<code>logits = h_MASK @ W_linear</code> (这里的 <code>W_linear</code> 是两个线性层的组合权重，或者分步计算)<br>
<code>logits</code> 的维度是 <code>(V,)</code> (例如 50257)。</p>
</li>
<li>
<p><strong>Softmax 预测：</strong><br>
<code>softmax(logits)</code> 得到一个概率分布。<br>
在这个概率分布中，<code>barked</code>、<code>looked</code>、<code>ran</code> 等词的概率会很高，而 <code>car</code>、<code>apple</code> 等词的概率会很低。<br>
模型最终选择概率最高的词，例如 <code>barked</code>。</p>
</li>
</ol>
<p><strong>为什么与GPT不同？</strong></p>
<ul>
<li><strong>BERT的 <code>[MASK]</code> 位置：</strong> BERT能够直接在 <code>[MASK]</code> 位置进行预测，因为它的注意力是双向的。当它计算 <code>[MASK]</code> 的表示时，它能看到整个句子的上下文，包括 <code>[MASK]</code> 之后的词。这意味着它能从两边推断出 <code>[MASK]</code> 应该是什么。</li>
<li><strong>GPT的下一个词预测：</strong> GPT的注意力是单向的。如果它要预测 <code>[MASK]</code>，它必须假装 <code>[MASK]</code> 是序列的最后一个词，并且不能看到 <code>[MASK]</code> 之后的任何词。这使得它在训练时无法像BERT那样充分利用左右上下文来理解一个词的含义。GPT擅长的是给定前缀，自回归地续写。</li>
</ul>
<p>因此，BERT的MLM任务和双向注意力使其能够有效地预测被遮盖的词，这是它在理解句子内部关系方面表现出色的关键。</p>
<br>
<h3 id="文本">文本</h3>
<h4 id="GPT2">GPT2</h4>
<p><a href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf">https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf</a></p>
<blockquote>
<p>卖点：更大的数据集，更大的模型，zero shot(一次训练，四处使用</p>
</blockquote>
<p>对比GPT pretrain + fine-tuning</p>
<ul>
<li>
<p>需要针对下游任务进行微调</p>
</li>
<li>
<p>微调训练集需要人工引入新符号</p>
</li>
</ul>
<br>
<h4 id="GPT3">GPT3</h4>
<p><a href="https://arxiv.org/abs/2005.14165">https://arxiv.org/abs/2005.14165</a></p>
<blockquote>
<p>卖点：无需微调数据集 + 克服微调泛化性问题 + 可迁移</p>
</blockquote>
<p>GPT3在推理时不更新梯度，通过prompt实现one-shot 或 few-shot</p>
<br>
<h4 id="InstructGPT">InstructGPT</h4>
<p>Training a Helpful and Harmless Assistant with Reinforcement Learning from Human Feedback&quot; (InstructGPT, 2022)</p>
<p><a href="https://arxiv.org/abs/2204.05862">https://arxiv.org/abs/2204.05862</a></p>
<br>
<h4 id="LLaMa-1">LLaMa-1</h4>
<p>LLaMA: Open and Efficient Foundation Language Models</p>
<p><a href="https://arxiv.org/abs/2302.13971">https://arxiv.org/abs/2302.13971</a></p>
<br>
<h4 id="LLaMA-2">LLaMA-2</h4>
<p>Llama 2: Open Foundation and Fine-Tuned Chat Models</p>
<p><a href="https://arxiv.org/abs/2307.09288">https://arxiv.org/abs/2307.09288</a></p>
<br>
<h4 id="DeepSeek-V1">DeepSeek-V1</h4>
<p><a href="https://arxiv.org/abs/2401.02954">https://arxiv.org/abs/2401.02954</a></p>
<br>
<h4 id="DeepSeek-V2">DeepSeek-V2</h4>
<p><a href="https://arxiv.org/abs/2405.04434">https://arxiv.org/abs/2405.04434</a></p>
<br>
<h4 id="DeepSeek-V3">DeepSeek-V3</h4>
<p><a href="https://arxiv.org/abs/2412.19437">https://arxiv.org/abs/2412.19437</a></p>
<br>
<h4 id="DeepSeek-R1-Zero-DeepSeek-R1">DeepSeek-R1-Zero&amp;DeepSeek-R1</h4>
<p><a href="https://arxiv.org/abs/2501.12948">https://arxiv.org/abs/2501.12948</a></p>
<br>
<h4 id="Qwen3">Qwen3</h4>
<p><a href="https://github.com/QwenLM/Qwen3/blob/main/Qwen3_Technical_Report.pdf">https://github.com/QwenLM/Qwen3/blob/main/Qwen3_Technical_Report.pdf</a></p>
<p>使用技术：GQA SwiGLU RoPE RMSNorm QK-Norm BBPE embedding</p>
<p><strong>概述</strong></p>
<p>训练数据通过多模型获取</p>
<ul>
<li>Qwen2.5-VL 提取PDF文件内容</li>
<li>Qwen2.5-Math 生成数学内容</li>
<li>Qwen2.5-Coder 生成代码内容</li>
</ul>
<p>三阶段 pre-training</p>
<ul>
<li>通用知识 train on 30 trillion tokens</li>
<li>STEM&amp;coding 知识</li>
<li>长上下文数据</li>
</ul>
<p>多阶段 post-training: fisrt two stages</p>
<ul>
<li>CoT cold-start finetuning</li>
<li>RL on math&amp;coding</li>
</ul>
<p>多阶段 post-training: final two stages</p>
<ul>
<li>混合 reasoning path data finetuning</li>
<li>general-domain RL</li>
</ul>
<br>
<p><strong>架构</strong></p>
<p><strong>embedding</strong></p>
<p><strong>layer</strong></p>
<p>begin</p>
<ul>
<li>
<p>输入 -&gt; RMSNorm</p>
</li>
<li>
<p>transformer</p>
<ul>
<li>GQA 头 &amp; 移除QKV-bias</li>
<li>对 Q，K 进行RMSNorm</li>
<li>RoPE 添加于norm后 Q，K</li>
<li>注意力计算</li>
</ul>
</li>
<li>
<p>残差</p>
</li>
</ul>
<p>end</p>
<p>begin</p>
<ul>
<li>输入 -&gt; RMSNorm</li>
<li>MLP</li>
<li>残差</li>
</ul>
<p>end</p>
<br>
<p><strong>MoE</strong></p>
<ul>
<li>sparse MoE，没有shared MoE</li>
<li>load balancing loss 专家被选的越多惩罚项越大</li>
</ul>
<br>
<p><strong>pretrain</strong></p>
<br>
<h3 id="CV">CV</h3>
<h4 id="Stable-Diffusion">Stable Diffusion</h4>
<p>2112.10752 High-Resolution Image Synthesis with Latent Diffusion Models (<a href="http://arxiv.org">arxiv.org</a>)</p>
<br>
<h4 id="ViT">ViT</h4>
<p><strong>An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale(ViT)</strong></p>
<p><a href="https://arxiv.org/abs/2010.11929">https://arxiv.org/abs/2010.11929</a></p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250530145000198.png" class="" title="image-20250530145000198">
<p><strong>核心思想：</strong> ViT将图像视为一系列的图像块（patches），然后将这些图像块的线性嵌入加上位置编码，送入标准的Transformer Encoder。</p>
<br>
<p><strong>ViT 在预训练阶段（或作为特征提取器）的输出</strong></p>
<p>在图像分类任务中，ViT通常会模仿BERT，引入一个特殊的**<code>[CLS]</code> token**（分类标记）。</p>
<ul>
<li>
<p><strong>输入处理：</strong></p>
<ol>
<li>图像被分割成固定大小的图像块（e.g., 16x16 像素）。</li>
<li>每个图像块被线性投影（embedding）成一个向量。</li>
<li>一个可学习的 <code>[CLS]</code> token 嵌入（与图像块嵌入维度相同）被添加到序列的<strong>开头</strong>。</li>
<li>位置编码被添加到这些嵌入中，以保留空间信息。</li>
<li>所有这些嵌入（<code>[CLS]</code> token嵌入 + 图像块嵌入 + 位置编码）形成一个序列，作为Transformer Encoder的输入。</li>
</ol>
</li>
<li>
<p><strong>Transformer Encoder 处理：</strong></p>
<ul>
<li>这个序列（例如 <code>[CLS]</code> + 256个图像块，如果图像是 224x224 且块大小是 16x16）会通过多个标准的Transformer Encoder层。</li>
<li><strong>关键点：</strong> Transformer Encoder中的自注意力是<strong>双向的</strong>。这意味着 <code>[CLS]</code> token可以关注到所有图像块的信息，反之亦然，所有图像块也可以关注到彼此以及 <code>[CLS]</code> token。</li>
<li>经过所有Encoder层后，每个token（包括 <code>[CLS]</code> token和所有图像块）都会得到一个上下文感知的最终隐藏向量。</li>
</ul>
</li>
<li>
<p><strong>ViT 最终输出的张量维度 (作为特征提取器)：</strong></p>
<ol>
<li>
<p><strong><code>[CLS]</code> token 的最终隐藏向量：</strong></p>
<ul>
<li>这个是<strong>最常被用来表示整个图像信息</strong>的输出。</li>
<li>维度：<code>(batch_size, d_model)</code></li>
<li>例如：如果 <code>batch_size = 3</code>，<code>d_model = 768</code> (ViT-Base)，那么输出是 <code>(3, 768)</code>。</li>
<li>这个向量包含了整个图像的全局特征，因为它通过双向注意力整合了所有图像块的信息。</li>
</ul>
</li>
<li>
<p><strong>所有 token 的最终隐藏向量序列：</strong></p>
<ul>
<li>如果你需要每个图像块的细粒度特征，或者用于其他下游任务（如目标检测、语义分割，但通常需要额外的解码器），你可以使用所有token的输出。</li>
<li>维度：<code>(batch_size, num_tokens, d_model)</code></li>
<li><code>num_tokens</code> = <code>1</code> (for <code>[CLS]</code>) + <code>num_patches</code>。</li>
<li>例如：如果 <code>batch_size = 3</code>，<code>num_patches = 256</code>，<code>d_model = 768</code>，那么输出是 <code>(3, 257, 768)</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<br>
<p><strong>ViT 用于图像分类任务时的最终输出</strong></p>
<p>当ViT被用于图像分类任务时，它会在上述 <code>[CLS]</code> token 的输出之上，添加一个分类头。</p>
<ul>
<li>
<p><strong>分类头：</strong></p>
<ul>
<li>通常是一个简单的<strong>线性层（Linear Layer）</strong>，它接收 <code>[CLS]</code> token 的最终隐藏向量 <code>(batch_size, d_model)</code> 作为输入。</li>
<li>线性层将这个向量投影到**类别数量（num_classes）**的维度。</li>
<li>线性层的权重矩阵维度是 <code>(d_model, num_classes)</code>。</li>
<li>进行矩阵乘法：<code>(batch_size, d_model) @ (d_model, num_classes) = (batch_size, num_classes)</code>。</li>
</ul>
</li>
<li>
<p><strong>最终输出维度 (用于分类任务的 logits)：</strong></p>
<ul>
<li><code>(batch_size, num_classes)</code></li>
<li>这些是每个图像在所有类别上的<strong>逻辑值（logits）</strong>。</li>
<li>在推理时，通常会再对这些 logits 应用 Softmax 激活函数，以得到每个类别的概率分布。</li>
<li><code>P(class | image) = softmax(logits)</code></li>
<li>然后选择概率最高的类别作为最终的分类结果。</li>
</ul>
</li>
</ul>
<p><strong>举例说明 (ViT-Base 用于 ImageNet 分类)：</strong></p>
<ul>
<li><code>batch_size = 4</code></li>
<li><code>d_model = 768</code></li>
<li><code>num_classes = 1000</code> (ImageNet 的类别数)</li>
</ul>
<ol>
<li>
<p><strong>ViT Encoder 的输出 (特征提取):</strong></p>
<ul>
<li><code>[CLS]</code> token 的隐藏向量: <code>(4, 768)</code></li>
<li>所有 token 的隐藏向量: <code>(4, 257, 768)</code> (假设图像块数量是 256)</li>
</ul>
</li>
<li>
<p><strong>分类任务的最终输出 (logits):</strong></p>
<ul>
<li><code>(4, 1000)</code></li>
</ul>
</li>
</ol>
<p>ViT的输出是其核心Transformer Encoder层处理后的<strong>上下文感知的特征表示</strong>。对于图像分类，最直接的输出通常是**<code>[CLS]</code> token对应的隐藏向量**，因为它被设计用来聚合整个图像的全局信息。这个 <code>[CLS]</code> token的向量随后会经过一个线性分类头，最终输出<strong>每个类别的logits</strong>，其维度为 <code>(batch_size, num_classes)</code>。</p>
<br>
<h3 id="图像-文本">图像-文本</h3>
<h4 id="UNITER">UNITER</h4>
<p><a href="https://arxiv.org/abs/1909.11740">https://arxiv.org/abs/1909.11740</a></p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250603133711303.png" class="" title="image-20250603133711303">
<p>four main tasks to pre-train our model:</p>
<ul>
<li>Masked Language Modeling conditioned on image regions (MLM),</li>
<li>Masked Region Modeling conditioned on input text (with three variants) (MRM),</li>
<li>Image-Text Matching (ITM),</li>
<li>Word-Region Alignment (WRA).</li>
</ul>
<p>方法：</p>
<ul>
<li>对于MLM和MRM，randomly mask some words or regions from the input and learn to recover the words or regions as the output of Transformer. Specifically, word masking is realized by replacing the token with a special token [MASK], and region masking is implemented by replacing the visual feature vector with all zeros. 仅mask单模态，自监督学习</li>
<li>对于ITM，sample both positive and negative imagesentence pairs and learn their matching scores. 模型输出 true or false判定图片文本是否匹配（监督学习）并计算交叉熵优化</li>
<li>对于WAR，通过训练模型旨在最小化 $\sum_{i,j} T_{ij}.c(w_i, v_j)$, where $c(w_i, v_j)$ 为衡量 $w_i$ 和 $v_j$ 相关性的成本函数（文中为cosine distance）
<ul>
<li><strong>Optimal Transport (OT) 和传输计划 T 本身不是 UNITER 模型的参数。</strong></li>
<li>最小化的$\sum_{i,j} T_{ij}.c(w_i, v_j)$为损失函数的一部分；当该值最小化时，当前模型中的 词向量 和 图向量的对齐程度最高</li>
</ul>
</li>
</ul>
<br>
<h4 id="ViLT">ViLT</h4>
<p><a href="http://proceedings.mlr.press/v139/kim21k/kim21k.pdf">http://proceedings.mlr.press/v139/kim21k/kim21k.pdf</a></p>
<p>参考：<a href="https://www.gnn.club/?p=2910">https://www.gnn.club/?p=2910</a></p>
<p>对比其他架构</p>
<img src="/2025/04/02/Paper-Reading-Record/20250410155409605.png" class="" title="img">
<p>文章架构</p>
<img src="/2025/04/02/Paper-Reading-Record/20250410214653107.png" class="" title="img">
<p>We train ViLT with two objectives commonly used to train VLP models: image text matching (ITM) and masked language modeling (MLM).</p>
<br>
<h4 id="ALBEF">ALBEF</h4>
<p><a href="https://arxiv.org/abs/2107.07651">https://arxiv.org/abs/2107.07651</a></p>
<p>参考：<a href="https://gnn.club/?p=2989">https://gnn.club/?p=2989</a></p>
<img src="/2025/04/02/Paper-Reading-Record/20250421211315671.png" class="" title="img">
<p><strong>训练</strong></p>
<ul>
<li>Image－Text Contrastive Loss，ITC</li>
<li>Image－Text Matching Loss，ITM</li>
<li>Masked Language Modeling Loss，MLM</li>
</ul>
<br>
<h3 id="MoE">MoE</h3>
<h4 id="A-survey-on-MoE">A survey on MoE</h4>
<p><a href="https://arxiv.org/pdf/2407.06204">https://arxiv.org/pdf/2407.06204</a></p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250613211803671.png" class="" title="image-20250613211803671">
<br>
<h4 id="Switch-Transformers">Switch Transformers</h4>
<p>Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity</p>
<p><a href="https://arxiv.org/abs/2101.03961">https://arxiv.org/abs/2101.03961</a></p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250604100042926.png" class="" title="image-20250604100042926">
<br>
<h4 id="MoE-in-DS-v3">MoE in DS-v3</h4>
<p><a href="https://arxiv.org/html/2412.19437v1">https://arxiv.org/html/2412.19437v1</a></p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250613211948220.png" class="" title="image-20250613211948220">
<blockquote>
<p>混合 sparse &amp; dense MoE</p>
</blockquote>
<br>
<h3 id="多模态">多模态</h3>
<h4 id="CLIP">CLIP</h4>
<p><a href="https://arxiv.org/abs/2103.00020">https://arxiv.org/abs/2103.00020</a></p>
<p>参考：<a href="https://gnn.club/?p=2921">https://gnn.club/?p=2921</a></p>
<p>仅预测哪段文本整体与哪张图像配对，而无需预测文本的具体词汇。</p>
<p>Given a batch of N (image, text) pairs, CLIP is trained to predict which of the N × N possible (image, text) pairings across a batch actually occurred.</p>
<p>To do this, CLIP learns a multi-modal embedding space by jointly training an image encoder and text encoder to maximize the cosine similarity of the image and text embeddings of the $N$ real pairs in the batch while minimizing the cosine similarity of the embeddings of the $N^2 − N$ incorrect pairings. We optimize a symmetric cross entropy loss over these similarity scores.</p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250601135610999.png" class="" title="image-20250601135610999">
<p>模型结构</p>
<p>We consider two different architectures for the image encoder. For the first, we use ResNet-50 (He et al., 2016a) as the base architecture for the image encoder due to its widespread adoption and proven performance. We make several modifications to the original version using the ResNetD improvements from He et al. (2019) and the antialiased rect-2 blur pooling from Zhang (2019). We also replace the global average pooling layer with an attention pooling mechanism. The attention pooling is implemented as a single layer of “transformer-style” multi-head QKV attention where the query is conditioned on the global average-pooled representation of the image. For the second architecture, we experiment with the recently introduced Vision Transformer (ViT) (Dosovitskiy et al., 2020). We closely follow their implementation with only the minor modification of adding an additional layer normalization to the combined patch and position embeddings before the transformer and use a slightly different initialization scheme.</p>
<p>The text encoder is a Transformer (Vaswani et al., 2017) with the architecture modifications described in Radford et al. (2019). As a base size we use a 63M-parameter 12- layer 512-wide model with 8 attention heads. The transformer operates on a lower-cased byte pair encoding (BPE) representation of the text with a 49,152 vocab size (Sennrich et al., 2015). For computational efficiency, the max sequence length was capped at 76. The text sequence is bracketed with [SOS] and [EOS] tokens and the activations of the highest layer of the transformer at the [EOS] token are treated as the feature representation of the text which is layer normalized and then linearly projected into the multi-modal embedding space. Masked self-attention was used in the text encoder to preserve the ability to initialize with a pre-trained language model or add language modeling as an auxiliary objective, though exploration of this is left as future work.</p>
<br>
<h4 id="Flamingo">Flamingo</h4>
<p>Flamingo: a Visual Language Model for Few-Shot Learning</p>
<p><a href="https://arxiv.org/abs/2204.14198">https://arxiv.org/abs/2204.14198</a></p>
<img src="/2025/04/02/Paper-Reading-Record/image-20250605114032032.png" class="" title="image-20250605114032032">
<img src="/2025/04/02/Paper-Reading-Record/image-20250605114141206.png" class="" title="image-20250605114141206">
<br>
<h4 id="BLIP-2">BLIP-2</h4>
<p>BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models</p>
<p><a href="https://arxiv.org/abs/2301.12597">https://arxiv.org/abs/2301.12597</a></p>
<br>
<h2 id="参考">参考</h2>
<br>]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM&amp;Rela</title>
    <url>/2025/03/19/LLM-Rela/</url>
    <content><![CDATA[<p>LLM相关</p>
<p>施工中…</p>
<span id="more"></span>
<h1>LLM&amp;Rela</h1>
<h2 id="LLM-base">LLM-base</h2>
<h3 id="期望与方差">期望与方差</h3>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>性质</strong></th>
<th style="text-align:center"><strong>期望 E[⋅]</strong></th>
<th style="text-align:center"><strong>方差 Var(⋅)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>线性变换</strong></td>
<td style="text-align:center">$E[aX+b]=aE[X]+b$</td>
<td style="text-align:center">$Var(aX+b)=a^2Var(X)$</td>
</tr>
<tr>
<td style="text-align:center"><strong>独立性影响</strong></td>
<td style="text-align:center">$E[XY]=E[X]E[Y]$（若独立）</td>
<td style="text-align:center">$Var(X+Y)=Var(X)+Var(Y)$（若独立）</td>
</tr>
<tr>
<td style="text-align:center"><strong>与矩的关系</strong></td>
<td style="text-align:center">一阶原点矩</td>
<td style="text-align:center">二阶中心矩</td>
</tr>
</tbody>
</table>
<br>
<h3 id="协方差">协方差</h3>
<p>$$Cov(X, Y) = E[XY] - E[X]E[Y]$$</p>
<p>X, Y相互独立 -&gt; $Cov(X, Y) = 0$</p>
<p>协方差为零仅排除线性关系，而独立性排除所有形式的依赖，在联合正态分布中，两者等价，这是特例而非普遍规律。</p>
<blockquote>
<p>没有线性关系意味着 不能通过线性方程 （如 $Y = aX + b$）来描述变量间的关系，但是它们可能存在非线性关系（如 $Y = aX^2 + bX + c$ 或 $Y = sin(X)$）</p>
<p><strong>独立性</strong> 意味着两个随机变量 $X$ 和 $Y$ 的联合分布完全由它们的边缘分布决定，即 $P(X,Y)=P(X)P(Y)$，且<strong>无法通过用任何有统计意义的任何函数（无论是线性还是非线性）从其中一个变量预测另一个变量</strong>。</p>
</blockquote>
<br>
<h3 id="激活函数">激活函数</h3>
<p>激活函数在神经网络的每一层中引入非线性，使得神经网络能够拟合复杂的非线性模式。常见的激活函数有 Sigmoid、ReLU（Rectified Linear Unit）、Tanh、Leaky ReLU 等</p>
<p><strong>Sigmoid 函数</strong></p>
<blockquote>
<p>sigmoid 乙型形状 $(-\infty, 0) \to (0,\frac{1}{2})$ &amp; $(0, +\infty) \to (\frac{1}{2}, 1)$</p>
</blockquote>
<p><strong>公式：</strong></p>
<p>$\sigma(x) = \frac{1}{1 + e^{-x}}$</p>
<p><strong>特点：</strong></p>
<ul>
<li>输出范围在 (0, 1) 之间</li>
<li>常用于二分类问题的输出层</li>
<li>缺点：在极端值处梯度很小，容易导致梯度消失</li>
</ul>
<br>
<p><strong>Tanh（双曲正切）函数</strong></p>
<p><strong>公式：</strong></p>
<p>$\tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}$</p>
<p><strong>特点：</strong></p>
<ul>
<li>输出范围在 (-1, 1) 之间</li>
<li>相比 Sigmoid 更适合隐藏层，因为它的均值为 0</li>
<li>同样存在梯度消失问题（但稍弱于 Sigmoid）</li>
</ul>
<br>
<p><strong>ReLU（Rectified Linear Unit）函数</strong></p>
<p><strong>公式：</strong></p>
<p>$\text{ReLU}(x) = \max(0, x)$</p>
<p><strong>特点：</strong></p>
<ul>
<li>简单、高效，收敛速度快</li>
<li>输出范围：[0, +∞)</li>
<li>缺点：负值部分梯度为 0，可能导致“神经元死亡”</li>
</ul>
<br>
<p><strong>Leaky ReLU 函数</strong></p>
<p><strong>公式：</strong></p>
<p>$\text{Leaky ReLU}(x) = \begin{cases} x &amp; \text{if } x \geq 0 \ \alpha x &amp; \text{if } x &lt; 0 \end{cases}$</p>
<p>其中，$\alpha$ 是一个很小的正数（如 0.01）</p>
<p><strong>特点：</strong></p>
<ul>
<li>改进了 ReLU 的“死亡神经元”问题</li>
<li>允许负方向有微小的梯度，避免完全失活</li>
</ul>
<br>
<h3 id="损失函数">损失函数</h3>
<p><strong>均方误差（Mean Squared Error, MSE）</strong></p>
<p><strong>公式：</strong></p>
<p>$\text{MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2$</p>
<ul>
<li>$y_i$：真实值</li>
<li>$\hat{y}_i$：预测值</li>
<li>$n$：样本数</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>回归问题（如房价预测）</li>
<li>对异常值敏感，平方项放大误差</li>
</ul>
<br>
<p><strong>平均绝对误差（Mean Absolute Error, MAE）</strong></p>
<p><strong>公式：</strong></p>
<p>$\text{MAE} = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{y}_i|$</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>回归问题</li>
<li>更鲁棒，不像 MSE 那样对异常值敏感</li>
</ul>
<br>
<p><strong>Huber Loss（平滑的 MSE 和 MAE 的结合）</strong></p>
<p><strong>公式：</strong></p>
<p>$L_\delta(a) = \begin{cases} \frac{1}{2} a^2 &amp; \text{if } |a| \leq \delta \ \delta (|a| - \frac{1}{2} \delta) &amp; \text{otherwise} \end{cases}$</p>
<p>其中 $a = y - \hat{y}$</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>回归问题</li>
<li>同时兼顾 MAE 的鲁棒性和 MSE 的可导性</li>
</ul>
<br>
<p><strong>交叉熵损失（Cross-Entropy Loss）</strong></p>
<p>▶ 二分类交叉熵（Binary Cross-Entropy）：</p>
<p><strong>公式：</strong></p>
<p>$\text{Loss} = - \left[ y \log(\hat{y}) + (1 - y) \log(1 - \hat{y}) \right]$</p>
<ul>
<li>$y \in {0, 1}$ 为真实标签</li>
<li>$\hat{y}$ 是预测概率</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>二分类问题（如猫 vs 狗）</li>
</ul>
<blockquote>
<p>预测值在log内</p>
<p>有负号</p>
</blockquote>
<br>
<p>▶ 多分类交叉熵（Categorical Cross-Entropy）：</p>
<p><strong>公式（softmax 输出）：</strong></p>
<p>$\text{Loss} = - \sum_{i=1}^{C} y_i \log(\hat{y}_i)$</p>
<ul>
<li>$C$ 是类别总数</li>
<li>$y_i$ 是 one-hot 编码的真实标签</li>
<li>$\hat{y}_i$ 是第 ii 类的预测概率</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>多分类问题（如数字识别）</li>
</ul>
<br>
<p><strong>KL 散度（Kullback–Leibler Divergence）</strong></p>
<p><strong>公式：</strong></p>
<p>$D_{KL}(P \parallel Q) = \sum_{i} P(i) \log\left(\frac{P(i)}{Q(i)}\right)$</p>
<ul>
<li>$P$：真实分布</li>
<li>$Q$：预测分布</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>分布之间的距离度量（如在生成模型中）</li>
</ul>
<blockquote>
<p>交叉熵 = KL散度 + 熵</p>
</blockquote>
<br>
<h3 id="优化算法">优化算法</h3>
<h4 id="梯度下降">梯度下降</h4>
<p>Gradient Descent</p>
<p><strong>公式：</strong></p>
<p>$\theta := \theta - \eta \cdot \nabla_\theta J(\theta)$</p>
<ul>
<li>$\theta$：模型参数</li>
<li>$\eta$：学习率（learning rate）</li>
<li>$\nabla_\theta J(\theta)$：损失函数 $J$ 关于参数 $\theta$ 的梯度</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>每次用<strong>全部数据</strong>计算梯度，更新参数</li>
<li>精度高但计算开销大，适合小数据集</li>
</ul>
<br>
<h4 id="随机梯度下降">随机梯度下降</h4>
<p>Stochastic Gradient Descent, SGD</p>
<p><strong>公式：</strong></p>
<p>$\theta := \theta - \eta \cdot \nabla_\theta J(\theta; x^{(i)}, y^{(i)})$</p>
<ul>
<li>每次仅用<strong>一个样本</strong> $(x(i),y(i))(x^{(i)}, y^{(i)})$ 更新一次参数</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>计算效率高、更新频繁</li>
<li>噪声大，有时不稳定，但有助于跳出局部最优</li>
</ul>
<br>
<h4 id="小批量梯度下降">小批量梯度下降</h4>
<p>Adaptive Moment Estimation</p>
<p><strong>公式：</strong></p>
<p>$\theta := \theta - \eta \cdot \frac{1}{m} \sum_{i=1}^{m} \nabla_\theta J(\theta; x^{(i)}, y^{(i)})$</p>
<ul>
<li>每次用一小批（mini-batch）样本来计算梯度</li>
<li>折中效率与稳定性，是深度学习中<strong>最常用的方式</strong></li>
</ul>
<br>
<h4 id="Adam">Adam</h4>
<p>ref: <a href="https://distill.pub/2017/momentum/">https://distill.pub/2017/momentum/</a></p>
<img src="/2025/03/19/LLM-Rela/image-20250830142432793.png" class="" title="image-20250830142432793">
<p>Adaptive Moment Estimation</p>
<p>Adam = <strong>Momentum（动量）</strong> + <strong>RMSProp（自适应学习率）</strong> + <strong>偏差修正</strong></p>
<br>
<p><strong>动量法（Momentum）来源</strong></p>
<p>先看普通的梯度下降更新：</p>
<p>$\theta := \theta - \eta \cdot \nabla_\theta J(\theta)$</p>
<p>但这个更新方向容易“来回震荡”，所以引入动量的思想，让参数更新像“带惯性的小球”那样滑下去：</p>
<p>动量法公式：</p>
<p>$v_t = \beta_1 v_{t-1} + (1 - \beta_1) \nabla_\theta J(\theta)$</p>
<p>$\theta := \theta - \eta \cdot v_t$</p>
<p>这个动量 $v_t$ 相当于对梯度的指数加权平均。</p>
<p>Adam 的第一部分：</p>
<p>$m_t = \beta_1 m_{t-1} + (1 - \beta_1) \cdot g_t$</p>
<p>就是来自这个思路，$m_t$ ≈ 平滑梯度（momentum）</p>
<br>
<p><strong>RMSProp 来源：自适应学习率</strong></p>
<p>RMSProp 想解决的问题是：<strong>不同参数的梯度尺度不同时，用相同学习率不合适</strong>。</p>
<p>所以它引入一个“平方梯度的指数平均”：</p>
<p>$s_t = \beta_2 s_{t-1} + (1 - \beta_2) g_t^2$</p>
<p>$\theta := \theta - \frac{\eta}{\sqrt{s_t} + \epsilon} \cdot g_t$</p>
<p>Adam 的第二部分：</p>
<p>$v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2$</p>
<p>就是借鉴了 RMSProp，让学习率根据梯度历史自适应调整。</p>
<br>
<p><strong>偏差修正的来由</strong></p>
<p>Adam 一开始 m_1, v_1 都是从 0 开始的，但因为是指数加权平均，会导致初始几步偏小，<strong>“有偏估计”</strong>。</p>
<p>所以做了修正：</p>
<p>$\hat{m}_t = \frac{m_t}{1 - \beta_1^t}, \quad \hat{v}_t = \frac{v_t}{1 - \beta_2^t}$</p>
<p>这个公式来源于“期望的无偏估计推导”，用数学方法校正初期偏小的问题。</p>
<blockquote>
<p>Q：为什么要做偏差修正？</p>
<p>A：因为初始时刻 $m_t$、$v_t$ 都从 0 开始，用指数加权会造成“低估”真实值（特别在前几步）。</p>
<p>所以 Adam 中引入了：</p>
<p>$\hat{m}_t = \frac{m_t}{1 - \beta_1^t}, \quad \hat{v}_t = \frac{v_t}{1 - \beta_2^t}$</p>
<p>下面<strong>推导</strong>这个修正项是怎么来的。</p>
<p>推导一阶动量偏差修正项（以 $m_t$ 为例）</p>
<p>我们从递推公式出发（假设 $m_0$ = 0）：</p>
<p>$m_1 = (1 - \beta_1) g_1  $</p>
<p>$m_2 = \beta_1 m_1 + (1 - \beta_1) g_2 = \beta_1 (1 - \beta_1) g_1 + (1 - \beta_1) g_2$</p>
<p>$m_3 = \beta_1^2 (1 - \beta_1) g_1 + \beta_1 (1 - \beta_1) g_2 + (1 - \beta_1) g_3$</p>
<p>可推广为：</p>
<p>$m_t = (1 - \beta_1) \sum_{i=1}^{t} \beta_1^{t-i} g_i$</p>
<p>期望分析：$m_t$ 是一个<strong>有偏估计</strong></p>
<p>我们希望的是：</p>
<p>$\mathbb{E}[m_t] = \mathbb{E}[g_t]$</p>
<p>但是上面推导的形式中：</p>
<p>$\mathbb{E}[m_t] = (1 - \beta_1) \sum_{i=1}^{t} \beta_1^{t-i} \mathbb{E}[g_i]$</p>
<p>如果我们假设：</p>
<ul>
<li>
<p>梯度是平稳的（即各时刻期望相同）：</p>
<p>$\mathbb{E}[g_1] = \mathbb{E}[g_2] = \dots = \mathbb{E}[g_t] = \mu$</p>
</li>
</ul>
<p>那么就有：</p>
<p>$\mathbb{E}[m_t] = (1 - \beta_1) \cdot \mu \sum_{i=1}^{t} \beta_1^{t - i} = \mu \cdot (1 - \beta_1) \cdot \sum_{k=0}^{t-1} \beta_1^k$</p>
<p>这是一个等比数列，求和后得到：</p>
<p>$\mathbb{E}[m_t] = \mu \cdot (1 - \beta_1) \cdot \frac{1 - \beta_1^t}{1 - \beta_1} = \mu \cdot (1 - \beta_1^t)$</p>
<p>所以：</p>
<p>$\boxed{\mathbb{E}[m_t] = \mu \cdot (1 - \beta_1^t)} \quad \text{有偏！}$</p>
<p>如何修正？</p>
<p>为了得到无偏估计，我们让：</p>
<p>$\hat{m}_t = \frac{m_t}{1 - \beta_1^t}$</p>
<p>那么：</p>
<p>$\mathbb{E}[\hat{m}_t] = \frac{\mathbb{E}[m_t]}{1 - \beta_1^t} = \mu$</p>
<p>成功修正偏差 🎉！</p>
<p>同理：</p>
<p>对于二阶动量 $v_t$，完全一样的推理过程也可以得到：</p>
<p>$\hat{v}_t = \frac{v_t}{1 - \beta_2^t}$</p>
</blockquote>
<br>
<p><strong>Adam公式：</strong></p>
<ol>
<li>
<p>一阶矩估计（类似动量）：</p>
<p>$m_t = \beta_1 m_{t-1} + (1 - \beta_1) \nabla_\theta J(\theta)$</p>
</li>
<li>
<p>二阶矩估计（平方梯度）：</p>
<p>$v_t = \beta_2 v_{t-1} + (1 - \beta_2)(\nabla_\theta J(\theta))^2$</p>
</li>
<li>
<p>偏差校正：</p>
<p>$\hat{m}_t = \frac{m_t}{1 - \beta_1^t}, \quad \hat{v}_t = \frac{v_t}{1 - \beta_2^t}$</p>
</li>
<li>
<p>参数更新：</p>
<p>$\theta := \theta - \eta \cdot \frac{\hat{m}_t}{\sqrt{\hat{v}_t} + \epsilon}$</p>
</li>
</ol>
<ul>
<li>通常 $\beta_1 = 0.9, \beta_2 = 0.999, \epsilon = 10^{-8}$</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>自适应调整每个参数的学习率</li>
<li>适用于大规模数据和参数模型，深度学习中的默认选择之一</li>
</ul>
<br>
<h3 id="梯度消失-爆炸">梯度消失&amp;爆炸</h3>
<p>梯度消失是指，损失函数对网络中某参数计算梯度，由于链式法则，计算链过长，得到的梯度计算结果接近0</p>
<p>可能出现：</p>
<ol>
<li>参数初始化存在问题，权重参数w_i过小导致梯度计算值接近0</li>
<li>参数/激活函数存在非线性运算，值被快速缩小导致梯度计算值接近0</li>
</ol>
<p>参数的更新依赖于梯度，当出现梯度消失时，参数无法得到更新</p>
<br>
<p><strong>解决梯度消失问题的方法：</strong></p>
<ol>
<li>使用恰当的激活函数：某些激活函数（如ReLU和Leaky ReLU）在反向传播过程中更不容易出现梯度消失问题，可以考虑使用它们替代Sigmoid和Tanh。</li>
<li>批量归一化（Batch Normalization）：批量归一化可以加速训练过程，还可以缓解梯度消失问题，使得网络更稳定和更易训练。</li>
<li>使用残差连接（Residual Connections）：残差连接可以跳过某些层，将输入直接与输出相加，有助于信息的传递和梯度的流动，减少梯度消失问题。</li>
<li>调整网络架构：适当调整网络的深度，避免设计过深的网络结构，也有助于减少梯度消失的影响。</li>
</ol>
<p><strong>解决梯度爆炸问题的方法：</strong></p>
<ol>
<li>梯度截断（Gradient Clipping）：设置一个梯度阈值，在反向传播过程中，如果梯度超过该阈值，则将其裁剪为阈值以内的数值，避免梯度爆炸。</li>
<li>使用恰当的权重初始化：合适的权重初始化可以减少梯度爆炸问题。例如，Xavier/Glorot初始化针对Sigmoid和Tanh激活函数的网络效果较好，而He初始化针对ReLU激活函数的网络效果较好。</li>
<li>减少学习率：较小的学习率可以缓解梯度爆炸的影响，但要注意不要将学习率设置得过小，以免影响收敛速度。</li>
<li>批量归一化（Batch Normalization）：同样，批量归一化在训练过程中有助于控制梯度的大小，减少梯度爆炸问题。</li>
</ol>
<br>
<h3 id="正则化-归一化">正则化&amp;归一化</h3>
<p><strong>正则化（Regularization）：</strong> 正则化是通过在损失函数中添加一个额外的项，来限制模型参数的大小，从而避免过拟合问题。常见的正则化项有L1正则化和L2正则化。</p>
<ul>
<li>L1正则化：在损失函数中添加模型参数的绝对值之和。L1正则化有助于稀疏模型，即将一些参数的值压缩为0，从而减少模型的复杂度。</li>
<li>L2正则化：在损失函数中添加模型参数的平方之和。L2正则化对参数的惩罚更加平滑，通常会让参数接近于0，但不会严格地等于0。</li>
</ul>
<p>正则化的目的是防止模型在训练集上过度拟合，使得模型能够更好地泛化到未见过的新数据上。</p>
<p>假设我们在线性回归中训练一个模型：</p>
<p>原始损失函数（MSE）：</p>
<p>$Loss = (y - ŷ )²$</p>
<p>加入 L2 正则化后：</p>
<p>$Loss = (y - ŷ )² + λ * ||w||²$</p>
<p>其中：</p>
<ul>
<li><code>||w||²</code> 表示所有权重的平方和</li>
<li><code>λ</code> 是正则化强度（超参数）</li>
</ul>
<p>➡️ <strong>作用：</strong> 如果某些权重太大，会被惩罚，从而让模型更简单、泛化能力更强。</p>
<br>
<p><strong>归一化（Normalization）：</strong> 归一化是将数据按比例缩放，使其值落在特定范围内。在深度学习中，常见的归一化方法是将输入特征缩放到0和1之间，或者使其均值为0，方差为1。</p>
<ul>
<li>最小-最大归一化（Normalization）：将数据缩放到指定的最小值和最大值之间，公式为：$(x - x_{min}) / (x_{max} - x_{min})$</li>
<li>均值-方差归一化（Standardization）：将数据缩放为均值为0，方差为1的分布，公式为：$(x - mean) / std$</li>
</ul>
<p>归一化的目的是将特征的值统一到相似的范围内，加速模型的训练过程，同时有助于梯度的传播和优化算法的收敛。</p>
<p>常见方法：</p>
<ul>
<li>
<p><strong>Min-Max 归一化：</strong> 把数据压缩到 [0,1] 区间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x&#x27; = (x - min) / (max - min)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Z-score 标准化（Standardization）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x&#x27; = (x - mean) / std</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<p><strong>两者的作用：</strong></p>
<ul>
<li>正则化用于防止过拟合，通过约束模型参数的大小，减少模型的复杂度，提高模型的泛化能力。</li>
<li>归一化用于将数据的特征缩放到统一的范围内，使得训练过程更稳定，加速优化算法的收敛，并且有助于避免梯度消失或梯度爆炸问题。</li>
</ul>
<p>在实际应用中，正则化和归一化通常是一起使用的，以提高深度学习模型的性能和训练效果。</p>
<br>
<h3 id="batch">batch</h3>
<p>在机器学习，特别是深度学习训练中，batch_size 为 1 做两次训练（假设数据集相同）和 batch_size 为 2 做一次训练<strong>不等价</strong>。</p>
<p>这里涉及到的主要区别在于：</p>
<ol>
<li><strong>梯度计算：</strong>
<ul>
<li><strong>Batch Size = 1 (两次训练)：</strong> 每次训练迭代时，模型会计算<strong>一个样本</strong>的损失，并基于这一个样本的损失来计算梯度。然后，优化器会使用这个梯度来更新模型的权重。这意味着梯度更新的方差会非常大，因为每次更新都只依赖于一个非常小的“样本”信息。</li>
<li><strong>Batch Size = 2 (一次训练)：</strong> 每次训练迭代时，模型会计算<strong>两个样本</strong>的损失，然后将这两个样本的梯度<strong>平均</strong>（或求和后归一化）起来，得到一个更稳定的梯度。优化器会使用这个平均梯度来更新模型的权重。</li>
</ul>
</li>
<li><strong>梯度更新的频率与方向：</strong>
<ul>
<li>batch_size = 1 做两次训练：会发生两次<strong>独立的</strong>权重更新。两次更新的方向可能差异很大，因为它们基于不同的单个样本。</li>
<li>batch_size = 2 做一次训练：会发生一次权重更新，这个更新的方向是两个样本的梯度<strong>综合平均</strong>的结果。</li>
</ul>
</li>
<li><strong>损失函数评估：</strong>
<ul>
<li>batch_size = 1 做两次训练：损失是在单个样本上评估的。</li>
<li>batch_size = 2 做一次训练：损失是在两个样本的平均或总和上评估的。</li>
</ul>
</li>
<li><strong>收敛性与稳定性：</strong>
<ul>
<li><strong>Batch Size = 1 (随机梯度下降SGD)：</strong> 梯度方差大，导致训练过程更不稳定，路径更“抖动”。虽然理论上SGD在非凸优化中也能找到局部最优解，但收敛速度可能较慢，并且在实践中更容易陷入次优解或在训练过程中出现震荡。这种极端情况下的SGD通常被称为<strong>在线学习（Online Learning）</strong>。</li>
<li><strong>Batch Size = 2 (小批量梯度下降Mini-Batch GD)：</strong> 通过对多个样本的梯度进行平均，可以减少梯度的方差，使梯度方向更稳定、更准确地指向损失函数的下降方向。这通常能带来更稳定的训练过程和更快的收敛速度。</li>
</ul>
</li>
</ol>
<br>
<h3 id="通道">通道</h3>
<img src="/2025/03/19/LLM-Rela/8361e16bac5ee3235ef89c78b1a1cf6b.png" class="" title="channel">
<p>多通道卷积过程</p>
<p>输入一张三通道的图片，有多个卷积核进行卷积，并且每个卷积核都有三通道，分别对这张输入图片的三通道进行卷积操作。每个卷积核，分别输出三个通道，这三个通道进行求和，得到一个featuremap，有多少个卷积核，就有多少个featuremap</p>
<br>
<h3 id="RNN-LSTM">RNN&amp;LSTM</h3>
<h4 id="RNN">RNN</h4>
<img src="/2025/03/19/LLM-Rela/e38fac064524158e493a66adb2caed6e.png" class="" title="RNN">
<br>
<h4 id="LSTM">LSTM</h4>
<p><strong>输出</strong></p>
<p>短期记忆 $h_t$，长期记忆 $c_t$，input $x_t$<br>
$$<br>
o_t = \sigma(W_o \cdot [h_{t-1}, x_t] + b_o)<br>
$$</p>
<p>$$<br>
h_t = o_t \odot \tanh(c_t)<br>
$$</p>
<p><strong>遗忘门(蓝色)</strong><br>
$$<br>
f_t = \sigma(W_f \cdot [h_{t-1}, x_t] + b_f)<br>
$$</p>
<p><strong>输入门和候选记忆</strong></p>
<ul>
<li>输入门控制当前输入信息 $x_t$ 的写入程度：</li>
</ul>
<p>$$<br>
i_t = \sigma(W_i \cdot [h_{t-1}, x_t] + b_i)<br>
$$</p>
<ul>
<li>候选记忆生成新的候选信息 $\tilde{c}_t$：</li>
</ul>
<p>$$<br>
\tilde{c}<em>t = \tanh(W_c \cdot [h</em>{t-1}, x_t] + b_c)<br>
$$</p>
<br>
<p><strong>短期记忆更新</strong></p>
<p>结合遗忘门和输入门的结果更新短期记忆 $c_t$：<br>
$$<br>
c_t = f_t \odot c_{t-1} + i_t \odot \tilde{c}_t<br>
$$</p>
<ul>
<li>$\odot$ 表示逐元素相乘。</li>
<li>第一项 $f_t \odot c_{t-1}$ 保留历史信息，第二项 $i_t \odot \tilde{c}_t$ 添加新信息。</li>
</ul>
<img src="/2025/03/19/LLM-Rela/image-20250402161828313.png" class="" title="image-20250402161828313">
<br>
<p><strong>LSTM Process</strong></p>
<img src="/2025/03/19/LLM-Rela/image-20250402162106999.png" class="" title="image-20250402162106999">
<br>
<h2 id="LLM-struc">LLM-struc</h2>
<p>大模型从模型架构上主要分为三种：Only-encoder, Only-Decoder, Encoder-Decoder三种模型架构</p>
<ul>
<li>Only-encoder：例如BERT，通过在大规模无标签文本上进行预训练，然后在下游任务上进行微调，具有强大的语言理解能力和表征能力。</li>
<li>Only-Decoder: 例如GPT，通过在大规模无标签文本上进行预训练，然后在特定任务上进行微调，具有很强的生成能力和语言理解能力。</li>
<li>Encoder-Decoder：例如T5（Text-to-Text Transfer Transformer）可以用于多种自然语言处理任务，如文本分类、机器翻译、问答等。</li>
</ul>
<img src="/2025/03/19/LLM-Rela/v2-ee9b5d4a0761d2d1d10acb37cebefba3_1440w.jpg" class="" title="img">
<br>
<h3 id="Encoder-Decoder">Encoder&amp;Decoder</h3>
<img src="/2025/03/19/LLM-Rela/image-20250706100412469.png" class="" title="image-20250706100412469">
<p>ref: <a href="https://arxiv.org/abs/1706.03762">Attention is All You Need</a></p>
<br>
<br>
<h3 id="Encoder-Only">Encoder Only</h3>
<img src="/2025/03/19/LLM-Rela/image-20250706105452257.png" class="" title="image-20250706105452257">
<p>ref: <a href="https://arxiv.org/abs/1810.04805">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a></p>
<h3 id="Decoder-Only">Decoder Only</h3>
<img src="/2025/03/19/LLM-Rela/LLM-structure.png" class="" title="structure">
<img src="/2025/03/19/LLM-Rela/LLM-structure-moe.png" class="" title="structure-moe">
<p>ref: <a href="https://github.com/jingyaogong/minimind">minimind</a></p>
<br>
<p>Comparsion</p>
<img src="/2025/03/19/LLM-Rela/1.webp" class="" title="img">
<p>ref: <a href="https://sebastianraschka.com/blog/2025/the-big-llm-architecture-comparison.html">https://sebastianraschka.com/blog/2025/the-big-llm-architecture-comparison.html</a></p>
<br>
<h3 id="Tokenizer">Tokenizer</h3>
<p>分词表</p>
<h4 id="BPE">BPE</h4>
<p>案例：BPE (Byte Pair Encoding)  ref: <a href="https://arxiv.org/pdf/2309.16609">QWEN TECHNICAL REPORT</a></p>
<p>假设我们有以下非常小的文本语料库：</p>
<p><code>&quot;low low low low low low low low low low&quot;</code><br>
<code>&quot;lower lower lower lower lower lower lower lower&quot;</code><br>
<code>&quot;newest newest newest newest&quot;</code><br>
<code>&quot;widest widest widest widest&quot;</code></p>
<p>并且我们希望通过 BPE 来构建一个词汇表。最初，我们的“词汇表”可能只包含所有的独立字符。</p>
<p><strong>初始状态：</strong></p>
<ul>
<li><strong>语料中的独立字符（初始token）：</strong> <code>l, o, w, e, r, n, s, t, i, d</code> (以及一个空格字符，我们这里为了简化暂时忽略它，但实际BPE会处理所有字节)</li>
<li><strong>当前词汇表：</strong> <code>[l, o, w, e, r, n, s, t, i, d]</code></li>
</ul>
<p><strong>BPE 步骤：</strong></p>
<p>BPE 的核心是<strong>迭代地寻找语料中出现频率最高的相邻“字节对”（或字符对）并将其合并成一个新的单元。</strong></p>
<p><strong>第一次迭代：</strong></p>
<ol>
<li>
<p><strong>统计字符对频率：</strong></p>
<ul>
<li><code>lo</code>: 出现很多次（来自 “low”, “lower”）</li>
<li><code>ow</code>: 出现很多次（来自 “low”, “lower”）</li>
<li><code>er</code>: 出现很多次（来自 “lower”）</li>
<li><code>ne</code>: 出现多次（来自 “newest”）</li>
<li><code>es</code>: 出现多次（来自 “newest”）</li>
<li><code>st</code>: 出现多次（来自 “newest”, “widest”）</li>
<li><code>wi</code>: 出现多次（来自 “widest”）</li>
<li><code>id</code>: 出现多次（来自 “widest”）</li>
<li><code>de</code>: 出现多次（来自 “widest”）</li>
</ul>
</li>
<li>
<p><strong>找到频率最高的对：</strong> 假设 <code>(l, o)</code> 和 <code>(o, w)</code> 的频率非常高（因为 “low” 和 “lower” 都包含它们）。<br>
我们选择 <code>(l, o)</code> 和 <code>(o, w)</code> 进行合并。为了简化，我们先合并 <code>(l, o)</code>。</p>
</li>
<li>
<p><strong>合并 <code>lo</code>：</strong> 将所有 <code>l o</code> 替换为新的 token <code>lo</code>。</p>
<ul>
<li><code>&quot;low low ...&quot;</code> 变成 <code>&quot;low low ...&quot;</code> (lo 依然是 lo，但现在是一个整体token)</li>
<li><code>&quot;lower lower ...&quot;</code> 变成 <code>&quot;lower lower ...&quot;</code></li>
<li><strong>新的词汇表：</strong> <code>[l, o, w, e, r, n, s, t, i, d, lo]</code></li>
</ul>
</li>
</ol>
<p><strong>第二次迭代：</strong></p>
<ol>
<li>
<p><strong>统计新的字符/token 对频率：</strong></p>
<ul>
<li>现在 <code>(lo, w)</code> 出现的频率很高（来自 “low”, “lower”）</li>
<li><code>(e, r)</code> 频率很高</li>
<li><code>(n, e)</code> 频率很高</li>
<li><code>(e, s)</code> 频率很高</li>
<li><code>(s, t)</code> 频率很高</li>
</ul>
</li>
<li>
<p><strong>找到频率最高的对：</strong> 假设 <code>(lo, w)</code> 是频率最高的对。</p>
</li>
<li>
<p><strong>合并 <code>low</code>：</strong> 将所有 <code>lo w</code> 替换为新的 token <code>low</code>。</p>
<ul>
<li><code>&quot;low low ...&quot;</code> 变成 <code>&quot;low low ...&quot;</code> (现在 <code>low</code> 是一个整体 token)</li>
<li><code>&quot;lower lower ...&quot;</code> 中的 <code>low</code> 也变成一个整体 token。</li>
<li><strong>新的词汇表：</strong> <code>[l, o, w, e, r, n, s, t, i, d, lo, low]</code></li>
</ul>
</li>
</ol>
<p><strong>第三次迭代：</strong></p>
<ol>
<li>
<p><strong>统计新的字符/token 对频率：</strong></p>
<ul>
<li><code>(low, er)</code> 出现频率很高（来自 “lower”）</li>
<li><code>(n, ew)</code> (如果 <code>ew</code> 被合并了)</li>
<li><code>(ne, st)</code></li>
<li><code>(wi, de)</code> (如果 <code>de</code> 被合并了)</li>
</ul>
</li>
<li>
<p><strong>找到频率最高的对：</strong> 假设 <code>(low, er)</code> 是频率最高的对。</p>
</li>
<li>
<p><strong>合并 <code>lower</code>：</strong> 将所有 <code>low er</code> 替换为新的 token <code>lower</code>。</p>
<ul>
<li><code>&quot;lower lower ...&quot;</code> 变成 <code>&quot;lower lower ...&quot;</code> (现在 <code>lower</code> 是一个整体 token)</li>
<li><strong>新的词汇表：</strong> <code>[l, o, w, e, r, n, s, t, i, d, lo, low, lower]</code></li>
</ul>
</li>
</ol>
<p><strong>继续迭代…</strong></p>
<p>这个过程会一直重复：</p>
<ul>
<li>统计当前所有 token 序列中<strong>相邻 token 对</strong>的频率。</li>
<li>选择频率最高的对。</li>
<li>将该对合并成一个新的、更长的 token。</li>
<li>将新 token 加入词汇表。</li>
<li>更新语料中的表示（将旧的对替换为新的 token）。</li>
</ul>
<br>
<h4 id="WordPiece">WordPiece</h4>
<p>（Google BERT 使用）</p>
<ul>
<li>思路和 BPE 类似，但不是贪心地选 <strong>频率最高的符号对</strong>，而是选择能最大化 <strong>训练数据似然</strong> 的合并。</li>
<li>偏向生成更能提高语言模型概率的子词。</li>
<li>例子：<code>unaffable</code> → <code>[un, ##aff, ##able]</code>。</li>
</ul>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unaffable</span><br><span class="line">unaffordable</span><br><span class="line">unable</span><br><span class="line">affable</span><br></pre></td></tr></table></figure>
<p>初始词表：所有<strong>字符</strong> <code>&#123;u,n,a,f,b,l,e,o,r,d&#125;</code>（以及特殊符号这里忽略）。</p>
<p>初始分词：全部按字符切分。</p>
<p>记号：语料被分成的所有 token 个数记为 <code>N</code>，每个 token 的出现次数为 <code>c(t)</code>。<br>
对于给定词表，极大似然下 token 概率是 <code>p(t)=c(t)/N</code>，训练目标是<strong>最大化对数似然</strong>：<br>
$$<br>
L = \sum_t c(t) · \log p(t) = \sum_t c(t) · \log(\frac{c(t)}{N})<br>
$$<br>
在本语料里，初始共有 <code>N = 34</code> 个字符 token（4 个词加起来的总字符数）。</p>
<p>与 BPE 一样，我们只在<strong>词内相邻</strong>位置取对（bigram）作为候选。但 WordPiece 不直接选“频数最高”的 pair，而是：</p>
<blockquote>
<p>对每个候选 AB，<strong>假设</strong>把 AB 作为一个新子词加入词表、并用“最长匹配”重新分词，计算新的对数似然 <code>L'</code>，取 <strong>ΔL = L’ - L</strong> 最大的那个。</p>
</blockquote>
<br>
<h4 id="SentencePiece">SentencePiece</h4>
<p>Google T5, ALBERT 使用</p>
<ul>
<li>直接把输入文本看作 <strong>不带空格的字符序列</strong>（空格也算符号）。</li>
<li>支持两种算法：
<ul>
<li><strong>BPE 模式</strong>（与经典 BPE 一致）。</li>
<li><strong>Unigram LM 模式</strong>（基于概率模型，从候选子词集中选择能最大化似然的子词集合）。</li>
</ul>
</li>
</ul>
<br>
<h4 id="词表">词表</h4>
<p>对应于项目中的 <code>tokenizer.json</code> 文件，它是一个至关重要的组件，其核心功能是将人类可读的文本转换为模型可理解的数字 ID 序列。可以将其理解为模型的“字典”或“编码器”。</p>
<p>具体来说，<code>tokenizer.json</code> 文件中包含了：</p>
<ol>
<li><strong>词表（Vocabulary）</strong>：这是最主要的部分，它列出了分词器识别的所有词元（tokens），每个词元都对应一个唯一的数字 ID。这些词元可以是单个字符、常用单词、词根、词缀甚至是不规则的子词单元（subword units），例如通过BPE（Byte Pair Encoding）或WordPiece等算法生成的。</li>
<li><strong>分词规则（Tokenization Rules）</strong>：除了词表本身，<code>tokenizer.json</code> 还定义了如何将原始文本拆分成这些词元序列的规则。这包括预处理步骤（如大小写转换、标点符号处理）、分词算法的配置以及如何处理未知词元（Out-Of-Vocabulary, OOV）等。</li>
</ol>
<p><strong>词表大小（Vocabulary Size）</strong> 指的是 <strong><code>tokenizer.json</code> 中定义的词元数量</strong>（即词表中词元ID的最大值加一），再加上 <strong>模型或分词器预设的特殊字符（Special Tokens）的数量</strong>。</p>
<p><strong>特殊字符</strong>通常包括：</p>
<ul>
<li><strong><code>[CLS]</code> (Classification Token)</strong>：在BERT等模型中用于表示句子的开头，其输出常用于分类任务。</li>
<li><strong><code>[SEP]</code> (Separation Token)</strong>：用于分隔不同的句子或文本片段。</li>
<li><strong><code>[PAD]</code> (Padding Token)</strong>：用于将不同长度的序列填充到相同的长度，以便于批处理。</li>
<li><strong><code>[UNK]</code> (Unknown Token)</strong>：当分词器遇到不在词表中的词元时，会用此标记替代。</li>
<li><strong><code>[MASK]</code> (Mask Token)</strong>：在预训练任务（如掩码语言模型）中用于替换被遮蔽的词元。</li>
</ul>
<p>因此，<strong>词表大小 = <code>tokenizer.json</code> 中唯一词元的数量 + 特殊字符的数量</strong>。这个大小直接决定了模型能够理解和表示的词元种类，也影响着模型的参数量和性能。</p>
<br>
<h3 id="Embedding">Embedding</h3>
<p>将 <strong>token ID 序列</strong> 转换为 <strong>连续的、稠密的向量表示</strong></p>
<p>例如，</p>
<ol>
<li>
<p><strong>原始文本:</strong> “The cat sat on the mat.”</p>
</li>
<li>
<p><strong>分词器 (Tokenizer):</strong></p>
<ul>
<li>将原始文本分解成一个个独立的单元，通常是词（word）或子词（subword）。</li>
<li>例如：<code>[&quot;The&quot;, &quot;cat&quot;, &quot;sat&quot;, &quot;on&quot;, &quot;the&quot;, &quot;mat&quot;, &quot;.&quot;]</code></li>
<li>分词器还会将这些词/子词映射到它们对应的<strong>整数ID (Integer ID)</strong>。</li>
<li>例如：<code>[101, 234, 567, 890, 101, 321, 999]</code> (这只是示例ID)</li>
</ul>
</li>
<li>
<p><strong>Embedding 层:</strong></p>
<ul>
<li>模型接收的输入是这些<strong>整数ID序列</strong>。</li>
<li>Embedding层本质上是一个<strong>查找表（lookup table）</strong>。</li>
<li>当接收到一个整数ID时，它会去这个查找表中找到该ID对应的<strong>预训练好的（或随机初始化后在训练中学习到的）低维、稠密的浮点数向量</strong>。</li>
<li>例如，ID <code>234</code> (对应“cat”) 可能被查找到一个像 <code>[0.1, -0.3, 0.8, ..., 0.5]</code> 这样的512维向量。</li>
<li>这些向量就是我们所说的<strong>词向量（Word Embeddings）<strong>或</strong>词嵌入</strong>。</li>
<li>这些词向量的特点是：
<ul>
<li><strong>低维：</strong> 相比独热编码的词汇表大小，词向量的维度通常是几十到几百（例如，50, 100, 300, 512, 768等）。</li>
<li><strong>稠密：</strong> 向量中的每个元素都是一个非零的浮点数。</li>
<li><strong>语义信息：</strong> 通过大量的语料库训练，这些向量能够捕捉词语的语义和语法信息，使得语义相似的词在向量空间中距离更近。</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>
<h4 id="Word2Vec">Word2Vec</h4>
<p>案例：Word2Vec训练方法</p>
<p>Word2Vec的CBOW（Continuous Bag of Words）模型是一种通过上下文词预测目标词的神经网络模型。以下是其训练流程的详细说明，并结合具体例子进行解释：</p>
<ol>
<li>数据准备</li>
</ol>
<p>首先，需要准备训练数据，通常是大量的文本语料。文本数据需要进行分词等预处理，将文本转换为词语序列。例如，句子“I learn NLP everyday”会被分词为<code>[&quot;I&quot;, &quot;learn&quot;, &quot;NLP&quot;, &quot;everyday&quot;]</code>。</p>
<ol>
<li>
<p>创建上下文窗口</p>
<p>对于每个目标词，CBOW模型定义了一个上下文窗口。窗口大小由超参数<code>window</code>指定，表示目标词左右两侧的词语数目。例如，窗口大小为2时，目标词“NLP”的上下文词为<code>[&quot;I&quot;, &quot;learn&quot;, &quot;everyday&quot;]</code>。</p>
</li>
<li>
<p>构建训练样本</p>
<p>对于每个目标词，CBOW模型从其上下文窗口中收集上下文词。每个训练样本由上下文词构成，目标是预测目标词。例如，目标词“NLP”的训练样本为<code>&#123;&quot;context&quot;: [&quot;I&quot;, &quot;learn&quot;, &quot;everyday&quot;], &quot;target&quot;: &quot;NLP&quot;&#125;</code>。</p>
</li>
<li>
<p>模型结构</p>
<p>CBOW模型是一个简单的三层神经网络，包括输入层、隐藏层和输出层： - <strong>输入层</strong>：上下文词用one-hot向量表示。例如，词汇表大小为10,000，单词“I”可能表示为<code>[1, 0, 0, ..., 0]</code>。 - <strong>隐藏层</strong>：通过词向量矩阵（Embedding Matrix）将输入的one-hot向量转换为低维词向量（通常是100～300维）。然后将所有上下文词的词向量相加取平均，作为隐藏层向量。 - <strong>输出层</strong>：隐藏层向量乘以输出权重矩阵，得到输出向量。使用Softmax函数计算目标词的概率分布。</p>
</li>
<li>
<p>训练目标</p>
<p>CBOW模型的训练目标是最大化给定上下文词时目标词的条件概率，即最大化$P(w_t | w_{t-c}, w_{t-c+1}, …, w_{t+c})$，其中$w_t$是目标词，$w_{t-c}$到$w_{t+c}$是上下文词。</p>
</li>
<li>
<p>梯度下降</p>
<p>使用梯度下降或其变种，通过反向传播算法调整嵌入层的权重，使得模型的预测更接近实际的目标词。</p>
</li>
<li>
<p>重复迭代</p>
<p>重复以上步骤多次，直到模型收敛到一个合适的状态。每一轮迭代都遍历整个训练数据。</p>
</li>
</ol>
<br>
<p>例子</p>
<p>假设语料为“I learn NLP everyday”，目标词为“NLP”，上下文词为<code>[&quot;I&quot;, &quot;learn&quot;, &quot;everyday&quot;]</code>：</p>
<ol>
<li>将上下文词转换为one-hot向量。</li>
<li>将one-hot向量乘以输入权重矩阵，得到词向量。</li>
<li>将所有上下文词的词向量相加取平均，得到隐藏层向量。</li>
<li>将隐藏层向量乘以输出权重矩阵，得到输出向量。</li>
<li>使用Softmax函数计算目标词“NLP”的概率分布。</li>
<li>通过损失函数（如负对数似然）计算预测误差，并使用梯度下降更新模型参数。</li>
</ol>
<p>以上便是CBOW模型的完整训练流程。</p>
<br>
<h3 id="Positional-Encoding">Positional Encoding</h3>
<p>词向量 → 含位置信息词向量，加入位置信息（多个正弦函数）到词向量</p>
<h4 id="Sinusoidal">Sinusoidal</h4>
<p>$$<br>
PE_{(pos,2i)}=sin(pos/10000^{2i/d_{model}})<br>
$$</p>
<p>$$<br>
PE_{(pos,2i+1)}=cos(pos/10000^{2i/d_{model}})<br>
$$</p>
<p>其中，$pos$ 表示该token在token序列中的位置，$i$ 表示 $d_{model}$ 中的第 $i$ 个维度</p>
<p>ref: <a href="https://arxiv.org/abs/1706.03762">Attention is All You Need</a></p>
<p>核心：由于attention score的计算有特性</p>
<p>$f(…,x_m,…,x_n,…) = f(…,x_n,…,x_m,…)$</p>
<p>我们希望</p>
<p>$\tilde{f}(…,x_m,…,x_n,…) = f(…,x_m + p_m,…,x_n + p_n,…)$</p>
<p>移除可交换性/无位置信息性</p>
<p>同时拥有特性：对于 $\tilde{f}$ 的泰勒展开，有项系数 $p_m H p_n$ ，包含相对位置信息；即当假设 $H = I$ 时，有</p>
<p>$&lt;p_m, p_n&gt; = Re[p_mp_n^*]=q_{m-n}$</p>
<p>可求解得到</p>
<p>$p_m = (cos(m\theta), sin(m\theta))$</p>
<blockquote>
<p>sinusoidal通过<strong>加</strong>的方式向原始向量添加位置信息</p>
</blockquote>
<br>
<h4 id="RoPE">RoPE</h4>
<p>ref: <a href="https://spaces.ac.cn/archives/8231">https://spaces.ac.cn/archives/8231</a></p>
<p><a href="https://spaces.ac.cn/archives/8265">https://spaces.ac.cn/archives/8265</a></p>
<img src="/2025/03/19/LLM-Rela/image-20250830112148964.png" class="" title="image-20250830112148964">
<blockquote>
<p>rope通过<strong>乘</strong>的方式向原始向量添加位置信息</p>
</blockquote>
<br>
<h3 id="Attention">Attention</h3>
<p>Transformer模型中隐藏层（hidden layer）的维度大小，也就是模型宽度（model width）</p>
<p>在Transformer架构中，这通常对应于：</p>
<ul>
<li>每个Transformer层的输入/输出维度（即隐藏状态的维度d_model）</li>
<li>注意力机制中Q/K/V向量的行维度（当使用标准实现时）</li>
<li>前馈网络层的输入/输出维度</li>
</ul>
<h4 id="注意力">注意力</h4>
<h5 id="自注意力-decoder">自注意力 - decoder</h5>
<img src="/2025/03/19/LLM-Rela/image-20250404192612286.png" class="" title="image-20250404192612286">
<img src="/2025/03/19/LLM-Rela/image-20250325195443397.png" class="" title="image-20250325195443397">
<p>ref: <a href="https://www.bilibili.com/video/BV1XH4y1T76e/">从编解码和词嵌入开始，一步一步理解Transformer，注意力机制(Attention)的本质是卷积神经网络(CNN)</a><br>
$$<br>
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^{\top}}{\sqrt{d}}\right)V<br>
$$<br>
$QK^T$ 相当于计算 $token_i$ 与 $token_j$ 对应词向量的相似度</p>
<img src="/2025/03/19/LLM-Rela/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9F%A9%E9%98%B5%E5%9B%BE.jpg" class="" title="img">
<p>softmax <strong>是按行（row-wise）进行的</strong></p>
<p>Attention是对每个token <strong>value化的词向量矩阵</strong> 进行相关性修正，得到注意力矩阵；</p>
<p>其中，每行<strong>每个修正后词向量</strong>包含其他相似词词向量的加和</p>
<blockquote>
<p>维度变化</p>
<p>假设 $W_Q$ 的维度为 ($d_{model}$, $d_k$)，输入形状为 (batch_size, $L_{actual}$, $d_{model}$)，这里的 $L_{actual}$ 为输入token序列长度，则 $QK^{\top}$ 的维度为 (batch_size, $L_{actual}$, $L_{actual}$)，V的维度为(batch_size, $L_{actual}$, $d_v$)</p>
</blockquote>
<br>
<h5 id="交叉注意力-encoder">交叉注意力 - encoder</h5>
<img src="/2025/03/19/LLM-Rela/image-20250325195459862.png" class="" title="image-20250325195459862">
<br>
<h4 id="多头注意力">多头注意力</h4>
<img src="/2025/03/19/LLM-Rela/multi-head-%E6%8B%BC%E6%8E%A5.jpg" class="" title="img">
<blockquote>
<p>将 $W_K, W_Q, W_V$ 竖着切分为 N 个，这意味着长度为  $L_{actual}$的token序列要与每个头进行注意力计算，得到 ($L_{actual}$, $d_h$) 的矩阵，然后拼接得到 ($L_{actual}$, $d_K$) 的矩阵， 进入(可选) 最终线性投影 $W_O$，size 为 $\mathbb{R}^{d_K \times d_{model}}$</p>
</blockquote>
<p>1.拆分</p>
<p>原始的单头注意力中，$W_K, W_Q, W_V \in \mathbb{R}^{d_{model} \times d_K}$<br>
在多头机制中，每个头的参数矩阵被水平拆分为更小的矩阵：</p>
<ul>
<li>
<p><strong>第 $h$ 个头的参数</strong>：</p>
<p>$W_K^{(h)}, W_Q^{(h)}, W_V^{(h)} \in \mathbb{R}^{d_{model} \times d_h}$，其中 $d_h = d_K/N_h$。例如，若总维度 $d_K=512$，头数 $N_h=8$，则每个头的维度 $d_h=64$。</p>
</li>
</ul>
<p><strong>拆分方式</strong>：</p>
<ul>
<li><strong>水平拆分</strong>：将原始矩阵按列切分（如 $W_K$ 被拆为 $[W_K^{(1)}, W_K^{(2)}, …, W_K^{(N_h)}]$），每个子矩阵对应一个头的参数。</li>
</ul>
<p>2.独立计算注意力</p>
<p>每个头 $h$ 使用自己的参数矩阵独立计算注意力：</p>
<ul>
<li>
<p><strong>输入 $x$ 通过第 $h$ 个头</strong>：</p>
<p>$K^{(h)} = x W_K^{(h)}$，</p>
<p>$Q^{(h)} = x W_Q^{(h)}$，</p>
<p>$V^{(h)} = x W_V^{(h)}$。</p>
<p>注意，当前步得到的 $K^{(h)}, Q^{(h)}, V^{(h)}$ 等价于直接从原始 $K, Q, V$ 中拆分</p>
</li>
<li>
<p><strong>计算注意力输出</strong>：<br>
$\text{Attn}_h(x) = \text{softmax}\left(\frac{Q^{(h)} K^{(h)\top}}{\sqrt{d_h}}\right) V^{(h)}$。</p>
</li>
</ul>
<blockquote>
<p>$K^{(h)}Q^{(h)}$ size 为 (L_actual, L_actual), $V^{(h)}$ size 为 (L_actual, d_h)</p>
</blockquote>
<p>3.整合</p>
<p>所有头的输出通过**拼接（Concatenate）**整合：</p>
<ul>
<li>
<p><strong>拼接（标准Transformer）</strong>：</p>
<p>$\text{MHA}(x) = Concat(\text{Attn}<em>1(x), \text{Attn}<em>2(x), …, \text{Attn}</em>{N_h}(x)) W_O$，其中 $W_O \in \mathbb{R}^{d</em>{K} \times d_{model}}$ 是输出投影矩阵。</p>
</li>
</ul>
<br>
<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Wq = Wk = Wv = np.array([</span><br><span class="line">    [1, 0, 0, 0],</span><br><span class="line">    [0, 2, 0, 0],</span><br><span class="line">    [0, 0, 3, 0],</span><br><span class="line">    [0, 0, 0, 4]</span><br><span class="line">]) </span><br><span class="line"></span><br><span class="line">输入 X:</span><br><span class="line"> [[1 0 1 0]</span><br><span class="line"> [0 2 0 2]]</span><br><span class="line"></span><br><span class="line">--- 单头 Attention ---</span><br><span class="line">QK^T / sqrt(dk):</span><br><span class="line"> [[ 5.  0.]</span><br><span class="line"> [ 0. 40.]]</span><br><span class="line">Attention Weights:</span><br><span class="line"> [[9.93307149e-01 6.69285092e-03]</span><br><span class="line"> [4.24835426e-18 1.00000000e+00]]</span><br><span class="line">Single-Head Output:</span><br><span class="line"> [[9.93307149e-01 2.67714037e-02 2.97992145e+00 5.35428074e-02]</span><br><span class="line"> [4.24835426e-18 4.00000000e+00 1.27450628e-17 8.00000000e+00]]</span><br><span class="line"></span><br><span class="line">--- 多头 Attention（Head 1）---</span><br><span class="line">Q1K1^T / sqrt(dk):</span><br><span class="line"> [[ 0.70710678  0.        ]</span><br><span class="line"> [ 0.         11.3137085 ]]</span><br><span class="line">Attention Weights Head 1:</span><br><span class="line"> [[6.69761549e-01 3.30238451e-01]</span><br><span class="line"> [1.22043184e-05 9.99987796e-01]]</span><br><span class="line">Head 1 Output:</span><br><span class="line"> [[6.69761549e-01 1.32095380e+00]</span><br><span class="line"> [1.22043184e-05 3.99995118e+00]]</span><br><span class="line"></span><br><span class="line">--- 多头 Attention（Head 2）---</span><br><span class="line">Q2K2^T / sqrt(dk):</span><br><span class="line"> [[ 6.36396103  0.        ]</span><br><span class="line"> [ 0.         45.254834  ]]</span><br><span class="line">Attention Weights Head 2:</span><br><span class="line"> [[9.98280432e-01 1.71956818e-03]</span><br><span class="line"> [2.21858114e-20 1.00000000e+00]]</span><br><span class="line">Head 2 Output:</span><br><span class="line"> [[2.99484130e+00 1.37565454e-02]</span><br><span class="line"> [6.65574341e-20 8.00000000e+00]]</span><br><span class="line"></span><br><span class="line">Multi-Head Output:</span><br><span class="line"> [[6.69761549e-01 1.32095380e+00 2.99484130e+00 1.37565454e-02]</span><br><span class="line"> [1.22043184e-05 3.99995118e+00 6.65574341e-20 8.00000000e+00]]</span><br></pre></td></tr></table></figure>
<br>
<h4 id="掩码注意力-decoder">掩码注意力 - decoder</h4>
<img src="/2025/03/19/LLM-Rela/mask-attention-map.jpg" class="" title="img">
<p><strong>掩码（Masking）在计算注意力权重（Attention Weights）时生效，注意力权重是通过Q（Query）和K（Key）的点积计算得出的。</strong> Value（V）是根据这些权重加权求和的。严格来说，掩码不是直接作用在Q、K、V的原始数值上，而是作用在<strong>Q和K计算得到的注意力分数（logits）上</strong>，以此来决定哪些K不能被Q关注到。</p>
<blockquote>
<p>需要说明的是，掩码通过作用于 $QK^T$ ，使得位置靠前的token 在 $softmax(\frac{QK^T}{\sqrt{d}})$ 后，其注意力权重向量（行向量）从结果上来说后位均为0，因此得到的修正词向量（注意力矩阵的每行），在原token序列越靠前的，其词向量变化越小（<strong>融入的上文信息量</strong>越少），越靠后的，在注意力机制下变化越大（融入的上文信息量越大）</p>
</blockquote>
<br>
<h4 id="MHA、MQA、GQA-MLA">MHA、MQA、GQA&amp;MLA</h4>
<p>ref: <a href="https://zhuanlan.zhihu.com/p/21151178690">https://zhuanlan.zhihu.com/p/21151178690</a></p>
<img src="/2025/03/19/LLM-Rela/v2-b257d8660af7678f9c9bdc14d095b6d3_1440w.jpg" class="" title="img">
<p>MQA(<strong>M</strong>ulti-<strong>Q</strong>uery <strong>A</strong>ttention): 每个 head 的 Query 共享K和V矩阵，KV cache的内存占用降为 $\frac{1}{n}$</p>
<p>GQA(<strong>G</strong>rouped-<strong>Q</strong>uery <strong>A</strong>ttention): 每个 head 的 Query 按组区分，共享K和V矩阵，$g = 1$ 为MQA，$g = n$ 为MHA</p>
<blockquote>
<p>GQA 相对于 MHA</p>
<p>MHA是对 $W_Q$ $W_K$ $W_V $按列划分为 num_heads 个头，每个头的维度为 $d_{head}$</p>
<p>GQA  是对 $W_Q$ 按列划分为 num_heads 个头，$W_K$ $W_V$ 按列划分为 num_heads / g 个头，每个头的维度为 $d_{head}$，头的维度一致</p>
<p>（拼起来的话K头和V头大小小于Q头</p>
</blockquote>
<p>MLA(<strong>M</strong>ulti-head <strong>L</strong>atent <strong>A</strong>ttention):</p>
<p><img src="https://sebastianraschka.com/images/blog/2025/the-big-llm-architecture-comparison/4.png" alt="img"></p>
<br>
<h3 id="Layer-Norm-Residual-Network">Layer Norm &amp; Residual Network</h3>
<p>Batch Normalization 是对 <strong>所有样本的同一特征维度</strong> 分别做归一化（按列操作）</p>
<p>Layer Normalization 是对 <strong>单个样本的所有特征维度</strong> 做归一化（按行操作）</p>
<p>例如：BN是对特征 $i$ 进行归一，LN是对样本 $x_i$ 进行归一</p>
<table>
<thead>
<tr>
<th style="text-align:center">样本</th>
<th style="text-align:center">特征1</th>
<th style="text-align:center">特征2</th>
<th style="text-align:center">特征3</th>
<th style="text-align:center">特征4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>x₁</strong></td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">4.0</td>
</tr>
<tr>
<td style="text-align:center"><strong>x₂</strong></td>
<td style="text-align:center">5.0</td>
<td style="text-align:center">6.0</td>
<td style="text-align:center">7.0</td>
<td style="text-align:center">8.0</td>
</tr>
<tr>
<td style="text-align:center"><strong>x₃</strong></td>
<td style="text-align:center">9.0</td>
<td style="text-align:center">10.0</td>
<td style="text-align:center">11.0</td>
<td style="text-align:center">12.0</td>
</tr>
</tbody>
</table>
<br>
<h3 id="MLP-FFN">MLP&amp;FFN</h3>
<p>在Transformer的每个编码器和解码器层中，MLP（也称为<strong>Feed Forward Network, FFN</strong>）用于对自注意力层的输出进行非线性变换和特征映射。</p>
<p>MLP (Multi-Layer Perceptron) 是 Transformer 编码器中每个自注意力层之后的一个前馈网络模块。这个 MLP 通常包含两个线性层，中间有一个非线性激活函数（如 GELU）</p>
<br>
$$
FFN(x)=Linear_{2}(Activation(Linear_{1}(x)))
$$
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FeedForwardNetwork</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model: <span class="built_in">int</span>, d_ff: <span class="built_in">int</span>, activation=<span class="string">&quot;relu&quot;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.linear1 = nn.Linear(d_model, d_ff)  <span class="comment"># 扩展层</span></span><br><span class="line">        self.linear2 = nn.Linear(d_ff, d_model)  <span class="comment"># 收缩层</span></span><br><span class="line">        self.activation = nn.ReLU() <span class="keyword">if</span> activation == <span class="string">&quot;relu&quot;</span> <span class="keyword">else</span> nn.GELU()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x: torch.Tensor</span>) -&gt; torch.Tensor:</span><br><span class="line">        <span class="comment"># x shape: [batch_size, seq_len, d_model]</span></span><br><span class="line">        x = self.linear1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line">        x = self.linear2(x)</span><br><span class="line">        <span class="keyword">return</span> x  <span class="comment"># 输出维度保持 [batch_size, seq_len, d_model]</span></span><br></pre></td></tr></table></figure>
<br>
<p><strong>关于 MLP size</strong></p>
<p>“MLP size” 指的是<strong>这两个线性层中间的隐藏维度</strong>。</p>
<ul>
<li><strong>在 ViT 中的体现:</strong>
<ul>
<li>结构: <code>Linear(D -&gt; MLP_Size) -&gt; GELU -&gt; Linear(MLP_Size -&gt; D)</code></li>
<li>它是一个“瓶颈”结构，将 $D$ 维的输入先扩展到一个更大的维度 <code>MLP_Size</code>，再压缩回 $D$ 维。</li>
</ul>
</li>
<li><strong>作用:</strong>
<ul>
<li><strong>增加非线性表达能力:</strong> MLP 层是 Transformer 编码器中引入非线性的主要方式，使得模型能够学习更复杂的函数关系。</li>
<li><strong>提供“思考空间”:</strong> 扩展到更大的维度（MLP Size）可以被认为是给模型更多的“思考空间”来处理特征。</li>
<li><strong>影响计算量和参数量:</strong> MLP size 越大，这部分的计算量和参数量也会越大。</li>
</ul>
</li>
<li><strong>与 Hidden Size 的关系:</strong> MLP size 通常是 Hidden size $D$ 的一个倍数，例如 <strong>4 倍</strong>。</li>
<li><strong>示例:</strong> 在 ViT-Base 模型中，如果 $D = 768$，那么 MLP size 通常是 $768 \times 4 = 3072$。</li>
</ul>
<br>
<h3 id="相关问题">相关问题</h3>
<ol>
<li>
<p>为什么Attenion公式中要除以 $\sqrt d$（d为Q, K矩阵的输出维度）？</p>
<ul>
<li>当向量维度变大的时候，d变大， q 和 k 的点积的方差变大</li>
<li>由于要对 q 和 k 的点积的每一行进行softmax，过大的方差将导致softmax极端化，得到类似于 $[1,0,0,…]$ 的one-hot分布</li>
<li>当输出接近one-hot时，非最大值的梯度趋近于0，反向传播时，这些位置的参数无法得到更新</li>
<li>因此，设置 softmax 的 temperature 来缓解这个问题，这里 temperature 被设置为了 $\sqrt d$ .</li>
</ul>
<p>如下图所示，假设随机向量 $X$ 满足均值为 0，协方差矩阵为单位矩阵（即各变量独立且方差为 1）的<strong>多元标准正态分布</strong>，可计算得到 $XY^T$ 满足均值为 0，协方差矩阵为 $D_{out} I$ 的<strong>多元正态分布</strong>，通过除以 $\sqrt d$ 将 $XY^T$ 的方差缩放为1</p>
</li>
</ol>
<img src="/2025/03/19/LLM-Rela/image-20250404100511037.png" class="" title="image-20250404100511037">
<ol start="2">
<li>
<p>为什么选择多头注意力？</p>
<p>有说法认为，克服**「模型在对当前位置的信息进行编码时，会过度的将注意力集中于自身的位置」<strong>，或者</strong>表达能力提升**：多个低秩注意力头（$d_h &lt; d$）的集成，能捕捉更复杂的交互模式；</p>
<p>但是仍有相悖观点认为并非如此</p>
<p>ref: <a href="https://arxiv.org/pdf/1905.10650">https://arxiv.org/pdf/1905.10650</a></p>
<img src="/2025/03/19/LLM-Rela/image-20250405101512560.png" class="" title="image-20250405101512560">
</li>
<li>
<p>Q，K，V为什么名为Query，Key，Value？注意力机制的注意力体现在哪里？</p>
<p>在交叉注意力场景中，</p>
<ol>
<li>
<p><strong>解码器的任务：</strong> 解码器的目标是根据编码器输出的源语句信息，并结合已经生成的词，来预测下一个词。</p>
</li>
<li>
<p><strong>编码器的输出：</strong> 编码器处理完源语句后，会输出一系列的向量表示。这些向量捕获了源语句中每个词的上下文信息。在 Transformer 的原始设计中，这些输出向量就是解码器交叉注意力的 K 和 V。</p>
</li>
<li>
<p><strong>Q 来源解码器：</strong> 解码器在生成第 t 个词时，它已经生成了 t-1 个词（或者说，它知道要生成哪个位置的词）。解码器使用它自己当前的输入（通常是前一个生成的词的嵌入，或者一个特殊的表示当前位置的向量）来生成 <strong>查询向量 Q</strong>。这个 Q 代表了“我（解码器）现在想知道什么？我需要哪些信息来生成下一个词？”</p>
</li>
<li>
<p><strong>K，V 来源于编码器：</strong> 编码器处理完整个源语句后，会输出一系列上下文向量。这些向量被用作 <strong>键向量 K</strong> 和 <strong>值向量 V</strong>。</p>
<ul>
<li><strong>K（键）</strong>：代表了源语句中每个词的“身份”或“特征”。当解码器的 Q 去查询时，它会与这些 K 进行匹配，以判断源语句中哪些词与当前的 Q 更相关。</li>
<li><strong>V（值）</strong>：包含了源语句中每个词的实际“内容”或“信息”。一旦 Q 和 K 确定了相关性，V 就会提供这些相关词的实际信息，供解码器使用。</li>
</ul>
</li>
<li>
<p><strong>交叉注意力的过程：</strong></p>
<ul>
<li>解码器的 Q（来自当前生成词的表示）与编码器的 K 矩阵进行点积，并通过 softmax 得到注意力权重。这些权重表明了当前解码器关注点在源语句中各个词上的分布。</li>
<li>将这些权重应用于编码器的 V 矩阵，进行加权求和，得到一个 <strong>上下文向量</strong>。这个上下文向量浓缩了源语句中对当前生成词最重要的信息。</li>
<li>解码器将这个上下文向量与自己的内部状态（例如，通过自注意力获得的已生成词的信息）结合起来，用于预测下一个词。</li>
</ul>
<p>“通过已经生成的词和源语句做自注意力，就是确定源语句中哪些词对接下来的词的生成更有作用”正是 <strong>交叉注意力</strong> 的功能。解码器的 Q（代表当前生成词的意图）去查询编码器的 K/V（源语句信息），找到源语句中最重要的部分。</p>
</li>
</ol>
<p>对比：</p>
<ul>
<li><strong>LSTM Seq2Seq 的问题：</strong>
<ul>
<li><strong>信息瓶颈（Information Bottleneck）</strong>：在传统的 LSTM Encoder-Decoder 架构中，编码器会将整个源序列压缩成一个固定长度的 <strong>上下文向量 C</strong>。无论源序列多长，所有信息都必须挤进这个 C。这导致长序列的信息丢失，尤其在解码器生成后半段序列时，C 中关于源序列前半段的信息可能已经非常稀释。</li>
<li><strong>“每一次生成词，都是通过 C 的全部信息去生成”</strong>：解码器在每一步都依赖于这个固定的 C。这使得模型难以动态地关注源序列中与当前生成词最相关的部分。</li>
<li><strong>“很多信息对于当前生成词而言都是没有意义的”</strong>：没错，对于生成某个特定词，源序列中可能只有一两个词是真正相关的。LSTM 的 C 却包含了所有信息，无法做到“按需提取”。</li>
</ul>
</li>
<li><strong>Transformer 注意力机制的解决方案：</strong>
<ul>
<li><strong>动态聚焦：</strong> 通过交叉注意力，解码器在生成每一个词时，都能动态地计算源序列中不同词的注意力权重。这意味着它能根据当前生成词的需要，<strong>“按需”地从编码器输出中提取最相关的信息</strong>。</li>
<li><strong>避免信息瓶颈：</strong> 编码器不再需要将所有信息压缩成一个单一向量。它输出的是一系列的上下文向量（每个对应源序列中的一个词），解码器可以随时通过注意力机制访问这些向量。</li>
<li><strong>长距离依赖：</strong> 注意力机制可以直接连接源序列中的任意两个词，无论它们相距多远，有助于捕捉长距离依赖关系，这在 LSTM 中很难实现。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>为什么encoder需要多个注意力层？</p>
<p>我们可以把自注意力（Self-Attention）看作是一次信息交互的过程。在一个注意力层中，每个token会“看”到序列中所有其他的token，并根据相关性（Attention Score）从它们那里“借”一些信息来更新自己。</p>
<ul>
<li><strong>一层注意力 = 一次直接交互</strong>：<br>
在句子 “The cat that chased the dog was tired” 中，第一层注意力可以让 “tired” 直接关联到 “cat”。它能建立起直接的语法联系。<br>
但是，“tired” 与 “dog” 的关系是<em>间接</em>的（“tired” -&gt; “cat” -&gt; “chased” -&gt; “dog”）。在一层注意力中，“tired” 看到 “dog” 主要是因为它们同在一个句子里，但它们之间的深层逻辑关系（猫因为追狗而累）还很模糊。</li>
<li><strong>多层注意力 = 多次间接交互</strong>：
<ul>
<li><strong>第一层</strong>：每个词都与所有其他词进行了直接的信息交换。现在，每个词的向量表示（embedding）已经包含了它直接邻居的信息。比如，“cat” 的新向量里包含了 “chased” 的信息。</li>
<li><strong>第二层</strong>：当第二层注意力开始工作时，它的输入是第一层处理过的、已经“混合”了初步上下文的序列。现在，当 “tired” 再次审视 “cat” 时，它看到的 “cat” 已经不是最初的那个了，这个 “cat” 的向量里已经带有了 “chased” 和 “dog” 的“影子”。</li>
<li><strong>以此类推</strong>：每一层都建立在前一层的基础上，信息可以像涟漪一样，通过中间token一跳一跳地传播到更远的地方。经过多层堆叠，一个token的表示就能够聚合到跨越整个序列的、非常复杂的间接依赖关系。</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>
<h2 id="LLM-Train">LLM-Train</h2>
<h3 id="Base">Base</h3>
<img src="/2025/03/19/LLM-Rela/image-20250613213945162.png" class="" title="image-20250613213945162">
<p>在Qwen3中</p>
<p>预训练包含了</p>
<p><strong>通用阶段（S1）</strong>：第一预训练阶段中，所有Qwen3模型在超过30T token上进行训练，使用4,096个token的序列长度。此阶段模型已在语言能力和通用世界知识方面得到全面训练，训练数据覆盖119种语言和方言。</p>
<p><strong>推理阶段（S2）</strong>：为增强推理能力，研究团队优化了此阶段的预训练语料库，提高了STEM、编程、推理和合成数据的比例。模型在约5T高质量token上进行进一步预训练，序列长度保持为4K token。在此阶段还加速了学习率衰减过程。</p>
<p><strong>长上下文阶段（S3）</strong>：最终预训练阶段，研究人员收集了高质量长上下文语料库以扩展Qwen3模型的上下文处理长度。所有模型在数百亿token上进行预训练，序列长度达32K token。长上下文语料库中，75%的文本长度在16K~32K token之间，25%的文本长度在4K~16K token之间。</p>
<p>后训练包含了</p>
<img src="/2025/03/19/LLM-Rela/post-training.png" class="" title="img">
<h3 id="Parallelism">Parallelism</h3>
<p>ref: <a href="https://x.com/_avichawla/status/1943558634388197458">https://x.com/_avichawla/status/1943558634388197458</a></p>
<img src="/2025/03/19/LLM-Rela/image-20250810092205813.png" class="" title="image-20250810092205813">
<h4 id="DataParallel">DataParallel</h4>
<blockquote>
<p>这不联邦学习吗</p>
</blockquote>
<p>数据并行 DataParallel (DP) - 相同的设置被复制多次，每次都输入一部分数据。处理是并行进行的，所有设置在每个训练步骤结束时同步。</p>
<ol>
<li><strong>模型复制</strong>：将<strong>相同的模型</strong>（包括参数、优化器状态等）复制到多个GPU上。</li>
<li><strong>数据分片</strong>：将训练数据<strong>划分为多个子批次（mini-batch）</strong>，每个GPU处理一个子批次。</li>
<li><strong>并行计算</strong>：所有GPU<strong>并行执行前向传播和反向传播</strong>，计算各自子批次的梯度。</li>
<li><strong>梯度同步</strong>：通过<strong>全局通信</strong>（如AllReduce）收集所有梯度并求平均，更新一次全局模型参数。</li>
</ol>
<img src="/2025/03/19/LLM-Rela/0.png" class="" title="alt text">
<p>图中对比了不同数据并行策略的资源消耗（以N=64个GPU为例）：</p>
<p><strong>Baseline（纯数据并行）</strong></p>
<ul>
<li><strong>内存消耗</strong>：120GB（最高）
<ul>
<li>原因：每个GPU需存储完整的模型参数（蓝色）、梯度（橙色）和优化器状态（绿色），无任何分区优化。</li>
</ul>
</li>
<li><strong>通信量</strong>：1x（基准）
<ul>
<li>需同步所有GPU的梯度（通信量随GPU数量线性增长）。</li>
</ul>
</li>
</ul>
<p><strong>优化策略（$P_{os}、P_{os+g}、P_{os+g+p}$）</strong></p>
<ul>
<li><strong>$P_{os}$</strong>：仅对优化器状态分区
<ul>
<li>内存降至16.6GB（优化器状态分到不同GPU）。</li>
</ul>
</li>
<li><strong>$P_{os+g}$</strong>：优化器状态+梯度分区
<ul>
<li>内存进一步降低（梯度不再全存储）。</li>
</ul>
</li>
<li><strong>$P_{os+g+p}$</strong>：参数、梯度、优化器状态全分区
<ul>
<li>内存最低（1.9GB），但通信量增至1.5x（需额外同步参数）。</li>
</ul>
</li>
</ul>
<br>
<h4 id="TensorParallel">TensorParallel</h4>
<p>每个张量被分成多个块，因此不是将整个张量驻留在单个 gpu 上，而是将张量的每个分片驻留在其指定的 gpu 上。在处理过程中，每个分片在不同的 GPU 上单独并行处理，结果在步骤结束时同步。这就是所谓的水平并行，因为拆分发生在水平层面。</p>
<img src="/2025/03/19/LLM-Rela/4.png" class="" title="alt text">
<br>
<h4 id="PipelineParallel">PipelineParallel</h4>
<p>将模型的不同层分布在不同 GPU 上，每张 GPU 负责模型的一部分，<strong>输入数据按 micro-batch 流水处理</strong>。</p>
<p>假设模型有 8 层：</p>
<ul>
<li>GPU0 负责第 1~4 层</li>
<li>GPU1 负责第 5~8 层</li>
<li>将 batch size 为 64 分为 4 个 micro-batch（每个 16 条数据）</li>
<li>micro-batch1 流经 GPU0，GPU1，接着 micro-batch2 开始处理，实现流水线并行</li>
</ul>
<br>
<h3 id="上下文扩展">上下文扩展</h3>
<h4 id="Yarn">Yarn</h4>
<p>扩展上下文界限 $L$ 到 $L’$  $(L’ &gt; L)$，相关定义如下：</p>
<p>比例因子 $s = \frac{L’}{L}$</p>
<p>波长 $\lambda_i = 2\pi B^{\frac{2i}{d_{model}}}$</p>
<p>频率 $\theta_i = B^{\frac{2i}{d_{model}}}$</p>
<p>位置 $pos’ = \frac{pos}{s}$</p>
<p>位置函数 $g(m)=\frac{m}{s}$</p>
<p>频率函数 $h(\theta) = \theta$</p>
<p><strong>Position Interpolation</strong></p>
<img src="/2025/03/19/LLM-Rela/image-20250901103525674.png" class="" title="image-20250901103525674">
<br>
<p><strong>NTK-aware</strong></p>
<p><strong>高频分量编码的是“相对位置”的精细信息，而低频分量编码的是“绝对位置”的粗略信息。直接缩放严重损害了前者，但对后者影响较小。</strong></p>
<p>我们用一个更具体的例子来解释：假设我们要将模型的上下文窗口从 <strong>2048</strong> 扩展到 <strong>8192</strong>，缩放因子为 <strong>s = 8192 / 2048 = 4</strong>。</p>
<p>在进行推理时，为了让模型能够处理新位置（如位置 4096），我们不能直接将位置 <code>m = 4096</code> 输入，因为模型从未见过这么大的位置。位置插值的做法是，将新的位置索引“压缩”回原来的范围。即，我们将实际位置 <code>m</code> 替换为 <code>m' = m / s</code>。</p>
<p>所以，RoPE 的旋转角度计算就从 <code>m * ω_i</code> 变成了 <code>(m/s) * ω_i</code>。</p>
<p>现在我们来分析这对高频和低频部分的不同影响。</p>
<hr>
<p>高频部分（大 ω）：信息严重压缩和丢失</p>
<p>高频分量的设计初衷是让相邻 token 之间有显著的差异，从而让模型精确地感知到“就在旁边”这个概念。</p>
<ul>
<li>
<p><strong>原始情况 (未缩放)</strong>:</p>
<ul>
<li>假设最高频 <code>ω_0 = 1</code>。</li>
<li>位置 <code>m=0</code> 和 <code>m=1</code> 的旋转角度差是 <code>(1 * 1) - (0 * 1) = 1</code> 弧度（约 57.3°）。这是一个非常大的、清晰可辨的差异。</li>
<li>位置 <code>m=1</code> 和 <code>m=2</code> 的角度差同样是 <code>1</code> 弧度。</li>
<li>模型在训练中学会了：当这个维度的嵌入向量旋转了约 57.3° 时，就意味着 token 的相对位置移动了 1。</li>
</ul>
</li>
<li>
<p><strong>缩放后 (s=4)</strong>:</p>
<ul>
<li>现在我们看真实位置 <code>m=0</code> 和 <code>m=1</code>。它们被映射到插值位置 <code>m'=0</code> 和 <code>m'=1/4=0.25</code>。</li>
<li>它们之间的旋转角度差变成了 <code>(0.25 * 1) - (0 * 1) = 0.25</code> 弧度（约 14.3°）。</li>
<li>再看真实位置 <code>m=0, 1, 2, 3</code>，它们被映射到 <code>m'=0, 0.25, 0.5, 0.75</code>。这些位置在原始模型看来，都挤在了原来 <code>m=0</code> 和 <code>m=1</code> 的区间内！</li>
<li><strong>结论</strong>: 原本用于区分相邻 token 的清晰“刻度”被严重模糊了。模型看到一个微小的角度变化（比如 14.3°），它无法判断这究竟是原始训练数据中一个 token 内的细微抖动，还是一个全新的、代表“下一个”token 的位置。这种区分能力的丧失，就是您所说的“高频分量消失”，导致模型对局部、短距离的依赖关系变得不敏感。</li>
</ul>
</li>
</ul>
<hr>
<p>低频部分（小 ω）：信息保留较好</p>
<p>低频分量的作用是提供一个缓慢变化的信号，来标识 token 在长序列中的大致位置。它对微小的位置变化不敏感。</p>
<ul>
<li>
<p><strong>原始情况 (未缩放)</strong>:</p>
<ul>
<li>假设一个很低的频率 <code>ω_i = 0.001</code>。</li>
<li>位置 <code>m=1000</code> 和 <code>m=1001</code> 的旋转角度差是 <code>(1001 * 0.001) - (1000 * 0.001) = 0.001</code> 弧度。这个差异本身就微乎其微。</li>
<li>这个分量的主要作用是看长距离差异。比如，位置 <code>m=0</code> 和 <code>m=1000</code> 的角度差是 <code>1000 * 0.001 = 1</code> 弧度，这是一个很大的差异，清晰地表明了两个 token 相距很远。</li>
</ul>
</li>
<li>
<p><strong>缩放后 (s=4)</strong>:</p>
<ul>
<li>我们看真实位置 <code>m=1000</code> 和 <code>m=1001</code>。它们被映射到插值位置 <code>m'=1000/4=250</code> 和 <code>m'=1001/4=250.25</code>。</li>
<li>旋转角度差为 <code>(250.25 * 0.001) - (250 * 0.001) = 0.00025</code> 弧度。这个差异比原来更小了，但本来就已经很小，所以影响不大。</li>
<li>我们再看长距离。真实位置 <code>m=0</code> 和 <code>m=4000</code>。它们被映射到 <code>m'=0</code> 和 <code>m'=1000</code>。</li>
<li>它们之间的旋转角度差是 <code>(1000 * 0.001) - (0 * 0.001) = 1</code> 弧度。</li>
<li><strong>结论</strong>: 在缩放后，真实位置 4000 处的低频分量，其旋转状态和原始模型在位置 1000 处的状态是<strong>完全一样</strong>的。由于低频信号本身就是缓慢、近乎线性变化的，模型可以很好地进行“线性外推”（Linear Extrapolation）。它看到一个缓慢变化的信号持续了更长时间，这符合它在训练期间学到的规律。因此，长距离的绝对位置信息得以保留。</li>
</ul>
</li>
</ul>
<p>正是因为这种对高频信息的破坏，后续的上下文扩展方法，如 <strong>NTK-aware Scaling</strong>，才会提出修改基数 <code>θ</code> 而不是直接插值位置 <code>m</code>，以求在扩展上下文的同时，尽可能减小对高频信息的损害。</p>
<p>改变频率 $\theta_i = B’^{\frac{2i}{d_{model}}}$</p>
<p>where $B’ = B*s^{\frac{|d_{model}|}{|d_{model}| - 2}}$</p>
<p><strong>NTK-by-parts</strong></p>
<p>ref: <a href="https://zhuanlan.zhihu.com/p/683863159">https://zhuanlan.zhihu.com/p/683863159</a></p>
<img src="/2025/03/19/LLM-Rela/image-20250901102212626.png" class="" title="image-20250901102212626">
<img src="/2025/03/19/LLM-Rela/image-20250901103305314.png" class="" title="image-20250901103305314">
<blockquote>
<p>显然，</p>
<p>对于低维/高频/短波部分，基频不发生改变</p>
<p>对于高维/低频/长波部分，基频缩小/对应位置的旋转角加快，使其在长波长场景下的位置变化可区分度提升</p>
</blockquote>
<p><strong>Yarn</strong></p>
<img src="/2025/03/19/LLM-Rela/image-20250901103056683.png" class="" title="image-20250901103056683">
<br>
<h4 id="DCA">DCA</h4>
<br>
<h2 id="LLM-Inference">LLM-Inference</h2>
<h3 id="Parameters">Parameters</h3>
<h4 id="Temperature">Temperature</h4>
<p><strong>温度参数控制输出随机性（多样性）的超参数。</strong></p>
<p>将模型输出的 logits（原始分数）除以温度值，然后再经过 softmax，计算出新的概率分布：<br>
$$<br>
P_i = \frac{e^{\frac{logit_i}{T}}}{\sum_j e^{\frac{logit_j}{T}}}<br>
$$</p>
<ul>
<li><strong>T &lt; 1</strong> → 增强高概率词，削弱低概率词</li>
<li><strong>T &gt; 1</strong> → 扁平化分布，低概率词获得更多机会</li>
<li><strong>T = 1</strong> → 原始 softmax 分布</li>
</ul>
<blockquote>
<p>温度对模型输出的影响相当于改进版的softmax层</p>
</blockquote>
<br>
<h4 id="Sampling">Sampling</h4>
<p>Top-K</p>
<p>Top-K控制的是“只在前K个最有可能的词中采样”。</p>
<ul>
<li><strong>K=1</strong> → 只选概率最大的词（等同于贪婪搜索）</li>
<li><strong>K=10</strong> → 从概率前10的词中进行随机选择</li>
<li><strong>K=100+</strong> → 越大，越接近全概率分布，输出更有创造性</li>
</ul>
<img src="/2025/03/19/LLM-Rela/6.png" class="" title="alt text">
<br>
<p>Top-p</p>
<p>使用随机策略选择一个输出，候选集为按概率排名靠前的连续结果，且累积概率&lt;=p</p>
<img src="/2025/03/19/LLM-Rela/6.png" class="" title="alt text">
<br>
<h3 id="内存优化">内存优化</h3>
<h4 id="KV-cache">KV cache</h4>
<h4 id="GQA-MLA">GQA &amp; MLA</h4>
<h4 id="Sliding-Window-Attention">Sliding Window Attention</h4>
<p>ref: <a href="https://sebastianraschka.com/blog/2025/the-big-llm-architecture-comparison.html#31-sliding-window-attention">https://sebastianraschka.com/blog/2025/the-big-llm-architecture-comparison.html#31-sliding-window-attention</a></p>
<img src="/2025/03/19/LLM-Rela/13.png" class="" title="img">
<br>
<h2 id="Fine-Tuning">Fine-Tuning</h2>
<p>高效微调技术分类：</p>
<ul>
<li>增加额外参数（A）
<ul>
<li>类适配器（Adapter-like）方法</li>
<li>软提示（Soft prompts）</li>
</ul>
</li>
<li>选取一部分参数更新（S）</li>
<li>引入重参数化（R）</li>
</ul>
<img src="/2025/03/19/LLM-Rela/v2-eaaf1c00d0c4ea350cd3a79b47de26d3_1440w.jpg" class="" title="img">
<br>
<p>ref: <a href="https://x.com/DailyDoseOfDS_/status/1942878914889826686">https://x.com/DailyDoseOfDS_/status/1942878914889826686</a></p>
<img src="/2025/03/19/LLM-Rela/image-20250810092440215.png" class="" title="image-20250810092440215">
<br>
<h3 id="BitFit-Prefix-Tuning-Prompt-Tuning">BitFit, Prefix Tuning &amp; Prompt Tuning</h3>
<p>BitFit（论文：<strong>BitFit: Simple Parameter-efficient Fine-tuning or Transformer-based Masked Language-models</strong>）是一种稀疏的微调方法，它训练时只更新bias的参数或者部分bias参数。</p>
<p>涉及到的bias参数有attention模块中计算query,key,value跟合并多个attention结果时涉及到的bias，MLP层中的bias，Layernormalization层的bias参数。</p>
<br>
<p>Prefix Tuning（论文：<strong>Prefix-Tuning: Optimizing Continuous Prompts for Generation</strong>），在输入token之前构造一段任务相关的virtual tokens作为Prefix，然后训练的时候只更新Prefix部分的参数，而PLM(Pretrain LM)中的其他部分参数固定。</p>
<br>
<p>Prompt Tuning（论文：<strong>The Power of Scale for Parameter-Efficient Prompt Tuning</strong>），该方法可以看作是Prefix Tuning的简化版本，它给每个任务定义了自己的Prompt，然后拼接到数据上作为输入，但<strong>只在输入层加入prompt tokens</strong>，并且不需要加入 MLP 进行调整来解决难训练的问题。</p>
<br>
<h3 id="P-Tuning">P-Tuning</h3>
<p>P-Tuning（论文：<strong>GPT Understands, Too</strong>），该方法将Prompt转换为可以学习的Embedding层，并用MLP+LSTM的方式来对Prompt Embedding进行一层处理。</p>
<p>相比Prefix Tuning，P-Tuning加入的可微的virtual token，但仅限于输入层，没有在每一层都加；另外，virtual token的位置也不一定是前缀，插入的位置是可选的。这里的出发点实际是把传统人工设计模版中的真实token替换成可微的virtual token。</p>
<p>P-Tuning v2（论文： <strong>P-Tuning v2: Prompt Tuning Can Be Comparable to Fine-tuning Universally Across Scales and Tasks</strong>），该方法在每一层都加入了Prompts tokens作为输入，而不是仅仅加在输入层</p>
<br>
<h3 id="Adapter-Tuning">Adapter Tuning</h3>
<p>Adapter Tuning（论文：<strong>Parameter-Efficient Transfer Learning for NLP</strong>），该方法设计了Adapter结构，并将其嵌入Transformer的结构里面，针对每一个Transformer层，增加了两个Adapter结构(分别是多头注意力的投影之后和第二个feed-forward层之后)，在训练时，固定住原来预训练模型的参数不变，只对新增的 Adapter 结构和 Layer Norm 层进行微调，从而保证了训练的高效性。</p>
<p>Adapter Fusion（论文：<strong>AdapterFusion:Non-Destructive Task Composition for Transfer Learning</strong>），一种融合多任务信息的Adapter的变体，在 Adapter 的基础上进行优化，通过将学习过程分为两阶段来提升下游任务表现。</p>
<p>AdapterDrop（论文：AdapterDrop: On the Efficiency of Adapters in Transformers），在不影响任务性能的情况下，对Adapter动态高效的移除，尽可能的减少模型的参数量，提高模型在反向传播（训练）和正向传播（推理）时的效率。</p>
<br>
<h3 id="LoRA">LoRA</h3>
<h4 id="奇异值分解与低秩分解">奇异值分解与低秩分解</h4>
<p><strong>SVD</strong></p>
<p>对于任意一个 $m \times n$ 的实矩阵 $A$，可以分解成三个矩阵的乘积：<br>
$$<br>
A = U \Sigma V^T<br>
$$</p>
<ul>
<li>$U$：$m \times m$ 的正交矩阵（左奇异向量）</li>
<li>$\Sigma$：$m \times n$ 的对角矩阵，对角线上的值是奇异值（非负，按大小排列）</li>
<li>$V^T$：$n \times n$ 的正交矩阵（右奇异向量的转置）</li>
</ul>
<br>
<p><strong>低秩分解</strong></p>
<p>r是矩阵的秩，决定了分解后保留的信息量。如果只保留最大的几个奇异值（低秩近似），就能用更少的参数近似原矩阵</p>
<p>例如，存在矩阵<br>
$$<br>
S = \begin{bmatrix}<br>
1 &amp; 0 &amp; 0 &amp; 2 &amp; 0 \<br>
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \<br>
0 &amp; 3 &amp; 0 &amp; 0 &amp; 0 \<br>
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \<br>
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \<br>
\end{bmatrix}<br>
$$<br>
分解后的三个矩阵：<br>
$$<br>
U \approx \begin{bmatrix}<br>
0.3 &amp; 0 &amp; 0.34 &amp; -0.68 &amp; -0.58 \<br>
-0.22 &amp; 0 &amp; -0.76 &amp; 0.2 &amp; -0.58 \<br>
0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 \<br>
-0.77 &amp; 0 &amp; 0.36 &amp; 0.52 &amp; 0 \<br>
-0.52 &amp; 0 &amp; -0.42 &amp; -0.48 &amp; -0.58 \<br>
\end{bmatrix}, \quad<br>
\Sigma = \begin{bmatrix}<br>
7.03 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \<br>
0 &amp; 3 &amp; 0 &amp; 0 &amp; 0 \<br>
0 &amp; 0 &amp; 2.15 &amp; 0 &amp; 0 \<br>
0 &amp; 0 &amp; 0 &amp; 0.11 &amp; 0 \<br>
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \<br>
\end{bmatrix}, \quad<br>
V \approx \begin{bmatrix}<br>
0.34 &amp; -0.32 &amp; 0 &amp; -0.89 &amp; 0 \<br>
0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \<br>
0.3 &amp; -0.93 &amp; 0 &amp; 0.22 &amp; 0 \<br>
-0.89 &amp; -0.19 &amp; 0 &amp; 0.41 &amp; 0 \<br>
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \<br>
\end{bmatrix}<br>
$$<br>
选择最大的三个奇异值重构，保留 $\sigma_{1} \approx 7.03$, $\sigma_{2} = 3$, $\sigma_{3}=2.15$，重构矩阵如下：</p>
<p>保留前三列：</p>
<p>$$<br>
U_{\text{trunc}} \approx<br>
\begin{bmatrix}<br>
0.3 &amp; 0 &amp; 0.34 \<br>
-0.22 &amp; 0 &amp; -0.76 \<br>
0 &amp; -1 &amp; 0 \<br>
-0.77 &amp; 0 &amp; 0.36 \<br>
-0.52 &amp; 0 &amp; -0.428<br>
\end{bmatrix}<br>
$$<br>
保留前三行和前三列：</p>
<p>$$<br>
\Sigma_{\text{trunc}} =<br>
\begin{bmatrix}<br>
7.03 &amp; 0 &amp; 0 \<br>
0 &amp; 3 &amp; 0 \<br>
0 &amp; 0 &amp; 2.15<br>
\end{bmatrix}<br>
$$<br>
保留前三行：</p>
<p>$$<br>
V_{\text{trunc}} \approx<br>
\begin{bmatrix}<br>
0.34 &amp; -0.32 &amp; 0 &amp; -0.89 &amp; 0 \<br>
0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \<br>
0.3 &amp; -0.93 &amp; 0 &amp; 0.22 &amp; 0<br>
\end{bmatrix}<br>
$$<br>
根据，$S’ = U_{\text{trunc}} \times \Sigma_{\text{trunc}} \times V_{\text{trunc}}^T$，计算得到重构后：</p>
<p>$$<br>
S’ =<br>
\begin{bmatrix}<br>
0.93 &amp; -0.01 &amp; 0 &amp; 2.03 &amp; 0 \<br>
0.02 &amp; 2 &amp; 0 &amp; 0.99 &amp; 0 \<br>
0 &amp; 0 &amp; 3 &amp; 0 &amp; 0 \<br>
2.05 &amp; 1.01 &amp; 0 &amp; 4.98 &amp; 0 \<br>
0.95 &amp; 1.99 &amp; 0 &amp; 3.02 &amp; 0<br>
\end{bmatrix}<br>
$$<br>
结果对比原始矩阵和重构矩阵，直观地看，基本保持一致。</p>
<p>事实上上面的结论：如果只保留最大的几个奇异值（低秩近似），就能用更少的参数近似 $W$。<br>
$$<br>
S =<br>
\begin{bmatrix}<br>
1 &amp; 0 &amp; 0 &amp; 2 &amp; 0 \<br>
0 &amp; 2 &amp; 0 &amp; 1 &amp; 0 \<br>
0 &amp; 0 &amp; 3 &amp; 0 &amp; 0 \<br>
2 &amp; 1 &amp; 0 &amp; 5 &amp; 0 \<br>
1 &amp; 2 &amp; 0 &amp; 3 &amp; 0<br>
\end{bmatrix}<br>
\quad<br>
S’ =<br>
\begin{bmatrix}<br>
0.93 &amp; -0.01 &amp; 0 &amp; 2.03 &amp; 0 \<br>
0.02 &amp; 2 &amp; 0 &amp; 0.99 &amp; 0 \<br>
0 &amp; 0 &amp; 3 &amp; 0 &amp; 0 \<br>
2.05 &amp; 1.01 &amp; 0 &amp; 4.98 &amp; 0 \<br>
0.95 &amp; 1.99 &amp; 0 &amp; 3.02 &amp; 0<br>
\end{bmatrix}<br>
$$<br>
实际上，可以通过保留的奇异值，计算重构后的矩阵，保留了多少信息，如下：</p>
<p>$$<br>
|A|_F^2 = 7.03^2 + 3^2 + 2.15^2 + 0.11^2 + 0^2 \approx 63.06<br>
\quad<br>
|A’|_F^2 = 7.03^2 + 3^2 + 2.15^2 \approx 63.04<br>
$$</p>
<p>$$<br>
\text{信息保留比例} = \frac{63.04}{63.06} \approx 99.97%<br>
$$</p>
<blockquote>
<p>为什么LoRA可以进行低秩分解？</p>
<p>通过对微调后的权重变化 $\Delta W$ 的奇异值分解发现，大部分信息集中在少数几个奇异值上；在GPT-3上测试时发现，$\Delta W$ 的前 10 - 20 个奇异值占据了 90% 的信息</p>
<p>可以对原始权重 $W$ 进行分解吗？</p>
<p>不可以，$W$ 接近满秩</p>
</blockquote>
<p>假设对一个 $512 \times 512$ 的权重矩阵 $W$ 进行微调</p>
<ul>
<li>全微调：可能需要调整 262144 个参数</li>
<li>LoRA：假设 r = 8，只需要调整 $A(512 \times 8)$ 和 $B(8 \times 512)$，共 8192 个参数</li>
</ul>
<br>
<h4 id="LoRA应用位置">LoRA应用位置</h4>
<p><strong>注意力层</strong></p>
<p>多应用与 $W_q$ 和 $W_v$ 上</p>
<p><strong>FFN层</strong></p>
<p>$W_1$ (升维)和 $W_2$ (降维)</p>
<br>
<h4 id="LoRA改进">LoRA改进</h4>
<h5 id="LoRA-2">LoRA+</h5>
<p><strong>核心思想</strong>：对低秩矩阵 $A$ 和 $B$ 设置不同的学习率，以增强训练动态性。</p>
<p>在标准 LoRA 中，权重更新为：</p>
<p>$$<br>
\Delta W = A B, \quad A \in \mathbb{R}^{d \times r}, ; B \in \mathbb{R}^{r \times d}<br>
$$</p>
<p>LoRA+ 设置独立的学习率：</p>
<p>$$<br>
A \leftarrow A - \eta_A \cdot \nabla_A \mathcal{L}, \quad B \leftarrow B - \eta_B \cdot \nabla_B \mathcal{L}<br>
$$</p>
<p>其中：</p>
<ul>
<li>$\eta_A$：A 的学习率</li>
<li>$\eta_B$：B 的学习率</li>
<li>通常设置 $\eta_B = \lambda \cdot \eta_A$，$\lambda \in [4, 16]$</li>
</ul>
<br>
<h5 id="DoRA">DoRA</h5>
<p><strong>核心思想</strong>：引入对残差结构的重构机制，更有效地利用参数空间。</p>
<p>标准 LoRA 更新为：<br>
$$<br>
W = W_0 + \Delta W = W_0 + A B<br>
$$<br>
而 DoRA 将残差部分进一步分解为：</p>
<p>$$<br>
W = U \cdot S \cdot V^T<br>
$$</p>
<p>其中：</p>
<ul>
<li>为低秩基</li>
<li>为可学习的对角矩阵或全连接矩阵（增强表达能力）</li>
</ul>
<p>若引入正则项，则完整目标函数为：<br>
$$<br>
\mathcal{L}<em>{\text{total}} = \mathcal{L}</em>{\text{task}} + \lambda |S|_F^2<br>
$$</p>
<br>
<h5 id="rsLoRA">rsLoRA</h5>
<p>rsLoRA 针对不同层设置不同的秩（rank），以便更灵活地分配参数量。<br>
<strong>核心思想</strong>：为每一层设置不同的秩 $r^{(l)}$，提高参数使用效率。</p>
<p>对于第 $l$ 层，有：<br>
$$<br>
\Delta W^{(l)} = A^{(l)} B^{(l)}, \quad A^{(l)} \in \mathbb{R}^{d \times r^{(l)}}, ; B^{(l)} \in \mathbb{R}^{r^{(l)} \times d}<br>
$$<br>
训练过程中可以手动设定 rank 或使用启发式函数自动选择：<br>
$$<br>
r^{(l)} = f\left( |W^{(l)}|, \sigma^{(l)} \right)<br>
$$<br>
其中 $\sigma^{(l)}$ 可为特征谱或梯度范数。</p>
<p><strong>优势</strong>：</p>
<ul>
<li>提高计算效率；</li>
<li>保持性能的同时减少冗余参数。</li>
</ul>
<br>
<h5 id="PiSSA">PiSSA</h5>
<p><strong>核心思想</strong>：用奇异值分解（SVD）初始化 $A$ 和 $B$，更好地保持原始权重结构。</p>
<p>将原始矩阵 $W$ 分解为：<br>
$$<br>
W \approx U_r \Sigma_r V_r^T<br>
$$<br>
其中：</p>
<ul>
<li>$U_r \in \mathbb{R}^{d \times r}, ; \Sigma_r \in \mathbb{R}^{r \times r}, ; V_r \in \mathbb{R}^{d \times r}$</li>
<li>保留前 $r$ 个奇异值（截断 SVD）</li>
</ul>
<p>初始化为：<br>
$$<br>
A = U_r \cdot \sqrt{\Sigma_r}, \quad B = \sqrt{\Sigma_r} \cdot V_r^T<br>
$$<br>
因此：<br>
$$<br>
\Delta W = A B = U_r \Sigma_r V_r^T \approx W_r<br>
$$<br>
<strong>优势</strong>：</p>
<ul>
<li>更接近原始参数空间；</li>
<li>避免随机初始化带来的不稳定性；</li>
<li>提升初期训练收敛速度。</li>
</ul>
<h4 id="LoRA相关论文">LoRA相关论文</h4>
<p>LoRA（论文：<strong>LoRA: LOW-RANK ADAPTATION OF LARGE LANGUAGE MODELS</strong>），该方法的核心思想就是通过低秩分解来模拟参数的改变量，从而以极小的参数量来实现大模型的间接训练。</p>
<br>
<p>AdaLoRA（论文：<strong>ADAPTIVE BUDGET ALLOCATION FOR PARAMETEREFFICIENT FINE-TUNING</strong>），是对LoRA的一种改进，它根据重要性评分动态分配参数预算给权重矩阵。</p>
<br>
<p>QLoRA（论文： <strong>QLORA: Efficient Finetuning of Quantized LLMs</strong>），使用一种新颖的高精度技术将预训练模型量化为 4 bit，然后添加一小组可学习的低秩适配器权重，这些权重通过量化权重的反向传播梯度进行微调。QLORA 有一种低精度存储数据类型（4 bit），还有一种计算数据类型（BFloat16）。实际上，这意味着无论何时使用 QLoRA 权重张量，我们都会将张量反量化为 BFloat16，然后执行 16 位矩阵乘法。QLoRA提出了两种技术实现高保真 4 bit微调——4 bit NormalFloat(NF4) 量化和双量化。此外，还引入了分页优化器，以防止梯度检查点期间的内存峰值，从而导致内存不足的错误，这些错误在过去使得大型模型难以在单台机器上进行微调。</p>
<br>
<h4 id="调参技巧">调参技巧</h4>
<ul>
<li>从低秩开始：对于绝大多数任务，可以从 $r=8$ 和 $r = 16$ 开始调整，评估性能后再决定是否需要更高的秩</li>
<li>数据集大小与秩的关系：小数据集（&lt;5k 样本）用低秩（$r=8$）；大数据集（&gt;50k样本）可以尝试更大秩（r=32+）</li>
<li>复杂任务策略：对于复杂推理任务，可以结合使用：（1）增大r到32或64；（2）启用rsLoRA；（3）添加更多目标层；</li>
</ul>
<br>
<h3 id="MAM-Adapter-UniPELT">MAM Adapter &amp; UniPELT</h3>
<p>MAM Adapter（论文：TOWARDS A UNIFIED VIEW OF PARAMETER-EFFICIENT TRANSFER LEARNING），一个在Adapter、Prefix Tuning和LoRA之间建立联系的统一方法。</p>
<br>
<p>UniPELT（论文： UNIPELT: A Unified Framework for Parameter-Efficient Language Model Tuning）是 LoRA、Prefix Tuning和Adapter的门控组合。</p>
<br>
<h2 id="Reinforce-Learning-on-LLM">Reinforce Learning on LLM</h2>
<h3 id="LLM-DPO">LLM-DPO</h3>
<p>Direct Preference Optimization</p>
<p>DPO的核心思想是：<strong>跳过显式奖励建模和复杂的强化学习步骤，直接通过一个简单的分类损失函数来优化语言模型，使其符合人类偏好。</strong></p>
<p>它将“让模型生成高奖励的回答”这个目标，等价地转换为了“直接增大模型对‘更优回答’的生成概率，同时减小对‘较差回答’的生成概率”。</p>
<p>整个训练流程比PPO更简洁，通常只有两步：</p>
<ol>
<li><strong>监督式微调（SFT）：</strong> 与PPO的第一步完全相同。训练一个基础模型来理解指令和生成基本回答。</li>
<li><strong>直接偏好优化（DPO）：</strong> 这一步直接取代了PPO流程中的“奖励模型训练”和“PPO强化学习”两个阶段。</li>
</ol>
<hr>
<h4 id="流程"><strong>流程</strong></h4>
<p>在DPO阶段，我们不再需要Critic模型，也不需要在线采样生成数据。我们使用的是一个<strong>静态的偏好数据集</strong>。</p>
<h5 id="第一阶段：定义参与者（两大模型）"><strong>第一阶段：定义参与者（两大模型）</strong></h5>
<p>在DPO训练开始前，我们只需要两个模型：</p>
<ol>
<li>
<p><strong>策略模型（Policy Model, <code>π_θ</code>）：</strong></p>
<ul>
<li><strong>角色:</strong> 主角，即我们正在微调的语言模型。</li>
<li><strong>来源:</strong> 经过第一步SFT训练后的模型副本。</li>
<li><strong>任务:</strong> 在DPO训练中，它的参数<code>θ</code>会被更新。</li>
</ul>
</li>
<li>
<p><strong>参考模型（Reference Model, <code>π_ref</code>）：</strong></p>
<ul>
<li><strong>角色:</strong> “锚点”或“基准”。</li>
<li><strong>来源:</strong> 同样是第一步SFT模型的<strong>一个固定、不更新的副本</strong>。</li>
<li><strong>任务:</strong> 提供一个基准概率。它的作用与PPO中的参考模型完全相同：防止策略模型<code>π_θ</code>为了迎合偏好数据而偏离其原始的语言能力太远，这是一种隐式的KL散度约束。</li>
</ul>
</li>
</ol>
<h5 id="第二阶段：准备数据集"><strong>第二阶段：准备数据集</strong></h5>
<p>DPO使用的数据集格式非常关键。它不是单个的“好回答”，而是一个偏好对的集合。每一条数据包含：</p>
<ul>
<li><strong>提示（Prompt, <code>x</code>）</strong></li>
<li><strong>更优的回答（Chosen Response, <code>y_w</code>）</strong></li>
<li><strong>较差的回答（Rejected Response, <code>y_l</code>）</strong></li>
</ul>
<p>这个数据集 <code>D = &#123; (x, y_w, y_l) &#125;</code> 通常就是用来训练PPO流程中奖励模型的那个数据集。</p>
<h5 id="第三阶段：DPO训练循环"><strong>第三阶段：DPO训练循环</strong></h5>
<p>DPO的训练过程更像一个标准的监督学习循环，而不是RL的“生成-评估-更新”循环。</p>
<p>对于从偏好数据集中采样的每一个<code>(x, y_w, y_l)</code>三元组：</p>
<ol>
<li>
<p><strong>计算策略模型概率：</strong></p>
<ul>
<li>将 <code>(x, y_w)</code> 输入到<strong>策略模型 <code>π_θ</code></strong> 中，计算模型生成 <code>y_w</code> 的总对数概率：<code>log π_θ(y_w | x)</code>。</li>
<li>将 <code>(x, y_l)</code> 输入到<strong>策略模型 <code>π_θ</code></strong> 中，计算模型生成 <code>y_l</code> 的总对数概率：<code>log π_θ(y_l | x)</code>。</li>
<li><em>（这是通过对回答中的每个token的条件概率取对数再求和得到的）</em></li>
</ul>
</li>
<li>
<p><strong>计算参考模型概率：</strong></p>
<ul>
<li>将 <code>(x, y_w)</code> 输入到<strong>固定的参考模型 <code>π_ref</code></strong> 中，计算其生成 <code>y_w</code> 的总对数概率：<code>log π_ref(y_w | x)</code>。</li>
<li>将 <code>(x, y_l)</code> 输入到<strong>固定的参考模型 <code>π_ref</code></strong> 中，计算其生成 <code>y_l</code> 的总对数概率：<code>log π_ref(y_l | x)</code>。</li>
</ul>
</li>
<li>
<p><strong>计算隐式奖励的差异：</strong></p>
<ul>
<li>DPO理论证明，模型的对数概率与参考模型的对数概率之差，正比于一个隐式的奖励函数。</li>
<li>计算<code>y_w</code>的隐式奖励（或称为“偏好得分”）:<br>
<code>r_θ(x, y_w) = β * (log π_θ(y_w | x) - log π_ref(y_w | x))</code></li>
<li>计算<code>y_l</code>的隐式奖励:<br>
<code>r_θ(x, y_l) = β * (log π_θ(y_l | x) - log π_ref(y_l | x))</code></li>
<li><code>β</code> 是一个超参数，通常设为0.1到0.5之间，它控制着模型对参考模型的偏离程度。</li>
</ul>
</li>
<li>
<p><strong>计算DPO损失函数：</strong></p>
<ul>
<li>DPO的目标是让 <code>y_w</code> 的奖励远高于 <code>y_l</code> 的奖励。它使用一个类似于<strong>二元分类的逻辑损失（Logistic Loss）</strong> 来实现这个目标。</li>
<li><code>Loss_DPO = -log(σ(r_θ(x, y_w) - r_θ(x, y_l)))</code></li>
<li>其中 <code>σ</code> 是 Sigmoid 函数。</li>
<li><strong>直观理解：</strong> 这个损失函数的目标是最大化 <code>r_θ(x, y_w)</code> 和 <code>r_θ(x, y_l)</code> 之间的差值。当策略模型赋予<code>y_w</code>的相对概率（相对于参考模型）远高于<code>y_l</code>时，损失就会变小。</li>
</ul>
</li>
<li>
<p><strong>反向传播与优化：</strong></p>
<ul>
<li>计算 <code>Loss_DPO</code> 相对于<strong>策略模型 <code>π_θ</code></strong> 参数的梯度。</li>
<li>使用AdamW等优化器更新<strong>策略模型 <code>π_θ</code></strong> 的参数。</li>
<li><strong>注意：参考模型 <code>π_ref</code> 的参数始终不更新。</strong></li>
</ul>
</li>
</ol>
<p>通过在整个偏好数据集上重复这个过程，策略模型 <code>π_θ</code> 会被直接优化，使其倾向于生成更符合人类偏好的回答。</p>
<br>
<h3 id="LLM-PPO">LLM-PPO</h3>
<p><a href="https://arxiv.org/abs/2203.02155">https://arxiv.org/abs/2203.02155</a></p>
<img src="/2025/03/19/LLM-Rela/image-20250325131654259.png" class="" title="image-20250325131654259">
<br>
<h4 id="流程-2"><strong>流程</strong></h4>
<p>我们可以将整个流程更清晰地划分为**“角色定义”<strong>、</strong>“数据生成（Rollout）”<strong>和</strong>“模型学习（Learning）”**三个阶段。</p>
<h5 id="第一阶段：定义参与者（四大模型）"><strong>第一阶段：定义参与者（四大模型）</strong></h5>
<p>在PPO训练循环开始前，我们有四个关键的模型，其中三个是神经网络：</p>
<ol>
<li>
<p><strong>Actor (策略模型 / Policy):</strong></p>
<ul>
<li><strong>角色:</strong> 主角，即我们正在微调的语言模型。</li>
<li><strong>来源:</strong> 经过第一步SFT（监督式微调）训练后的模型副本。</li>
<li><strong>任务:</strong> 根据当前状态 <code>s_t</code>（已生成的文本），生成下一个token <code>a_t</code>。</li>
</ul>
</li>
<li>
<p><strong>Reference Model (参考模型):</strong></p>
<ul>
<li><strong>角色:</strong> “锚点”或“约束器”。</li>
<li><strong>来源:</strong> 同样是第一步SFT模型的<strong>一个固定、不更新的副本</strong>。</li>
<li><strong>任务:</strong> 提供一个基准的概率分布 <code>π_ref(a|s_t)</code>，用于计算KL散度，防止Actor为了追求奖励而“走火入魔”，生成不自然或语法混乱的文本。</li>
</ul>
</li>
<li>
<p><strong>Critic (价值模型 / Value Network):</strong></p>
<ul>
<li><strong>角色:</strong> “评估员”或“裁判”。</li>
<li><strong>来源:</strong> 通常用RM的头部或SFT模型的头部初始化，然后与Actor一起在PPO阶段训练。</li>
<li><strong>任务:</strong> 评估当前状态 <code>s_t</code> 的<strong>潜在价值</strong> <code>V(s_t)</code>，即从这个状态开始，预期未来能获得多少总奖励。它的存在是为了减少策略梯度更新的方差（通过计算优势函数）。</li>
</ul>
</li>
<li>
<p><strong>Reward Model (奖励模型 / RM):</strong></p>
<ul>
<li><strong>角色:</strong> “最终裁判”，定义了优化的最终目标。</li>
<li><strong>来源:</strong> 第二步训练好的人类偏好模型，在PPO阶段<strong>保持固定，不更新</strong>。</li>
<li><strong>任务:</strong> 对一个<strong>完整的</strong>生成序列（prompt + response）给出一个标量分数 <code>R_final</code>，代表人类对这个回答的偏好程度。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="第二阶段：数据生成（Rollout-Phase）"><strong>第二阶段：数据生成（Rollout Phase）</strong></h5>
<p>对于一个从数据集中采样的 <code>prompt</code>，我们执行一次完整的序列生成来收集训练数据。</p>
<ol>
<li>
<p><strong>初始化:</strong> 从一个 <code>prompt</code> 开始，得到初始状态 <code>s_0</code>。</p>
</li>
<li>
<p><strong>逐Token生成循环 (For t = 0, 1, …, T-1):</strong></p>
<ul>
<li><strong>动作 (Action):</strong> Actor模型接收当前状态 <code>s_t</code>，输出概率分布 <code>π_actor(·|s_t)</code>，并从中<strong>采样</strong>一个token <code>a_t</code>。</li>
<li><strong>记录 (Log):</strong> 记录Actor输出该token的对数概率 <code>log π_actor(a_t|s_t)</code>。</li>
<li><strong>价值评估 (Value Estimation):</strong> Critic模型评估当前状态的价值 <code>V(s_t)</code>。</li>
<li><strong>计算即时奖励 (Immediate Reward):</strong> 这里的奖励<strong>主要不是来自RM</strong>。
<ul>
<li><strong>KL惩罚:</strong> 计算Actor策略与Reference策略在当前步的KL散度，作为惩罚项。<br>
<code>r_t = -β * log(π_actor(a_t|s_t) / π_ref(a_t|s_t))</code></li>
<li><code>β</code> 是一个控制KL惩罚力度的超参数。这个 <code>r_t</code> 是每一步都会计算的。</li>
</ul>
</li>
<li><strong>状态转移:</strong> 将新生成的token <code>a_t</code> 添加到序列中，得到新状态 <code>s_&#123;t+1&#125;</code>。</li>
<li><strong>存储经验:</strong> 将元组 <code>(s_t, a_t, r_t, V(s_t), log π_actor(a_t|s_t))</code> 存储起来。</li>
</ul>
</li>
<li>
<p><strong>最终奖励计算 (Final Reward):</strong></p>
<ul>
<li>当生成结束（例如遇到EOS token或达到最大长度）时，我们得到了一个完整的回答。</li>
<li>将完整的（<code>prompt</code>, <code>response</code>）输入到<strong>Reward Model (RM)</strong> 中，获得最终的标量奖励 <code>R_final</code>。</li>
<li>将这个最终奖励 <strong>加到最后一步的即时奖励 <code>r_T</code> 上</strong>。所以，<code>r_T</code> 变为 <code>r_T (KL惩罚) + R_final</code>。</li>
<li><strong>关键点:</strong> 只有在序列结束时，RM才提供一次性的、整体的奖励信号。而KL惩罚是贯穿于每一步的。</li>
</ul>
</li>
</ol>
<p>至此，我们收集到了一条完整的轨迹（trajectory）。</p>
<hr>
<h5 id="第三阶段：模型学习（Learning-Phase）"><strong>第三阶段：模型学习（Learning Phase）</strong></h5>
<p>利用收集到的轨迹数据，我们来更新Actor和Critic模型。</p>
<ol>
<li>
<p><strong>计算优势函数 (Advantage Estimation):</strong></p>
<ul>
<li>使用收集到的奖励 <code>r_t</code> 和价值估计 <code>V(s_t)</code>，通过**广义优势估计（GAE）**算法计算每一步的优势 <code>A_t</code>。</li>
<li>GAE能有效平衡偏差和方差，稳定训练过程。<code>A_t</code> 直观地表示了在状态 <code>s_t</code> 选择动作 <code>a_t</code> 相对于平均水平有多好。</li>
</ul>
</li>
<li>
<p><strong>更新Actor (策略模型):</strong></p>
<ul>
<li>使用计算出的优势 <code>A_t</code> 和之前记录的 <code>log π_actor(a_t|s_t)</code>，构造PPO的<strong>裁剪代理目标函数（Clipped Surrogate Objective）</strong>。</li>
<li>通过梯度上升（最大化目标函数）来更新Actor模型的参数。PPO的裁剪机制确保了每次更新的步子不会太大，从而保证了训练的稳定性。</li>
</ul>
</li>
<li>
<p><strong>更新Critic (价值模型):</strong></p>
<ul>
<li>Critic的目标是更准确地预测未来的回报。</li>
<li>构造一个损失函数，通常是<strong>均方误差（MSE）</strong>，使其预测的价值 <code>V(s_t)</code> 尽可能接近于在该步之后实际观察到的累积回报（也称为Returns）。</li>
<li>通过梯度下降来更新Critic模型的参数。</li>
</ul>
</li>
</ol>
<br>
<h4 id="相关内容">相关内容</h4>
<p><strong>SFT LLM</strong></p>
<p>train Reward Model</p>
<img src="/2025/03/19/LLM-Rela/image-20250325151928459.png" class="" title="image-20250325151928459">
<p>use LLM_sft to be the Actor(reference model)</p>
<img src="/2025/03/19/LLM-Rela/image-20250325153214542.png" class="" title="image-20250325153214542">
<img src="/2025/03/19/LLM-Rela/image-20250325153304648.png" class="" title="image-20250325153304648">
<br>
<p><strong>PPO架构</strong></p>
<img src="/2025/03/19/LLM-Rela/image-20250325153337812.png" class="" title="image-20250325153337812">
<blockquote>
<p>广义优势GAE为多步时序差分的指数加权平均，详见reinforce-learning-record，参数含Value值和Reward值</p>
</blockquote>
<p><strong>为什么引入KL散度项？</strong></p>
<p>这个KL项有两个作用。首先，它作为一种熵奖励，鼓励策略进行探索，防止其坍缩到单一模式。其次，它确保策略不会学习生成与奖励模型在训练期间见过的输出差异过大的结果。</p>
<ul>
<li>在 RLHF 中，PPO 策略在优化过程中可能会偏离初始 SFT 模型太远，导致“灾难性遗忘” (catastrophic forgetting)，即模型忘记了 SFT 阶段学到的通用语言能力或指令遵循能力，过度追求奖励信号。PPO 通常会加入一个 KL 散度惩罚项来约束当前策略与 SFT 模型的距离。</li>
</ul>
<br>
<h3 id="LLM-GRPO">LLM-GRPO</h3>
<p>Group Relative Policy Optimization</p>
<ul>
<li>
<p>一个问题，多个回答</p>
</li>
<li>
<p>reward = Model + Rules -&gt; reward (仍然是对每句话给出)</p>
</li>
<li>
<p>advantage = $\frac{r - mean}{std}$</p>
</li>
<li>
<p>优化公式变化</p>
</li>
</ul>
<br>
<h4 id="相关内容-2">相关内容</h4>
<img src="/2025/03/19/LLM-Rela/image-20250325195333997.png" class="" title="image-20250325195333997">
<p>由于PPO算法中使用的价值函数通常是与策略模型规模相当的另一个模型，这会带来巨大的内存和计算负担。此外，在强化学习训练过程中，价值函数被作为计算优势函数（advantage）的基线以实现方差缩减。然而在大型语言模型（LLM）场景中，通常只有最后一个token会被奖励模型分配奖励分数，这可能导致对每个token都精确建模价值函数的训练变得复杂。为解决这一问题，如图4所示，我们提出了组相对策略优化（Group Relative Policy Optimization, GRPO）</p>
<p>每一个 $o_g $为策略模型对于输入 $q$ 的输出，每一个 $r_g$ 为 RM 对 每一个 $o_g$ 的评分</p>
<img src="/2025/03/19/LLM-Rela/image-20250325201341810.png" class="" title="image-20250325201341810">
<img src="/2025/03/19/LLM-Rela/image-20250901113222981.png" class="" title="image-20250901113222981">
<img src="/2025/03/19/LLM-Rela/image-20250325201533207.png" class="" title="image-20250325201533207">
<br>
<p>GRPO 的奖励（Reward）和优势（Advantage）是在序列层面（per-sequence）计算的，但在应用这个优势进行策略更新时，其目标函数是在词元层面（per-token）上定义的。</p>
<p><strong>奖励和优势的计算：序列级 (Per-Sequence)</strong></p>
<ul>
<li><strong>单一奖励</strong>：首先，模型针对一个问题 <code>q</code> 生成一个<strong>完整的</strong>输出序列 <code>o_i</code>。然后，一个奖励模型会评估这<strong>整个</strong>序列，并给出一个<strong>单一的、整体的</strong>奖励分数 <code>r_i</code>。</li>
<li><strong>单一优势</strong>：接着，算法会比较一组（G个）输出序列的奖励，计算出每个序列 <code>o_i</code> 的<strong>单一优势值 Â_i</strong>。这个优势值代表了序列 <code>o_i</code> 相对于同组其他序列的优劣程度。</li>
</ul>
<p>到此为止，所有的评估都是在序列（sequence）层面完成的。我们得到了一个适用于整个序列 <code>o_i</code> 的功劳/惩罚信号 <code>Â_i</code>。</p>
<p><strong>目标函数的计算：词元级 (Per-Token)</strong></p>
<p>现在，如何用这个序列级的优势 <code>Â_i</code> 来更新模型参数呢？这里就是词元级计算发挥作用的地方，也是第三张图中公式的核心。</p>
<ul>
<li>
<p><strong>广播优势 (Broadcast Advantage)</strong>：算法将序列级的优势值 <code>Â_i</code> <strong>“广播”或复制</strong>给该序列中的<strong>每一个词元 (token)</strong>。也就是说，对于序列 <code>o_i</code> 中的所有时间步 <code>t</code> (从1到序列长度 <code>|o_i|</code>)，我们设定 <code>Â_&#123;i,t&#125; = Â_i</code>。这意味着，如果一个序列是好的（<code>Â_i</code> &gt; 0），那么构成这个序列的<strong>每一个词元</strong>都被认为是“有功劳的”；反之亦然。</p>
</li>
<li>
<p><strong>词元级概率比 (Per-Token Policy Ratio)</strong>：在目标函数内部，计算的是<strong>每个词元</strong>的概率比：<code>π_θ(o_&#123;i,t&#125; | q, o_&#123;i,&lt;t&#125;) / π_θ_old(o_&#123;i,t&#125; | q, o_&#123;i,&lt;t&#125;)</code>。这衡量了新策略相比于旧策略，在特定上下文中生成特定词元 <code>o_&#123;i,t&#125;</code> 的概率变化。</p>
</li>
<li>
<p><strong>累加和平均 (Summation and Average)</strong>：如公式所示，最终的目标函数 <code>J_GRPO(θ)</code> 是对一个序列中<strong>所有词元的损失进行求和，然后再取平均</strong> (<code>1/|o_i| * Σ_&#123;t=1 to |o_i|&#125;</code>)。每个词元的损失都是用 PPO 的 <code>min-clip</code> 形式，乘以<strong>被广播过来的那个相同的优势值 <code>Â_&#123;i,t&#125;</code></strong> 来计算的。</p>
</li>
</ul>
<br>
<p>过程监督与结果监督</p>
<ol>
<li>结果监督 (Outcome Supervision)</li>
</ol>
<p>这部分描述的就是我们之前一直在讨论的标准 GRPO 模式。明确指出，优势值 <code>Â_&#123;i,t&#125;</code> 是为<strong>所有词元 (all tokens)</strong> 设置的。所有这些词元的优势值都被设置成了<strong>同一个值</strong>——即整个序列的归一化奖励 <code>r̃_i</code>。一个在<strong>序列层面</strong>计算出的单一评估值（这里的归一化奖励 <code>r̃_i</code>，也就是优势），被<strong>复制或广播</strong>给了构成该序列的<strong>每一个词元</strong>。</p>
<ol start="2">
<li>过程监督 (Process Supervision)</li>
</ol>
<p>这一节作为对比，描述了一种更复杂的、<strong>非广播</strong>的模式：</p>
<ul>
<li><strong>奖励</strong>：奖励是在<strong>每一步 (each reasoning step)</strong> 提供的，而不是只在最后。</li>
<li><strong>优势</strong>：每个词元的优势 <code>Â_&#123;i,t&#125;</code> 是通过计算<strong>其后所有步骤</strong>的奖励之和来得到的 (<code>Σ_&#123;index(j)≥t&#125;</code>…)。</li>
</ul>
<p>在这种模式下，一个序列中不同位置的词元 <code>t</code> 会有<strong>不同</strong>的优势值 <code>Â_&#123;i,t&#125;</code>。这与传统的强化学习中的回报（Return）计算方式更相似。</p>
<img src="/2025/03/19/LLM-Rela/image-20250325202638658.png" class="" title="image-20250325202638658">
<br>
<h3 id="LLM-GSPO">LLM-GSPO</h3>
<p><strong>单一的重要性权重 (Single Importance Weight)</strong>: <code>s_i(θ)</code> 是为<strong>一整个序列 <code>y_i</code></strong> 计算出来的一个<strong>标量值</strong>。它首先计算整个序列的新旧策略概率比，然后进行长度归一化。</p>
<p><strong>没有词元级求和 (No Per-Token Summation)</strong>: 在 <code>min(...)</code> 这个核心计算部分，<strong>没有任何对序列内部词元 <code>t</code> 的求和符号 <code>Σ_t</code></strong>。目标函数直接将序列级的权重 <code>s_i(θ)</code> 与序列级的优势 <code>Â_i</code> 相乘。</p>
<p><strong>将序列视为一个整体</strong>: 整个优化过程将每个输出序列 <code>y_i</code> 视为一个不可分割的整体数据点。优化目标是提高那些具有正优势值的<strong>完整序列</strong>的生成概率（由 <code>s_i(θ)</code> 体现），同时通过 <code>clip</code> 函数加以限制。</p>
<img src="/2025/03/19/LLM-Rela/image-20250901105613345.png" class="" title="image-20250901105613345">
<p>以优秀的回复 <strong>y₁</strong> 为例：</p>
<p><code>s₁(θ)</code> = (新模型 <code>π_θ</code> 生成 y₁ 的概率 / 旧模型 <code>π_θold</code> 生成 y₁ 的概率) ^ (1 / y₁的长度)</p>
<ul>
<li><strong>概率比值</strong>：假设我们的新模型 <code>π_θ</code> 经过初步学习，现在生成 y₁ 的概率比旧模型高了一点。比如，概率比值是 1.15。</li>
<li><strong>长度归一化</strong>：公式右上角的 <code>1/|y_i|</code> 是长度归一化。 这么做的目的是为了消除句子长度对结果的影响，使得长句子和短句子的比例值可以在一个统一的范围内比较，从而降低方差，让训练更稳定。</li>
<li>假设经过长度归一化后，我们得到 <code>s₁(θ) = 1.1</code>。</li>
</ul>
<p>同样，对于糟糕的回复 <strong>y₃</strong>，新模型可能更不倾向于生成它，所以 <code>s₃(θ)</code> 可能是一个小于1的数字，比如 0.9。</p>
<br>
<h2 id="附录">附录</h2>
<h3 id="为什么Qwen3-0725放弃了thinking-fusion">为什么Qwen3 0725放弃了thinking fusion?</h3>
<p>以下是结合相关技术分析，对这种“单一模型+特殊令牌”实现方式存在问题的深入探讨：</p>
<p><strong>性能稀释与参数冲突 (Performance Dilution &amp; Parameter Conflict)</strong></p>
<p>这是最根本的问题。一个模型的参数（权重）需要同时学习两种截然不同的任务模式：</p>
<ul>
<li><strong>“指令”模式 (Non-thinking):</strong> 目标是<strong>简洁、直接、高效</strong>。它需要模型学习遵循指令、提取信息、保持风格，并快速生成符合人类交流习惯的答案。这部分训练会惩罚冗余和啰嗦。</li>
<li><strong>“思考”模式 (Thinking):</strong> 目标是<strong>严谨、深入、逻辑自洽</strong>。它需要模型学习逐步分解问题、进行符号推理、验证中间步骤，并最终得出结论。这部分训练会奖励详细的、展示推理过程的输出。</li>
</ul>
<p>让同一组神经网络参数去同时精通这两种互有冲突的目标，就像要求一位短跑冠军同时也是一位马拉松冠军。虽然可能做到“两边都还不错”，但很难在任何一个项目上都达到世界顶尖水平。模型有限的“能力带宽”（parameter capacity）会被分散，导致：</p>
<ul>
<li>在需要简洁回答时，可能仍然会残留一些推理的痕迹，不够直接。</li>
<li>在需要复杂推理时，为了兼顾简洁性，其推理的深度和严谨性可能会受到限制。</li>
</ul>
<p>最终结果是两种模式的性能都无法达到极致，是一种“折衷”而非“最优”。</p>
<p><strong>训练目标与优化难题 (Conflicting Training Objectives)</strong></p>
<p>在模型的训练阶段，尤其是RLHF（基于人类反馈的强化学习）阶段，这种冲突会变得更加尖锐。</p>
<ul>
<li>对于一个需要快速回答的问题，人类标注员会给简洁、直接的答案打高分。</li>
<li>对于一个复杂的数学题，标注员会给详细、步骤正确的“思考链”答案打高fen。</li>
</ul>
<p>当模型面对这些混合在一起的反馈信号时，其优化过程会感到“困惑”。优化算法（如PPO）很难找到一个能同时满足这两个矛盾目标的“最优策略”。这可能导致训练不稳定，或者模型最终学到一种“四不像”的中间策略。</p>
]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>Python, Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>QuestionBank</title>
    <url>/2025/02/03/QuestionBank/</url>
    <content><![CDATA[<p>夺命连环问！</p>
<span id="more"></span>
<h1>Java Question Bank</h1>
<blockquote>
<p>以下问题为转载，提供答案为AI生成，仅作参考和可能提问范围学习</p>
</blockquote>
<p>ref: <a href="https://www.v2ex.com/t/1106872">https://www.v2ex.com/t/1106872</a></p>
<h2 id="问题">问题</h2>
<p>HashSet 的底层实现说下？为什么内置 HashMap ？说下它的数据结构，为什么 loadFactor 是 0.75 ？你说泊松分布，什么是泊松分布？为什么要高位参与与运算？为什么它的 size 是 2 的 n 次方？为什么默认是 16 ？讲下它的扩容机制。什么时候转红黑树，为什么要转红黑树？为什么它是线程不安全的，它的哪些方法是线程不安全的？为什么会造成死循环？ 1.8 是如何解决这个问题的？它的线程安全的实现有什么？ ConcurrentHashMap 和 HashTable 有什么区别？说下它 1.7 和 1.8 的实现是什么？有什么区别？为什么要这么做？为什么说 ConcurrentHashMap 是线程安全的？它的 get 操作是有锁的吗？它是强一致性的吗？它为什么是弱一致性的？ ConcurrentHashMap 1.7 和 1.8 是如何扩容的？ sizeCtl 参数是干什么的，讲讲变换过程？为什么要用 volatile 修饰？说说它的功能？什么是 MESI 协议？ CPU 原语是什么？什么是可见性？ JMM 说说是什么？为什么要有 JMM ？ Happened-before 是什么？它和 synchronized 的区别是什么？锁的升级与降级说下是什么？自旋锁是什么？偏向锁是什么？ Mark-Word 说下？锁的粒度是什么？锁消除了解吗？锁会被合并吗？什么时候会发生？你刚才说了 CAS ，你能说下它是什么东西吗？为什么要引入 CAS ？ ABA 问题是如何解决的？ AQS 了解吗？它是如何实现的？ CLH 又是什么？ ReentrantLock 和 synchronized 区别是什么？为什么 ReetrantLock 能实现公平锁？默认构造器是公平锁吗？为什么不是？ Copy-on-Write 了解吗？ Fork/Join 又是什么？什么是线程，什么是协程？你刚才说了管程？你能说下这几个到底是做什么的吗？线程池说下参数，四种内置的拒绝策略，以及它的执行流程。你用过吗？为什么要这么设置参数？ I/O 密集型应用和计算密集型应用如何设置其参数？你具体的业务线程池的参数是怎么设计的？为什么？测过吗？你定制化开发过吗？线程池预留了 3 个供子类扩展的方法你知道是哪三个吗？能做什么你知道吗？ ThreadLocal 是什么？它为什么会造成内存泄漏？你实际开发中用到过吗？ Spring 事务用这个干什么的？什么是 Spring 事务的 SavePoint ？你知道死锁吗？如何解决死锁？ sleep 和 wait 的区别是什么？ BIO 、NIO 、AIO 是什么？说下区别，以及如何使用？了解 Netty 吗？如何解决粘包问题？ ChannelPipeline 又是什么？ ByteBuf 知道吗？读写指针又是什么？为什么要用它，解决了 NIO 类库的 ByteBuffer 什么问题？它和 mina 的区别是什么？它的 Zero-Copy ？了解过 FastThreadLocal 吗？它为什么比 ThreadLocal 快？有看过其中源码吗？ Netty 解决了 NIO 类库的什么问题？空轮询又是什么？ RPC 又是什么？序列化和反序列化又是什么？几个核心抽象说下。是干什么的？讲讲 Netty 的线程模型。</p>
<p>你说你了解虚拟机，你知道虚拟机的运行时数据区吗？哪些是线程共享的，哪些是线程独有的？你了解 JVM 调优吗？调优过吗？为什么要这么设置？垃圾回收算法有几种？为什么要分代收集？ Young 区说说它的分布结构，为什么 Eden 区 80%？为什么大对象直接进入老年代？控制的参数是什么？一个对象如果不是大对象，怎样才能进入老年代？控制的参数是什么？什么时候会发生 OOM ？你遇到过吗？怎么解决的？为什么低版本的 JDK 要把永久代内存调大点？默认大小是多少你知道吗？什么是 Major GC ，什么是 Minor GC ？什么情况下会频繁 GC ？你查看过 GC 日志吗？什么时候回收对象？引用计数和可达性分析是什么？为什么 Java 使用后者？ Python 使用前者？什么是 GCRoot ？什么类型的对象可以作为 GCRoot ？什么时候对象不可达？ Java 的四种引用说下，分别用在什么场景？你知道 JDK 源码哪里有用到 WeakReference 吗？什么是 STW ？什么是 Safepoint ？类加载的过程说下，什么时候优化，以及不同的阶段的主要优化是什么？解语法糖是什么时候？为什么在编译的时候解语法糖？什么是双亲委派模型？可以破坏吗？各个 ClassLoader 加载哪部分类的？你自定义过 ClassLoader 吗？你说你用过 Jstack 诊断 CPU 使用率飙升的情况，说下具体步骤？ Arthas 用过吗？ Class 文件格式说下，什么是魔数，Class 文件的魔数是什么？ JMX 了解吗？生产上有碰到过虚拟机的问题吗？怎么解决的？</p>
<p>ACID 说下是什么，如何实现的？你说你优化过 SQL ，怎么优化的说下。like ‘%xx%’，like ‘%xx’，like ‘xx%’ 哪种情况会用到索引，为什么？说下 MySQL 执行流程。WAL(Write-Ahead Logging) 知道吗？ redo log 和 undo log 是什么，它们作用说下。你说你改过 buffer_pool_size 等参数，为什么要改它？它里面的数据结构说下是什么？为什么冷热 3:7 ？ join_buffer 你说你也改了，为什么？什么是驱动表和被驱动表？如何优化？你说你建了索引，什么是蔟集索引，什么是非蔟集索引？什么是回表？什么时候会索引失效？你的二级索引什么用得多？为什么优先使用普通索引，而不是唯一索引？ MySQL 会死锁吗？什么是间隙锁？它会导致什么问题？ MVCC 说下是什么？ 4 种事务说下是什么？哪种或者哪几种事务隔离级别能避免幻读？能避免脏读？你说你还开启了 binlog ，能说说是什么吗？ binlog 有几种格式？你选的是哪个？为什么？ canal 用过吗？说说它的原理。MySQL 主从模式如何开启？你是如何优化 SQL 的？上亿级别的数据你是如何优化分页的？为什么不建议在 MySQL 中使用分区机制？几个主要的线程说下它们是什么？做什么的？ MySQL 读写了解吗？如何实现的？能做到强一致性吗？为什么？为什么删了数据还是磁盘空间不变？自增主键用完了会怎么样？如何解决这个问题？自增主键什么时候是不连续的？这样做的好处是什么？为什么推荐用自增主键？ B+ Tree 又是什么？如何迁移数据库？为什么不建议使用外键？在高版本的 MySQL 中 count(1) 和 count(*) 区别是什么？ order by 是如何工作的？分页机制又是什么？ ACL 和 RBAC 是什么？ PBAC 和 ABAC 知道吗说下？ grant 之后一定要刷新吗？视图用过吗？它的作用说下。视图和表的区别说下。存储过程写过吗？存储函数和存储过程的区别说下。为什么要分库分表？分库分表如何做到动态缩容/扩容？ NoSQL 用过吗？ OceanBase 了解吗？ HBase 了解吗？ HBase 有哪些坑，你碰到过吗？什么是 RegionServer ？什么时候用 NoSQL ，它能取代 RDBMS 吗？你说你用过 Elasticsearch ，能说下它的请求执行过程吗？它的总体架构说下，画一下。它的插件你用过吗？你们的分词策略是什么？倒排索引说下是什么。</p>
<p>线程和进程说下区别？线程的几种状态说下。Java 中的线程和操作系统的线程关系？动态内存分配和回收策略是什么？什么是空闲列表和指针碰撞？具体用什么数据结构存的？什么时候用它们？空闲列表四种策略说下。Page Cache 知道吗，说说它的作用。Redis 和 Kafka 中间件如何通过 Page Cache 来优化？哪些类型会导致内存泄漏？ TCP 和 HTTP 是什么？它们之间的关系说下。OSI 七层是哪七层？分别是干什么的？ TCP 和 UDP 区别是什么？什么时候会导致 TCP 抖动？ TCP 是如何保证稳定的？我就要用 UDP ，如何使它和 TCP 一样能保证数据到达？ CPU 是如何执行任务的？你知道 numa 架构吗？哪些中间件可以通过这个来怎么优化？为什么绑核能优化？什么是 Zero-Copy ？你用的中间件中有哪些用到了这个特性？内核态和用户态是什么？硬件你了解过吗？什么是 x86 ？什么是 ARM ？你说精简指令集？它精简了什么？ ARM 架构的 CPU 是什么样的？画一下。M1 芯片为什么这么快，有了解吗？ 5G 有了解吗？有点题外话了，最后问你个问题，你说你是软件通信工程，通信学的什么？选修了什么？通信是学硬件吗？光纤为什么这么快？ 8 根线和 4 根线区别？傅立叶变换说下是什么？数字信号模拟信号？你大学在班级定位？前几？</p>
<p>Redis 它的 5 种基础类型和 6 个数据结构说下。HyperLogLog 、BitMap 、GEO 、Stream 有接触过吗？什么时候用这些特殊数据结构？跳表又是什么，画一下？为什么使用跳表？为什么不用红黑树？全局 Hash 表又是什么？如何扩容的？什么是渐进式 rehash ？ Redis 怎么做到的？ IO 多路复用是什么？多路是什么？复用了什么？ AOF 和 RDB 又是什么？为什么 Redis 没有实现 WAL 机制？ AOF 持久化策略有哪三种？你们是怎么选的？ AOF 什么时候重写？为什么重写？主从复制用到了哪种日志？主从复制过程说下。主从复制什么时候增量，什么时候全量？第一次连接时，网络中断了怎么办？ Redis 主从是什么？主从从又是什么？为什么主从从可以减少主库压力？从库可以设置可写吗？从库可写会带来什么问题？主从什么时候会导致数据丢失？ Redis 十万并发能支撑住吗？如何支撑十万以上并发？为什么操作大对象支持不了十万并发？ Redis Cluster 是什么？ 你说到了 CRC16 ，你知道一致性哈希算法吗，能说下是什么吗？你说虚拟节点，说下如何实现？ Codis 了解吗？你们的 Redis 集群方案是什么？ Redis 是如何保证高可用的？哨兵机制了解吗？什么是主观下线什么是客观下线？选主的四个筛选条件优先级的条件依次递减分别是什么？打分又是什么？如何打分？缓存击穿、缓存雪崩、缓存穿透说下？如何解决？布隆过滤器又是什么？能手写个布隆过滤器吗？数据倾斜知道吗，如何解决？分布式锁了解过吗？讲讲分布式锁实现原理？ Redisson 源码看过吗？它是如何实现的分布式锁？ Lua 脚本保证原子性吗？分布式锁需要注意哪四个问题？ Redis 事务说下。缓存污染知道是什么吗？如何淘汰数据的？分别是哪八种策略？ Redis 对 lru 做了什么改变吗？ lfu 又是什么？ Redis 做了什么优化？ Redis 多线程是什么多线程？默认开启吗？你们生产中用了吗？ Redis 6 还有什么新特性？自定义过 Redis 数据类型吗？自定义过 Redis 命令吗？如何解决数据库和缓存数据不一致问题？ Pika 知道吗？ Tendis 和它的区别？如何实现一个 Key 千万并发？（这个有个群的群友的 Zoom 面试题）</p>
<p>消息中间件解决了哪几个问题？简单介绍下你用的 Kafka 。从 Topic -&gt; Record&lt;Key,Value&gt; -&gt; Producer -&gt; acks -&gt; Interceptor -&gt; Broker -&gt; Page Cache -&gt; Controller -&gt; Coordinator -&gt; Partition -&gt; Replica -&gt; Leader Replica -&gt; Follower Replica -&gt; ISR -&gt; Unclean Leader Election -&gt; Consumer -&gt; Consumer Group -&gt; Consumer Offset -&gt; Consumer Group Offset -&gt; Idempotence -&gt; Transaction -&gt; Rebalance -&gt; High Watermark -&gt; Log Deletion -&gt; Leader Epoch -&gt; LEO -&gt; Zero Copy -&gt; Consumer Heartbeat -&gt; Zookeeper 到这结束。它和 RocketMQ 、RabbitMQ 有什么区别？什么时候消息会丢失？ Producer 网络抖动后，它的消息在哪存着，内存还是磁盘还是哪里？ Producer 和 Consumer 什么时候建立的 TCP 连接？为什么这么做？ Consumer 为什么要采取 pull 的方式？ Producer 为什么采用 push 的方式？为什么用 TCP 不用 HTTP ？高水位、LEO 是什么？ Lead Epoch 知道吗？幂等性是如何实现的？说下 Kafka 事务，Kafka 事务实现的事务隔离级别？什么时候触发 Rebalance ？如何避免？如何指定发送消息到指定 Partition ？消息交付可靠性保障承诺三个说下，以及 Kafka 是如何实现它们的？哦，你说精准一次，怎么实现的？根据消息数以及消息大小，计算需要多少磁盘容量和带宽。Kafka 的 JVM 参数调优说下。JMS 了解吗？</p>
<p>Spring Bean Scope 说下。Spring 的注入方式有几种，为什么推荐用构造器注入？@Resource 和 @<a href="https://www.v2ex.com/member/Autowired">Autowired</a> 区别说下。什么是 IoC 和 AOP ？ Spring 解决了什么？@Bean 和 @<a href="https://www.v2ex.com/member/Component">Component</a> 区别说下。Spring Bean 的生命周期说下。Spring AOP 原理，各种 Advice 和 Advisor 说下。AOP 的两种代理方式是什么？ AOP 一般作用说下。三级缓存解决循环依赖的过程说下。Spring 的事务传播行为说下。Spring 事务隔离级别说下。Spring 事务实现原理。Spring 用到了哪些设计模式，能分别讲讲它是如何实现的吗，具体是哪些类？ BeanFactory 和 ApplicationContext 说下区别。说下 BeanFactory 和 FactoryBean 区别？ BeanPostProcessor 和 BeanFactoryPostProcessor 区别是什么？ Spring 事件知道吗？ Spring 如何自定义 XML 解析？各种 Smart 开头的 Bean 的前置处理器，什么时候被调用，你知道吗？ Spring Cache 是如何实现的？ Spring Data JPA 呢？ 注解扫描如何实现的，你能手写个吗？写过 Spring 的插件吗？如何实现的？代码开源了吗？</p>
<p>Spring MVC 执行流程说下。 @<a href="https://www.v2ex.com/member/RestController">RestController</a> 和 @<a href="https://www.v2ex.com/member/Controller">Controller</a> 区别说下。怎么取得 URL 中的 { } 里面的变量？ Spring MVC 和 Struts2 比有什么优点？ Spring MVC 怎么样设定重定向和转发的？说下 Spring MVC 的常用注解。如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？ Interceptor 和 Filter 区别？ Spring MVC 的异常处理 ？怎样在方法里面得到 Request ，或者 Session ？ Spring MVC 中函数的返回值是什么？怎么样把 ModelMap 里面的数据放入 Session 里面？ Spring MVC 的控制器是不是单例模式,如果是,有什么问题,怎么解决？ Spring MVC 的 RequestMapping 的方法是线程安全的吗？为什么？介绍下 WebApplicationContext 。跨域问题如何解决？如何解决全局异常？ validation 有了解吗？用过吗？ Json 处理如何实现的？哦，你刚才说了父子容器，能讲讲什么是父子容器吗？ Spring MVC 国际化有了解过吗？怎么实现的</p>
<p>Spring Boot 是如何实现自动装配的？运行 Spring Boot 有几种方式？ Spring Boot Starter 工作原理。Spring Boot 核心注解说下。 @<a href="https://www.v2ex.com/member/Enable">Enable</a> 类型注解是如何实现的？@Conditional 类型注解呢？自定义过吗？说下异步调用 @<a href="https://www.v2ex.com/member/Async">Async</a> 。什么是 YAML ？ Spring Boot Profiles 如何实现的？ bootstrap.properties 和 application.properties 说下区别。Spring Boot 事件和 Spring 事件有什么关系？ Spring Boot Actuator 了解过吗？说一下。Spring Batcher 用过吗，说下。Spring Boot 是如何实现内嵌 Servlet 容器的，在哪行代码启动的？ Spring Boot 完美实现了模块化编程，你认同吗？</p>
<p>Spring Cloud Netflix 听说你了解。画一下 Spring Cloud Netflix 架构图。说说 Eureka 默认多少秒发送心跳？增量还是全量？ CP 还是 AP ？如何防止脑裂的？二级缓存知道吗？ Eureaka 的自我保护模式说下。ServiceInstance 和 DiscoryClient 知道吗？是干嘛的？分布式事务除了两段提交，还有什么实现方式？哦，你说 Saga ，Saga 你说下是什么？ Ribbon 是什么说一下，它解决了什么问题？ Feign 又是什么？它和 Ribbon 什么关系？ Dubbo 和 Feign 区别？ Dubbo 的 SPI 知道吗？ Zuul 是什么？它和 Nginx 有什么区别？除了 Zuul 还有什么网关可选？ Hystrix 是什么？它是如何实现的？熔断、降级和限流他们的区别说一下。Hystrix 信号量机制，隔离策略细粒度控制如何做的？了解过他们的源码实现吗？看过源码吗？你优化过吗？微服务十一点说一下分别是什么？分布式配置中心有哪些？你们用的 Apollo 还是 Spring Config 还是其他的？为什么？服务监控有了解吗？什么是幂等？如何实现接口幂等？如何实现分布式 Session ？有更好的方法吗？哦，你说了 JWT ，能详细说下吗？不同系统的间授权的 OAuth2 了解吗？</p>
<p>MyBatis 了解吗？一级缓存，二级缓存？# 和 $ 说下。如何实现的动态 SQL ？ ORM 是什么？和 Hibernate 区别？ MyBatis 工作原理？ MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？ MyBatis 中如何指定使用哪一种 Executor 执行器？模糊查询 like 语句该怎么写？ MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？ MyBatis 如何执行批量操作？ SqlSessionFactoryBean 是什么？如何实现和 Spring 的整合的？ Mapper 方法可以重载吗？为什么不可以？ MyBatis 是如何将 SQL 执行结果封装为目标对象并返回的？都有哪些映射形式？哦，你说简单封装了 JDBC ，说下 JDBC 几个重要的类。为什么要预编译？有什么好处吗？</p>
<p>Nginx 了解吗，说下其优缺点？怎么实现 Nginx 集群？什么是反向代理？和正向代理区别是什么？ Tomcat 和 Nginx 区别？限流怎么做的，有哪三种？令牌桶和漏斗算法是什么，区别是什么？如何在其之上使用 Lua 脚本？有几种负载均衡策略？你们生产上用的哪个？为什么？为什么 Nginx 性能这么高？有没有更高的？ F5 又是什么？ Nginx 是怎么处理请求的？ Nginx 目录有哪些？ nginx.conf 配置过吗？有哪些属性模块？静态资源放哪？虚拟主机配置？ location 说下。location 语法说下。</p>
<p>Tomcat 你也了解？什么是 Tomcat 的 Connector ？ Service 、Connector 、Container 介绍下它们。详细说下它们是如何处理请求的，能画下它们的架构图吗？如何部署的？一定要放到 webapps 目录下吗？在哪配置？为什么不用 Jetty ？区别是什么？ Servlet 是线程安全的吗？为什么？怎样让它线程安全？ Servlet 初始化过程？ init 方法什么时候调用？ Servlet 什么时候第一次初始化？ JSP 知道吗？有几个内置对象？你说 JSP 是特殊的 Servlet ，你看过源码吗？ JSP 如何热部署的？ EL 表达式知道吗？如何实现的？（大四神州集团校招的时候被问到的）。</p>
<p>云原生了解吗？云原生十二要素说下。Cloud Foundry 平台你知道吗？ HeroKu ？ Kong ？</p>
<p>哦？你说是六边形架构？你说下什么是六边形架构？整洁架构呢？它们之间的区别？分层架构了解吗？ MVP 、MVC 架构说下。负载均衡算法七种说下。如何实现一个秒杀系统。一定不会超卖吗？如何解决？什么是 SOA ？什么是微服务？以及两者的区别。什么是事件驱动架构？ CAP 和 BASE 说下是什么？最终一致性和人弱一致性什么关系？画一下你们系统的整体架构图。QPS 和 TPS ？你们的 QPS 是多少知道吗？压测过吗？说下点击网页的请求过程。哦，你说你是蓝绿部署，什么是蓝绿部署？什么是金丝雀发布？如何实现？</p>
<p>Docker 你也用？怎么构建 Docker 镜像？ Docker 和虚拟机的区别？ Docker 好处说下？ Kubernetes 你也知道，说下它的组成结构？ etcd 是什么？为什么不用 Zookeeper ？ pod 又是什么？你们生产上怎么用的？如何控制滚动更新过程？</p>
<p>你说你知道 DDD ？能简单说下吗？你们代码落地了吗？是如何拆分服务的？事件风暴又是什么？你们有 Code Review 吗？具体规矩？领域事件是什么？子域、通用域、核心域、支撑域、限界上下文、聚合、聚合根、实体、值对象又是什么？你们有 EventBus 吗？如何使用的？</p>
<h2 id="刷题">刷题</h2>
<p>算法：代码随想录、LCR75、LChot100、面试题150题 就照着上面顺序刷下去就好了，保持手感，做好笔记。</p>
<p>剑指 offer <a href="https://www.nowcoder.com/exam/oj/ta?page=1&amp;tpId=13&amp;type=13">https://www.nowcoder.com/exam/oj/ta?page=1&amp;tpId=13&amp;type=13</a></p>
<p>leetcode hot 100 <a href="https://leetcode.cn/studyplan/top-100-liked/">https://leetcode.cn/studyplan/top-100-liked/</a></p>
<p>给二叉树后序和中序遍历，写前序遍历。手写个快排。翻转一下链表。O(1) 空间复杂度找出链表有环。DFS 找出二叉树搜索树第 k 大节点（这些都真的碰过了）。</p>
<p>实现一个多线程类，并用该线程类实例化 3 个线程 A,B,C ； A 线程打印字符 A,B 线程打印字符 B ，C 线程打印字符 C ；启动这 3 个线程，要求启动线程的顺序为 C 线程-&gt;B 线程-&gt;A 线程，并且最后输出内容为：A B C 。禁止使用 sleep 函数。阿里应该还有各种多线程打印的问题，这个得准备。这些只是最最最基础的内容。</p>
<p>接下来应该是更高级的算法题目，至少是 LeetCode Menium 难度的，翻转链表确实有点初级，练个半个小时就搞定了。暂时还没碰到，碰到我也挂了。应该是动态规划，滑动窗口，字符串的问题，手写 O(1) 时间复杂度的 LRU ，回溯，贪心。</p>
<p>外排序（磁盘排序）</p>
<p>java 多线程求10000以内质数</p>
<p>thread - runnable - Callable&lt;T&gt;+Future+threadpool.submit(lambda)</p>
<h2 id="杂">杂</h2>
<p>Java基础：韩顺平</p>
<p>Redis看黑马，做了黑马点评</p>
<p>JUC、JVM看稀土的竹子爱熊猫</p>
<p>Spring可以看看廖雪峰、黑马。</p>
<p>计网、操作系统、MySQL：小林coding</p>
<p>其他推荐：极客时间的MySQL45讲、《对线面试官》、黑马23年面经</p>
<p>微信朋友圈系统设计（feed流系统）</p>
<p>给一个生成65536内随机数的函数对20w腾讯员工公平抽奖（k进制）</p>
<p>用udp实现tcp（http3）</p>
<p>实现atoi原型</p>
<p>位图桶排序</p>
<p>mysql联合索引实现原理和场景分析（压力，问的很怪，需要根据原理去否定一些离谱的要求）</p>
<p>智力题30！和int64谁更大</p>
<p>智力题 倒水10 7 3 从10 0 0倒出5 5 0</p>
<p>sleep能不能实现准确的微秒级别的睡眠时间（很怪，扯了扯线程切换和线程状态就不追问了，转问操作系统细节）</p>
<p>八股：黑马程序员+大话面试+竹子爱熊猫+小林coding</p>
<p>算法：hot100+top150反复刷，面试前刷CodeTop（跟着代码随想录入门之后每天定时刷三道）</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm, Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Trae &amp; Claude Task Master 4 Develop</title>
    <url>/2025/07/13/Trae-Claude-Task-Master-4-Develop/</url>
    <content><![CDATA[<p>AI-Agent workflow Record</p>
<span id="more"></span>
<h1>Trae &amp; Claude Task Master 4 Develop</h1>
<h2 id="相关工具">相关工具</h2>
<p>Trae为字节开发的<strong>Intelligence IDE</strong>  ref: <a href="https://www.trae.ai/">https://www.trae.ai/</a></p>
<blockquote>
<p>Q: 为什么选择Trae？</p>
<p>A: 因为本人事学生所以Trae毫无疑问是最便宜的IDE</p>
<p>对比选择</p>
<ul>
<li>cursor 贵</li>
<li>windsurf （团队好像都要跑路了现在开pro疑似有点危险</li>
<li>Claude Code 封号王，没有纯净IP不建议</li>
<li>Gemini Code 个人没试过</li>
</ul>
</blockquote>
<p>Claude Task Master为项目级任务管理MCP ref: <a href="https://github.com/eyaltoledano/claude-task-master">https://github.com/eyaltoledano/claude-task-master</a></p>
<blockquote>
<p>这里不得不吐槽一句：因为Claude Task Master是作为MCP使用的，它的文档写的真的是…（因为给AI看所以就不好好写文档了是吧</p>
</blockquote>
<br>
<p><strong>CTM功能分析</strong></p>
<p><strong>可用工具</strong></p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713145216113.png" class="" title="image-20250713145216113">
<br>
<p><strong>核心功能</strong></p>
<ol>
<li>项目初始化</li>
</ol>
<p>创建文件夹 <code>.taskmaster</code> 和 <code>.xxx</code>(对应IDE rules)</p>
<p><code>.taskmaster</code></p>
<ul>
<li><code>config.json</code> 配置各模式使用LLM</li>
<li><code>templates</code> PRD文档模板</li>
<li><code>tasks</code> 包含文件 <code>tasks.json</code> PRD文档解析后得到的任务列表</li>
<li><code>docs</code> 用户自行创建文件 <code>prd.txt</code></li>
</ul>
<p><code>.xxx</code>(对应IDE rules)</p>
<ul>
<li><code>rules</code> IDE基本规则，参考<a href="https://docs.cursor.com/context/rules">cursor rules</a>, <a href="https://docs.trae.ai/ide/rules-for-ai">trae rules</a> 和 <a href="https://github.com/PatrickJS/awesome-cursorrules">rules编写</a></li>
<li><code>mcp.json</code> 配置LLM API key</li>
</ul>
<br>
<ol start="2">
<li>PRD文档解析</li>
</ol>
<p>PRD文档解析使用项目初始化后的 <code>.taskmaster\config.json</code> 配置可用LLM，使用以下Prompt实现文档解析功能：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;prompts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;system&quot;</span><span class="punctuation">:</span> <span class="string">&quot;You are an AI assistant specialized in analyzing Product Requirements Documents (PRDs) and generating a structured, logically ordered, dependency-aware and sequenced list of development tasks in JSON format.&#123;&#123;#if research&#125;&#125;\nBefore breaking down the PRD into tasks, you will:\n1. Research and analyze the latest technologies, libraries, frameworks, and best practices that would be appropriate for this project\n2. Identify any potential technical challenges, security concerns, or scalability issues not explicitly mentioned in the PRD without discarding any explicit requirements or going overboard with complexity -- always aim to provide the most direct path to implementation, avoiding over-engineering or roundabout approaches\n3. Consider current industry standards and evolving trends relevant to this project (this step aims to solve LLM hallucinations and out of date information due to training data cutoff dates)\n4. Evaluate alternative implementation approaches and recommend the most efficient path\n5. Include specific library versions, helpful APIs, and concrete implementation guidance based on your research\n6. Always aim to provide the most direct path to implementation, avoiding over-engineering or roundabout approaches\n\nYour task breakdown should incorporate this research, resulting in more detailed implementation guidance, more accurate dependency mapping, and more precise technology recommendations than would be possible from the PRD text alone, while maintaining all explicit requirements and best practices and all details and nuances of the PRD.&#123;&#123;/if&#125;&#125;\n\nAnalyze the provided PRD content and generate &#123;&#123;#if (gt numTasks 0)&#125;&#125;approximately &#123;&#123;numTasks&#125;&#125;&#123;&#123;else&#125;&#125;an appropriate number of&#123;&#123;/if&#125;&#125; top-level development tasks. If the complexity or the level of detail of the PRD is high, generate more tasks relative to the complexity of the PRD\nEach task should represent a logical unit of work needed to implement the requirements and focus on the most direct and effective way to implement the requirements without unnecessary complexity or overengineering. Include pseudo-code, implementation details, and test strategy for each task. Find the most up to date information to implement each task.\nAssign sequential IDs starting from &#123;&#123;nextId&#125;&#125;. Infer title, description, details, and test strategy for each task based *only* on the PRD content.\nSet status to &#x27;pending&#x27;, dependencies to an empty array [], and priority to &#x27;&#123;&#123;defaultTaskPriority&#125;&#125;&#x27; initially for all tasks.\nRespond ONLY with a valid JSON object containing a single key \&quot;tasks\&quot;, where the value is an array of task objects adhering to the provided Zod schema. Do not include any explanation or markdown formatting.\n\nEach task should follow this JSON structure:\n&#123;\n\t\&quot;id\&quot;: number,\n\t\&quot;title\&quot;: string,\n\t\&quot;description\&quot;: string,\n\t\&quot;status\&quot;: \&quot;pending\&quot;,\n\t\&quot;dependencies\&quot;: number[] (IDs of tasks this depends on),\n\t\&quot;priority\&quot;: \&quot;high\&quot; | \&quot;medium\&quot; | \&quot;low\&quot;,\n\t\&quot;details\&quot;: string (implementation details),\n\t\&quot;testStrategy\&quot;: string (validation approach)\n&#125;\n\nGuidelines:\n1. &#123;&#123;#if (gt numTasks 0)&#125;&#125;Unless complexity warrants otherwise&#123;&#123;else&#125;&#125;Depending on the complexity&#123;&#123;/if&#125;&#125;, create &#123;&#123;#if (gt numTasks 0)&#125;&#125;exactly &#123;&#123;numTasks&#125;&#125;&#123;&#123;else&#125;&#125;an appropriate number of&#123;&#123;/if&#125;&#125; tasks, numbered sequentially starting from &#123;&#123;nextId&#125;&#125;\n2. Each task should be atomic and focused on a single responsibility following the most up to date best practices and standards\n3. Order tasks logically - consider dependencies and implementation sequence\n4. Early tasks should focus on setup, core functionality first, then advanced features\n5. Include clear validation/testing approach for each task\n6. Set appropriate dependency IDs (a task can only depend on tasks with lower IDs, potentially including existing tasks with IDs less than &#123;&#123;nextId&#125;&#125; if applicable)\n7. Assign priority (high/medium/low) based on criticality and dependency order\n8. Include detailed implementation guidance in the \&quot;details\&quot; field&#123;&#123;#if research&#125;&#125;, with specific libraries and version recommendations based on your research&#123;&#123;/if&#125;&#125;\n9. If the PRD contains specific requirements for libraries, database schemas, frameworks, tech stacks, or any other implementation details, STRICTLY ADHERE to these requirements in your task breakdown and do not discard them under any circumstance\n10. Focus on filling in any gaps left by the PRD or areas that aren&#x27;t fully specified, while preserving all explicit requirements\n11. Always aim to provide the most direct path to implementation, avoiding over-engineering or roundabout approaches&#123;&#123;#if research&#125;&#125;\n12. For each task, include specific, actionable guidance based on current industry standards and best practices discovered through research&#123;&#123;/if&#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Here&#x27;s the Product Requirements Document (PRD) to break down into &#123;&#123;#if (gt numTasks 0)&#125;&#125;approximately &#123;&#123;numTasks&#125;&#125;&#123;&#123;else&#125;&#125;an appropriate number of&#123;&#123;/if&#125;&#125; tasks, starting IDs from &#123;&#123;nextId&#125;&#125;:&#123;&#123;#if research&#125;&#125;\n\nRemember to thoroughly research current best practices and technologies before task breakdown to provide specific, actionable implementation details.&#123;&#123;/if&#125;&#125;\n\n&#123;&#123;prdContent&#125;&#125;\n\n\n\t\tReturn your response in this format:\n&#123;\n    \&quot;tasks\&quot;: [\n        &#123;\n            \&quot;id\&quot;: 1,\n            \&quot;title\&quot;: \&quot;Setup Project Repository\&quot;,\n            \&quot;description\&quot;: \&quot;...\&quot;,\n            ...\n        &#125;,\n        ...\n    ],\n    \&quot;metadata\&quot;: &#123;\n        \&quot;projectName\&quot;: \&quot;PRD Implementation\&quot;,\n        \&quot;totalTasks\&quot;: &#123;&#123;#if (gt numTasks 0)&#125;&#125;&#123;&#123;numTasks&#125;&#125;&#123;&#123;else&#125;&#125;&#123;number of tasks&#125;&#123;&#123;/if&#125;&#125;,\n        \&quot;sourceFile\&quot;: \&quot;&#123;&#123;prdPath&#125;&#125;\&quot;,\n        \&quot;generatedAt\&quot;: \&quot;YYYY-MM-DD\&quot;\n    &#125;\n&#125;&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<br>
<h2 id="初始化">初始化</h2>
<p>由于Trae MCP市场暂无CTM，因此手动安装</p>
<p>命令行安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Install globally</span></span><br><span class="line">npm install <span class="literal">-g</span> task<span class="literal">-master-ai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OR install locally within your project</span></span><br><span class="line">npm install task<span class="literal">-master-ai</span></span><br></pre></td></tr></table></figure>
<p>配置MCP</p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713151404427.png" class="" title="image-20250713151404427">
<p>Configure Manually</p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713151435125.png" class="" title="image-20250713151435125">
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;taskmaster-ai&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;--package=task-master-ai&quot;</span><span class="punctuation">,</span> <span class="string">&quot;task-master-ai&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ANTHROPIC_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_ANTHROPIC_API_KEY_HERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;PERPLEXITY_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_PERPLEXITY_API_KEY_HERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OPENAI_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_OPENAI_KEY_HERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;GOOGLE_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_GOOGLE_KEY_HERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MISTRAL_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_MISTRAL_KEY_HERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OPENROUTER_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_OPENROUTER_KEY_HERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;XAI_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_XAI_KEY_HERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AZURE_OPENAI_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_AZURE_KEY_HERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OLLAMA_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_OLLAMA_API_KEY_HERE&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>API Key推荐使用Gemini</p>
<p>在不绑卡的情况下可直接免费试用</p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713151804420.png" class="" title="image-20250713151804420">
</blockquote>
<p>配置完成</p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713151517858.png" class="" title="image-20250713151517858">
<p>选择Agent开始开发</p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713151555641.png" class="" title="image-20250713151555641">
<br>
<h2 id="流程">流程</h2>
<h3 id="初始化项目">初始化项目</h3>
<p>直接与Agent对话</p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713152021953.png" class="" title="image-20250713152021953">
<p>或者</p>
<p>命令行初始化项目</p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713152046213.png" class="" title="image-20250713152046213">
<blockquote>
<p>需要注意的是</p>
<p>在初始化项目上，请指定您当前所使用的IDE；如上图所示，Agent在命令的传入参数中指定了IDE rules为Trae</p>
</blockquote>
<br>
<h3 id="完成PRD文档">完成PRD文档</h3>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713151900249.png" class="" title="image-20250713151900249">
<br>
<h3 id="Parse-PRD">Parse PRD</h3>
<p>解析PRD文档得到task list</p>
<p>该步骤需要使用LLM，因此请配置以下文件</p>
<ul>
<li>
<p><code>.trae\mcp.json</code>: 添加LLM API Key，推荐使用Gemini</p>
</li>
<li>
<p><code>.taskmaster\config.json</code>: 修改 main 为 google gemini</p>
</li>
</ul>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713152535100.png" class="" title="image-20250713152535100">
<blockquote>
<p>如果执行失败了，Agent也会给出建议修复该问题</p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713152633165.png" class="" title="image-20250713152633165">
</blockquote>
<p>得到tasks.json</p>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713152708978.png" class="" title="image-20250713152708978">
<br>
<h3 id="任务执行">任务执行</h3>
<img src="/2025/07/13/Trae-Claude-Task-Master-4-Develop/image-20250713152810221.png" class="" title="image-20250713152810221">
<br>
<h2 id="存在问题">存在问题</h2>
<p>施工中…</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SAR&amp;Rela</title>
    <url>/2025/04/16/Search-Ads-Rec-Rela/</url>
    <content><![CDATA[<p>Search, Advertising, Recommendation与相关</p>
<p>施工中…</p>
<span id="more"></span>
<h1>SAR&amp;Rela</h1>
<br>
<h2 id="概要">概要</h2>
<h3 id="链路">链路</h3>
<p>多通道召回</p>
<ul>
<li>内容过滤</li>
<li>协同过滤</li>
<li>双塔…</li>
</ul>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672040737101-86c337d2-1134-4829-b25a-4d0ee6e7a1be.png" class="" title="img">
<p>粗排&amp;精排</p>
<ul>
<li>粗排使用小规模神经网络，给几千篇笔记打分，选出分数最高的几百篇；</li>
<li>用大规模神经网络，给几百篇笔记打分，选出分数最高的几十篇；</li>
</ul>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672040737189-3e05f4a0-4485-42c8-b518-62280943b0c9.png" class="" title="img">
<p>重排</p>
<ul>
<li>多样性随机抽样：避免推荐结果过于同质化（例如全部是同一类型的笔记），让用户看到更丰富的内容，对候选集按类别、主题、作者等维度分组（如“美食”“旅行”“科技”），从每组中随机抽取一定比例的内容，组成最终推荐列表。</li>
<li>规则去重：防止内容高度相似的笔记连续出现（例如同一作者的多个笔记，或同一事件的重复报道）。</li>
<li>广告插入</li>
</ul>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672040737268-b4922779-dc96-4c53-b21e-1c46437cdbc7.png" class="" title="img">
<br>
<h3 id="测试">测试</h3>
<p><strong>A/B测试</strong></p>
<p>通过对比两个或多个版本（A版和B版）来确定哪个版本效果更好的实验方法。</p>
<br>
<p><strong>分层实验</strong></p>
<ul>
<li>同层互斥：例如，在召回层的用户仅可以属于一个桶</li>
<li>异层正交：例如，召回层用户A在粗排层被随机打散分布在粗排层的10个桶</li>
</ul>
<br>
<p><strong>Holdout</strong></p>
<p>保留10%的用户完全不参与到实验中，作为对照组</p>
<br>
<h2 id="离散特征处理">离散特征处理</h2>
<h3 id="离散特征">离散特征</h3>
<p>离散特征案例：</p>
<ul>
<li>性别：男、女两种类别</li>
<li>国籍：中国、美国、印度等 200 个国家</li>
<li>英文单词：常见的英文单词有几万个</li>
</ul>
<p>离散特征向量化</p>
<ul>
<li>one-hot：超高维稀疏 - 球面</li>
<li>分词器：单维稠密 - 坐标轴</li>
<li>embedding</li>
</ul>
<br>
<h3 id="矩阵补充">矩阵补充</h3>
<p>在实践中不使用！！</p>
<p>用于实际物品数量庞大，可暴露给用户的物品量极少（绿色为暴露给用户的，灰色为没有曝光的），矩阵补充用于训练网络预测未暴露给用户的，用户对物品的兴趣度（格子中的值为兴趣度）</p>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672042316018-1bf99117-9105-4290-9997-5fd589d5ba94.png" class="" title="img">
<br>
<h4 id="训练">训练</h4>
<p>训练两个Embedding Layer，内积为预测的兴趣度</p>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672042315791-5bfc7658-6112-4537-8a28-4d1085472232.png" class="" title="img">
<p>数据集：</p>
<ul>
<li>
<p>（用户 ID，物品 ID，真实兴趣分数）的集合，记作 $\Omega={(u,i,y) }$</p>
</li>
<li>
<p>数据集中的兴趣分数是系统记录的，比如：</p>
<ul>
<li>曝光但是没有点击 → 0 分</li>
<li>点击、点赞、收藏、转发 → 各算 1 分</li>
<li>分数最低是 0，最高是 4</li>
</ul>
</li>
<li>
<p>训练的目的就是让模型的输出拟合真实兴趣分数</p>
</li>
</ul>
<p>损失函数：</p>
<p>$$<br>
\min_{\bold{A},\bold{B}}\sum_{(u,i,y)\in\Omega}(y- \left\langle \bold{a}_u,\bold{b}_i \right\rangle)^2<br>
$$</p>
<br>
<h4 id="近似最近邻搜索">近似最近邻搜索</h4>
<h5 id="衡量近邻指标">衡量近邻指标</h5>
<ul>
<li>欧式距离</li>
<li>向量内积</li>
<li>夹角余弦</li>
</ul>
<br>
<h5 id="流程">流程</h5>
<ul>
<li>数据预处理：将数据划分为多个区域，使用索引向量（单位向量）表示每个区域</li>
<li>实时推荐时，将用户向量与所有索引向量做对比</li>
<li>通过索引向量，找到索引对应区域中的所有物品，然后再计算该区域中所有物品与 用户向量 的相似度</li>
</ul>
<br>
<h2 id="召回">召回</h2>
<h3 id="基于协同过滤的召回">基于协同过滤的召回</h3>
<p>无需物品特征（如分类、标签），仅依赖用户行为即可工作。</p>
<br>
<h4 id="ItemCF">ItemCF</h4>
<p><strong>Item-based Collaborative Filtering</strong> 基于物品的协同过滤</p>
<h5 id="评分">评分</h5>
<p>定义用户为 $u$，定义物品为 $i$， 用户对候选物品 $i_k$ 的兴趣表示为：<br>
$$<br>
R(u, i_k) = \sum_{j}R(u, i_{j}) \times \text{sim}(i_{j},i_{k})<br>
$$</p>
<br>
<h5 id="物品相似度">物品相似度</h5>
<p>相似度计算公式如下：</p>
<p>定义喜欢物品 $i$ （与物品 $i$ 有交互）的用户群体为 $N(i)$，有物品相似度定义如下：<br>
$$<br>
\text{sim}(i_1, i_2) = \frac{|N(i_1) \cap N(i_2)|}{\sqrt{|N(i_1)|\cdot|N(i_2)|}}<br>
$$<br>
修正：若引入用户对物品的评分 $R(u, i)$，物品相似度定义如下：<br>
$$<br>
\text{sim}(i_1, i_2) = \frac{\sum_{u \in N(i_1) \cap N(i_2)}R(u, i_1)\cdot R(u, i_2)}{\sqrt{\sum_{u_{1} \in N(i)}R^{2}(u_{1}, i_1)} \cdot \sqrt{\sum_{u_{2} \in N(i_2)}R^{2}(u_{2}, i_2)}}<br>
$$</p>
<blockquote>
<p>相似度公式1相当于公式2中的R为布尔值</p>
</blockquote>
<p>在实际使用中，使用向量计算相似度</p>
<ul>
<li>每个物品通过向量表示</li>
<li>向量的每一位表示用户对该物品的喜欢度</li>
<li>相似度为物品向量夹角余弦</li>
</ul>
<br>
<h5 id="流程-2">流程</h5>
<p>如果想知道 Alice 对物品5打多少分， 基于物品的协同过滤算法会这么做：</p>
<ul>
<li>首先计算一下物品5和物品1， 2， 3， 4之间的相似性。</li>
<li>在Alice找出与物品 5 最相近的 n 个物品。</li>
<li>根据 Alice 对最相近的 n 个物品的打分去计算对物品 5 的打分情况。</li>
</ul>
<br>
<h4 id="UserCF">UserCF</h4>
<p>基于用户的协同过滤</p>
<h5 id="评分-2">评分</h5>
<p>$$<br>
R(u, i) = \sum_jsim(u,u_j)×R(u_j,i)<br>
$$</p>
<h5 id="用户相似度">用户相似度</h5>
<p>定义用户相似度为</p>
<ul>
<li>记用户 $u_1$ 交互物品的集合为 $\mathcal{J}(u_1)$</li>
<li>记用户 $u_2$ 交互物品的集合为 $\mathcal{J}(u_2)$</li>
</ul>
<p>用户的相似度公式为：</p>
<p>$$<br>
sim(u_1,u_2)=\frac{|\mathcal{J}(u_1)\cap\mathcal{J}(u_2)|}{\sqrt{|\mathcal{J}(u_1)|·|\mathcal{J}(u_2)|}}<br>
$$</p>
<p>修正：考虑降低热门物品的权重</p>
<p>$$<br>
sim(u_1,u_2)=\frac{\sum_{l\in{\mathcal{J}_1\cap\mathcal{J}_2}} \frac{1}{\log{(1+n_l)}}}{\sqrt{|\mathcal{J}(u_1)|·|\mathcal{J}(u_2)|}}<br>
$$</p>
<ul>
<li>
<p>$n_l$：喜欢物品 $l$ 的用户数量，反映物品的热门程度</p>
</li>
<li>
<p>物品越热门，$\frac{1}{\log{(1+n_l)}}$ 越小，对相似度的贡献就越小</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"></span><br><span class="line">i = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]  // 用户i，每一列表示对物品n是否喜欢</span><br><span class="line">j = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]  // 用户j，每一列表示对物品n是否喜欢</span><br><span class="line">cosine_similarity([i, j])</span><br></pre></td></tr></table></figure>
<br>
<h5 id="流程-3">流程</h5>
<p>预估用户a对物品x的评分</p>
<ul>
<li>查找数据库，得到与用户a相似程度最接近（近似最近邻搜索ANN得到）的前N个用户</li>
<li>根据相似用户对物品x的评分估计用户a对物品x的评分</li>
</ul>
<br>
<h4 id="Swing">Swing</h4>
<p>物品相似度公式更新，其他与ItemCF相同</p>
<p>需要注意的是，“Swing召回”主要用于推荐系统中，通过构造用户–物品二分图来衡量两个物品之间的相似度，其思想是既考虑了直接由同一用户触发的共现关系，也考虑了间接的关联（即“摇摆”效果）。不同的论文和实现可能在细节上有所差别，但基本思想是一致的。</p>
<br>
<h5 id="相似度">相似度</h5>
<p>在实践中常用的<strong>统一双重求和</strong>形式</p>
<ul>
<li>用户 $u_1$ 喜欢的物品记作集合 $\mathcal{J}(u_1)$</li>
<li>用户 $u_2$ 喜欢的物品记作集合 $\mathcal{J}(u_2)$</li>
</ul>
<p>用户 $u_1$ 和 $u_2$ 的重合度高，则他们可能来自一个小圈子，要降低他们的权重</p>
<br>
<p>物品相似度</p>
<ul>
<li>喜欢物品 $i_1$ 的用户记作集合 $N_1$</li>
<li>喜欢物品 $i_2$ 的用户记作集合 $N_2$</li>
</ul>
<p>两个物品的相似度：<br>
$$<br>
sim(i_1,i_2)=\sum_{u_1\in N_1 \cap N_2 }\sum_{u_2\in N_1 \cap N_2} \frac{1}{\sqrt{|\mathcal{J}(u_1)}} \cdot \frac{1}{\sqrt{|\mathcal{J}(u_2)|}} \cdot \frac{1}{\alpha+|\mathcal{J}(u_1) \cap \mathcal{J}(u_2)|}<br>
$$</p>
<ul>
<li>
<p>$α$ 是超参数</p>
</li>
<li>
<p>重合度高，说明两人是一个小圈子的，那么他两对物品相似度的贡献就比较小；重合度小，两人不是一个小圈子的，他两对物品相似度的贡献就比较大</p>
</li>
</ul>
<br>
<h4 id="矩阵分解">矩阵分解</h4>
<p>Matrix Factorization</p>
<br>
<h3 id="基于向量的召回">基于向量的召回</h3>
<h4 id="FM召回">FM召回</h4>
<br>
<h4 id="item2vec召回">item2vec召回</h4>
<br>
<h4 id="双塔模型">双塔模型</h4>
<h5 id="模型与训练">模型与训练</h5>
<h6 id="模型">模型</h6>
<p><strong>用户</strong></p>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672042316812-3bce2474-8eda-48cb-aa80-6f58bb78b238.png" class="" title="img">
<p><strong>物品</strong></p>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672042316930-512c4448-5964-4bf2-9309-419cd3a16db5.png" class="" title="img">
<p><strong>双塔模型</strong></p>
<p>输出的余弦相似度为 <strong>预估用户对物品的兴趣</strong></p>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672042317078-7e47cf8c-e659-4582-8ea5-4b131b39913f.png" class="" title="img">
<h6 id="训练-2">训练</h6>
<p><strong>Pointwise</strong></p>
<p>二元分类每个正样本，负样本</p>
<p>对于正样本，鼓励 $cos(\mathbf{a},\mathbf{b})$ 接近 +1</p>
<p>对于负样本，鼓励 $cos(\mathbf{a},\mathbf{b})$ 接近 -1</p>
<br>
<p><strong>Pairwise</strong></p>
<p>每次取一个正样本和一个负样本</p>
<blockquote>
<p>ref: Jui-Ting Huang et al. Embedding-based Retrieval in Facebook Search. In KDD, 2020</p>
</blockquote>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672042317349-25d382e4-8c3f-4881-984e-7348d3173963.png" class="" title="img">
<p>鼓励 $\cos{(\mathbf{a},\mathbf{b}^+)}$ 大于 $\cos{(\mathbf{a},\mathbf{b}^-)}$</p>
<ul>
<li>
<p>如果  $\cos{(\mathbf{a},\mathbf{b}^+)}$ 大于  $\cos{(\mathbf{a},\mathbf{b}^-)}+m$，则没有损失</p>
<ul>
<li>m 是超参数，需要调</li>
</ul>
</li>
<li>
<p>否则，损失等于  $\cos{(\mathbf{a},\mathbf{b}^-)}+m-\cos{(\mathbf{a},\mathbf{b}^+)}$</p>
</li>
</ul>
<br>
<p><strong>Triplet hinge loss</strong>:<br>
$$<br>
L(\mathbf{a}, \mathbf{b}^+, \mathbf{b}^-) = \max \left{ 0, \cos(\mathbf{a}, \mathbf{b}^-) + m - \cos(\mathbf{a}, \mathbf{b}^+) \right}<br>
$$<br>
<strong>Triplet logistic loss:</strong><br>
$$<br>
L(\mathbf{a}, \mathbf{b}^+, \mathbf{b}^-) = \log \left( 1 + \exp \left[ \sigma \cdot \left( \cos(\mathbf{a}, \mathbf{b}^-) - \cos(\mathbf{a}, \mathbf{b}^+) \right) \right] \right)<br>
$$</p>
<ul>
<li>$\sigma$ 是大于 0 的超参数，控制损失函数的形状，需手动设置</li>
</ul>
<br>
<p><strong>Listwise</strong></p>
<blockquote>
<p>ref: Xinyang Yi et al. Sampling-Bias-Corrected Neural Modeling for Large Corpus Item Recommendations. In RecSys, 2019.</p>
</blockquote>
<p>每次取一个正样本和多个负样本，训练数据包含：</p>
<ul>
<li>
<p>一个用户，特征向量记作 $\mathbf{a}$</p>
</li>
<li>
<p>一个正样本，特征向量记作 $\mathbf{b}^+$</p>
</li>
<li>
<p>多个负样本，特征向量记作 $\mathbf{b}^-_1,…,\mathbf{b}^-_n$</p>
</li>
</ul>
<p>鼓励 $\cos{(\mathbf{a},\mathbf{b}^+)}$ 尽量大</p>
<p>鼓励 $\cos{(\mathbf{a},\mathbf{b}^-_1)},…,\cos{(\mathbf{a},\mathbf{b}^-_n)}$ 尽量小</p>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672042317453-2e6860cf-79ad-492a-b350-5f8115174edf.png" class="" title="img">
<p>用 $y$ 和 $s$ 的交叉熵作为损失函数，意思是鼓励 $Softmax$ 的输出 $s$ 接近标签 $y$</p>
<br>
<br>
<h5 id="正负样本">正负样本</h5>
<h6 id="样本">样本</h6>
<ul>
<li>正样本：曝光而且有点击的（用户-物品交互） 用户-物品 二元组</li>
<li>负样本：
<ul>
<li>没有被召回的？</li>
<li>召回但是被粗排，精排淘汰的？</li>
<li>曝光但是未点击？</li>
</ul>
</li>
</ul>
<img src="/2025/04/16/Search-Ads-Rec-Rela/1672042317852-e1721f7f-f1cb-4910-af2f-0847eaf52b1b.png" class="" title="img">
<br>
<h6 id="正样本">正样本</h6>
<p>曝光而且有点击的（用户-物品交互） 用户-物品 二元组</p>
<p>存在问题：正样本多为热门物品；</p>
<p>解决方案：过采样冷门物品，降采样热门物品；</p>
<h6 id="简单负样本">简单负样本</h6>
<p>取 用户-物品交互 条目为Batch</p>
<p>Batch内 用户与未交互物品形成负样本</p>
<br>
<p>存在问题：热门物品高概率成为负样本</p>
<p>解决方案：</p>
<blockquote>
<p>Xinyang Yi et al. Sampling-Bias-Corrected Neural Modeling for Large Corpus Item Recommendations. In RecSys, 2019.</p>
</blockquote>
<p>修正偏差：</p>
<ul>
<li>
<p>物品 $i$ 被抽样到的概率：$p_i \propto \text{点击次数}$</p>
<ul>
<li>预估用户对物品 $i$ 的兴趣：$cos(\mathbf{a}, \mathbf{b_i})$</li>
<li>训练时，将兴趣调整为：$cos(\mathbf{a}, \mathbf{b_i)} - log(p_i)$</li>
</ul>
</li>
<li>
<p>纠偏避免过度打压热门物品</p>
<ul>
<li>非训练线上召回时，使用 $cos(\mathbf{a}, \mathbf{b_i})$ 作为兴趣</li>
</ul>
</li>
</ul>
<br>
<h6 id="困难负样本">困难负样本</h6>
<p>被粗排淘汰的物品（比较困难）</p>
<ul>
<li>这些物品被召回，说明和用户兴趣有关；又被粗排淘汰，说明用户对物品兴趣不大</li>
<li>而在对正负样本做二元分类时，这些困难样本容易被分错（被错误判定为正样本）</li>
</ul>
<p>精排分数靠后的物品（非常困难）</p>
<ul>
<li>能够进入精排，说明物品比较符合用户兴趣，但不是用户最感兴趣的</li>
</ul>
<br>
<p>对正负样本做二元分类：</p>
<ul>
<li>全体物品（简单）分类准确率高</li>
<li>被粗排淘汰的物品（比较困难）容易分错</li>
<li>精排分数靠后的物品（非常困难）更容易分错</li>
</ul>
<p>训练数据</p>
<ul>
<li>混合几种负样本
<ul>
<li>
<p>50% 的负样本是全体物品（简单负样本）</p>
</li>
<li>
<p>50% 的负样本是没通过排序的物品（困难负样本）</p>
<ul>
<li>即在粗排、精排淘汰的物品</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<h5 id="线上召回与更新">线上召回与更新</h5>
<h6 id="线上召回">线上召回</h6>
<p><strong>双塔模型的召回</strong></p>
<p>离线存储：</p>
<ol>
<li>完成训练之后，用物品塔计算每个物品的特征向量 $\mathbf{b_i}$</li>
<li>把几亿个物品向量 $\mathbf{b_i}$ 存入向量数据库（比如 Milvus、Faiss、HnswLib ）</li>
<li>向量数据库建索引，以便加速最近邻查找</li>
</ol>
<p>线上召回：查找用户最感兴趣的 $k$ 个物品</p>
<ol>
<li>给定用户 ID 和画像，线上用神经网络现算（<strong>实时计算</strong>）用户向量 $\mathbf{a}$</li>
<li>最近邻查找：
<ul>
<li>
<p>把向量 $\mathbf{a}$ 作为 query，调用向量数据库做最近邻查找</p>
</li>
<li>
<p>返回余弦相似度最大的 $k$ 个物品，作为召回结果</p>
</li>
</ul>
</li>
</ol>
<br>
<p>为什么事先存储物品向量 $\mathbf{b_i}$，线上现算用户向量 $\mathbf{a}$？</p>
<ul>
<li>每做一次召回，用到一个用户向量 $\mathbf{a}$，几亿物品向量 $\mathbf{b_i}$（线上算物品向量的代价过大）</li>
<li>用户兴趣动态变化，而物品特征相对稳定（可以离线存储用户向量，但不利于推荐效果）</li>
</ul>
<br>
<h6 id="模型更新">模型更新</h6>
<br>
<h3 id="其他召回模型">其他召回模型</h3>
<h4 id="BM25召回">BM25召回</h4>
<blockquote>
<p>langchain的BM25 retriever默认使用的preprocessing_func是通过whitespace分割string的，适用于英文句子，不适用于中文</p>
</blockquote>
<p>BM25（Best Match 25）是一种<strong>基于词频统计</strong>的文本相关性计算模型，广泛应用于信息检索领域，尤其在早期阶段的召回（Retrieval）环节中扮演重要角色。它的目标是根据查询（query）和文档（document）中的词语匹配程度，给文档打分，从而找出与查询最相关的文档集合。</p>
<p>输入 查询词list，返回每个文档与 查询词list 的匹配性分数，分数越高匹配度越高</p>
<br>
<p><strong>BM25 的核心思想</strong></p>
<p>BM25 的核心思想是：</p>
<ol>
<li><strong>词频（TF）的重要性：</strong> 一个词在文档中出现的次数越多，该词对于文档的重要性越高。</li>
<li><strong>逆文档频率（IDF）的重要性：</strong> 一个词在整个语料库中出现的文档越少，该词对于区分文档的重要性越高。</li>
<li><strong>文档长度的标准化：</strong> 短文档出现某个词的频率可能很高，但不一定比长文档更相关。BM25 会对文档长度进行标准化，避免长文档天然获得更高的分数。</li>
<li><strong>词频饱和度：</strong> 20 个“猫”字不一定比 10 个“猫”字更重要两倍。当词频达到一定程度后，其对分数的贡献会逐渐减小。</li>
</ol>
<br>
<p><strong>BM25 的计算公式</strong></p>
<p>BM25 的打分公式如下：</p>
<p>$$Score(D, Q) = \sum_{i=1}^{n} IDF(q_i) \cdot \frac{f(q_i, D) \cdot (k_1 + 1)}{f(q_i, D) + k_1 \cdot (1 - b + b \cdot \frac{|D|}{avgDL})}$$</p>
<p>其中：</p>
<ul>
<li>
<p>$D$：文档（Document）</p>
</li>
<li>
<p>$Q$：查询（Query），由 $n$ 个词 $q_1, q_2, …, q_n$ 组成</p>
</li>
<li>
<p>$f(q_i, D)$：查询词 $q_i$ 在文档 $D$ 中出现的频率（Term Frequency, TF）</p>
</li>
<li>
<p>$|D|$：文档 $D$ 的长度（词数）</p>
</li>
<li>
<p>$avgDL$：语料库中所有文档的平均长度</p>
</li>
<li>
<p><strong>$k_1$（词频饱和度参数）：</strong></p>
<ul>
<li>通常取值范围在 $1.2$ 到 $2.0$ 之间。</li>
<li>$k_1$ 越大，词频对分数的影响越大，直到词频非常高。</li>
<li>$k_1$ 越小，词频对分数的贡献越快达到饱和。</li>
<li>$k_1 = 0$ 时，完全不考虑词频。</li>
</ul>
</li>
<li>
<p><strong>$b$（文档长度归一化参数）：</strong></p>
<ul>
<li>通常取值范围在 $0$ 到 $1$ 之间。</li>
<li>$b = 1$ 时，完全根据文档长度进行归一化（短文档会得到相对更高的分数）。</li>
<li>$b = 0$ 时，不进行文档长度归一化。</li>
</ul>
</li>
<li>
<p>$IDF(q_i)$：查询词 $q_i$ 的逆文档频率（Inverse Document Frequency）。通常使用以下公式计算：<br>
$$IDF(q_i) = \log \frac{N - n(q_i) + 0.5}{n(q_i) + 0.5} + 1$$<br>
或者更简单的：<br>
$$IDF(q_i) = \log \frac{N}{n(q_i)}$$<br>
这里我们使用前者，因为它在实践中表现更好，避免了当 $n(q_i)=0$ 时的对数无穷大问题。</p>
<ul>
<li>$N$：语料库中的文档总数</li>
<li>$n(q_i)$：包含查询词 $q_i$ 的文档数量（Document Frequency, DF）</li>
</ul>
<p>包含查询词 $q_i$ 的文档数量越多，$IDF(q_i)$ 的值越小</p>
</li>
</ul>
<p>对于公式的各部分</p>
<ul>
<li>$IDF(q_i)$ 旨在 赋予稀有词更高的权重，因为稀有词比常见词更能区分文档。
<ul>
<li><strong>原理：</strong>
<ul>
<li><strong>逆文档频率 (IDF)：</strong> 这是信息检索中的核心思想。一个词在语料库中出现的文档越多（$n(q_i)$ 越大），它作为查询词时，其区分文档的能力就越弱，因此权重应该越低。反之，一个词在少量文档中出现，它就更具独特性，更能指示文档的主题，所以权重应该更高。</li>
<li><strong>对数 (log)：</strong> 使用对数是为了平滑 IDF 的值。词的文档频率分布往往是长尾的，直接使用 $N/n(q_i)$ 会导致一些极端稀有词的 IDF 值过大，对总分产生过大的影响。对数函数能有效缩小高 IDF 值的差距，使其更加稳定。</li>
<li><strong>平滑项 $0.5$：</strong>
<ul>
<li>在分子和分母中都加上 $0.5$ (或其它小常数)。这被称为<strong>平滑处理</strong>。</li>
<li><strong>解决问题1 (Zero Frequency Problem):</strong> 如果一个查询词 $q_i$ 从未在语料库中出现过，那么 $n(q_i)$ 会是 $0$。如果直接用 $\log(N/n(q_i))$，就会出现除以零的问题。加上 $0.5$ 可以避免这个问题。</li>
<li><strong>解决问题2 (High Frequency Problem):</strong> 如果一个词在所有文档中都出现 ($n(q_i) = N$)，那么原始的 $\log(N/N) = \log(1) = 0$。而加上平滑项后，分子 $N - N + 0.5 = 0.5$，分母 $N + 0.5$，IDF 会是一个很小的负值或接近于0的数。这样，对于极其常见的词（如停用词），其 IDF 贡献会变得非常小，符合其区分度低的特性。</li>
<li><strong>额外的 $+1$：</strong> 确保 IDF 值不会是负数，并且对于非常常见的词，其 IDF 仍然是一个正数（尽管非常小），避免了对数结果为零或负数导致的问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>分数部分 $\frac{f(q_i, D) \cdot (k_1 + 1)}{f(q_i, D) + k_1 \cdot (1 - b + b \cdot \frac{|D|}{avgDL})}$ 结合了词频、词频饱和度、文档长度和文档长度归一化
<ul>
<li>
<p><strong>分子 $f(q_i, D) \cdot (k_1 + 1)$：</strong></p>
<ul>
<li><strong>$f(q_i, D)$ (Term Frequency, TF)：</strong> 查询词 $q_i$ 在文档 $D$ 中出现的频率。直观上，一个词在文档中出现的次数越多，文档与该词的相关性就越强。</li>
<li><strong>$(k_1 + 1)$：</strong> 这是一个常数因子，它确保当 $f(q_i, D)$ 增加时，分子也能以线性方式增加，为后面的饱和度函数提供一个比例因子。它不是一个可调参数，只是一个常数。</li>
</ul>
</li>
<li>
<p><strong>分母 $f(q_i, D) + k_1 \cdot (1 - b + b \cdot \frac{|D|}{avgDL})$：</strong><br>
这是整个 BM25 设计的精髓所在，它包含了两个关键的 BM25 改进点：<strong>词频饱和度</strong> 和 <strong>文档长度归一化</strong>。</p>
<ul>
<li>
<p><strong>$f(q_i, D)$：</strong> 再次出现词频，在分母中，它的存在使得整个分式表现出“饱和”特性。</p>
</li>
<li>
<p><strong>$k_1$（词频饱和度参数）：</strong></p>
<ul>
<li><strong>设计目的：</strong> 解决传统 TF（如线性增长）的不足。BM25 认为，词频对相关性的贡献不是线性增长的。当一个词出现一两次时，每次增加其出现频率会显著提高相关性；但当该词出现几十次后，再增加其出现频率，对相关性的额外提升效果会递减，最终趋于饱和。</li>
<li><strong>原理：</strong>
<ul>
<li>当 $f(q_i, D)$ 很小时，分母主要由 $k_1 \cdot (\dots)$ 项主导，此时 TF-Component 接近于 $\frac{f(q_i, D) \cdot (k_1 + 1)}{k_1 \cdot (\dots)}$，表现出近似线性的增长。</li>
<li>当 $f(q_i, D)$ 很大时，分母中的 $f(q_i, D)$ 会变得占主导地位，此时 TF-Component 接近于 $\frac{f(q_i, D) \cdot (k_1 + 1)}{f(q_i, D)} = k_1 + 1$。这意味着，无论词频多高，其对分数的贡献都不会超过一个上限值 $(k_1 + 1)$。</li>
<li>$k_1$ 的值控制了饱和的速度。$k_1$ 越小，饱和速度越快（即词频对分数的贡献越早达到上限）；$k_1$ 越大，饱和速度越慢（词频对分数的贡献可以持续更久）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>$(1 - b + b \cdot \frac{|D|}{avgDL})$（文档长度归一化项）：</strong></p>
<ul>
<li><strong>设计目的：</strong> 解决长文档在 TF-IDF 中可能天然获得更高分数的偏见。在没有长度归一化的情况下，一个长文档因为词汇量大，更容易包含某个查询词，而且即便某个词只出现一次，但由于文档总词数多，其 TF 值也可能被稀释。更重要的是，长文档更容易出现查询词，但并不意味着它就比短文档更相关。</li>
<li><strong>原理：</strong>
<ul>
<li><strong>$|D|$：</strong> 当前文档的长度（词数）。</li>
<li><strong>$avgDL$：</strong> 语料库中所有文档的平均长度。</li>
<li><strong>$\frac{|D|}{avgDL}$：</strong> 这个比值衡量了当前文档相对于平均文档是长还是短。
<ul>
<li>如果 $|D| &gt; avgDL$，则 $\frac{|D|}{avgDL} &gt; 1$。</li>
<li>如果 $|D| &lt; avgDL$，则 $\frac{|D|}{avgDL} &lt; 1$。</li>
</ul>
</li>
<li><strong>$b$（文档长度归一化参数）：</strong>
<ul>
<li><strong>设计作用：</strong> 控制文档长度归一化的程度。</li>
<li>当 $b=0$ 时：整个项变为 $(1 - 0 + 0 \cdot \frac{|D|}{avgDL}) = 1$。此时分母中的 $k_1 \cdot (\dots)$ 项简化为 $k_1$，完全不考虑文档长度。</li>
<li>当 $b=1$ 时：整个项变为 $(1 - 1 + 1 \cdot \frac{|D|}{avgDL}) = \frac{|D|}{avgDL}$。此时分母中的 $k_1 \cdot (\dots)$ 项变为 $k_1 \cdot \frac{|D|}{avgDL}$。这意味着，如果一个文档比平均文档长，那么分母会变大，导致整个 TF-Component 变小，从而降低该文档的分数。反之，如果文档比平均文档短，分母会变小，分数会升高。</li>
<li>通常 $b$ 取 $0.75$，这意味着长度归一化是适度的，而不是完全的。</li>
</ul>
</li>
<li><strong>整体效果：</strong> 这个长度归一化项会影响分母的大小。
<ul>
<li>对于<strong>长文档</strong>（$|D| &gt; avgDL$），这个项会大于 1，使得分母变大，从而<strong>降低</strong>整个 TF-Component 的值。</li>
<li>对于<strong>短文档</strong>（$|D| &lt; avgDL$），这个项会小于 1，使得分母变小，从而<strong>提高</strong>整个 TF-Component 的值。</li>
</ul>
</li>
<li><strong>优势：</strong> 这种设计使得短文档在包含查询词时，其相关性分数不会被长文档的“词汇量优势”所掩盖，更公平地评估其相关性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<p><strong>BM25 召回的步骤</strong></p>
<ol>
<li><strong>文本预处理：</strong> 对所有文档和查询进行分词、去除停用词、词干化/词形还原等操作。</li>
<li><strong>构建倒排索引：</strong> 为了高效计算 $f(q_i, D)$ 和 $n(q_i)$，通常需要构建倒排索引。倒排索引会存储每个词出现在哪些文档中，以及在该文档中出现的频率。</li>
<li><strong>计算所有词的 IDF 值：</strong> 遍历整个语料库，统计每个词的文档频率，然后计算其 IDF 值。</li>
<li><strong>计算平均文档长度：</strong> 遍历所有文档，计算其长度，然后求平均值。</li>
<li><strong>处理查询：</strong>
<ul>
<li>对查询进行预处理。</li>
<li>对于查询中的每个词 $q_i$，查找其在每个文档 $D$ 中的频率 $f(q_i, D)$。</li>
<li>使用上述 BM25 公式，计算查询与每个文档之间的分数。</li>
</ul>
</li>
<li><strong>排序并返回：</strong> 根据计算出的分数，对文档进行降序排序，返回得分最高的 K 个文档。</li>
</ol>
<br>
<p><strong>举例详解 BM25 召回（Python 实现）</strong></p>
<p>我们用一个简单的例子来演示 BM25 召回。</p>
<p><strong>语料库 (Corpus):</strong></p>
<ol>
<li>“The quick brown fox jumps over the lazy dog.”</li>
<li>“A dog is a man’s best friend.”</li>
<li>“Foxes are clever animals.”</li>
<li>“The quick brown fox.”</li>
</ol>
<p><strong>查询 (Query):</strong> “quick fox”</p>
<br>
<p><strong>Python 实现</strong></p>
<p>我们将使用 <code>nltk</code> 进行分词，并手动实现 BM25 算法。在实际生产环境中，你可能会使用 <code>gensim</code> 库，它内置了 BM25 实现，更加高效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> word_tokenize</span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> stopwords</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"></span><br><span class="line">nltk.download(<span class="string">&#x27;punkt_tab&#x27;</span>)</span><br><span class="line">nltk.download(<span class="string">&#x27;stopwords&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 文本预处理函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_text</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="comment"># 转为小写</span></span><br><span class="line">    text = text.lower()</span><br><span class="line">    <span class="comment"># 分词</span></span><br><span class="line">    tokens = word_tokenize(text)</span><br><span class="line">    <span class="comment"># 移除标点符号和数字 (可选，根据需求)</span></span><br><span class="line">    tokens = [word <span class="keyword">for</span> word <span class="keyword">in</span> tokens <span class="keyword">if</span> word.isalpha()]</span><br><span class="line">    <span class="comment"># 移除停用词 (可选，根据需求)</span></span><br><span class="line">    stop_words = <span class="built_in">set</span>(stopwords.words(<span class="string">&#x27;english&#x27;</span>))</span><br><span class="line">    tokens = [word <span class="keyword">for</span> word <span class="keyword">in</span> tokens <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> stop_words]</span><br><span class="line">    <span class="keyword">return</span> tokens</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 构建语料库和词汇表</span></span><br><span class="line">corpus = [</span><br><span class="line">    <span class="string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A dog is a man&#x27;s best friend.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Foxes are clever animals.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The quick brown fox.&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理所有文档</span></span><br><span class="line">processed_corpus = [preprocess_text(doc) <span class="keyword">for</span> doc <span class="keyword">in</span> corpus]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- 预处理后的文档 ---&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, doc <span class="keyword">in</span> <span class="built_in">enumerate</span>(processed_corpus):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Doc <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: <span class="subst">&#123;doc&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 计算文档频率 (DF) 和 词频 (TF)</span></span><br><span class="line"><span class="comment"># doc_freq: 存储每个词在多少个文档中出现</span></span><br><span class="line">doc_freq = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># term_freqs: 存储每个文档中每个词的频率 &#123;doc_id: &#123;word: count&#125;&#125;</span></span><br><span class="line">term_freqs = []</span><br><span class="line"><span class="comment"># doc_lengths: 存储每个文档的长度</span></span><br><span class="line">doc_lengths = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, doc_tokens <span class="keyword">in</span> <span class="built_in">enumerate</span>(processed_corpus):</span><br><span class="line">    doc_len = <span class="built_in">len</span>(doc_tokens)</span><br><span class="line">    doc_lengths.append(doc_len)</span><br><span class="line"></span><br><span class="line">    current_doc_tf = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    unique_words_in_doc = <span class="built_in">set</span>() <span class="comment"># 用于统计doc_freq</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> doc_tokens:</span><br><span class="line">        current_doc_tf[token] += <span class="number">1</span></span><br><span class="line">        unique_words_in_doc.add(token)</span><br><span class="line"></span><br><span class="line">    term_freqs.append(current_doc_tf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> unique_words_in_doc:</span><br><span class="line">        doc_freq[word] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">N = <span class="built_in">len</span>(corpus) <span class="comment"># 文档总数</span></span><br><span class="line">avgDL = <span class="built_in">sum</span>(doc_lengths) / N <span class="comment"># 平均文档长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;文档总数 (N): <span class="subst">&#123;N&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;平均文档长度 (avgDL): <span class="subst">&#123;avgDL:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- 词的文档频率 (DF) ---&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> word, df <span class="keyword">in</span> doc_freq.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;&#x27;<span class="subst">&#123;word&#125;</span>&#x27;: <span class="subst">&#123;df&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 计算 IDF (Inverse Document Frequency)</span></span><br><span class="line"><span class="comment"># IDF(q_i) = log((N - n(q_i) + 0.5) / (n(q_i) + 0.5)) + 1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_idf</span>(<span class="params">word, N, doc_freq</span>):</span><br><span class="line">    n_qi = doc_freq.get(word, <span class="number">0</span>) <span class="comment"># 包含词的文档数量</span></span><br><span class="line">    <span class="keyword">return</span> math.log((N - n_qi + <span class="number">0.5</span>) / (n_qi + <span class="number">0.5</span>)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 实现 BM25 评分函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bm25_score</span>(<span class="params">query_tokens, doc_id, k1, b, N, avgDL, term_freqs, doc_freq, doc_lengths</span>):</span><br><span class="line">    score = <span class="number">0.0</span></span><br><span class="line">    current_doc_tf = term_freqs[doc_id]</span><br><span class="line">    doc_len = doc_lengths[doc_id]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> q_i <span class="keyword">in</span> query_tokens:</span><br><span class="line">        <span class="comment"># 如果查询词不在文档中，跳过</span></span><br><span class="line">        <span class="keyword">if</span> q_i <span class="keyword">not</span> <span class="keyword">in</span> current_doc_tf:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        f_qi_D = current_doc_tf[q_i] <span class="comment"># 词 q_i 在文档 D 中的频率</span></span><br><span class="line">        idf_qi = calculate_idf(q_i, N, doc_freq)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算 BM25 的 TF 部分</span></span><br><span class="line">        tf_component = (f_qi_D * (k1 + <span class="number">1</span>)) / (f_qi_D + k1 * (<span class="number">1</span> - b + b * (doc_len / avgDL)))</span><br><span class="line">        </span><br><span class="line">        score += idf_qi * tf_component</span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 定义参数</span></span><br><span class="line">k1 = <span class="number">1.5</span> <span class="comment"># 词频饱和度参数，常用范围 1.2 - 2.0</span></span><br><span class="line">b = <span class="number">0.75</span> <span class="comment"># 文档长度归一化参数，常用范围 0 - 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 执行查询</span></span><br><span class="line">query = <span class="string">&quot;quick fox&quot;</span></span><br><span class="line">processed_query = preprocess_text(query)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;查询 (Query): &#x27;<span class="subst">&#123;query&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;预处理后的查询: <span class="subst">&#123;processed_query&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    score = bm25_score(processed_query, i, k1, b, N, avgDL, term_freqs, doc_freq, doc_lengths)</span><br><span class="line">    results.append((score, i, corpus[i]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 排序并输出结果</span></span><br><span class="line">results.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- BM25 召回结果 ---&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> score, doc_id, original_doc <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文档 ID: <span class="subst">&#123;doc_id+<span class="number">1</span>&#125;</span>, 分数: <span class="subst">&#123;score:<span class="number">.4</span>f&#125;</span>, 文档内容: &#x27;<span class="subst">&#123;original_doc&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果和分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- 预处理后的文档 ---</span><br><span class="line">Doc 1: [&#x27;quick&#x27;, &#x27;brown&#x27;, &#x27;fox&#x27;, &#x27;jumps&#x27;, &#x27;lazy&#x27;, &#x27;dog&#x27;]</span><br><span class="line">Doc 2: [&#x27;dog&#x27;, &#x27;man&#x27;, &#x27;best&#x27;, &#x27;friend&#x27;]</span><br><span class="line">Doc 3: [&#x27;foxes&#x27;, &#x27;clever&#x27;, &#x27;animals&#x27;]</span><br><span class="line">Doc 4: [&#x27;quick&#x27;, &#x27;brown&#x27;, &#x27;fox&#x27;]</span><br><span class="line">------------------------------</span><br><span class="line">文档总数 (N): 4</span><br><span class="line">平均文档长度 (avgDL): 4.00</span><br><span class="line">--- 词的文档频率 (DF) ---</span><br><span class="line">&#x27;brown&#x27;: 2</span><br><span class="line">&#x27;jumps&#x27;: 1</span><br><span class="line">&#x27;dog&#x27;: 2</span><br><span class="line">&#x27;fox&#x27;: 2</span><br><span class="line">&#x27;lazy&#x27;: 1</span><br><span class="line">&#x27;quick&#x27;: 2</span><br><span class="line">&#x27;best&#x27;: 1</span><br><span class="line">&#x27;man&#x27;: 1</span><br><span class="line">&#x27;friend&#x27;: 1</span><br><span class="line">&#x27;foxes&#x27;: 1</span><br><span class="line">&#x27;clever&#x27;: 1</span><br><span class="line">&#x27;animals&#x27;: 1</span><br><span class="line">------------------------------</span><br><span class="line">查询 (Query): &#x27;quick fox&#x27;</span><br><span class="line">预处理后的查询: [&#x27;quick&#x27;, &#x27;fox&#x27;]</span><br><span class="line">------------------------------</span><br><span class="line">--- BM25 召回结果 ---</span><br><span class="line">文档 ID: 4, 分数: 2.2535, 文档内容: &#x27;The quick brown fox.&#x27;</span><br><span class="line">文档 ID: 1, 分数: 1.6327, 文档内容: &#x27;The quick brown fox jumps over the lazy dog.&#x27;</span><br><span class="line">文档 ID: 2, 分数: 0.0000, 文档内容: &#x27;A dog is a man&#x27;s best friend.&#x27;</span><br><span class="line">文档 ID: 3, 分数: 0.0000, 文档内容: &#x27;Foxes are clever animals.&#x27;</span><br></pre></td></tr></table></figure>
<br>
<h4 id="地理位置召回">地理位置召回</h4>
<br>
<h4 id="关注者召回">关注者召回</h4>
<br>
<h4 id="缓存召回">缓存召回</h4>
<br>
<br>
<h2 id="排序">排序</h2>
<h3 id="GBDT-LR">GBDT+LR</h3>
<br>
<br>
<h3 id="特征交叉">特征交叉</h3>
<br>
<br>
<h3 id="序列模型">序列模型</h3>
<br>
<h3 id="多任务学习">多任务学习</h3>
<br>
<h2 id="重排">重排</h2>
<br>
<h3 id="RRF算法">RRF算法</h3>
<p>RRF算法的目的是生成一个 <strong>有序且受到限制的重排序列</strong>。它不是一个通用的随机排列算法，而是针对 <strong>排名信息</strong> 和 <strong>限制条件</strong> 进行重排列的。可以理解为：在一个已排序的基础上，进行<strong>局部调整</strong>，以达到某种优化目标。</p>
<br>
<h2 id="物品冷启动">物品冷启动</h2>
<br>
<br>]]></content>
      <categories>
        <category>SAR</category>
      </categories>
      <tags>
        <tag>Python, LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>common-commands</title>
    <url>/2024/06/22/common-commands/</url>
    <content><![CDATA[<p>常用指令</p>
<span id="more"></span>
<h1>Common Commands</h1>
<h2 id="python">python</h2>
<p><a href="https://zhuanlan.zhihu.com/p/69746955">https://zhuanlan.zhihu.com/p/69746955</a></p>
<p>python变量，函数均为对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() : </span><br><span class="line">    <span class="comment">#函数在创建时同时生成变量对象hello和函数对象（函数对象名为hello）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    x=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test())<span class="comment">#函数默认返回值为None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say = hello</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> hello <span class="comment">#del删除了hello变量对象</span></span><br><span class="line">say()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(say))<span class="comment">##对象属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(say))<span class="comment">##对象属性</span></span><br><span class="line"><span class="built_in">print</span>(say)<span class="comment">##对象属性</span></span><br><span class="line"><span class="built_in">print</span>(say.__name__) <span class="comment">##对象属性,查看对象名</span></span><br></pre></td></tr></table></figure>
<p>python类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line">    def my_method(self, arg1, arg2):</span><br><span class="line">    #类的方法第一个参数为self</span><br><span class="line">        # 方法体</span><br><span class="line"></span><br><span class="line">#Bound Method</span><br><span class="line">obj = MyClass()#类 实例化</span><br><span class="line">obj.my_method(arg1, arg2)#实例对象调用方法</span><br><span class="line"></span><br><span class="line">#Unbound Method</span><br><span class="line">MyClass.my_method(obj, arg1, arg2)</span><br><span class="line">	#原因：可以直接通过类访问方法，但是必须指定类的实例</span><br></pre></td></tr></table></figure>
<p>函数内部函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hello()())</span><br><span class="line"><span class="comment">#首先hello()返回函数对象test，然后调用 test()</span></span><br></pre></td></tr></table></figure>
<p>函数装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inn</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;inner&quot;</span>)</span><br><span class="line">        f()</span><br><span class="line">    <span class="keyword">return</span> inn</span><br><span class="line"></span><br><span class="line"><span class="meta">@hello</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">test=hello(test)<span class="comment">#原函数对象test仍存在，变量对象test指向新函数hello(test)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#test &lt;function test at 0x000001821AE551C0&gt;</span></span><br><span class="line"><span class="comment">#test() None</span></span><br><span class="line"><span class="comment">#test为函数对象，test()为（执行函数对象后的）返回值</span></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(test.__name__)</span><br></pre></td></tr></table></figure>
<p>with语句 上下文对象管理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    contents = f.read()</span><br><span class="line">    print(contents)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>open(‘myfile.txt’, ‘r’)</strong>：这是一个上下文管理器，它打开文件并返回一个文件对象。</li>
<li><strong>as f</strong>：将文件对象赋值给变量 f，以便在 with 代码块中使用。</li>
<li>在 with 代码块中，我们可以使用 f 读取文件内容。</li>
<li>当 with 代码块执行完毕后，文件会自动关闭，即使在读取过程中发生异常。</li>
</ul>
<p>Python类型注解</p>
<p><a href="https://zhuanlan.zhihu.com/p/419955374">https://zhuanlan.zhihu.com/p/419955374</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment">#规定函数传入参数为str类型，返回值为str类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mix</span>(<span class="params">scores: <span class="built_in">list</span>[<span class="built_in">int</span>], ages: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]</span>) -&gt; <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment">#容器注解</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">seq: Seq1[<span class="built_in">str</span>]</span>):</span><br><span class="line">    <span class="comment">#传入参数为（列表+元组）的泛化：序列Seq</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a: <span class="built_in">int</span> = <span class="number">0</span></span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="comment">#可选返回值：为None或为str</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Yeah&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>() -&gt; <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>, <span class="built_in">float</span>]:</span><br><span class="line">    <span class="comment">#可选返回值：为str，int，float 三选一</span></span><br><span class="line">    <span class="comment">#Optional[int] 和 Union[int, None] 是等价的。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#T为泛型，T必须为str或int</span></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>, <span class="built_in">str</span>, <span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a: T, b: T</span>) -&gt; <span class="type">List</span>[T]:</span><br><span class="line">    <span class="keyword">return</span> [a, b]</span><br><span class="line"></span><br><span class="line"><span class="comment"># K的具体类型没有限制</span></span><br><span class="line">K = TypeVar(<span class="string">&quot;K&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="python-环境">python 环境</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  <span class="comment"># 更新包管理器</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install python3-venv  <span class="comment"># 安装Python虚拟环境工具</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /path/to/your/project</span><br><span class="line"></span><br><span class="line">python3 -m venv venv</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br><span class="line"></span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<p>conda指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line"></span><br><span class="line">conda create --name your_env_name python=3.5 numpy scipy</span><br><span class="line"></span><br><span class="line">conda remove --name your_env_name --all</span><br><span class="line"></span><br><span class="line">conda install</span><br><span class="line"></span><br><span class="line">conda install numpy=1.9.3</span><br><span class="line"></span><br><span class="line">activate your_env_name</span><br><span class="line"></span><br><span class="line">deactivate</span><br><span class="line"></span><br><span class="line">conda clean --all</span><br></pre></td></tr></table></figure>
<p>当前conda虚拟环境中存在pip时，使用pip指令将优先使用环境中pip而非全局pip，可通过pip list（当前环境必须已安装pip）和 conda list 查看当前环境包列表</p>
<p>出现报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PackagesNotFoundError: The following packages are not available from current channels</span><br></pre></td></tr></table></figure>
<p>尝试在<a href="https://anaconda.xn--org-us9ds1a2eq8vn4srgggrku8b9tcdqf8an48pgtee4b666aphkt3ki53cqmo">https://anaconda.org直接搜索该包并使用网站所提供的指令安装</a></p>
<h2 id="Docker">Docker</h2>
<ol>
<li>
<p><strong><code>docker pull</code></strong>：用于从 Docker 镜像仓库下载镜像到本地主机。</p>
<ul>
<li>语法：<code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code></li>
<li>示例：<code>docker pull ubuntu:20.04</code></li>
</ul>
<p>这个命令用于获取 Docker 镜像，其中 <code>NAME</code> 表示镜像的名称，<code>TAG</code> 表示镜像的标签，或者可以使用 <code>@DIGEST</code> 来指定镜像的摘要。如果不指定标签，将默认获取 <code>latest</code> 标签的镜像。</p>
</li>
<li>
<p><strong><code>docker load</code></strong>：用于从文件加载镜像，通常是以 tar 归档文件的形式。</p>
<ul>
<li>语法：<code>docker load [OPTIONS]</code></li>
<li>示例：<code>docker load -i myimage.tar</code></li>
</ul>
<p>这个命令用于加载以 tar 归档文件格式存储的 Docker 镜像。通常用于将镜像从一个环境传输到另一个环境。</p>
</li>
<li>
<p><strong><code>docker save</code></strong>：用于将 Docker 镜像保存为 tar 归档文件。</p>
<ul>
<li>语法：<code>docker save [OPTIONS] IMAGE [IMAGE...]</code></li>
<li>示例：<code>docker save -o myimage.tar myimage:tag</code></li>
</ul>
<p>这个命令允许你将一个或多个 Docker 镜像保存为 tar 归档文件，通常用于导出镜像以便在不同环境中使用。</p>
</li>
<li>
<p><strong><code>docker run</code></strong>：用于创建和启动 Docker 容器。</p>
<ul>
<li>语法：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></li>
<li>示例：<code>docker run -d -p 8080:80 my-web-app</code></li>
</ul>
<p>这个命令用于在 Docker 容器中运行一个镜像，你需要指定镜像的名称、容器选项（如端口映射、环境变量、容器名称等），以及容器内要执行的命令。</p>
</li>
<li>
<p><strong><code>docker build</code></strong>：用于构建自定义 Docker 镜像，通常通过 Dockerfile 文件定义构建步骤。</p>
<ul>
<li>语法：<code>docker build [OPTIONS] PATH | URL | -</code></li>
<li>示例：<code>docker build -t my-custom-image .</code></li>
</ul>
<p><code>docker build</code> 命令用于基于 Dockerfile 构建自定义镜像。你需要提供包含 Dockerfile 的路径，以及可选的选项和标签。</p>
<p>Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用官方 Python 3 镜像作为基础镜像</span><br><span class="line">FROM python:3.8</span><br><span class="line"></span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 复制本地项目到容器中</span><br><span class="line">COPY ./myproject /app</span><br><span class="line"></span><br><span class="line"># 安装项目依赖</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"># 指定容器启动命令</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>docker rm</code></strong>：用于删除已停止的容器。</p>
<ul>
<li>语法：<code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code></li>
<li>示例：<code>docker rm my-container</code></li>
</ul>
<p>这个命令用于删除一个或多个已经停止的容器，释放资源并清理系统。</p>
</li>
<li>
<p><strong><code>docker stop</code></strong>：用于停止运行中的容器。</p>
<ul>
<li>语法：<code>docker stop [OPTIONS] CONTAINER [CONTAINER...]</code></li>
<li>示例：<code>docker stop my-container</code></li>
</ul>
<p>这个命令用于停止一个或多个正在运行的容器，使它们从运行状态转换为停止状态。</p>
</li>
<li>
<p><strong><code>docker ps</code></strong>：用于列出正在运行的容器。</p>
<ul>
<li>语法：<code>docker ps [OPTIONS]</code></li>
<li>示例：<code>docker ps -a</code></li>
</ul>
<p><code>docker ps</code> 命令用于列出当前正在运行的容器，包括容器的 ID、状态、端口映射等信息。加上 <code>-a</code> 选项可以列出所有容器，包括已停止的容器。</p>
</li>
</ol>
<h2 id="Git操作实例"><strong>Git操作实例</strong></h2>
<p>Git 的设计是基于不可变的 DAG（有向无环图）</p>
<p><strong>工作区</strong>：开发者在工作区中进行日常的代码开发和修改工作（就是什么git操作都没有做直接改代码，这个地方就是工作区</p>
<p><strong>暂存区</strong>：<code>git add</code> 会将文件的当前状态（即 <strong>修改后的内容</strong>）从 <strong>工作区</strong> 拷贝到 <strong>暂存区</strong>。如果此时再次修改 <strong>工作区</strong> 内容， <strong>暂存区</strong> 内容不受影响。</p>
<p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在桌面创建test目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /Users/wangsaichao/Desktop/test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到test目录</span></span><br><span class="line"><span class="built_in">cd</span> /Users/wangsaichao/Desktop/test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并初始化git库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接到远程git仓库 </span></span><br><span class="line"><span class="comment"># -t 默认使用远程仓库的 main 分支，origin为远程仓库别名（替换链接）</span></span><br><span class="line"><span class="comment"># 为本地分支 main 设置了上游跟踪分支为 origin/main。这意味着当执行 git pull 或 git push 不带分支参数 时，Git 会默认使用 main 分支与 origin/main 同步</span></span><br><span class="line">git remote add origin -t main https://github.com/xx/xxx.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程git库下载到本地</span></span><br><span class="line">git pull origin/main</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录下所有文件都增加到本地库中。</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交更改到本地仓库</span></span><br><span class="line">git commit -m <span class="string">&#x27;提交注释&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地的master分支改为main分支, github为避免联想奴隶制。在持续的外界影响之下,默认分支由master改为main。 </span></span><br><span class="line"><span class="comment"># 但是git工具默认init还是创建的master分支 所以要改成main分支。</span></span><br><span class="line">git branch -M main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地修改推到github上</span></span><br><span class="line">git push -u origin main  <span class="comment"># 首次</span></span><br><span class="line">git push origin main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除文件跟踪 适用于文件夹</span></span><br><span class="line">git <span class="built_in">rm</span> -r --cached <span class="built_in">dir</span>/</span><br><span class="line"><span class="comment"># 移除文件跟踪 适用于文件</span></span><br><span class="line">git <span class="built_in">rm</span> --cached file</span><br></pre></td></tr></table></figure>
<p>branch</p>
<p><strong>创建一个新的分支指针</strong>，并将它指向当前的 <code>HEAD</code> 所在的检查点（即当前的 commit）。这个新的分支指针会指向当前分支的最新提交，或者如果你在一个 <strong>detached HEAD</strong> 状态下，它会指向 <code>HEAD</code> 当前指向的 commit。</p>
<ul>
<li>
<p><strong>分支指针始终指向该分支最新的 commit（HEAD 的位置）。</strong></p>
</li>
<li>
<p>当在该分支上提交新的 commit 时，分支指针会自动前移到新 commit。</p>
</li>
<li>
<p>注意，分支指针指向的是最新的 commit，而不是所有 commit。历史 commit 通过链式引用联系在一起。</p>
</li>
</ul>
<p>commit</p>
<p>创建检查点，每个 commit 都有一个或多个后继引用它（例如分支或标签），但它不“属于”任何特定分支。</p>
<p><strong>判断一个节点是否是“野生”的，核心就是看是否有任何分支指针通过回溯能够遍历到它。</strong></p>
<p>add</p>
<p>将工作区内容<strong>覆写</strong>到暂存区</p>
<p>checkout</p>
<p>使<strong>head指针</strong>指向<strong>指定branch指针</strong>或<strong>检查点</strong></p>
<p>git checkout main  # 切换head指向main分支指针</p>
<p>git checkout C1  # 切换head指向检查点，<strong>此时head指针与main指针分离！！！</strong>，后续提交的节点为&quot;野生&quot;节点</p>
<blockquote>
<p>当 HEAD 指针移动到 main 分支上的非最新提交 c1 (最新提交是 c2) 后，执行commit指令</p>
<ol>
<li><strong>HEAD 指针移动:</strong> git checkout c1 命令会将 HEAD 指针移动到 c1 提交，此时处于 “分离 HEAD 状态”。</li>
<li><strong>新提交产生:</strong> 当进行新的提交时，Git 会创建一个新的提交对象 c3，并将 c1 作为 c3 的父提交。</li>
<li><strong>HEAD 指针移动:</strong> c3 提交创建后，HEAD 指针会指向新的提交 c3。新的检查点将不属于任何branch，可能在未来的被垃圾回收</li>
</ol>
</blockquote>
<p>reset</p>
<p>移动当前branch指针到指定检查点</p>
<p>假设有以下历史：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A---B---C---D  (main)</span><br><span class="line">            ^</span><br><span class="line">           HEAD</span><br></pre></td></tr></table></figure>
<ol>
<li><strong><code>git reset --soft B</code></strong>：
<ul>
<li>HEAD 指向 <code>B</code>。</li>
<li><code>C</code> 和 <code>D</code> 被“取消”，但它们的更改仍然在暂存区中（即提交<code>C</code>和<code>D</code>的修改内容全部保存在暂存区</li>
</ul>
</li>
<li><strong><code>git reset --mixed B</code></strong>：
<ul>
<li>HEAD 指向 <code>B</code>。</li>
<li><code>C</code> 和 <code>D</code> 的更改从暂存区移到工作区。</li>
</ul>
</li>
<li><strong><code>git reset --hard B</code></strong>：
<ul>
<li>HEAD 指向 <code>B</code>。</li>
<li><code>C</code> 和 <code>D</code> 被丢弃，暂存区和工作区都回到 <code>B</code> 的状态。</li>
</ul>
</li>
</ol>
<p>rebase [target branch] [source branch(可选)]</p>
<p>假设有以下分支结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A---B---C  (current-branch)</span><br><span class="line"> \</span><br><span class="line">  D---E---F  (target-branch)</span><br></pre></td></tr></table></figure>
<p>在 <code>current-branch</code> 上运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase target-branch</span><br></pre></td></tr></table></figure>
<p>Rebase 会执行以下步骤：</p>
<ol>
<li><strong>找到共同祖先</strong>：
<ul>
<li><code>A</code> 是 <code>current-branch</code> 和 <code>target-branch</code> 的共同祖先。</li>
</ul>
</li>
<li><strong>暂存当前分支的提交</strong>：
<ul>
<li>提取 <code>B</code> 和 <code>C</code>，准备在目标分支上重新应用。</li>
</ul>
</li>
<li><strong>在目标分支的基础上重新应用</strong>：
<ul>
<li><code>B</code> 被重新应用到 <code>F</code> 之后，产生一个新的 commit（假设为 <code>B'</code>）。</li>
<li><code>C</code> 被重新应用到 <code>B'</code> 之后，产生另一个新的 commit（假设为 <code>C'</code>）。</li>
</ul>
</li>
<li><strong>移动当前分支的指针</strong>：
<ul>
<li><code>current-branch</code> 的指针被移动到 <code>C'</code>。</li>
</ul>
</li>
</ol>
<p>最终的结构变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D---E---F---B&#x27;---C&#x27;  (current-branch)</span><br></pre></td></tr></table></figure>
<p>merge [target branch]</p>
<p>创建新的检查点，该检查点的父节点为<strong>当前branch指针所指向节点</strong>和<strong>目标branch指针所指向节点</strong>，<strong>移动当前branch指针指向新创建节点</strong>。</p>
<p>fetch</p>
<ul>
<li>fetch将下载远程仓库的内容，并移动 远程指针 &lt;远程仓库名&gt;/&lt;分支&gt; 指向与远程仓库同步的位置</li>
<li>不更新本地指针！！！这意味着，如果本地main分支指针现在指向C2，远程指针指向C1，远程仓库已更新至C3，执行fetch后会存在以下情况</li>
</ul>
<img src="/2024/06/22/common-commands/image-20240823160319940.png" class="" title="image-20240823160319940">
<img src="/2024/06/22/common-commands/image-20240823160406360.png" class="" title="image-20240823160406360">
<p>pull</p>
<ul>
<li>pull指令为fetch和merge指令的和，因此会使当前branch指针移动</li>
<li><code>git pull</code> 拉取时，默认是针对当前分支关联的单个远程分支进行操作</li>
</ul>
<p><code>git pull</code> 的一些常见行为：</p>
<ul>
<li>
<p><strong><code>git pull</code> (不带参数):</strong> 这是最常用的方式。它会从当前分支追踪的远程分支获取最新提交，并尝试将其合并到当前分支。如果你的当前分支已经设置了上游分支 (upstream branch)，那么 <code>git pull</code> 将会使用这个上游分支。你可以使用 <code>git branch -vv</code> 查看当前分支追踪的远程分支。</p>
</li>
<li>
<p>**<code>git pull &lt;remote&gt; &lt;branch&gt;</code>: ** 这会从指定的远程仓库 <code>&lt;remote&gt;</code> 的 <code>&lt;branch&gt;</code> 分支获取最新提交，并尝试将其合并到当前分支。 例如，<code>git pull origin develop</code> 会从远程仓库 <code>origin</code> 的 <code>develop</code> 分支获取更新，并合并到当前分支。</p>
</li>
<li>
<p><strong><code>git pull --rebase</code>:</strong> 这会使用 <code>git rebase</code> 而不是 <code>git merge</code> 来整合远程分支的更改。<code>rebase</code> 会将你的本地提交放在远程分支的最新提交之后，从而创建一个更线性的提交历史。  可以通过 <code>git config --global pull.rebase true</code> 设置全局使用 rebase 模式。</p>
</li>
</ul>
<p>push</p>
<ul>
<li><code>git push</code> 命令默认只推送<strong>当前分支</strong>到远程对应的分支。</li>
</ul>
<p>几种 <code>git push</code> 的行为：</p>
<ul>
<li>
<p><strong><code>git push</code> (不带任何参数):</strong>  推送当前分支到其upstream分支。如果当前分支没有设置upstream分支，会报错。  这是最常用的方式。</p>
</li>
<li>
<p><strong><code>git push &lt;remote&gt;</code>:</strong> 推送当前分支到指定远程仓库 <code>&lt;remote&gt;</code> 的同名分支。例如 <code>git push origin</code> 会将当前分支推送到名为 <code>origin</code> 的远程仓库的同名分支。</p>
</li>
<li>
<p><strong><code>git push &lt;remote&gt; &lt;branch&gt;</code>:</strong> 将本地 <code>&lt;branch&gt;</code> 分支推送到远程仓库 <code>&lt;remote&gt;</code> 的 <code>&lt;branch&gt;</code> 分支。例如 <code>git push origin develop</code> 会将本地的 <code>develop</code> 分支推送到远程仓库 <code>origin</code> 的 <code>develop</code> 分支。</p>
</li>
<li>
<p><strong><code>git push &lt;remote&gt; &lt;local_branch&gt;:&lt;remote_branch&gt;</code>:</strong> 将本地 <code>&lt;local_branch&gt;</code> 分支推送到远程仓库 <code>&lt;remote&gt;</code> 的 <code>&lt;remote_branch&gt;</code> 分支。 这允许你将本地分支推送到远程的不同名分支。例如 <code>git push origin feature/new-login:develop</code> 会将本地的 <code>feature/new-login</code> 分支推送到远程仓库 <code>origin</code> 的 <code>develop</code> 分支。</p>
</li>
<li>
<p><strong><code>git push &lt;remote&gt; --all</code>:</strong> 推送所有本地分支到远程仓库 <code>&lt;remote&gt;</code>。</p>
</li>
<li>
<p><strong><code>git push &lt;remote&gt; --tags</code>:</strong>  推送所有本地标签到远程仓库 <code>&lt;remote&gt;</code>。</p>
</li>
</ul>
<h2 id="bash通配符">bash通配符</h2>
<p>?表示单个字符，*表示任意个字符，[abc]表示匹配abc中任意一个字符，{a,b,c}表示匹配a或b或c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls [ab].txt</span><br><span class="line">a.txt b.txt</span><br><span class="line"></span><br><span class="line">$ ls *[ab].txt</span><br><span class="line">ab.txt a.txt b.txt</span><br><span class="line"></span><br><span class="line">$ echo d&#123;a,e,i,u,o&#125;g</span><br><span class="line">dag deg dig dug dog</span><br></pre></td></tr></table></figure>
<h2 id="gcc">gcc</h2>
<p>hello.c -预处理 -E-&gt; hello.i -编译 -S-&gt; hello.s -汇编 -c-&gt; hello.o -链接 -&gt; hello</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc  main.cpp hello.cpp factorial.cpp -o hello</span><br></pre></td></tr></table></figure>
<p>使用gcc 将多个文件 <strong>生成</strong> 为 hello可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	gcc test.c</span><br><span class="line">	将 test.c 预处理、编译、汇编并链接形成可执行文件。这里未指定输出文件，默认输出为 a.out。</span><br><span class="line"></span><br><span class="line">-o：指定生成的输出文件；</span><br><span class="line">	gcc test.c -o test</span><br><span class="line">	将 test.c 预处理、编译、汇编并链接形成可执行文件 test。-o 选项用来指定输出文件的文件名。</span><br><span class="line">	</span><br><span class="line">-E：仅执行编译预处理；</span><br><span class="line">	gcc -E test.c -o test.i</span><br><span class="line">	将 test.c 预处理输出 test.i 文件。</span><br><span class="line"></span><br><span class="line">-S：将C代码转换为汇编代码；</span><br><span class="line">	gcc -S test.i</span><br><span class="line">	将预处理输出文件 test.i 汇编成 test.s 文件。</span><br><span class="line"></span><br><span class="line">-wall：显示警告信息；</span><br><span class="line"></span><br><span class="line">-c：仅执行编译操作，不进行连接操作。</span><br><span class="line">	gcc -c test.s</span><br><span class="line">	将汇编输出文件 test.s 编译输出 test.o 文件。</span><br><span class="line"></span><br><span class="line">-l：用来指定程序要链接的库，-l参数紧接着就是库名</span><br><span class="line"></span><br><span class="line">-I：寻找头文件的目录</span><br></pre></td></tr></table></figure>
<h2 id="Makefile">Makefile</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make main</span><br><span class="line">make -f config.txt //指定makefile文件</span><br><span class="line">make --file=config.txt</span><br></pre></td></tr></table></figure>
<p>使用Make指令执行Makefile文件(make指令自动寻找当前文件夹下的Makefile文件)</p>
<p>Makefile文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;	//目标，前置条件</span><br><span class="line">[tab] &lt;commands&gt;	//命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY: clean	//声明目标clean为伪目标</span><br><span class="line">clean:</span><br><span class="line">    rm -rf *.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//一个简单的实例</span><br><span class="line">main:main.o fun0.o fun1.o fun2.0	</span><br><span class="line">	gcc -o main main.o fun0.o fun1.o fun2.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//一个复杂的实例</span><br><span class="line"># Define required macros here</span><br><span class="line">SHELL = /bin/sh		//宏定义</span><br><span class="line">OBJS =  main.o factorial.o hello.o</span><br><span class="line">CFLAG = -Wall -g</span><br><span class="line">CC = gcc</span><br><span class="line">INCLUDE =</span><br><span class="line">LIBS = -lm</span><br><span class="line">hello:$&#123;OBJ&#125;	//$&#123;&#125;表示变量</span><br><span class="line">   $&#123;CC&#125; $&#123;CFLAGS&#125; $&#123;INCLUDES&#125; -o $@ $&#123;OBJS&#125; $&#123;LIBS&#125;</span><br><span class="line">clean:</span><br><span class="line">   -rm -f *.o core *.core	//类似于bash,?表示单个字符，*表示任意个字符，[abc]表示匹配abc中任意个字符，&#123;a,b,c&#125;表示匹配a或b或c</span><br><span class="line">.cpp.o:</span><br><span class="line">   $&#123;CC&#125; $&#123;CFLAGS&#125; $&#123;INCLUDES&#125; -c</span><br></pre></td></tr></table></figure>
<p>冒号左侧：目标文件</p>
<p>冒号右侧：被依赖文件，前置条件</p>
<p>前置条件决定 “目标” 是否需要重新构建。只要前置条件中列出的文件中，有任何一个文件被更新（即前置条件列出的文件的最后修改时间比目标的最后修改时间新），或者 “目标” 不存在，那 “目标” 就需要重新构建。</p>
<p>如果前置条件中列出的文件中有任何一个文件不存在，那么 Make 就需要在 Makefile 文件中寻找并执行能够生成该文件的规则，也就是说缺失文件本身也是一个 “目标”，需要先将该 “目标” 构建出来才能利用它去构建当前 “目标”（构建 A 时发现 A 需要依赖 B，所以要先构建 B 才能继续构建 A，简称递归生成依赖）。</p>
<p><code>$@</code>，<code>$^</code>，<code>$&lt;</code> 这种符号，这种符号称为自动变量。自动变量是局部变量，作用域范围在当前的规则内（即自动化变量只应该出现在 Makefile 目标规则中）</p>
<p><code>$@</code> 指代当前目标， Make 命令意图构建的目标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello: hello.o</span><br><span class="line">    gcc hello.o -o $@	//$@为hello</span><br></pre></td></tr></table></figure>
<p><code>$&lt;</code> 指代第一个前置条件。比如规则为 hello: a b，那么 <code>$&lt;</code> 就指代 a。</p>
<p><code>$^</code> 指代所有前置条件，之间以空格分隔。比如，规则为 hello: a b，那么 <code>$^</code> 就指代 a 和 b。</p>
]]></content>
      <tags>
        <tag>Python, Bash, C</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2024/04/11/first_post/</url>
    <content><![CDATA[<p>写一个测试试一下</p>
<p>数学公式测试：$r_n=W_n\log_2\left(1+\frac{P_nd_n^{-\beta}h_n^2}{N_0+I_n}\right)$</p>
<p>$$t_n^{loc}=\frac{(1-\rho_n)C_n}{f_n}$$</p>
]]></content>
  </entry>
  <entry>
    <title>pic_test</title>
    <url>/2024/04/12/pic-test/</url>
    <content><![CDATA[<p>图片插入测试：</p>
<img src="/2024/04/12/pic-test/img.png" class="">]]></content>
  </entry>
  <entry>
    <title>Op_sys Learning Record</title>
    <url>/2024/04/12/Op-sys-Learning-Record/</url>
    <content><![CDATA[<p>操作系统相关学习记录</p>
<span id="more"></span>
<h1>Op_sys_learning_record</h1>
<h3 id="硬件">硬件</h3>
<p>QEMU：近似模拟硬件SiFiveFU540-C000主板(RISC-V,64 bit register, 56 bit physical memory)</p>
<p>intel 8086：20根地址线，16位寄存器</p>
<h3 id="软件">软件</h3>
<p>XV6：操作系统</p>
<p><a href="https://github.com/seaswalker/tiny-os">tiny-os</a></p>
<h2 id="系统启动">系统启动</h2>
<h3 id="基础信息">基础信息</h3>
<h4 id="物理地址空间">物理地址空间</h4>
<p>20根地址线，16位寄存器，可访问1MB的内存空间</p>
<p>0x00000-0x9FFFF: DRAM</p>
<p>0xF0000-0xFFFFF: ROM，BIOS代码位置</p>
<p>通过段寄存器左移4位+偏移地址</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240413150024273.png" class="" title="image-20240413150024273">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240417110651232.png" class="" title="image-20240417110651232">
<h4 id="SiFive-FU540物理地址空间">SiFive FU540物理地址空间</h4>
<p>物理地址0x80000000以前的部分由主板上非DRAM组成（例如：boot ROM，PLIC等）</p>
<p>物理地址对应的硬件（图例为SiFive主板，仅截取部分，物理地址0x80000000以前的部分非DRAM）</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240413150852809.png" class="" title="image-20240413150852809">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240412184947166.png" class="" title="image-20240412184947166">
<h4 id="显存地址空间">显存地址空间</h4>
<p>0xB8000-0xBFFFF为显存中字符显示部分，默认模式为80个字符*25行，一个字符2字节表示</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240420184138573.png" class="" title="image-20240420184138573">
<h4 id="寄存器">寄存器</h4>
<p>不可见寄存器</p>
<p>GDTR	全局描述符表寄存器</p>
<p>IDTR	中断描述符表寄存器</p>
<p>LDTR	局部描述符表寄存器</p>
<p>TR	任务寄存器</p>
<p>CR0~3	控制寄存器</p>
<p>IP	指令指针寄存器</p>
<p>flags	标志寄存器</p>
<p>DR0~3	调试寄存器</p>
<p>可见寄存器</p>
<p>通用寄存器，可直接访问</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240420144227413.png" class="" title="image-20240420144227413">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240420144655049.png" class="" title="image-20240420144655049">
<p>段寄存器，段基址*16+偏移</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240420144356905.png" class="" title="image-20240420144356905">
<p>32位与16位</p>
<p>32位地址总线，32位寄存器</p>
<p>寄存器组</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240416185859023.png" class="" title="image-20240416185859023">
<p>通用寄存器组，Eflag和EIP变为32位</p>
<p>段寄存器仍为16位宽！！内容为段选择子</p>
<h4 id="Intel语法风格">Intel语法风格</h4>
<p>右 -&gt; 左</p>
<p>实模式</p>
<p>段内偏移默认基于DS进行偏移</p>
<p>基址寄存器：bx寄存器默认基于DS进行偏移，bp寄存器默认基于SS进行偏移</p>
<p>变址寄存器：si寄存器和di寄存器默认基于ds进行偏移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, [0x1234]	;取DS*16+0x1234处的值赋给ax</span><br><span class="line"></span><br><span class="line">add [bx], 0x1234	;将0x1234赋给内存中DS*16+bx处</span><br><span class="line"></span><br><span class="line">mov ax, [fs:0x5678]	;显式指定使用gs寄存器作为段基址，将gs*16+0x5678的值赋给ax</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x01], &#x27;M&#x27;	;显式指定使用gs段寄存器作为段基址，指定操作数为1字节，向gs*16+0x01的位置写入1字节的数据&#x27;M&#x27;</span><br><span class="line"></span><br><span class="line">mov ax, [sp]	;将sp指向的值赋给ax</span><br><span class="line"></span><br><span class="line">mov ax, [bp+4]	;将SS*16+bp+4处的值赋给ax</span><br><span class="line"></span><br><span class="line">mov [di], ax	;将ax的值写入DS*16+di处</span><br><span class="line"></span><br><span class="line">mov [si+0x1234], ax	;将ax的值写入DS*16+si+0x1234处</span><br><span class="line"></span><br><span class="line">mov [bx+di], ax	;将ax的值写入DS*16+bx+di</span><br><span class="line"></span><br><span class="line">jump $	; $符号表示当前行，该语句为跳转至当前行；$$为当前section</span><br><span class="line"></span><br><span class="line">;-----------------------stdcall调用约定------------------------</span><br><span class="line">push 2</span><br><span class="line">push 3	;从右往左将传入参数压栈</span><br><span class="line">call subtract	;将当前eip压栈，跳转至被调函数地址开始执行</span><br><span class="line"></span><br><span class="line">push ebp	;压栈保存原ebp，</span><br><span class="line">mov ebp, esp	;更新栈帧基址，进入新栈帧</span><br><span class="line"></span><br><span class="line">mov eax, [ebp+0x8]</span><br><span class="line">mov eax, [ebp+0xc]</span><br><span class="line"></span><br><span class="line">mov esp, ebp</span><br><span class="line"></span><br><span class="line">pop ebp	;弹出栈顶保存的原ebp值到ebp</span><br><span class="line">ret 8	;弹出栈顶地址到eip(弹栈使得esp自加4)，esp+8(移除压栈的传入参数)</span><br><span class="line">;-------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">;-----------------------cdecl调用约定--------------------------</span><br><span class="line">push 2</span><br><span class="line">push 3	;从右往左将传入参数压栈</span><br><span class="line">call subtract	;将当前eip压栈，跳转至被调函数地址开始执行</span><br><span class="line">add esp, 8	;清栈，移除传入参数</span><br><span class="line"></span><br><span class="line">push ebp	;压栈保存原ebp，进入新栈帧</span><br><span class="line">mov ebp, esp</span><br><span class="line"></span><br><span class="line">mov eax, [ebp+0x8]</span><br><span class="line">mov eax, [ebp+0xc]</span><br><span class="line"></span><br><span class="line">mov esp, ebp</span><br><span class="line"></span><br><span class="line">pop ebp	;弹出栈顶保存的原ebp值到ebp</span><br><span class="line">ret	;弹出栈顶地址到eip(弹栈使得esp自加4)，esp+8(移除压栈的传入参数)</span><br><span class="line">;-------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">section .data	;section为伪指令，面向程序员的跳转记号</span><br><span class="line">	var dd 0</span><br><span class="line">	str: dd &quot;hello&quot;, 0xa, 0</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">extern c_print	;导入外部函数 c_print</span><br><span class="line">global _start	;将函数_start导出为全局符号，供外部文件调用</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	push str</span><br><span class="line">	jmp $$</span><br></pre></td></tr></table></figure>
<p>SS为栈底，bp为当前帧底</p>
<p>保护模式</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240420193121630.png" class="" title="image-20240420193121630">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240420195137241.png" class="" title="image-20240420195137241">
<p>segment与section</p>
<p>section称为节，是指在汇编源码中经由关键字section或segment修饰、逻辑划分的指令或数据区域，汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中。</p>
<p>segment称为段，是链接器根据目标文件中属性相同的多个section合并后的section集合，这个集合称为segment，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中。我们平时所说的可执行程序内存空间中的代码段和数据段就是指的segment。</p>
<h4 id="AT-T语法风格">AT&amp;T语法风格</h4>
<p>左 -&gt; 右</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl %eax, immed32(%ebx, %esi,2)	</span><br><span class="line">	#将eax的值写入内存immed32+ebx+esi*2处</span><br><span class="line">	#()括号表示取内的值作为内存地址</span><br><span class="line">	#寄存器前必须有%</span><br><span class="line"></span><br><span class="line">movl $123, %eax	#将立即数123写入寄存器eax</span><br><span class="line"></span><br><span class="line">andl %ebx, %ecx #对寄存器 %ebx 和 %ecx 的内容执行按位与操作，并将结果存储到 %ecx 寄存器中。</span><br><span class="line"></span><br><span class="line">xchgl %eax, (%esp) #交换寄存器eax和栈顶位置的值</span><br><span class="line"></span><br><span class="line">popl %eax #指从栈顶弹出数据，并将弹出的数据写入 %eax 寄存器。</span><br><span class="line"></span><br><span class="line">ret #弹出栈顶值写入PC</span><br><span class="line">iret #弹出eip并写入，弹出cs并写入，弹出eflags并写入</span><br></pre></td></tr></table></figure>
<p>内联汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> [<span class="keyword">volatile</span>] (<span class="string">&quot;&quot;</span>)	<span class="comment">//volatile为可选项，表示此处代码不得修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;movl $9, %eax;&quot;</span> <span class="string">&quot;pushl %eax&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> [<span class="keyword">volatile</span>] (<span class="string">&quot;&quot;</span>:<span class="string">&quot;&quot;</span>(output) :<span class="string">&quot;&quot;</span>(input) :clobber/modify)</span><br><span class="line">	<span class="comment">//&quot;&quot; 内部为汇编代码</span></span><br><span class="line">    <span class="comment">//output, input为c变量，它们前面的&quot;&quot;为约束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;addl %%ebx, %%eax;&quot;</span>:<span class="string">&quot;=a&quot;</span>(out_sum):<span class="string">&quot;a&quot;</span>(in_a),<span class="string">&quot;b&quot;</span>(in_b))</span><br><span class="line">	<span class="comment">//&quot;a&quot;为约束名，约束c语言变量in_a使用寄存器eax</span></span><br><span class="line">	<span class="comment">//&quot;b&quot;为约束名，约束c语言变量in_b使用寄存器ebx</span></span><br><span class="line">	<span class="comment">//&quot;=a&quot;为约束名，将寄存器eax的值写入c语言变量out_sum</span></span><br><span class="line">	<span class="comment">//=为只写，+为读写，&amp;为独占所约束的寄存器</span></span><br><span class="line">	<span class="comment">//由于扩展内联汇编中，%0为占位符符号，故修改寄存器表示为%%eax</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;movb %0 %1;&quot;</span>::<span class="string">&quot;a&quot;</span>(in_a),<span class="string">&quot;m&quot;</span>(in_b))</span><br><span class="line">	<span class="comment">//&quot;a&quot;为约束名，约束c语言变量in_a使用寄存器eax</span></span><br><span class="line">	<span class="comment">//&quot;m&quot;为约束名，使用c语言变量in_b的内存地址</span></span><br><span class="line">	<span class="comment">//%0,%1为序号占位符，所有input和output从左至右被标序号，这里对应in_a, in_b</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;divb %[divisor]; movb %%al, %[result]&quot;</span>\</span><br><span class="line">		:[result]<span class="string">&quot;=m&quot;</span>(out)\</span><br><span class="line">		:<span class="string">&quot;a&quot;</span>(in_a),[divisor]<span class="string">&quot;m&quot;</span>(in_b)\</span><br><span class="line">		);</span><br><span class="line">	<span class="comment">//[divisor]为in_b的内存地址，通过%[divisor]获取内存的值</span></span><br><span class="line">	<span class="comment">//[result]为out的内存地址，</span></span><br></pre></td></tr></table></figure>
<h4 id="C-C-相关">C/C++ 相关</h4>
<p><strong>宏函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"><span class="comment">//  (x) * (x)外的一层括号是为了展开时不改变运输优先级</span></span><br><span class="line"><span class="comment">// 对比 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x) (x) + (x)</span></span><br><span class="line"><span class="comment">// 在使用 4 / ADD(2) 时，展开式</span></span><br><span class="line"><span class="comment">// 4 / (2) * (2) 导致运算优先级错误</span></span><br><span class="line"><span class="comment">// 对比 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) x * x</span></span><br><span class="line"><span class="comment">// 在使用 SQUARE(2 + 3) 时，展开式</span></span><br><span class="line"><span class="comment">// 2 + 3 * 2 + 3 导致运算优先级错误</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_FUNC(x) &#123; \</span></span><br><span class="line"><span class="meta">    int result = (x) * 2; \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;result: %d\n&quot;</span>, result); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 使用 &#123;&#125; 可以为宏函数创建一个独立的作用域，避免宏函数内部定义的变量与外部代码中的变量发生冲突。</span></span><br><span class="line"><span class="comment">// 故在使用宏函数的时候使用括号 #define func() (&#123;函数体&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="comment">//预处理器会将代码中所有出现宏函数名的地方，替换成宏函数定义的代码段。文本替换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>内联函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内联函数在编译阶段由编译器决定是否进行内联展开。如果编译器认为函数体积较小，且调用频率较高，就会将函数代码直接插入到调用点，不使用函数调用的方式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MAX 是一个宏函数，而 max 是一个内联函数。两者都可以用来计算两个数的最大值，但 max 函数更安全，因为它有类型检查，并且不会造成变量名污染。</span></span><br></pre></td></tr></table></figure>
<p><strong>const与const_cast&lt;&gt;()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>;	<span class="comment">//该const声明此函数不会修改调用该函数的对象</span></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">Complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag) : <span class="built_in">real_</span>(real), <span class="built_in">imag_</span>(imag) &#123;&#125; <span class="comment">// 构造函数初始化列表，冒号标志着初始化列表的开始，将构造函数参数 real 的值赋给成员变量 real_</span></span><br><span class="line">    </span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;  <span class="comment">// 版本1: const 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real_ + other.real_, imag_ + other.imag_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) &#123;       <span class="comment">// 版本2: 非 const 成员函数</span></span><br><span class="line">        real_ += other.real_; <span class="comment">// 修改了调用该函数的对象</span></span><br><span class="line">        imag_ += other.imag_;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">  		<span class="type">double</span> real_;</span><br><span class="line">  		<span class="type">double</span> imag_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    c1 = c1 + c2;  <span class="comment">// 调用版本1或版本2都可以</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Complex <span class="title">c3</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line">    c3 = c3 + c2;  <span class="comment">// 只能调用版本1 (const 成员函数)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;	<span class="comment">//该函数返回值为const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">   <span class="built_in">A</span>()  </span><br><span class="line">   &#123;  </span><br><span class="line">      m_iNum = <span class="number">1</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">   <span class="type">int</span> m_iNum;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">   <span class="comment">//1. 指针指向类    </span></span><br><span class="line">   <span class="type">const</span> A *pca1 = <span class="keyword">new</span> A;    </span><br><span class="line">   A *pa2 = <span class="built_in">const_cast</span>&lt;A*&gt;(pca1);  <span class="comment">//常量指针转换为非常量指针    </span></span><br><span class="line">   pa2-&gt;m_iNum = <span class="number">200</span>;    <span class="comment">//fine    </span></span><br><span class="line">       </span><br><span class="line">   <span class="comment">//转换后指针指向原来的对象    </span></span><br><span class="line">   cout&lt;&lt; pca1-&gt;m_iNum &lt;&lt;pa2-&gt;m_iNum&lt;&lt;endl; <span class="comment">//200 200    </span></span><br><span class="line">        </span><br><span class="line">   <span class="comment">//2. 指针指向基本类型    </span></span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> ica = <span class="number">100</span>;    </span><br><span class="line">   <span class="type">int</span> * ia = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(&amp;ica);    </span><br><span class="line">   *ia = <span class="number">200</span>;    </span><br><span class="line">   cout&lt;&lt; *ia &lt;&lt;ica&lt;&lt;endl;   <span class="comment">//200 100  </span></span><br><span class="line">    </span><br><span class="line">   A a0;  </span><br><span class="line">   <span class="type">const</span> A &amp;a1 = a0;  </span><br><span class="line">   A a2 = <span class="built_in">const_cast</span>&lt;A&amp;&gt;(a1);　<span class="comment">//常量引用转为非常量引用</span></span><br><span class="line">  </span><br><span class="line">   a2.m_iNum = <span class="number">200</span>;    <span class="comment">//fine    </span></span><br><span class="line">  </span><br><span class="line">   cout&lt;&lt; a0.m_iNum &lt;&lt; a1.m_iNum &lt;&lt; a2.m_iNum &lt;&lt; endl; <span class="comment">//1 1 200    </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//常量对象被转换成非常量对象时出错  </span></span><br><span class="line">   <span class="type">const</span> A ca;  </span><br><span class="line">   A a = <span class="built_in">const_cast</span>&lt;A&gt;(ca);  <span class="comment">//不允许</span></span><br><span class="line">   </span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> i = <span class="number">100</span>;  </span><br><span class="line">   <span class="type">int</span> j = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&gt;(i);  <span class="comment">//不允许 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>static_cast&lt;??&gt;(obj)</strong>:
<ul>
<li>用于<strong>相关类型</strong>之间的转换，例如：
<ul>
<li>基本类型转换 (int 到 float，double 到 int 等)</li>
<li>void 指针和其他指针类型之间的转换</li>
<li>向上转型 (派生类指针/引用到基类指针/引用)</li>
<li>向下转型 (基类指针/引用到派生类指针/引用，<strong>需要程序员保证安全性</strong>)</li>
</ul>
</li>
<li>编译时检查类型，不安全的操作可能导致未定义行为。</li>
<li>将obj转换为<code>&lt;??&gt;</code>类型</li>
</ul>
</li>
<li><strong>dynamic_cast</strong>:
<ul>
<li>用于<strong>多态类型</strong>之间的<strong>安全向下转型</strong> (基类指针/引用到派生类指针/引用)。</li>
<li>运行时检查类型，失败时返回 nullptr (指针) 或抛出 std::bad_cast 异常 (引用)。</li>
<li>要求基类至少有一个虚函数。</li>
</ul>
</li>
<li><strong>const_cast</strong>:
<ul>
<li>用于<strong>移除或添加 const 和 volatile 限定符</strong>。</li>
<li>不会改变对象本身的常量性，只是告诉编译器不要进行常量性检查。</li>
<li>如果修改了实际为常量的对象，会导致未定义行为。</li>
</ul>
</li>
<li><strong>reinterpret_cast</strong>:
<ul>
<li>用于<strong>底层类型转换</strong>，例如：
<ul>
<li>将指针转换为整数</li>
<li>将整数转换为指针</li>
<li>将一个指针转换为另一个不相关的指针类型</li>
</ul>
</li>
<li>非常危险，应该尽量避免使用。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>函数指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello from greet function!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returnType (*pointerName)(parameter1Type, parameter2Type, ...);</span></span><br><span class="line"><span class="built_in">void</span> (*ptr)() = greet; <span class="comment">// 定义函数指针并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种调用方式是等效的</span></span><br><span class="line"><span class="built_in">ptr</span>();         <span class="comment">// 简洁写法，ptr实际为地址</span></span><br><span class="line">(*ptr)();     <span class="comment">// 更明确的写法，强调解引用</span></span><br><span class="line">(<span class="type">void</span> *)<span class="number">1234</span>	<span class="comment">//表示一个未知类型的地址</span></span><br><span class="line">(<span class="built_in">void</span> (*)())<span class="number">1234</span>  <span class="comment">//将1234强制类型转换为函数指针（函数的地址</span></span><br><span class="line">(*((<span class="built_in">void</span> (*)())<span class="number">1234</span>))()  <span class="comment">//调用位于地址1234处的函数</span></span><br></pre></td></tr></table></figure>
<p><strong>虚函数与纯虚函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;  <span class="comment">// 普通虚函数，有默认实现；必须声明为虚才可以在子类中重写</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal making sound\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写基类的虚函数,可以不重写</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Woof!\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;  <span class="comment">// 一个类中可同时存在虚和非虚函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，没有函数体</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printDescription</span><span class="params">()</span> </span>&#123;  <span class="comment">// 非虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 派生类必须实现 draw() 函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VShape</span> &#123; <span class="comment">// 含纯虚函数即不可实例化</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123; <span class="comment">// 非抽象类，包含虚函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Shape* s = new Shape();  // 错误：无法实例化抽象类</span></span><br><span class="line">    Shape* c = <span class="keyword">new</span> <span class="built_in">Circle</span>();    <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    Rectangle r;               <span class="comment">// 正确：非抽象类可以实例化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>继承与初始化列表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// :: 双冒号 作用域解析运算符</span></span><br><span class="line"><span class="comment">// : 单冒号 继承/初始化列表/标签/三目运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 C++ 中，当子类继承父类时，子类对象创建过程中会自动调用父类的构造函数。在 C++ 多继承情况下，子类对象创建时会调用所有直接父类的构造函数。</span></span><br><span class="line"><span class="comment">// 如果父类有默认构造函数(即没有参数的构造函数)： 子类可以不显式调用父类构造函数，编译器会自动调用默认构造函数。如果父类没有默认构造函数： 子类必须在初始化列表中显式调用父类构造函数并传递参数。</span></span><br><span class="line"><span class="comment">// 在 Java 中，子类构造函数不会自动调用父类的构造函数，需要程序员显式地使用 super() 方法来调用父类的构造函数，并通过传参的不同，调用不同的构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="keyword">public</span> ClassA, <span class="keyword">public</span> ClassB  &#123;  <span class="comment">// 公有继承于ClassA和ClassB</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">a</span>(age),  <span class="built_in">n</span>(name) &#123;&#125;  <span class="comment">// 初始化列表，成员变量的初始化顺序与其在类定义中声明的顺序一致。编译器会按照成员变量在类定义中出现的顺序依次进行初始化，即使你在初始化列表中以不同的顺序列出它们。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">// 按照这里的顺序初始化成员变量，即先初始化n，后初始化a</span></span><br><span class="line">  std::string n;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量名(值)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base1</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base1 default constructor called.\n&quot;</span>; &#125;  <span class="comment">// 默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base2</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;&#125; <span class="comment">// 没有默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>() &#123;  &#125; <span class="comment">// 没有显式调用父类构造函数，报错</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>(<span class="type">int</span> value) : <span class="built_in">Base2</span>(value) &#123;&#125; <span class="comment">// 显式调用 Base2 的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>static与内部类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++没有静态类的概念，直接使用static声明类的成员函数/变量即可。相似的，可以在没有实例化类的情况下直接调用方法/访问变量</span></span><br><span class="line"><span class="comment">// c++的内部类和普通类无区别</span></span><br><span class="line"><span class="comment">// java只有内部类可以是静态的；静态内部类可以有（非静态的变量和方法）和（静态的变量和方法）</span></span><br><span class="line"><span class="comment">// java普通内部类不能有静态变量/方法！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar; <span class="comment">// 静态数据成员声明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123; <span class="comment">// 静态成员函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is a static method.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">10</span>; <span class="comment">// 静态数据成员定义和初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticMethod</span>(); <span class="comment">// 直接调用静态成员函数</span></span><br><span class="line">    std::cout &lt;&lt; MyClass::staticVar &lt;&lt; std::endl; <span class="comment">// 直接访问静态数据成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> outerVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 静态成员</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 非静态成员</span></span><br><span class="line">        <span class="type">int</span> instanceVar;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Static method in inner class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 非静态方法</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">instanceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Instance method in inner class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuterClass</span><span class="params">(OuterClass&amp; outer)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Accessing outer class variable: &quot;</span> &lt;&lt; outer.outerVar &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line"><span class="type">int</span> OuterClass::InnerClass::staticVar = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    OuterClass outer;</span><br><span class="line">    OuterClass::InnerClass inner;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用静态方法</span></span><br><span class="line">    OuterClass::InnerClass::<span class="built_in">staticMethod</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用非静态方法</span></span><br><span class="line">    inner.<span class="built_in">instanceMethod</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问外部类成员</span></span><br><span class="line">    inner.<span class="built_in">accessOuterClass</span>(outer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 显然，我们并没有显式的定义构造函数，但是即使没有显式地定义构造函数，C++ 也会提供一个默认构造函数。默认构造函数会将类的成员变量初始化为默认值 (例如，数字类型初始化为 0，指针类型初始化为 nullptr)。</span></span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// value被默认构造函数初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MyClass* <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MyClass</span>(); <span class="comment">// 使用指针创建实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;  <span class="comment">// obj1通过调用了默认构造函数对其进行了初始化，不为null</span></span><br><span class="line">    </span><br><span class="line">    MyClass* obj2 = obj1.<span class="built_in">createInstance</span>(); <span class="comment">// 通过obj1指针创建实例</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Address of obj1: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;obj1) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 本机测试 Address of obj1: 0x61fe14</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2 value: &quot;</span> &lt;&lt; obj2-&gt;value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> obj2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>菱形继承与虚继承</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">data</span>(x) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A constructor called with &quot;</span> &lt;&lt; data &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 虚继承不会改变成员继承规则，派生类仍然会继承虚基类的所有成员。</span></span><br><span class="line"><span class="comment">// 虚继承A类时，A类相当于成为了一个共享类，其他所有再进行虚继承A类时，均只会继承该共享类，不会出现二义性继承（即D类继承了两个A类）。</span></span><br><span class="line"><span class="comment">// 个人理解：类B普通继承类A时，B中相当于加了个A；如果类C普通继承类A，类D普通继承类B，C时，D中相当于有了两个实A，出现二义性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，当B类虚继承A，C类继承A，D类继承B，C时，类D相当于有了一个虚A一个实A，ダメです。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123; <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x) : <span class="built_in">A</span>(x) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B constructor called&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123; <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> x) : <span class="built_in">A</span>(x) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;C constructor called&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方式继承会让D继承到两个A，编译通过，但是A的构造函数触发两次</span></span><br><span class="line"><span class="comment">// 尝试打印A中的data变量，报错：&quot;D::data&quot; is ambiguous</span></span><br><span class="line"><span class="comment">//class C : public A &#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="comment">//    C(int x) : A(x) &#123; </span></span><br><span class="line"><span class="comment">//        std::cout &lt;&lt; &quot;C constructor called&quot; &lt;&lt; std::endl; </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span> x) : <span class="built_in">A</span>(x), <span class="built_in">B</span>(x), <span class="built_in">C</span>(x) &#123;  <span class="comment">// 直接初始化虚基类 A</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D constructor called&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>; </span><br><span class="line">    std::cout &lt;&lt; d.data &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件: my_template_class.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplateClass</span> &#123;  <span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">  <span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件: my_template_class.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_template_class.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template &lt;typename T&gt; 作用域极小，只有紧接着的函数/类中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 为 print 函数声明模板参数，即 print 函数为模板函数</span></span><br><span class="line"><span class="type">void</span> MyTemplateClass&lt;T&gt;::<span class="built_in">print</span>(<span class="type">const</span> T&amp; value) &#123; <span class="comment">// 为模板类 MyTemplateClass&lt;T&gt; 定义 print</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果写成 MyTemplateClass::print，编译器会认为正在为非模板类 MyTemplateClass 的某个模板成员函数进行定义。</span></span><br><span class="line"><span class="comment">//1.由于不存在该非模板类，报错。2.非模板类不能包含模板函数: 非模板类只能包含非模板函数，不能包含模板函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 为 getValue 函数声明模板参数，即 getValue 函数为模板函数</span></span><br><span class="line">T MyTemplateClass&lt;T&gt;::<span class="built_in">getValue</span>() <span class="type">const</span> &#123; <span class="comment">// 为 MyTemplateClass&lt;T&gt; 定义 getValue</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>栈上创建与堆上创建</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈上创建</span></span><br><span class="line"><span class="function">MyTemplateClass&lt;<span class="type">int</span>&gt; <span class="title">intObject1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 变量名intObject1，值10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量名(值)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆上创建</span></span><br><span class="line">MyTemplateClass&lt;<span class="type">int</span>&gt;* intObject2 = <span class="keyword">new</span> <span class="built_in">MyTemplateClass</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h4 id="GDT-LDT与TSS">GDT, LDT与TSS</h4>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240609174716552.png" class="" title="image-20240609174716552">
<p>硬件厂商推荐通过每个任务拥有一个LDT和一个TSS的方式实现多任务</p>
<p>eg: call 0x0018:0x1234 使用在GDT中索引0x0018的选择子获得段基址，偏移0x1234</p>
<blockquote>
<p>在使用中，段寄存器中的值将确定使用GDT/LDT中的第x项</p>
</blockquote>
<h4 id="段描述符与门描述符区别">段描述符与门描述符区别</h4>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240416192952163.png" class="" title="image-20240416192952163">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240417104649804.png" class="" title="image-20240417104649804">
<p>门 = 选择子 + 偏移</p>
<p>选择子 = 基址 + 偏移</p>
<p>IDT 保存 中断门</p>
<p>GDT/LDT 保存 任务门/描述符</p>
<h4 id="物理地址空间使用情况">物理地址空间使用情况</h4>
<p>tiny-os kernel地址空间</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240421151156773.png" class="" title="image-20240421151156773">
<p>地址空间：</p>
<p>0x0009a000为位图起始地址，占4页</p>
<p>0x0009e000为内核PCB起始，占1页</p>
<p>​	0x0009f000为PCB中内核栈顶(低1M地址中所使用到的最高地址)</p>
<p>0x0009f000~0x00100000为空</p>
<p>0x00100000为内核堆起始，</p>
<p>​	0x00100000~0x00101fff为页目录表和页表</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240427095137775.png" class="" title="image-20240427095137775">
<p>SiFive FU540</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240412184838896.png" class="" title="image-20240412184838896.png">
<p>用户程序地址空间</p>
<p>虚拟地址：</p>
<p>KERNBASE = 0x8000 0000</p>
<p>KERNLINK = 0x8010 0000</p>
<p>KERNBASE+PHYSTOP = 0x8E00 0000</p>
<p>DEVSPACE = 0xFE00 0000</p>
<p>物理地址：</p>
<p>低1M部分：0 - 0x10 0000</p>
<p>部分内核数据+空闲空间（用户程序所分配的页表）：0x10 0000 - 0xE00 0000(PHYSTOP)</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240412200020614.png" class="" title="image-20240412200020614">
<p>用户程序虚拟内存内容</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240413095215393.png" class="" title="image-20240413095215393">
<p>Linux 0.11</p>
<p>虚拟地址空间使用情况</p>
<p>每个进程最大虚拟空间为64MB（巨大差异</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240706102456745.png" class="" title="image-20240706102456745">
<h4 id="会话session">会话session</h4>
<p>进程通过fork创建新的子进程，进程与创建出的子进程同属一个进程组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> main.c | grep <span class="keyword">for</span> | more</span><br></pre></td></tr></table></figure>
<p>以上三个命令对应三个进程，同属于一个进程组，CTRL+C将中止该进程组的所有进程</p>
<p>Session为进程组的集合，用户通过tty登录后所有的命令(执行的程序)属于同一个session</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240609190505627.png" class="" title="image-20240609190505627">
<h3 id="引导启动程序">引导启动程序</h3>
<h4 id="启动流程图">启动流程图</h4>
<p>Linux</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240608151929426.png" class="" title="image-20240608151929426">
<h4 id="BIOS">BIOS</h4>
<p>计算机启动时为实模式运行，20位地址线，仅能访问1MB空间</p>
<p>机器上电，cs:ip 初始化为 0xf000:0x1110；</p>
<p>CPU从0xffff0开始执行，执行至0xfffff处指令jump后跳转至 f000:e05b，BIOS主体代码所在处；</p>
<p>BIOS内容代码进行硬件检测（内存检测，显卡检测…），</p>
<p>在0x000-0x3ff处建立数据结构，中断向量表IVT，填写中断例程，</p>
<p>进行启动盘检测(0盘0道1扇区最后2个字节:55AA)，从硬盘0盘0道1扇区加载MBR至0x7c00后，跳转执行MBR。</p>
<h4 id="MBR">MBR</h4>
<p>MBR占512字节（一个扇区），结尾内容为55AA。</p>
<p>MBR程序位于0x7c00</p>
<p>Linux: boot/bootsect.s</p>
<p>bootsect程序(MBR)位于0x7c00，然后bootsect将自身复制到0x90000处，执行跳转至0x90000，使用0x9ff00为栈顶</p>
<p>bootsect将setup程序写入0x90200处，将system加载至0x10000处</p>
<p>​	ps:未直接加载内核至0x00000的原因是0x00000有中断向量表</p>
<p>tiny_os</p>
<p>MBR程序将loader程序写入0x90000处</p>
<h4 id="setup-loader">setup&amp;loader</h4>
<p>Linux: boot/setup.s</p>
<p>使用实模式下的中断向量表读取机器数据（读取屏幕光标位置，读取扩展内存大小，读取显卡显示模式，检查显示方式并取参数，取硬盘0信息，取硬盘1信息，检查硬盘2信息），写入0x90000及以后处（覆盖bootsect）</p>
<p>将内核从0x10000~0x8ffff移动至0x00000~0x7ffff处，</p>
<p>开启A20地址线</p>
<p>修改控制寄存器CR0，进入保护模式</p>
<p>跳转至地址0x00000（通过段选择子2，偏移0转移）</p>
<p>临时gdt已通过data段形式实现在setup.s程序尾部</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240706144702481.png" class="" title="image-20240706144702481">
<p>tiny_os</p>
<p>loader程序位于0x90000，使用0x90000以下部分作为程序栈</p>
<p>loader设置gdt，进入保护模式，并在保护模式加载内核</p>
<h5 id="保护模式">保护模式</h5>
<p>保护模式使机器从16位进入到32位，寻址方式变更为 基址+偏移</p>
<h6 id="段描述符与全局描述符表GDT">段描述符与全局描述符表GDT</h6>
<p>段寄存器: cs, ds, …(16位寄存器)，保存选择子，即gdt/ldt的index对于的值</p>
<p>选择子</p>
<p>RPL：特权等级；TI：选择GDT/LDT；索引值：GDT/LDT表中的第x个段描述符</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240416193845119.png" class="" title="image-20240416193845119">
<p>GDTR</p>
<p>保存GDT的物理地址，GDT的段描述符记录了各内存段的相关信息</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240416193617238.png" class="" title="image-20240416193617238">
<p>LDTR</p>
<p>保存LDT的内存地址，<strong>LDT必须在GDT中声明</strong>，通过GDT获得LDT内存地址后写入LDTR后使用LDT</p>
<p>GDT</p>
<p>item: 段描述符</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240416192952163.png" class="" title="image-20240416192952163">
<p>段基址：32位段基址；</p>
<p>段界限：对于数据段和代码段，段界限向高地址延申；对于栈，段界限向低地址延申；若偏移量超界错；段大小由 段界限*G 确定，</p>
<p>DPL：段特权级</p>
<p>S：是否系统段</p>
<p>TYPE：段类型</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240427102403905.png" class="" title="image-20240427102403905">
<p>段描述符缓冲寄存器</p>
<p>保存处理后的段描述符</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240420192623948.png" class="" title="image-20240420192623948">
<p>段描述符与内存段</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240427102456078.png" class="" title="image-20240427102456078">
<p>地址计算方式=32位段基址+32段偏移</p>
<h5 id="保护模式的启动">保护模式的启动</h5>
<p>Linux: boot/setup.s</p>
<p>使用实模式下的中断向量表读取机器数据，写入0x90000处（覆盖bootsect）</p>
<p>整体下移内核至0x00000处，</p>
<p>设置临时ldt和gdt，加载ldtr和gdtr，开启A20地址线；</p>
<p>重新设备中断控制芯片8259A，设置硬件中断号为0x20 ~ 0x2f，修改CR0寄存器</p>
<p>进入保护模式，跳转至地址0x00000</p>
<p>tiny_os</p>
<p>loader程序位于0x90000，使用0x90000以下部分作为程序栈</p>
<p>1.构建GDT，<strong>GDT内容直接定义在loader内</strong></p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240427102121106.png" class="" title="image-20240427102121106">
<p>2.开启A20地址线</p>
<p>A20地址线：20位地址线的CPU自动发生地址回绕（20位段基址+16位段偏移所产生的超出1MB的部分）</p>
<p>32位地址线为了兼容20位地址线产生的地址回绕，在关闭A20地址线时，CPU将进行地址回绕；在开启A20地址线时，正确访问；</p>
<p>3.加载GDT地址到GDTR</p>
<p>4.置位CR0寄存器的PE位</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240416195112069.png" class="" title="image-20240416195112069">
<p>5.将段寄存器内容更新为段选择子内容</p>
<p>Linux:[类似]</p>
<p>临时gdt包含了两个段描述符，数据段描述符和代码段描述符，段基址均为0x00000</p>
<p>跳转0x00000处</p>
<h4 id="head-loader">head&amp;loader</h4>
<h5 id="页表组成与构建">页表组成与构建</h5>
<p>虚拟地址与物理地址映射关系</p>
<p>虚实转换由MMU(Memory Management Unit)硬件实现，</p>
<p>CPU中的SATP寄存器保存Page Table Entry，指向最高一级的页目录page directory的物理内存地址</p>
<p>CPU中的TLB(Translation Lookside Buffer)保存近期访问的PTE内容</p>
<p>XV6</p>
<p>页表中的每一项为PTE(Page Table Entry)，一个PTE 54bit，一级页表为3.375KB</p>
<p>通过SATP寄存器获得最高级页表的物理地址PPN，使用L2查最高级页表获得中间级页表的物理地址；使用L1查中间级页表获得最低级页表的物理地址；使用L0查最低级页表，获得物理地址；</p>
<p>通过TLB获取物理地址PPN；</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240412190738605.png" class="" title="image-20240412190738605">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240412192043741.png" class="" title="image-20240412192043741">
<p>Linux 2.6</p>
<p>虚拟地址高10位，在页目录表中查找对应索引，获得页表的物理地址（20位，余下12位补0）；</p>
<p>虚拟地址中10位，在页表中查找对应索引，获得页的物理地址（20位，余下12位补0）；</p>
<p>虚拟地址后12位，页内偏移；</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240420140907729.png" class="" title="image-20240420140907729">
<p>tiny-os</p>
<p>用户使用低3GB，内核使用高1GB，每页4KB</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240427102727532.png" class="" title="image-20240427102727532">
<p>建立页目录表–页目录表的项即指向一个页表</p>
<p>在物理地址0x100000建立页目录表，一个页目录表含1024个页表项PDE，每个页目录表项4B，占4KB，</p>
<p>第0项（保证loader程序在启动页表后能够正常运行）指向第一个页表，物理地址0x101000</p>
<p>第768项（虚拟地址3GB，用户程序访问内核）指向第一个页表，物理地址0x101000</p>
<p>第1023项指向页目录表，物理地址0x100000</p>
<p>建立页表</p>
<p>在物理地址0x101000建立，一个页表含1024个页表项，每个页表项4B，占4KB，可表示4KB*1024=4MB的地址空间</p>
<p>该页表指向的物理地址为0-0x3fffff</p>
<h5 id="head-s-页表构建与进入分页模式">head.s / 页表构建与进入分页模式</h5>
<p>Linux: boot/head.s</p>
<p>![image-20240609161606117](file://D:/github/blog/source/_posts/Op-sys-Learning-Record/image-20240609161606117.png?lastModify=1717920885)</p>
<p>位于物理地址0x00000处</p>
<p>加载数据段寄存器，</p>
<p>重新设置idtr，循环创建256项中断描述符，全部指向哑中断处理程序（该程序位于0x6000~中断描述符表前，图中的head.s部分代码）</p>
<p>重新设置gdtr</p>
<p>检查A20地址线是否开启</p>
<p>检查机器是否含有数学协处理器，修改CR0寄存器标志位</p>
<p>将main代码的地址压入位于(ss: 内核数据段选择符, esp: 内核sched模块user_stack处 )的栈，</p>
<p>设置页目录表（为全体进程使用）与页表，4个页表（内核专用页表，新的进程的页表会在主内存区申请）位于页目录表之后，寻址16Mb空间（4KB/页表大小，4B/页表项，1024*4KB=4MB每项寻址空间）</p>
<p>iret弹出入栈的main函数地址，跳转前往执行main函数</p>
<blockquote>
<p>这段汇编先从0x0000开始运行，然后运行到设置内存页表的时候使用.org向后跳，空出内存页表的空间0x1000~0x5000，一直跳到0x6000处继续，将main参数和地址压栈，然后跳过哑中断处理程序，开始创建页内存目录表和写入刚才空出来的内存页表（页内存目录表创建在0x0000，这意味着原本位于这里的head.s的代码将被覆盖</p>
<p>idt是循环创建的，gdt是预先手写好的</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240706163733389.png" class="" title="image-20240706163733389">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240706163716837.png" class="" title="image-20240706163716837">
<p>Linux 0.1x 内核和所有进程共用0x0000的页目录表（这意味着CR3寄存器中的值始终为0x0000，即全部进程共享的页目录表，</p>
<p>其他的4页页表为内核专用，用户进程的页表存放在随机的主内存区</p>
</blockquote>
<p>tiny_os</p>
<p>loader中实现页表的构建与进入分页模式</p>
<p>loader程序</p>
<p>6.清空页目录占用空间0x100000+4096</p>
<p>7.创建页目录项并写入页目录表第0项(指向第1个页表)，第768项(指向第1个页表)和第1023项(指向页目录表，该项用于修改页目录表)</p>
<p>8.创建页表项写入第1个页表(位于0x101000)，分配物理地址0~0x3fffff(实验用mini内核在此处)</p>
<p>9.创建页目录项并写入页目录表第769项~第1022项(指向第2,3,4…个页表,第2,3,4…个页表位于0x102000,0x103000…)</p>
<p>10.修改gdt中段描述符的地址值，上移至0xc0000000以上</p>
<p>11.修改gdt基址，修改esp，上移至0xc0000000以上</p>
<p>12.将页目录地址赋值给cr3，打开cr3的pg位，新gdt值写入gdtr</p>
<p>分页模式启动，</p>
<p>程序<strong>此时</strong>已进入虚拟地址运行，</p>
<p>当前虚拟地址0x0000xxxx，仍处于低1M地址空间中(页目录表第一项指向第一个页表的原因)；</p>
<p>从gdt中获得的段描述符的值为虚拟地址；</p>
<h4 id="内存分段机制">内存分段机制</h4>
<p>​	<img src="/2024/04/12/Op-sys-Learning-Record/image-20240706103147318.png" class="" title="image-20240706103147318"></p>
<p>从该图可以看出，偏移值(IP)和段选择子(CS/DS/…)中的地址为虚拟地址，</p>
<p>通过段选择子读取段描述符表中的段描述符获取完整虚拟地址基址，得到线性地址；</p>
<p>使用线性地址根据页目录表和页表得到物理地址</p>
<h4 id="main-c-loader">main.c&amp;loader</h4>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240609163346462.png" class="" title="image-20240609163346462">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240609180508264.png" class="" title="image-20240609180508264">
<p>Linux: main.c &amp; 任务0（idle进程）</p>
<p>初始化设备与内存信息：</p>
<p>​	根设备号，高速缓存末端地址，机器内存量，主内存开始地址；</p>
<p>调用内核中初始化函数初始化各功能部分；</p>
<ul>
<li>主内存区初始化</li>
<li>硬件中断向量初始化</li>
<li>块设备初始化</li>
<li>字符设备初始化</li>
<li>tty初始化</li>
<li>时间初始化，访问CMOS获取</li>
<li>调度程序初始化</li>
<li>缓存初始化</li>
<li>硬盘初始化</li>
<li>软驱初始化</li>
</ul>
<p>移动到用户模式下执行</p>
<blockquote>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240706162745211.png" class="" title="image-20240706162745211">
<p>此处的宏函数move_to_user_mode展开后，实际上是原地跳转，但是在执行过程中修改了</p>
<p>cs段选择符-&gt;(ldtr寄存器)LDT表的RPL=3的第一个段选择子，任务0代码段</p>
<p>eip-&gt;下一条指令的地址(原地跳转)</p>
<p>ds, es, fs, gs -&gt; (ldtr寄存器)LDT表的RPL=3的第二个段选择子，任务0数据段</p>
<p>ss未变更？</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240706163156118.png" class="" title="image-20240706163156118">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240706163204640.png" class="" title="image-20240706163204640">
</blockquote>
<p>fork创建出任务1(init())</p>
<p>循环pause状态—</p>
<p>​	ps: 程序进入interruptible状态（闲置进程），无任务可调度时调度任务0</p>
<p>​	ps:任务0为所有进程的父进程，故不使用堆栈</p>
<p>Linux: main.c/init() 任务1</p>
<p>读取硬盘参数（包含分区表信息），加载虚拟盘（若存在），安装根文件系统设备</p>
<p>以读写方式打开tty0，得到文件句柄0stdin，复制两次得到stdout和stderr</p>
<p>fork产生任务2，等待任务2退出</p>
<p>循环</p>
<p>若产生的子进程死亡，重新产生新的进程并进入wait</p>
<blockquote>
<p>任务1与任务0区别</p>
<p>任务1的页表在主内存区，对于任务1，在页目录表有对应于自己的页目录表项，页表内容与任务0相同，虚拟地址高任务0一个页目录表项（在图中线性地址中体现，高的原因是任务1的页目录表项为第二个</p>
<p>任务1会在主内存区申请1页存放PCB+内核栈</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240713185606091.png" class="" title="image-20240713185606091">
</blockquote>
<p>Linux: main.c/init() 任务2</p>
<p>关闭从任务1所继承的stdin，stdout和stderr；创建新的会话期</p>
<p>tiny_os</p>
<p>loader中实现kernel写入内核</p>
<p>loader程序位于0x90000，使用0x90000以下部分作为程序栈</p>
<p>13.读磁盘指定扇区，写kernel.bin到虚拟地址0xc0070000~0xc009fbff</p>
<p>14.初始化kernel，将kernel.bin中的segment复制到被编译的虚拟地址处，第一个segment起始于0xc0001500</p>
<p>15.修改栈指针，跳转至kernel，虚拟地址0xc0001500</p>
<h2 id="中断">中断</h2>
<h3 id="外部中断与内部中断">外部中断与内部中断</h3>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240421152049031.png" class="" title="image-20240421152049031">
<p>中断引脚：</p>
<p>INTR: Interupter</p>
<p>NMI: Non Maskable Interupter	向CPU传入中断向量号 2</p>
<p>外部设备中断由中断代理芯片8259A接收后发送中断向量号到CPU中断引脚INTR</p>
<p>Linux： int32 ~ int47 -&gt; IRQ0 ~ IRQ15</p>
<p>软中断：系统调用</p>
<p>Linux：int128</p>
<p>异常：指针越界，栈溢出</p>
<p>Linux：int0 ~ int31</p>
<h3 id="实模式下的中断向量表">实模式下的中断向量表</h3>
<p>仅在实模式使用，由BIOS进行创建，位于0x00000~0x003ff</p>
<h3 id="中断门与保护模式下的中断描述符表IDT">中断门与保护模式下的中断描述符表IDT</h3>
<p>中断向量号为 中断向量表/中断描述符表 的索引下标</p>
<p>IDTR(Interrupt Descriptor Table Register) 中保存 IDT 位置信息</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240417105214817.png" class="" title="image-20240417105214817">
<p>IDT(Interrupt Descriptor Table)</p>
<p>item: 门</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240417104649804.png" class="" title="image-20240417104649804">
<h3 id="中断过程">中断过程</h3>
<h4 id="中断初始化">中断初始化</h4>
<p>tiny_os</p>
<p>实模式由BIOS创建中断向量表和中断处理程序；</p>
<p>保护模式由kernel创建中断描述符表和中断处理程序；</p>
<p>1.kernel进行中断初始化：中断描述符初始化，异常处理程序初始化，pic初始化</p>
<p>2.中断描述符初始化：创建中断描述符，描述符中的偏移量由一阶中断处理程序的偏移给出(位于kernel.asm，一阶中断处理程序在进行上下文保存后call二阶中断处理程序，即该初始化中创建的异常处理程序)，写入中断描述符表</p>
<p>3.异常处理程序初始化：将异常处理程序的地址写入二阶中断处理程序表，该表保存函数地址，由一阶中断处理程序call；</p>
<p>4.pic初始化</p>
<p>5.将中断描述符表地址写入idtr</p>
<h4 id="中断处理过程">中断处理过程</h4>
<p>1.中断请求</p>
<p>中断请求可能为内部中断或者外部中断</p>
<p>外部中断如下：</p>
<p>当外设发出中断信号后，信号被送入8259A；</p>
<p>8259A检查IMR寄存器中是否屏蔽了来自该IRQ的信号，若IMR寄存器中对应的位为1，表示屏蔽了IRQ代表的中断，则丢掉此中断信号，若IMR寄存器中对应的位为0，表示未屏蔽此中断，则将IRR寄存器中与此中断对应的位 置1。</p>
<p>PR优先级裁决器从IRR寄存器中挑选一个优先级最大的中断，然后8259A向CPU发送INTR信号。</p>
<p>内部中断由代码通过中断向量号触发。</p>
<p>2.(外)中断响应</p>
<p>CPU收到INTR信号后便知道有新的中断了，在执行完当前指令后，向8259A发送一个中断回复信号。</p>
<p>8259A收到回复信号后，将选出来的优先级最大的中断在ISR寄存器中相应的位 置1，表示该中断正在处理，同时将此中断在IRR寄存器中相应的位 置0，相当于将此中断从中断请求队列中去掉。</p>
<p>CPU再向8259A发送INTR信号，表示想要获取中断向量号。</p>
<p>8259A通过数据总线向CPU发送中断向量号，<strong>中断向量号 = 起始向量号 + IRQ接口号</strong>，一般起始向量号为32，从中断向量表可看出0—31已经被占用，后面的32—127是分配给可屏蔽中断的，所以此处外设的中断设置的起始向量号便为32。</p>
<p>3.保护现场__压栈</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714201118464.png" class="" title="image-20240714201118464">
<p>CPU据中断向量号去IDT中获取中断描述符，</p>
<blockquote>
<p>此时将取出选择子中的DPL与当前特权级CPL进行比较，若特权级发生变化，则需要切换栈（不同特权级有着不同的栈，如Linux使用了0， 3特权级，则有两个栈，一个内核栈，一个用户栈）。</p>
</blockquote>
<p>处理器从当前任务的TSS段（每一个任务有一个TSS结构，其中保存着不同特权级栈的SS和ESP值）中获取与DPL特权级相同的栈信息，处理器将当前的旧的SS和ESP的值压入目标栈(<strong>每个进程都拥有独立的内核栈</strong>).</p>
<p>向内核栈压入EFLAGS寄存器值</p>
<p>向内核栈压入CS，EIP值。</p>
<p>若该中断有错误码，压入错误码，</p>
<p>将 段选择符，偏移值写入CS, EIP, 前往执行一阶中断服务程序</p>
<p>图示为发生了特权级改变时的压栈情况</p>
<p><strong>以上过程不由一阶中断程序实现，硬件自动实现</strong></p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240421154614894.png" class="" title="image-20240421154614894">
<p>4.定位中断服务程序</p>
<p>访问中断处理程序的流程</p>
<p>1.通过idtr获得idt的地址，将中断向量号作为索引，访问到中断描述符</p>
<p>2.中断描述符给出<strong>一阶中断处理程序</strong>的段选择子和偏移</p>
<p>3.通过gdtr获得gdt的地址，将段选择子作为索引，访问到段描述符</p>
<p>4.段描述符给出<strong>一阶中断处理程序</strong>的段<strong>虚拟地址</strong>，</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240417110140482.png" class="" title="image-20240417110140482">
<p>5.通过段<strong>虚拟地址</strong>和偏移访问到<strong>一阶中断处理程序</strong>，</p>
<p><strong>一阶中断处理程序</strong>将C函数地址(二阶中断处理程序)压栈，后将地址交换写入eax, 原eax值入栈</p>
<p>其余上下文(ebx,ecx,edx,edi,esi,ebp,ds,es,fs)压栈，</p>
<p>压入错误码，压入执行一阶中断程序前的栈指针(esp0)，作为<strong>二阶中断处理程序参数</strong></p>
<p>并在<strong>二阶中断处理程序</strong>执行完成后，</p>
<p>弹出错误码和esp0，弹出上下文</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240702102514943.png" class="" title="image-20240702102514943">
<p>6.中断处理过程</p>
<p><strong>二阶中断处理程序</strong>，打印出错程序信息</p>
<p>中断的实际处理过程就是执行中断处理程序，Linux将中断处理程序分为上下两部分，需要紧急处理立即执行的归为上半部，不那么紧急的归为下半部。</p>
<p>开中断，即EFLAGS的IF位置1，表示允许响应中断；关中断，即EFLAGS的IF位置0，表示不允许响应中断。</p>
<p>上半部分是刻不容缓的，需要立即执行的部分，所以要在关中断的状态下执行。</p>
<p>而下半部分不那么紧急，在开中断的情况下进行，如果此时有新的中断发生，当前中断处理程序便会换下CPU，CPU会另寻时间重新调度，完成整个中断处理程序。</p>
<p>7.中断返回——出栈</p>
<p>中断返回就是出栈的过程，将第三步保护现场压入栈中的信息弹出。</p>
<p>有错误码弹出错误码。</p>
<p>此时的栈顶指针ESP应指向EIP_old，剩余栈中的信息使用iret指令弹出，CPU执行到iret指令时再次检查和比较特权级是否变化。</p>
<p>弹出EIP_old, CS_old</p>
<p>若特权级变化，将ESP_old, SS_old, 加载到ESP，SS寄存器。</p>
<h3 id="中断处理程序">中断处理程序</h3>
<p>Linux: asm.s, traps.c</p>
<p>asm.s</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240702102514943.png" class="" title="image-20240702102514943">
<p><strong>一阶中断处理程序</strong>将C函数地址(二阶中断处理程序)压栈，后将该值交换进入eax, 原eax值入栈</p>
<p>其余上下文(ebx,ecx,edx,edi,esi,ebp,ds,es,fs)压栈，</p>
<p>压入错误码(或0)，压入执行一阶中断程序前的栈指针(esp0)，作为<strong>二阶中断处理程序参数</strong></p>
<p>改变段寄存器ds, es, fs为内核数据段选择符</p>
<p>call<strong>二阶中断处理程序</strong>,</p>
<p>并在<strong>二阶中断处理程序</strong>执行完成后，弹出错误码和esp0，弹出上下文</p>
<p>traps.c</p>
<p><strong>二阶中断处理程序</strong>, 打印出错信息</p>
<p>初始化，设置中断调用门，传入<strong>一阶中断处理程序</strong>(函数)的地址</p>
<h3 id="系统调用处理程序与信号">系统调用处理程序与信号</h3>
<p>Linux: system.c</p>
<p><strong>含时钟中断!!!</strong></p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240704153835415.png" class="" title="image-20240704153835415">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240704190208804.png" class="" title="image-20240704190208804">
<p>对于系统调用处理程序(一阶中断处理程序)：</p>
<p>判断调用号范围</p>
<p>压栈ds, es, fs, edx, ecx, ebx,</p>
<p>修改ds, es, fs,</p>
<p>call 对应的C处理函数(二阶中断处理程序)</p>
<p>压栈eax(二阶中断处理程序返回值)</p>
<p>if(任务非就绪/时间片耗尽):</p>
<p>​	执行调度程序</p>
<p>​	执行ret_from_sys_call</p>
<p>else:</p>
<p>​	执行ret_from_sys_call</p>
<p>对于函数ret_from_sys_call：</p>
<p>if(非初始任务/非超级用户程序/?):</p>
<p>​	取当前任务结构的信号位图，取信号屏蔽码，得到可行信号图，复位信号图并写回</p>
<p>​	将可行信号图中最小的信号压栈，call do_signal，</p>
<p>弹出信号值signr, eax, ebx, ecx, edx, fs, es, ds</p>
<blockquote>
<p>此时cs为用户代码段选择子，eip为信号处理程序；内核栈中的ss和esp将在cpu检查段选择子的rpl部分时发现进入低特权级，弹出并写入；</p>
<p>后续执行信号处理程序，ret时将用户栈顶的restorer写入eip，执行restorer；</p>
<p>restorer丢弃用户栈顶的信号值signr, 设置信号屏蔽码, 丢弃block, 弹出eax, ecx, edx, eflags, ret将用户栈顶的原eip写入eip，恢复系统调用前状态</p>
</blockquote>
<p>​</p>
<p>函数do_signal：</p>
<blockquote>
<p>sys_signal和sys_sigaction修改进程task_struct的sigaction[32]，用于修改在接收信号时的处理函数，返回原对应信号的处理函数指针</p>
<p>sigaction[32]的项：</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240704193952350.png" class="" title="image-20240704193952350">
<p>sys_sigaction是sys_signal的超集</p>
</blockquote>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240704190208804.png" class="" title="image-20240704190208804">
<p>从task_struct-&gt;sigaction[32]中获取信号signr对应的sigaction</p>
<p>if(非忽略句柄/非默认句柄):</p>
<p>​	若sigaction-&gt;sa_flag为oneshot, 将句柄置空</p>
<p>​	修改内核堆栈中eip的值为信号处理程序句柄</p>
<p>​	下移用户堆栈对应esp，并向用户堆栈写入图示值</p>
<blockquote>
<p>sa_restorer</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240704195323779.png" class="" title="image-20240704195323779">
</blockquote>
<p><strong>信号</strong></p>
<p>有上可知，信号将在系统调用结束时检查，并使用该程序task_struct中sigaction[32]中设置的处理函数进行处理</p>
<p>向某程序发信息 -&gt; 修改该程序task_struct的signal</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240705101522972.png" class="" title="image-20240705101522972">
<h3 id="中断处理程序-系统调用处理程序的注册">中断处理程序/系统调用处理程序的注册</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">register_handler</span><span class="params">(<span class="type">uint8_t</span> vec_no, intr_handler handler)</span> &#123;</span><br><span class="line">    sys_call_table[vec_no] = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<strong>中断处理程序表/系统调用处理程序表</strong>指向的二阶中断处理程序</p>
<p>仅在内核态可修改此类表</p>
<h2 id="进程与线程">进程与线程</h2>
<h3 id="TSS与任务链">TSS与任务链</h3>
<p>TR(Task Register)</p>
<p>保存TSS地址</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714093840136.png" class="" title="image-20240714093840136">
<p>Task State Segment</p>
<p>TSS描述符保存于GDT</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240506191146645.png" class="" title="image-20240506191146645">
<p>TSS内容</p>
<p>保存任务快照（任务被换上/换下CPU时）</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240506191245406.png" class="" title="image-20240506191245406">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240428111029824.png" class="" title="image-20240428111029824">
<p>TSS段</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240713192515176.png" class="" title="image-20240713192515176">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240713192710613.png" class="" title="image-20240713192710613">
<h3 id="PCB">PCB</h3>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240705104639547.png" class="" title="image-20240705104639547">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240705104656011.png" class="" title="image-20240705104656011">
<blockquote>
<p>进程的页目录表基址保存在PCB，linux 0.1x的所有进程的这个值均为0x0000</p>
<p>进程的tss位于PCB</p>
<p>进程的ldt位于PCB和tss</p>
</blockquote>
<h3 id="进程">进程</h3>
<p>Linux</p>
<h4 id="fork">fork</h4>
<p>通过fork从task0创建</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714144402746.png" class="" title="image-20240714144402746">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714144419322.png" class="" title="image-20240714144419322">
<blockquote>
<p>被fork出来的子进程将复制父进程的页目录表和页表，fork()后，子进程将获得自己的PCB，其中PCB的页目录表基址和父进程不一致，指向自己的页目录表。该页目录表对应页表中的页表项指向的物理地址与父进程的一致，直至子进程发生写行为时分配新内存页（写时复制技术）</p>
<p>创建新进程需要在fork后在子进程内执行execve切换执行内容</p>
<p>fork的核心工作是复制出新的PCB，并修改PCB中的各值(包括对TSS的修改)</p>
</blockquote>
<h4 id="execve">execve</h4>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240715111107866.png" class="" title="image-20240715111107866">
<p>tiny_os</p>
<p>进程创建过程</p>
<p>kernel启动进程，传入进程参数（进程文件名和进程名），启动进程。</p>
<p>1.初始化线程</p>
<p>从内核空间申请页面，清洗页面，初始化线程名为线程/进程名；</p>
<p>根据线程/进程名初始化线程状态；</p>
<p>初始化优先级，时间片上限，已使用时间片，页目录表地址，内核栈指针，魔数等；</p>
<p>加入线程队列，线程指针thread指向该页面底部；</p>
<p>2.创建用户进程的虚拟地址池</p>
<p>用户进程虚拟地址池位于PCB中</p>
<p>设置虚拟地址池起始于0x00000000</p>
<p>设置虚拟地址池所管理的空间的页数和虚拟地址池长度</p>
<p>3.初始化内核栈</p>
<p>线程内核栈位置为PCB页面顶部（高地址），thread-&gt;self_kstack为线程内核栈指针；</p>
<p>下移thread-&gt;self_kstack，留出中断栈空间sizeof(intr_stack)</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240425101059850.png" class="" title="image-20240425101059850">
<p>下移thread-&gt;self_kstack，留出线程栈空间sizeof(thread_stack)</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240425101121206.png" class="" title="image-20240425101121206">
<p>创建线程栈指针kthread_stack，指向当前thread-&gt;self_kstack指针位置，</p>
<p>初始化线程栈，依次写入eip，函数名，函数参数和寄存器初始值ebp,ebx,esi,edi；</p>
<p>thread-&gt;self_kstack此时位于线程栈栈顶，栈顶内容为edi，esi，ebx，ebp，函数参数，函数名，eip；</p>
<p>//不执行ret指令，将压栈的函数参数，函数名和返回地址弹出，并前往执行对应函数；</p>
<p>4.创建用户进程的页目录表</p>
<p>从内核分配一页作为进程页目录表</p>
<p>将内核页目录表的高半部分（对应内核空间部分）项复制到进程页目录表中</p>
<p>设置最后一项页表的地址为页目录表地址</p>
<p>4.5 初始化用户内存块表</p>
<p>5.加入调度链表</p>
<p>关中断；</p>
<p>将进程加入调度链表；</p>
<p>开中断；</p>
<p>进程执行</p>
<p>构建用户进程初始上下文信息</p>
<p>移动线程栈指针kthread_stack指向intr_stack顶部，线程栈底部</p>
<p>写入中断栈，依次写入edi, esi, ebp, esp_dummy</p>
<p>ebx, edx, ecx, eax, gs,</p>
<p>ds, es, fs, eip, cs, eflag, esp, ss, 此类寄存器中值均为用户空间，为通过中断返回的方式进入3特权级做准备</p>
<p>thread-&gt;self_kstack此时位于中断栈栈顶，栈顶内容为：</p>
<p>vec_no, edi, esi, ebp, esp_dummy…</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240507185615764.png" class="" title="image-20240507185615764">
<p>将esp设置为中断栈栈顶指针thread-&gt;self_kstack，</p>
<p>jmp intr_exit，跳过压入的中断向量号vec_no，popad弹出所有通用寄存器值，pop gs，fs，es，ds，跳过错误码；此时栈顶为：eip值为filename（指向用户进程入口地址），cs值为SELECTOR_U_CODE，eflag为(EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);</p>
<p>前往执行对应函数，进入特权级3；</p>
<h3 id="调度">调度</h3>
<p>调度发生在：</p>
<p>Flag <code>need_sched</code>为1</p>
<p>1.系统调用/中断(包括时间中断)-执行处理函数后，若当前进程时间片为0或任务未就绪，调用<code>schedule()</code></p>
<p>2.切换当前running态进程为其他态后，调用<code>schedule()</code></p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240608144715684.png" class="" title="image-20240608144715684">
<p>TASK_INTERRUPTIBLE与TASK_UNINTERRUPTIBLE</p>
<p>TASK_INTERRUPTIBLE可接收信号，会被提前唤醒并响应信号</p>
<p>TASK_UNINTERRUPTIBLE屏蔽信号，即使是 SIGKILL 信号也无法将其杀死。 只有当它自己 wake up 之后，才会查看信号，然后进行处理。</p>
<p><strong>进程需要调度判定</strong></p>
<p>PCB <code>need_resched</code> flag</p>
<p><strong><code>need_resched</code> 标志作用</strong></p>
<p>need_resched 标志用于指示内核调度器，当前进程需要重新调度。当该标志被设置为 1 时，表示当前进程的运行时间已经超过了其时间片，或者有更高优先级的进程进入就绪状态，内核调度器需要在下一次调度时机选择新的进程运行。</p>
<p><strong><code>need_resched</code> 标志生效时机</strong></p>
<p>多种情况下会设置 <code>need_resched</code> 标志，主要包括：</p>
<ul>
<li><strong>时间片耗尽：</strong> 当一个进程运行的时间超过了分配给它的时间片时，内核调度器会设置该进程的 <code>need_resched</code> 标志，以便在下一次调度时选择其他进程运行。</li>
<li><strong>更高优先级进程就绪：</strong> 当一个更高优先级的进程进入就绪状态时，内核调度器会设置当前运行进程（如果其优先级低于新就绪进程）的 <code>need_resched </code>标志，以便尽快调度更高优先级的进程运行。</li>
<li><strong>进程主动放弃 CPU：</strong> 当一个进程主动调用 sched_yield() 或类似的系统调用时，表示它愿意放弃 CPU 使用权，此时内核会设置该进程的 <code>need_resched </code>标志。</li>
<li><strong>从内核态返回用户态：</strong> 当一个进程从内核态返回用户态时，内核会检查 <code>need_resched </code>标志，如果设置了该标志，则会进行进程调度，切换到新的进程运行。</li>
</ul>
<p><strong><code>need_resched</code> 标志检查时机</strong></p>
<p>内核态返回用户态时：系统调用返回/中断返回（含时钟中断）</p>
<p>若<code>need_resched</code>标志为<code>1</code>，则调用<code>schedule()</code></p>
<p><strong>等待队列与唤醒</strong></p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240801110805754.png" class="" title="image-20240801110805754">
<p><strong>一个文件表项 -&gt; 一个等待队列！！！</strong></p>
<p><strong>过程</strong></p>
<ol>
<li>
<p><strong>进程睡眠：</strong></p>
<ul>
<li>
<p>进程调用 read() 等系统调用读取驱动设备数据，由于数据尚未准备好，驱动程序会将进程加入到自身维护的一个等待队列中 / 进程将自己添加进等待队列</p>
<p>进程通过以下步骤将自己加入等待队列</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240801110303316.png" class="" title="image-20240801110303316">
<blockquote>
<p>进程在执行到<code>schedule()</code>时，将自己当前状态的上下文保存至TSS，包括EIP和CS，由于EIP指向<code>while(!condition)</code>判断，即下次程序执行时会进行condition的判断，若满足则结束等待</p>
</blockquote>
</li>
<li>
<p>进程将自身状态设置为 TASK_INTERRUPTIBLE 或 TASK_UNINTERRUPTIBLE，表示可以被信号或中断唤醒。</p>
</li>
</ul>
</li>
<li>
<p><strong>中断/事件发生：</strong></p>
<ul>
<li>驱动设备完成数据输入后，会向 CPU 发出一个中断请求 / 被占用的资源被释放 / 进程主动等待的条件满足。</li>
<li>CPU 收到中断请求后，会保存当前上下文，并跳转到该中断对应的中断处理函数执行 / 执行与该事件关联的代码（例如，资源管理代码）</li>
</ul>
</li>
<li>
<p><strong>处理程序/唤醒程序：</strong></p>
<ul>
<li>处理程序执行设备相关的处理逻辑，例如从设备读取数据到缓冲区。</li>
<li><strong>关键步骤：</strong> 中断处理程序会调用 wake_up_interruptible() 或类似的 API。该函数会:
<ul>
<li>将等待队列中所有等待该设备数据的进程标记为<strong>状态TASK_RUNNING</strong>，并将进程从等待队列的链表中移除，<code>activate_task()</code> 函数负责将进程加入到就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>调度与唤醒：</strong></p>
<ul>
<li>中断处理完成后，CPU 会根据调度策略选择下一个要运行的进程。</li>
<li>被唤醒的进程最终获得 CPU 时间，继续执行，此时 read() 系统调用会成功返回读取到的数据。</li>
</ul>
</li>
</ol>
<p><strong>任务切换</strong></p>
<p>使用远跳转实现任务切换</p>
<p>call指令可以实现向高特权级跳转，jmp平级跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 近跳转</span><br><span class="line">jmp short next_instruction</span><br><span class="line"></span><br><span class="line">; 远跳转，使用段地址和偏移量 (实模式)</span><br><span class="line">jmp far 1000h:1234h</span><br><span class="line"></span><br><span class="line">; 远跳转，使用选择子和偏移量 (保护模式)</span><br><span class="line">jmp far [selector:offset]</span><br><span class="line">call 0x0008:0x1234 ; 向GDT中索引为1的调用门跳转，忽略偏移0x1234</span><br></pre></td></tr></table></figure>
<p>在linux 0.x 中，所有任务的TSS均保存在GDT中；</p>
<p>在发生上述两种需要调度的情况时，调度程序(内核)将获取下一个可执行任务，并获取该任务对应的TSS；</p>
<p>jmp far [TSS 选择子]</p>
<ul>
<li><strong>读取 TSS 选择子：</strong> CPU 从指令中获取 [TSS 选择子] 的值，该值指向目标任务 (Task B) 的 TSS 描述符在 GDT 中的位置。</li>
<li><strong>读取 TSS 描述符：</strong> CPU 根据 TSS 选择子，从 GDT 中读取 Task B 的 TSS 描述符，该描述符包含了 Task B 的 TSS 段基址。</li>
<li><strong>加载新 TSS：</strong> CPU 将 Task B 的 TSS 段基址加载到 TR 寄存器中，表示当前任务切换为 Task B。</li>
<li><strong>保存当前任务状态：</strong> CPU 将当前任务 (Task A) 的状态信息保存到 Task A 的 TSS 中，包括：
<ul>
<li>CS、EIP、EFLAGS、SS、ESP 等通用寄存器的值。</li>
<li>段寄存器 DS、ES、FS、GS 的值。</li>
</ul>
</li>
<li><strong>加载新任务状态：</strong> CPU 从 Task B 的 TSS 中加载新的任务状态，包括：
<ul>
<li>将 Task B 的 CS、EIP、EFLAGS、SS、ESP 等寄存器的值加载到相应的寄存器中。</li>
<li>将 Task B 的 DS、ES、FS、GS 段寄存器的值加载到相应的段寄存器中。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在CPU识别出跳转目标为TSS选择子时（通过硬件机制识别），不会直接将 选择子:偏移 写入 CS:EIP，会进入任务切换流程，通过硬件自动将当前任务的 CS:EIP 以及其他相关寄存器（包括 EFLAGS、SS、ESP、段寄存器等）的值保存在当前任务的 TSS 中，然后从目标任务的 TSS 中加载新的 CS:EIP 以及其他寄存器的值。</p>
</blockquote>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240715103745870.png" class="" title="image-20240715103745870">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240715103802105.png" class="" title="image-20240715103802105">
<p>进程切换时，修改以下：</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714095015752.png" class="" title="image-20240714095015752">
<p>Linux: system_call.s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.align 2</span><br><span class="line">_timer_interrupt:</span><br><span class="line">	push %ds		# save ds,es and put kernel data space</span><br><span class="line">	push %es		# into them. %fs is used by _system_call</span><br><span class="line">	push %fs</span><br><span class="line">	pushl %edx		# we save %eax,%ecx,%edx as gcc doesn&#x27;t</span><br><span class="line">	pushl %ecx		# save those across function calls. %ebx</span><br><span class="line">	pushl %ebx		# is saved as we use that in ret_sys_call</span><br><span class="line">	pushl %eax</span><br><span class="line">	movl $0x10,%eax</span><br><span class="line">	mov %ax,%ds</span><br><span class="line">	mov %ax,%es</span><br><span class="line">	movl $0x17,%eax</span><br><span class="line">	mov %ax,%fs</span><br><span class="line">	incl _jiffies  #发生时间中断时将jiffies自增</span><br><span class="line">	movb $0x20,%al		# EOI to interrupt controller #1</span><br><span class="line">	outb %al,$0x20</span><br><span class="line">	movl CS(%esp),%eax</span><br><span class="line">	andl $3,%eax		# %eax is CPL (0 or 3, 0=supervisor)</span><br><span class="line">	pushl %eax</span><br><span class="line">	call _do_timer		# &#x27;do_timer(long CPL)&#x27; does everything from PS: 其实就是修改计时器和调度</span><br><span class="line">	addl $4,%esp		# task switching to accounting ...</span><br><span class="line">	jmp ret_from_sys_call</span><br></pre></td></tr></table></figure>
<p>Linux: sched.c（核心代码</p>
<p>jiffies</p>
<blockquote>
<p>include/sched.h 定义为变量</p>
</blockquote>
<p>schedule()</p>
<blockquote>
<p>调度代码</p>
</blockquote>
<p>从任务数组中最后一个任务开始向前扫描直到第一个任务前(跳过空)：</p>
<p>​	若task_struct-&gt;alarm &lt; jiffies, 修改signal并置alarm为0</p>
<p>​	若任务除去屏蔽信号外存在信号且为interruptible, 修改task_struct-&gt;state为就绪</p>
<blockquote>
<p>alarm判断+有信号存在</p>
</blockquote>
<p>next = 0</p>
<p>while(1)</p>
<p>​	从任务数组中最后一个任务开始向前扫描直到第一个任务前(跳过空)：</p>
<p>​		next = 当前task_struct-&gt;counter最大的任务；</p>
<p>​		if(counter最大的任务的counter&gt;0):break;</p>
<p>​		else:使用任务优先级更新所有任务的counter</p>
<p>switch_to(next)</p>
<blockquote>
<p>next默认为0，即在没有可执行任务时系统切换至任务0(idle任务)执行</p>
</blockquote>
<p>sleep_on(struct task_struct **p)</p>
<blockquote>
<p>将当前任务state置为uninterruptible并加入睡眠队列</p>
<p>传入的p指向睡眠队列头，该函数将当前task置为睡眠队列头</p>
</blockquote>
<p>do_timer(long cpl)</p>
<blockquote>
<p>时钟中断二阶处理程序</p>
</blockquote>
<p>增加内核/用户代码运行时间</p>
<p>定时器链中定时器的值减少，若为0调用处理函数并移除该定时器</p>
<p>减少当前程序的<code>counter</code>值，若为0则置当前进程<code>need_sched</code>为<code>1</code></p>
<p>switch_to()</p>
<blockquote>
<p>switch_to修改current指针指向传入的task任务，切换进程</p>
</blockquote>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240705161507324.png" class="" title="image-20240705161507324">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240705155902092.png" class="" title="image-20240705155902092">
<h2 id="特权级">特权级</h2>
<p>CPL(Current Privilege Level)  当前代码特权级</p>
<p>为当前运行代码段的特权级，保存于CS寄存器中段选择子的RPL(2位)处</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240416193845119.png" class="" title="image-20240416193845119">
<p>eg: 运行用户程序代码，CPL = 3</p>
<p>​	  运行内核程序代码，CPL = 0</p>
<p>RPL(Request Privilege Level) 访问者特权级</p>
<p>访问者代码所在段的描述符的DPL为RPL值</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240416192952163.png" class="" title="image-20240416192952163">
<p>DPL(Descriptor Privilege Level) 受访者特权级</p>
<p>受访者代码所在段的描述符的DPL</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240416192952163.png" class="" title="image-20240416192952163">
<h3 id="门描述符">门描述符</h3>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240417104649804.png" class="" title="image-20240417104649804">
<p>门描述符含有DPL，访问者的权限需大于等于门描述符的权限</p>
<p>eg: 访问者RPL=3, 门描述符DPL=3</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240417104649804.png" class="" title="image-20240417104649804">
<p>门描述符给出目标中断程序的段描述符选择子，</p>
<p>段描述符选择子含有DPL，门描述符的特权小于被访问者(中断程序)的权限</p>
<p>eg: 门描述符DPL=3，中断程序段描述符DPL=0</p>
<h3 id="访问过程">访问过程</h3>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240506164402606.png" class="" title="image-20240506164402606">
<h2 id="内存管理">内存管理</h2>
<p>tiny_os</p>
<p>物理内存被划分为内核内存池和用户内存池</p>
<p>所有程序（用户程序和内核）均存在虚拟地址池，记录虚拟内存使用情况</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240425160621730.png" class="" title="image-20240425160621730">
<h3 id="内存管理-2">内存管理</h3>
<p>Linux</p>
<blockquote>
<p>Linux不对主内存(物理内存)进行内核使用和用户使用的划分；</p>
<p>所有物理内存的申请均在主内存实现；</p>
</blockquote>
<p><strong>VMA 列表</strong></p>
<p>在 Linux 中，每个进程都维护着一个虚拟内存区域（Virtual Memory Area，VMA）列表。</p>
<p>VMA 列表存储在进程的 PCB 的 mm_struct 结构体中。mm_struct 结构体是 Linux 内核用来管理进程地址空间的核心数据结构。</p>
<p>该列表记录了进程虚拟地址空间中每个内存区域的详细信息，例如：</p>
<ul>
<li><strong>起始地址和结束地址：</strong>  定义了该 VMA 覆盖的虚拟地址范围。</li>
<li><strong>访问权限：</strong>  例如，只读、读写、可执行等。</li>
<li><strong>映射类型：</strong>  例如，文件映射、匿名映射、设备映射等。</li>
<li><strong>文件映射信息：</strong>  如果 VMA 映射了文件，则会记录文件的路径、文件偏移量等信息。</li>
<li><strong>其他属性：</strong>  例如，是否共享、是否私有、是否可交换等。</li>
</ul>
<p>进程的 VMA 列表是一个按照虚拟地址排序的链表。 内核可以使用红黑树等数据结构来加速 VMA 的查找。</p>
<p>每个 VMA 只是描述了进程虚拟地址空间中的一段<strong>连续区域</strong>。 一个进程可以有多个 VMA，每个 VMA 对应不同的内存区域，例如代码段、数据段、堆、栈、共享库映射区域等。</p>
<p><strong>VMA 数据结构</strong></p>
<p>VMA 列表中的每个元素都是一个 <code>vm_area_struct</code> 结构体，该结构体定义在 <code>include/linux/mm_types.h</code> 头文件中。  以下是 <code>vm_area_struct</code> 结构体中一些重要的成员变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* VMA 的起始和结束虚拟地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* VMA 的访问权限 */</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* VMA 的标志位，例如 VM_READ、VM_WRITE、VM_EXEC 等 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 指向 VMA 所属进程的 mm_struct 结构体指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 指向下一个 VMA 的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 指向映射文件的 file 结构体指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件映射的起始偏移量 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... 其他成员变量 ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>虚拟内存区域</strong></p>
<p>常见的虚拟内存区域，每个区域通常对应一个或多个 VMA：</p>
<ul>
<li><strong>代码段 (Text Segment):</strong> 存储程序的机器指令代码，通常是只读的。</li>
<li><strong>数据段 (Data Segment):</strong> 存储程序的全局变量和静态变量，分为初始化数据段和未初始化数据段。</li>
<li><strong>堆 (Heap):</strong> 用于动态内存分配，通过 malloc()、calloc()、realloc() 等函数管理。</li>
<li><strong>栈 (Stack):</strong> 用于函数调用，存储函数参数、局部变量、返回地址等信息。</li>
<li><strong>共享库映射区 (Shared Library Mapping Area):</strong> 用于映射动态链接库 (DLL) 的代码和数据。</li>
<li><strong>内存映射文件 (Memory-Mapped Files):</strong> 使用 mmap() 系统调用将文件映射到内存中。</li>
<li><strong>匿名映射 (Anonymous Mapping):</strong> 不对应于任何文件的内存映射，通常用于进程间通信或动态内存分配。</li>
</ul>
<p>tiny_os</p>
<p>内存池创建：</p>
<p>1.kernel创建内核内存池和用户内存池，两个池均位于物理地址0x0009a000；分别管理物理内存的0x00102000~?和0x?(大小为物理内存剩下的一半)</p>
<p>2.kernel创建kernel的虚拟地址池，位于kbm和ubm之后；管理0xc0100000~?(大小同内核内存池)的虚拟地址</p>
<p>3.初始化内核内存池，用户内存池，虚拟地址池，</p>
<p>申请内存过程：</p>
<p>1.在虚拟地址池中申请连续虚拟内存</p>
<p>扫描虚拟地址池位图，判断是否可申请对应页数；若允许，修改位图并返回页<strong>起始虚拟地址</strong>。</p>
<p>2.在给定的物理内存池中逐一申请物理页(不要求连续)</p>
<p>判断需要在哪个物理池中进行申请；扫描物理地址池位图，修改位图并返回单页<strong>起始物理地址</strong>，重复。</p>
<p>3.通过页表建立虚拟页与物理页的映射关系.</p>
<p>将多页虚拟地址差分为单页，传入单页虚拟地址的和单页物理地址；</p>
<p>将虚拟地址高10位作为页目录索引v_pdi，中10位作为页表索引v_pti；</p>
<p>若页目录索引v_pdi处存在PDE，使用单页物理地址构造页表项PTE，写入PDE指向的页表的页表索引v_pti处；</p>
<p>若页目录索引v_pdi处为空，在内核中申请一个物理页作为页表，使用单页物理地址构造页表项PTE，写入PDE指向的页表的页表索引v_pti处；</p>
<p>申请过程中会将所申请到的页清理干净</p>
<h3 id="动态加载与缺页">动态加载与缺页</h3>
<p><strong>缺页中断存在两种情况</strong></p>
<ol>
<li><strong>页表项存在，但 Present 位为 0:</strong> 这表示该虚拟地址已经映射到某个物理页面，但该页面当前不在物理内存中，可能被换出到磁盘了。 这种情况下，缺页中断处理程序需要将页面从磁盘加载到内存中，并更新页表项。</li>
<li><strong>页表项不存在：</strong> 这表示该虚拟地址尚未映射到任何物理页面。 这通常发生在程序第一次访问该地址时，例如访问未初始化的数据段、堆区或动态链接库。 这种情况下，缺页中断处理程序需要分配一个新的物理页面，并将虚拟地址映射到该页面，然后才会允许程序继续执行。</li>
</ol>
<p><strong>加载dll文件</strong></p>
<ul>
<li><strong>查找 DLL 文件：</strong> 根据文件名在磁盘上搜索 DLL 文件。</li>
<li><strong>分配虚拟地址空间：</strong> 在进程的虚拟地址空间中找到一块足够大的空闲区域，用于映射 DLL 文件。 <strong>这一步就决定了 DLL 会被加载到哪个虚拟地址范围。</strong></li>
<li><strong>创建 VMA：</strong> 为 DLL 创建一个虚拟内存区域 (VMA)，记录 DLL 的起始地址、大小、访问权限等信息。</li>
<li><strong>修改页表：</strong> 此时，操作系统<strong>并不会</strong>立即为 DLL 分配物理页面，也不会将 DLL 文件内容加载到内存中。 它只是修改进程的页表，将 DLL 文件的映射信息写入页表，并将这些页表项标记为<strong>无效</strong> (例如，Present 位为 0)。</li>
<li><strong>处理重定位表：</strong> DLL 文件中包含一个重定位表，记录了 DLL 代码和数据中需要进行地址修正的位置。 加载器会根据 DLL 的加载地址，修改重定位表中的地址，确保 DLL 能够正确访问自身和其他模块的代码和数据。</li>
</ul>
<p><strong>加载文件</strong></p>
<ul>
<li><strong>系统调用：</strong> 进程使用 read()、write() 等系统调用来读写文件。</li>
<li><strong>文件描述符表：</strong> 内核根据文件描述符，在进程的文件描述符表中找到对应的文件表项指针。</li>
<li><strong>文件表项：</strong> 内核访问文件表项，获取文件的当前偏移量、访问模式等信息。</li>
<li><strong>虚拟文件系统 (VFS)：</strong> 内核调用虚拟文件系统 (VFS) 的函数，将文件操作转换为具体文件系统的操作。</li>
<li><strong>具体文件系统：</strong> 具体文件系统（例如，ext4、NTFS）负责将文件数据从磁盘读取到内核缓冲区，或者将内核缓冲区中的数据写入磁盘。</li>
<li><strong>数据拷贝：</strong> 内核将数据在内核缓冲区和用户空间缓冲区之间进行拷贝。</li>
</ul>
<blockquote>
<p>为什么不直接将用户进程的一部分虚拟地址空间映射到内存中文件</p>
<p>考虑多个进程访问一个文件的情况：进程直接修改内存中的文件原件会导致同步文件（如同时写导致的数据丢失），还有安全风险、无法充分利用文件系统的缓存机制的问题。</p>
<p>对比 <code>mmap()</code></p>
<p>mmap() 系统调用提供了多种不同的映射方式，包括：</p>
<ul>
<li><strong>文件映射：</strong> 将文件内容映射到进程地址空间，可以高效地读取和修改文件数据。</li>
<li><strong>匿名映射：</strong> 创建不对应于任何文件的内存映射，可用于进程间通信、动态内存分配等。</li>
<li><strong>设备映射：</strong> 将设备寄存器或其他硬件资源映射到进程地址空间，方便用户程序直接访问硬件。</li>
</ul>
<p>使用mmap就可以达到上面讲的那种情况了</p>
<p>PS：mmap允许将相同的物理地址映射到两个不同的进程中不同的虚拟地址空间上，这样就实现了IPC进程间通信，隔壁Binder机制就是这么做的</p>
<ul>
<li><strong>MAP_SHARED 标志：</strong> 当使用 mmap() 创建映射时，可以通过指定 MAP_SHARED 标志来实现共享内存。 使用该标志时，多个进程对映射区域的修改对所有进程可见。</li>
</ul>
</blockquote>
<ul>
<li><strong>更新文件偏移量：</strong> 内核更新文件表项中的文件偏移量，以便下次读写操作从正确的位置开始。</li>
</ul>
<h2 id="文件系统">文件系统</h2>
<h3 id="i节点">i节点</h3>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714155420209.png" class="" title="image-20240714155420209">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714155445517.png" class="" title="image-20240714155445517">
<h3 id="文件打开">文件打开</h3>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714155625208.png" class="" title="image-20240714155625208">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714155718673.png" class="" title="image-20240714155718673">
<p><code>open()</code> 函数返回的指针是进程数据结构中文件指针数组的一个索引。具体来说，当一个文件被打开时，<code>open()</code> 函数会在进程的数据结构中分配一个文件指针数组的索引（在图的最左边），并将其指向文件表（<code>file_table</code>）中的一个条目。在文件表条目中包含了文件的状态标志、引用计数、inode指针和文件位置等信息。</p>
<p>在实际使用中，<code>open()</code> 函数返回的值是文件描述符（file descriptor），它是一个非负整数，通常从0开始递增。这个文件描述符对应于进程数据结构中文件指针数组的一个索引。</p>
<blockquote>
<p>注意，同一个进程多次打开同一个文件，会在系统的打开文件表中新增多个项，因为打开文件表中的项记录了打开文件的权限（eg.: 只读），多次打开时的设置可能不一样</p>
</blockquote>
<p><strong>文件描述符的值</strong></p>
<p>在一个典型的UNIX系统中，文件描述符的值可能是：</p>
<ul>
<li><code>0</code> 对应标准输入（stdin）</li>
<li><code>1</code> 对应标准输出（stdout）</li>
<li><code>2</code> 对应标准错误（stderr）</li>
</ul>
<p>其他文件描述符值将分配给用户打开的文件。例如，<code>open()</code> 函数第一次被调用时，可能返回 <code>3</code>，表示第一个用户打开的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程</span><br><span class="line">+--------------------+</span><br><span class="line">| FD Table (进程)    |</span><br><span class="line">| +-----+------------|</span><br><span class="line">| | 0   | stdin      |</span><br><span class="line">| | 1   | stdout     |</span><br><span class="line">| | 2   | stderr     |</span><br><span class="line">| | ... | ...        |</span><br><span class="line">| | 3   | device_fd  | --&gt; 文件表项 --&gt; inode (device)</span><br><span class="line">| | 4   | property_fd| --&gt; 文件表项 --&gt; inode (property)</span><br><span class="line">| | 5   | socket_fd  | --&gt; 文件表项 --&gt; 套接字结构</span><br><span class="line">| | 6   | pipe_read_fd | --&gt; 文件表项 --&gt; 管道缓冲区</span><br><span class="line">| | 7   | pipe_write_fd| --&gt; 文件表项 --&gt; 管道缓冲区</span><br><span class="line">+-----+--------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于pipe</p>
<p>在一个进程中创建一个管道时，使用 <code>pipe</code> 系统调用会返回两个文件描述符，一个用于读端 (<code>pipe_read_fd</code>)，一个用于写端 (<code>pipe_write_fd</code>)。这两个文件描述符指向不同的文件表项，但文件表项指向相同的管道缓冲区。</p>
<p>操作系统不会在内存中创建新的inode节点，因为管道是内存数据结构，并不与文件系统实体关联</p>
<p>假定当前进程是一个shell，而它调用fork()产生两个子进程，从而创建一个两阶段管道，具体步骤如下：</p>
<p>1，使用pipe() 创建管道。必须首先做到这一点，以便主进程创建的两个子进程能够继承打开的文件描述符。</p>
<p>2，调用fork()，产生我们的“生产者进程”。该进程的标准输出流向管道。在该子进程中进行如下操作：</p>
<p>a, 因为生产者进程不需要管道的读取端所以使用 close(pipefd[0]) 关闭它。</p>
<p>b,使用close(STDOUT_FILENO)，（即1）关闭最初的标准输出。</p>
<p>c,使用dup(pipefd[1])将管道的写入端改变为文件描述符1.</p>
<blockquote>
<p>dup 函数创建一个新的文件描述符，指向与 oldfd 相同的打开文件表项。新文件描述符的值将是当前进程中可用的最小未使用的文件描述符。此处即为刚才关闭的标准输出，文件描述符1。</p>
</blockquote>
<p>d,我们不需要打开的文件描述符的两份拷贝，所以使用close(pipefd[1])关闭一个。</p>
<blockquote>
<p>注意关闭未使用的管道文件描述符的重要性。因为直到最后一个打开的文件描述符关闭，文件才真正关闭，即使多个进程共享文件描述符时也是如此。因为只有所有的写入端拷贝都被关闭，从管道读取数据 的进程才会知道是否到达文件末尾，所以关闭未使用的文件描述符至关重要。</p>
</blockquote>
<p>e,调用exec()启动运行的程序。</p>
<p>3，调用fork()产生我们的“消费者进程“，该进程的标准输入来自于管道。该子进程中的和生产者的步骤相似，</p>
<p>a,因为右侧的子进程不需要管道的输入端所以使用close(pipefd[1]) 关闭它。</p>
<p>b,使用close(STDIN_FILENO)关闭最初的标准输入。STDIN_FILENO为 0</p>
<p>c,使用dup(pipefd[0])将管道的读取端（输入）改变为文件描述符0.</p>
<p>d,使用close(pipefd[0])关闭文件描述符的一个拷贝。</p>
<p>e,调用exec()启动运行的程序。</p>
<p>4，父进程关闭管道的两端close(pipefd[0]),close(pipefd[1])。</p>
<p>5，最后，在父进程中使用wait等待两个子进程的结束。</p>
</blockquote>
<blockquote>
<p>关于socket</p>
<p>内核会执行以下操作：</p>
<ol>
<li>
<p><strong>分配资源：</strong> 在内核空间中分配一个新的 socket 数据结构，用于存储 socket 的相关信息，例如：协议族、套接字类型、本地地址、远程地址、连接状态等。</p>
</li>
<li>
<p><strong>创建文件表项：</strong> 为 socket 创建一个文件表项，并将其添加到系统打开文件表中。文件表项中包含指向 socket 数据结构的指针以及其他文件操作相关的信息。</p>
</li>
<li>
<p><strong>分配文件描述符：</strong> 在进程的文件描述符表中找到一个最小的未使用的文件描述符，并将其指向新创建的文件表项。</p>
</li>
</ol>
</blockquote>
<p><strong>文件表中的值</strong></p>
<p>文件表（<code>file_table</code>）中的每个条目（<code>struct file</code>）可能包含以下信息：</p>
<ul>
<li><code>f_flags</code>：文件状态标志，如只读、只写或读写。</li>
</ul>
<blockquote>
<p>注意：poll系统调用监视的就是这个值的变化</p>
</blockquote>
<ul>
<li><code>f_count</code>：引用计数，表示当前有多少进程共享此文件。</li>
<li><code>f_inode</code>：指向内存中i节点结构的指针，包含文件的元数据。</li>
<li><code>f_pos</code>：文件位置指针，表示当前文件的读写位置。</li>
</ul>
<p>文件表在系统中的组织方式如下：</p>
<ul>
<li><strong>每个进程有自己的文件指针数组</strong>：每个进程都有一个文件指针数组，存储文件描述符到文件表条目的映射。</li>
<li><strong>全局文件表</strong>：文件表是内核中的全局结构，所有进程共享一个文件表。文件表中的每个条目存储了文件的状态和位置信息。</li>
</ul>
<p>示例</p>
<p>假设有两个进程A和B，同时打开了同一个文件。文件表和文件指针数组可能如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程A的文件指针数组:</span><br><span class="line">[0] -&gt; stdin</span><br><span class="line">[1] -&gt; stdout</span><br><span class="line">[2] -&gt; stderr</span><br><span class="line">[3] -&gt; file_table[5]</span><br><span class="line"></span><br><span class="line">进程B的文件指针数组:</span><br><span class="line">[0] -&gt; stdin</span><br><span class="line">[1] -&gt; stdout</span><br><span class="line">[2] -&gt; stderr</span><br><span class="line">[3] -&gt; file_table[5]</span><br><span class="line"></span><br><span class="line">全局文件表(file_table):</span><br><span class="line">[0] - 空闲</span><br><span class="line">[1] - 空闲</span><br><span class="line">...</span><br><span class="line">[5] -&gt; &#123;</span><br><span class="line">    f_flags: O_RDWR,  // 读写标志</span><br><span class="line">    f_count: 2,      // 引用计数为2，因为两个进程都打开了这个文件</span><br><span class="line">    f_inode: 指向i节点,</span><br><span class="line">    f_pos: 0         // 文件位置</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">[63] - 空闲</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>open()</code> 函数在进程A和B中分别返回了 <code>3</code>，指向了文件表中的同一个条目（<code>file_table[5]</code>），并且引用计数为 <code>2</code>。</p>
<h2 id="字符设备与块设备">字符设备与块设备</h2>
<p>控制设备的<strong>内核模块</strong>被成为<strong>设备驱动程序</strong>，一个设备驱动程序控制一类设备</p>
<p>e.g.: 一个磁盘驱动程序控制所有的磁盘设备</p>
<p>部分驱动程序控制的是<strong>软设备</strong>，软设备不存在对应的物理设备</p>
<p>在 Linux 系统中，硬件设备被抽象为文件，称为设备文件。这些文件通常位于 /dev 目录下，用户可以通过文件操作函数来访问硬件设备</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714193850691.png" class="" title="image-20240714193850691">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714194037398.png" class="" title="image-20240714194037398">
<h3 id="字符设备">字符设备</h3>
<p>字符设备是一种以字节流的方式进行数据传输的设备，它每次只传输一个字节的数据，并且数据传输没有缓存</p>
<ul>
<li>键盘、鼠标：每次按键或移动鼠标都会产生一个字符流。</li>
<li>串口、并口：数据以字节流的形式进行传输。</li>
<li>终端设备 (tty, Teletypewriter)：用于与用户交互，每次输入或输出一个字符。</li>
</ul>
<h4 id="TTY">TTY</h4>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714194408562.png" class="" title="image-20240714194408562">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714194437093.png" class="" title="image-20240714194437093">
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240714194601289.png" class="" title="image-20240714194601289">
<blockquote>
<p>键盘按键如何到达进程的</p>
<p><strong>1. 硬件中断：</strong></p>
<ul>
<li>当按下或释放键盘上的一个键时，键盘控制器（Keyboard Controller）会生成一个硬件中断信号，发送给中断控制器（Interrupt Controller）。</li>
<li>中断控制器会根据中断优先级和其他因素，决定是否将该中断信号传递给 CPU。</li>
</ul>
<p><strong>2. 中断处理程序：</strong></p>
<ul>
<li>
<p>终端驱动程序（Terminal Driver）会注册一个中断处理程序，专门处理来自键盘的中断。</p>
</li>
<li>
<p>如果 CPU 接受了中断请求，它会暂停当前正在执行的任务，转而执行键盘中断处理程序（Interrupt Handler）。当键盘中断发生时，终端驱动的中断处理程序会被调用，它会将扫描码转换为 ASCII 码或 Unicode 码等字符编码。</p>
</li>
<li>
<p>中断处理程序会读取键盘控制器中的数据，获取按键的扫描码（Scan Code），它代表了按下或释放的具体键位。终端驱动程序会将转换后的字符存储在一个缓冲区（Buffer）中，等待用户程序读取。</p>
</li>
</ul>
<p><strong>3. 用户程序：</strong></p>
<ul>
<li>当用户程序（例如 shell 或文本编辑器）需要获取键盘输入时，它会调用系统调用（System Call）读取终端设备文件（例如 /dev/tty）。</li>
<li>终端驱动程序会将缓冲区中的字符返回给用户程序，用户程序就可以根据这些字符执行相应的操作了。</li>
</ul>
</blockquote>
<h3 id="块设备">块设备</h3>
<p>块设备是一种以数据块为单位进行数据传输的设备，它可以随机访问数据块，并且数据传输通常有缓存</p>
<ul>
<li>硬盘、SSD：数据以块的形式存储和读取。</li>
<li>USB 存储设备：例如 U 盘、移动硬盘等。</li>
<li>CD/DVD 光驱：数据以扇区 (sector) 为单位存储，每个扇区通常为 512 字节。</li>
</ul>
<h2 id="kernel程序">kernel程序</h2>
<h3 id="VX6-kernel程序内容">VX6 kernel程序内容</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kinit：设置好页表分配器（page allocator）</span><br><span class="line"></span><br><span class="line">kvminit：为kernel分配页表，将低地址设备映射到kernel地址空间（即在kernel页表中写入PTE指向设备）</span><br><span class="line"></span><br><span class="line">kvminithart：页表开始生效，程序计数器将会通过MMU翻译为物理地址</span><br><span class="line"></span><br><span class="line">processinit：设置好初始进程或者说设置好进程表单</span><br><span class="line"></span><br><span class="line">trapinit/trapinithart：设置好user/kernel mode转换代码</span><br><span class="line"></span><br><span class="line">plicinit/plicinithart：设置好中断控制器PLIC（Platform Level Interrupt Controller），我们后面在介绍中断的时候会详细的介绍这部分，这是我们用来与磁盘和console交互方式</span><br><span class="line"></span><br><span class="line">binit：分配buffer cache</span><br><span class="line"></span><br><span class="line">iinit：初始化inode缓存</span><br><span class="line"></span><br><span class="line">fileinit：初始化文件系统</span><br><span class="line"></span><br><span class="line">virtio_disk_init：初始化磁盘</span><br><span class="line"></span><br><span class="line">userinit：最后当所有的设置都完成了，操作系统也运行起来了，会通过userinit运行第一个进程</span><br></pre></td></tr></table></figure>
<h3 id="tiny-os-kernel程序内容">tiny-os kernel程序内容</h3>
<p>loader程序与kernel程序对比</p>
<p>loader为纯二进制程序 ，仅包含机器码，根据机器码内容装载至内存后直接开始运行；</p>
<p>kernel为elf文件，存在文件头，节等内容，在进行segment展开后成为可运行的机器码</p>
<img src="/2024/04/12/Op-sys-Learning-Record/image-20240421144651548.png" class="" title="image-20240421144651548">
<p>kernel代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//interrupt.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_init</span><span class="params">()</span> &#123;</span><br><span class="line">    idt_desc_init(); <span class="comment">//创建门描述符，写入属性和一阶中断程序入口地址，填入idt</span></span><br><span class="line">    exception_handler_init();</span><br><span class="line">    <span class="comment">//异常处理函数初始化，创建中断处理函数，使一阶中断程序有可用调用的函数</span></span><br><span class="line">    pic_init(); <span class="comment">//初始化主片8259A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将idt地址写入idtr</span></span><br><span class="line">    <span class="type">uint64_t</span> idt_operand = ((<span class="keyword">sizeof</span>(idt) - <span class="number">1</span>) | ((<span class="type">uint64_t</span>) ((<span class="type">uint32_t</span>) idt &lt;&lt; <span class="number">16</span>)));</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;lidt %0&quot;</span> : : <span class="string">&quot;m&quot;</span> (idt_operand))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//timer.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">()</span> &#123;</span><br><span class="line">    frequency_set(COUNTER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);<span class="comment">//设置8253发中断的周期</span></span><br><span class="line">    register_handler(<span class="number">0x20</span>, intr_timer_handler);</span><br><span class="line">    <span class="comment">//触发0x20中断时调用intr_timer_handler函数，用于进行调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//memory.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> total_memory = (*(<span class="type">uint32_t</span>*) (<span class="number">0xb00</span>));</span><br><span class="line">    mem_pool_init(total_memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_all</span><span class="params">()</span> &#123;</span><br><span class="line">    idt_init();</span><br><span class="line">    timer_init</span><br><span class="line">    <span class="title function_">mem_init</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_args)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//此为内核拉起的内核线程，故申请内核页作为PCB</span></span><br><span class="line"></span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    <span class="comment">//将申请到的内核页清空并写入PCB中的属性</span></span><br><span class="line">    </span><br><span class="line">    thread_create(thread, function, func_args);</span><br><span class="line">    <span class="comment">//初始化PCB中的栈，创建中断栈和线程栈，压入线程需要执行的函数的相关数据和寄存器初始值</span></span><br><span class="line"></span><br><span class="line">    ASSERT(!list_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    <span class="comment">//将线程加入就绪队列，general_tag为就绪队列/运行队列/阻塞队列等使用</span></span><br><span class="line"></span><br><span class="line">    ASSERT(!list_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    <span class="comment">//将线程加入系统线程队列，all_list_tag为系统线程队列使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret&quot;</span> : : <span class="string">&quot;g&quot;</span> (thread-&gt;self_kstack) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//将压栈的寄存器初始值弹栈，ret将线程需要执行的函数的相关数据弹栈并前往执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    init_all();</span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_1&quot;</span>, <span class="number">31</span>, k_thread_function, <span class="string">&quot;skywalker &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Operation System</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2025/01/17/Java/</url>
    <content><![CDATA[<p>Java&amp;related</p>
<span id="more"></span>
<h1>Java</h1>
<h2 id="关键字">关键字</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问修饰符] [非访问修饰符] 数据类型 变量名 [= 初始值];</span><br><span class="line"></span><br><span class="line">[访问修饰符] [非访问修饰符] 返回值类型 方法名(参数列表) [<span class="keyword">throws</span> 异常列表] &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问修饰符 (可选):</strong></p>
<ul>
<li>public：任何地方都可以访问。</li>
<li>protected：同一个包内和子类可以访问。</li>
<li>private：只有同一个类内可以访问。</li>
<li>默认 (不写)：同一个包内可以访问。</li>
</ul>
<p><strong>非访问修饰符 (可选):</strong></p>
<ul>
<li>static：静态变量，属于类本身。</li>
<li>final：常量，值一旦初始化后不可改变。</li>
<li>transient：当一个对象被序列化的时候，transient型变量的值不包括在序列化的结果中。</li>
<li>volatile：保证多线程环境下变量的可见性。</li>
<li>native：</li>
</ul>
<p><strong>abstract</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  <span class="comment">// 与C++的含虚函数的类一样，Java抽象类不能直接实例化</span></span><br><span class="line">    <span class="comment">// 实例变量，有默认值</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类变量，有默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CATEGORY</span> <span class="operator">=</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非默认构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法  含抽象方法的类就一定不能实例化</span></span><br><span class="line">    <span class="comment">// 同时，Abstract method in non-abstract class 是不被允许的，即抽象方法一定得在抽象类中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age); <span class="comment">// 调用父类的非默认构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> superDog <span class="keyword">extends</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">xxx</span>;  <span class="comment">// 可以</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>相对于直接继承普通类，继承抽象类的优点在于？</p>
<p>1.对于没有抽象方法的抽象类，继承普通类有一样的效果</p>
<p>2.对于通过继承抽象类实现的多态，继承普通类进行override有一样的效果</p>
<p><strong>抽象类的真正优势在于强制子类实现某些抽象父类方法，以及通过抽象方法定义一种契约或规范。</strong></p>
</blockquote>
<p><strong>static</strong></p>
<ul>
<li>
<p><strong>类静态变量</strong>：</p>
</li>
<li>
<p><strong>类静态方法</strong>：</p>
</li>
<li>
<p><strong>静态代码块</strong>：静态代码块在类加载时执行，仅执行一次，多用于初始化静态变量，加载配置文件，初始化资源</p>
</li>
<li>
<p><strong>静态类</strong>：</p>
<ul>
<li>
<p><strong>声明位置:</strong> 静态类只能在另一个类的内部进行声明，使用 static 关键字修饰。</p>
</li>
<li>
<p><strong>与外部类的关系:</strong></p>
<ul>
<li>静态类不持有对其外部类实例的引用。</li>
<li><strong>静态类的实例化不需要依赖外部类的实例，可以直接通过 OuterClass.StaticNestedClass 的方式创建。</strong></li>
</ul>
</li>
<li>
<p><strong>静态内部类可以有非静态的变量和方法</strong>：静态内部类本质上是一个独立的类，它可以拥有实例变量和实例方法。要访问这些实例变量和方法，必须创建静态内部类的对象。</p>
<p><strong>静态内部类可以有静态的变量和方法</strong>：由于静态内部类是静态的，它可以直接包含静态变量和静态方法。这些静态成员属于静态内部类本身，而不属于其外部类的实例。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>内部类</strong></p>
<p><strong>内部类中不能使用静态的变量和静态的方法！</strong>！！</p>
<p>内部类的实例化是由外部类实例化之后才加载的，如果外部类还没有实例化，这时候调用内部类的静态成员，此时内部类还没有被加载，却要开始创建静态成员,显示是不合理的,</p>
<p><strong>接口可继承接口</strong></p>
</blockquote>
<p><strong>实例初始化块与构造函数</strong></p>
<ul>
<li><strong>实例初始化块</strong>：<br>
在每次创建对象时执行，且在<strong>构造函数之前</strong>执行。无论调用哪个构造函数，实例初始化块都会执行。</li>
<li><strong>构造函数</strong>：<br>
在创建对象时执行，具体执行哪个构造函数取决于<code>new</code>关键字后面调用的构造函数。</li>
</ul>
<p><strong>常见的变量名前缀：</strong></p>
<ul>
<li><strong>m：</strong> 表示 <strong>成员变量</strong> (member variable)，即类级别的变量，区别于局部变量。例如：private int mCount;</li>
<li><strong>s：</strong> 表示 <strong>静态变量</strong> (static variable)，即属于类本身的变量，所有实例共享。例如：public static String sTag = “MyClass”;</li>
<li><strong>p：</strong> 表示 <strong>参数</strong> (parameter)，即方法或构造函数的输入参数。例如：public void setName(String pName) { … }</li>
<li><strong>g：</strong> 表示 <strong>全局变量</strong> (global variable)，一般用于 C/C++ 代码中。</li>
<li><strong>i：</strong> 表示 <strong>接口</strong> (interface) 或 <strong>抽象类</strong> (abstract class) 的实现类。例如，ActivityManagerProxy 实现了 IActivityManager 接口。</li>
<li><strong>l：</strong> 表示 <strong>局部变量</strong> (local variable)，即方法或代码块内部定义的变量。</li>
<li><strong>this：</strong> 表示当前对象的引用。</li>
</ul>
<p><strong>其他约定：</strong></p>
<ul>
<li><strong>常量 (Constant)：</strong> 通常使用全部大写字母，单词之间用下划线分隔。例如：public static final int MAX_COUNT = 100;</li>
<li><strong>布尔类型 (boolean)：</strong> 通常以 is 或 has 开头，例如：private boolean isRunning; 或 public boolean hasPermission();</li>
</ul>
<h2 id="String">String</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="comment">// String 类被 final 关键字修饰，所以它不会有子类，这就意味着没有子类可以重写它的方法，改变它的行为。</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value; <span class="comment">// String 类的数据存储在 char[] 数组中，而这个数组也被 final 关键字修饰了，这就表示 String 对象是没法被修改的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字符串常量池与字符串对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>; <span class="comment">// s 指向字符串常量池中的 &quot;apple&quot; 的地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;banana&quot;</span>); <span class="comment">// s1 指向堆内存中的 String 对象，而堆对象内部的字符内容引用字符串常量池中的 &quot;banana&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern(); </span><br><span class="line"><span class="comment">// intern() 方法：检查字符串常量池中是否已存在与 s1 字符内容相同的字符串：</span></span><br><span class="line"><span class="comment">// 如果存在，返回该字符串的引用地址（指向字符串常量池中的地址）。</span></span><br><span class="line"><span class="comment">// 如果不存在，将 s1 的字符内容添加到字符串常量池，并返回该地址。</span></span><br></pre></td></tr></table></figure>
<p><strong><code>StringBuilder</code> 对象</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>会在堆内存中分配一个 <code>StringBuilder</code> 对象。</li>
<li>该对象内部维护一个初始容量的 <code>char[] value</code> 数组，并将 <code>&quot;hello&quot;</code> 的字符内容存储到这个数组中，字符串 <code>&quot;hello&quot;</code> 会按照字符一个一个地存储到数组中。</li>
<li>由于<code>StringBuilder</code>内部通过  <code>char[] value</code>  数组逐个字符的保存原始字符串，<code>StringBuilder</code> 不会把内容存储到字符串常量池中。</li>
</ul>
<p><strong>追加字符串</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sb.append(<span class="string">&quot; world&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>append()</code> 方法会直接在内部的 <code>char[] value</code> 数组上修改，效率较高。</li>
<li>如果追加后的内容超出了当前数组容量，<code>StringBuilder</code> 会分配一个更大的数组（通常是旧容量的两倍），并将原来的内容拷贝到新数组中。</li>
</ul>
<h2 id="枚举">枚举</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点</p>
<ul>
<li><code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。</li>
<li>不可能引用到非枚举的值，因为无法通过编译。</li>
<li>不同类型的枚举不能互相比较或者赋值</li>
</ul>
<p>类型比较，要使用<code>equals()</code>方法，如果使用<code>==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。</p>
<p><code>enum</code>类型的<strong>每个枚举值</strong>在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较</p>
<p><strong><code>enum</code>定义的类型就是<code>class</code>, 每个枚举值均为该枚举类型的实例！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">    <span class="comment">// 枚举值后接括号 相当于 使用了枚举类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;  <span class="comment">// 可以非final，不推荐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue, String chinese)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="built_in">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  <span class="comment">// 覆写toString</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>name()</p>
<p>返回常量名，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Weekday.SUN.name(); <span class="comment">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。</p>
</blockquote>
<p>ordinal()</p>
<p>返回定义的常量的顺序，从0开始计数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="数组，字符串，容器diff">数组，字符串，容器diff</h2>
<p><strong>长度</strong></p>
<p><strong>数组</strong>是 Java 中的基本数据结构，使用 <code>length</code> 属性。</p>
<p><strong>字符串</strong>是 <code>String</code> 类的对象，使用 <code>length()</code> 方法。</p>
<p><strong>容器</strong>（如 <code>List</code>、<code>Set</code>、<code>Map</code> 等）是集合框架的一部分，使用 <code>size()</code> 方法。</p>
<p><strong>排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序基本类型数组</span></span><br><span class="line"><span class="type">int</span>[] intArray = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Arrays.sort(intArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序对象数组</span></span><br><span class="line">String[] strArray = &#123;<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(strArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Collections.sort() 排序</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 List.sort() 排序</span></span><br><span class="line">List.sort()</span><br><span class="line">list.sort((a, b) -&gt; a.compareTo(b)); <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">9</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 使用 Collections.sort() 和 Comparator 排序</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;ListNode&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(ListNode o1, ListNode o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.val - o2.val; <span class="comment">// 按 val 升序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用 List.sort() 和 Lambda 表达式排序</span></span><br><span class="line">list.sort((o1, o2) -&gt; o1.val - o2.val); <span class="comment">// 按 val 升序排序</span></span><br></pre></td></tr></table></figure>
<h2 id="常用容器与初始化">常用容器与初始化</h2>
<blockquote>
<p>第一项表示 数据结构 数组/链表/树</p>
<p>第二项表示 逻辑结构 有序序列/集合/队列/数据对</p>
</blockquote>
<img src="/2025/01/17/Java/gailan-01.png" class="" title="volum">
<p><code>HashMap</code>: Node&lt;K,V&gt;[] table + Node链表/TreeNode红黑树</p>
<blockquote>
<p>class Node&lt;K, V&gt; 存在属性 next，next用于指向链表中下一节点</p>
</blockquote>
<p><code>LinkedHashMap</code>: Node&lt;K,V&gt;[] table + Node链表/TreeNode红黑树</p>
<blockquote>
<p>Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt;存在属性before和after，会向table中装入Entry&lt;K,V&gt;类型节点，装入时修改before after以记录写入顺序</p>
</blockquote>
<p><code>TreeMap</code>: Entry&lt;K, V&gt;节点的红黑树</p>
<blockquote>
<p>所有的map均含有</p>
<p><strong>entrySet:</strong> 该集合包含了 Map 对象中所有的键值对 (key-value pairs)，每个键值对都被封装成一个 Map.Entry 对象</p>
<p><strong>keySet():</strong> 返回一个包含了 Map 中所有 key 的 Set 集合。</p>
<p><strong>values():</strong> 返回一个包含了 Map 中所有 value 的 Collection 集合。</p>
</blockquote>
<p><code>ArrayList</code>: 自扩容数组</p>
<p><code>LinkedList</code>: 双向链表</p>
<blockquote>
<p>List -&gt; 有序, 通过索引访问对象</p>
</blockquote>
<p><code>PriorityQue</code>: 小顶堆数组</p>
<p><code>ArrayDeque</code>: 双端队列数组</p>
<blockquote>
<p>que -&gt; 队列</p>
</blockquote>
<p><code>HashSet</code>: 通过HashMap实现</p>
<p><code>LinkedHashSet</code>:</p>
<p><code>TreeSet</code>: 红黑树，无法重复元素插入</p>
<p>数组不可用迭代器，<code>Collection</code> 类型的对象可用（如 <code>List</code>）</p>
<p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组初始化不存在new xxx()的用法</span></span><br><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// new 关键字初始化</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器初始化通过new实现，不存在new xxx&lt;&gt;&#123;&#125;这样的用法</span></span><br><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line"><span class="type">int</span>[][] arr = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// new 关键字初始化</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>]; <span class="comment">// 初始化3x3的二维数组</span></span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.asList</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// List.of Java 9+</span></span><br><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// new 关键字初始化</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// Arrays.asList 返回的是一个固定大小的列表（基于数组），不能添加或删除元素，但可以修改元素：</span></span><br><span class="line"><span class="comment">// List.of 返回的是一个完全不可变的 List</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">list.set(<span class="number">0</span>, <span class="string">&quot;grape&quot;</span>); <span class="comment">// 可以修改</span></span><br><span class="line">list.add(<span class="string">&quot;pear&quot;</span>);     <span class="comment">// 抛出 UnsupportedOperationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 Arrays.asList 创建可变 List</span></span><br><span class="line">List&lt;String&gt; mutableList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">mutableList1.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// 可以添加元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;mutableList1: &quot;</span> + mutableList1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 List.of 创建可变 List</span></span><br><span class="line">List&lt;String&gt; mutableList2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">mutableList2.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// 可以添加元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;mutableList2: &quot;</span> + mutableList2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Set.of、Map.of、List.of 初始化 Set, Map, List, 直接创建均为不可变对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用List初始化Set</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line"><span class="comment">// 使用List初始化Queue</span></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组长为length，容器长为size()</span></span><br><span class="line">arr.length;</span><br><span class="line">list.size();</span><br><span class="line">set.size();</span><br></pre></td></tr></table></figure>
<p><strong>排序</strong></p>
<p>在不指定Comparator的情况下，使用 <strong>自然排序</strong> (natural ordering)，即键的升序排列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">// 匿名内部类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line">(s1, s2) -&gt; Integer.compare(s1.length(), s2.length())</span><br></pre></td></tr></table></figure>
<p><strong>对比</strong></p>
<p>peek&amp;&amp;get</p>
<p>peek -&gt; element || NULL</p>
<p>get -&gt; element || throw an exception</p>
<p>poll&amp;&amp;remove</p>
<p>poll -&gt; element || NULL</p>
<p>remove -&gt; element || throw an exception</p>
<p>offer&amp;&amp;add</p>
<blockquote>
<p>default: at the tail of this deque</p>
</blockquote>
<p>offer -&gt; true || false</p>
<p>add -&gt; true || IllegalStateException</p>
<h2 id="this-static-class与内部类">this, static class与内部类</h2>
<blockquote>
<p>Java 的语言设计中，不支持在顶层声明一个静态类！！！</p>
</blockquote>
<p>优先级：方法参数 &gt; 当前类变量 &gt; 外部类变量</p>
<p>作用域：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>内部类</th>
<th>静态内部类</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问外部类实例变量</td>
<td>可以直接访问</td>
<td>不能直接访问</td>
</tr>
<tr>
<td>访问外部类静态变量</td>
<td>可以直接访问</td>
<td>可以直接访问</td>
</tr>
<tr>
<td>持有外部类实例引用</td>
<td>隐式持有</td>
<td>不持有</td>
</tr>
<tr>
<td>作用域关系</td>
<td>嵌套在外部类作用域内</td>
<td>嵌套在外部类作用域内</td>
</tr>
</tbody>
</table>
<p><code>this</code> refers to the current <strong>instance</strong> of the class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">StaticTest</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">test</span> <span class="operator">=</span> <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">StaticTest</span> <span class="operator">=</span> <span class="number">501231</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interMethod</span><span class="params">(<span class="type">int</span> <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Local variable: &quot;</span> + <span class="keyword">var</span>); <span class="comment">// 参数 instanceVar</span></span><br><span class="line">            System.out.println(<span class="string">&quot;InnerClass variable: &quot;</span> + <span class="built_in">this</span>.instanceVar); <span class="comment">// InnerClass实例的 instanceVar</span></span><br><span class="line">            System.out.println(<span class="string">&quot;priority test: &quot;</span> + instanceVar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ccc</span> <span class="operator">=</span> <span class="number">12315</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interMethod</span><span class="params">(<span class="type">int</span> instanceVar)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Parameter variable: &quot;</span> + instanceVar);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outter static variable: &quot;</span> + MyClass.staticVar);</span><br><span class="line">            System.out.println(<span class="string">&quot;Local variable: &quot;</span> + <span class="built_in">this</span>.instanceVar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">interStaticMethod</span><span class="params">(<span class="type">int</span> instanceVar)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Parameter variable: &quot;</span> + instanceVar);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outter static variable1: &quot;</span> + MyClass.staticVar);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outter static variable2: &quot;</span> + StaticTest);</span><br><span class="line">            System.out.println(<span class="string">&quot;Local static variable: &quot;</span> + staticVar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">(<span class="type">int</span> instanceVar)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Local variable: &quot;</span> + instanceVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;Parameter: &quot;</span> + <span class="built_in">this</span>.instanceVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance variable without this &quot;</span> + test);</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance variable: &quot;</span> + <span class="built_in">this</span>.instanceVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;Static variable (discouraged): &quot;</span> + <span class="built_in">this</span>.staticVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;Static variable (preferred): &quot;</span> + MyClass.staticVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;InnnerClass static variable: &quot;</span> + InnerClass.staticVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;InnnerStaticClass static variable: &quot;</span> + StaticInnerClass.staticVar);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;InnnerClass static variable without classname: &quot; + ccc);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="comment">//        MyClass.InnerClass interObj = new MyClass.InnerClass(); // 错误：非（静态内部类）的实例化必须依赖于实例了的外部类</span></span><br><span class="line">        MyClass.<span class="type">InnerClass</span> <span class="variable">interObj</span> <span class="operator">=</span> obj.<span class="keyword">new</span> <span class="title class_">InnerClass</span>(); <span class="comment">// 正确</span></span><br><span class="line">        interObj.interMethod(<span class="number">40</span>);</span><br><span class="line">        MyClass.StaticInnerClass.interStaticMethod(<span class="number">123</span>);</span><br><span class="line">        MyClass.<span class="type">StaticInnerClass</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>.StaticInnerClass();</span><br><span class="line">        staticObj.interMethod(<span class="number">40</span>);</span><br><span class="line">        obj.myMethod(<span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包">包</h2>
<p>对于<code>com.example.project</code></p>
<p>其中， <code>com</code> 是顶层包, <code>example</code> 是 <code>com</code> 包的子包, <code>project</code> 是 <code>com.example</code> 包的子包。</p>
<p>在文件系统中，存在以下的层次结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com/</span><br><span class="line">    example/</span><br><span class="line">        project/</span><br><span class="line">            MyClass.java </span><br></pre></td></tr></table></figure>
<p>如果项目根目录是 MyProject，那么 <code>com.example.project.MyClass</code> 类文件应该位于 <code>MyProject/src/main/java/com/example/project/MyClass.java</code></p>
<h2 id="Throw">Throw</h2>
<p><strong>Throw</strong></p>
<p>Throw 用于抛出<strong>一个</strong>异常</p>
<p><strong>Throws</strong></p>
<p>方法中抛出 <strong>受检异常</strong> ，必须在方法签名处使用 Throws 声明会抛出的受检异常；</p>
<p>非受检异常无需在方法签名处声明 Throws</p>
<blockquote>
<p>受检异常是 <code>Exception</code> 类的子类（但不包括 <code>RuntimeException</code> 及其子类）。这些异常通常表示程序可以预期并处理的错误情况，例如文件不存在、网络连接中断等。</p>
<p>非受检异常是 <code>RuntimeException</code> 及其子类。这些异常通常表示程序中的逻辑错误，例如空指针、数组越界等。</p>
</blockquote>
<p><strong>多层嵌套异常抛出</strong></p>
<p>如果一个方法调用了另一个可能抛出<strong>受检异常（Checked Exception）<strong>的方法（即被调用的方法签名中使用了 <code>throws</code> 声明），那么调用方方法</strong>必须</strong>做以下两件事之一：</p>
<ol>
<li><strong>使用 <code>try-catch</code> 捕获并处理异常</strong>，或者</li>
<li><strong>在自己的方法签名中使用 <code>throws</code> 声明该异常</strong>，将异常继续向上抛出。</li>
</ol>
<p><strong>Try-Catch-Finally</strong></p>
<p>执行逻辑</p>
<p>Try块顺序执行，直到遇到Exception</p>
<p>即 1.若没有抛出Exception，则Try块将顺序执行完成</p>
<p>​	 2.若抛出Exception，Try块执行将到抛出Exception的位置截至</p>
<p>Catch块仅在Try块抛出Exception时执行</p>
<p>Finally块 <strong>不论 Try块/Catch块 的执行情况，一定会得到执行</strong></p>
<p>即 即使在Try块/Catch块中存在return，Finally块一定会得到执行，且在Finally块执行完成后进行return；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Try block - start&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>; <span class="comment">// 抛出 ArithmeticException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Try block - end&quot;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Catch block: &quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 在Finally块执行结束后返回</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finally block - always executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;After try-catch-finally&quot;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有在Catch块中抛出Exception，程序会中断当前执行流程</p>
</blockquote>
<h2 id="泛型与通配符">泛型与通配符</h2>
<p><code>MyClass&lt;T&gt;</code> 泛型类，<strong>泛型类的核心就在于其内部可以使用泛型类型参数</strong></p>
<p><code>public static &lt;T&gt; void myMethod()</code> 泛型方法，<strong>泛型方法在于方法的参数和方法体内部的逻辑可以使用泛型类型参数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IResponse</span>&lt;T&gt; &#123; <span class="comment">//使用泛型</span></span><br><span class="line">	</span><br><span class="line">	T <span class="title function_">getData</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringResponse</span> <span class="keyword">implements</span> <span class="title class_">IResponse</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(String t)</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Response</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">IResponse</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Response</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BaseData</span>&gt; <span class="keyword">implements</span> <span class="title class_">IResponse</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getToken</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(data!=<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> data.getToken();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"></span><br><span class="line">Person person;	</span><br><span class="line">person = student; <span class="comment">// 多态</span></span><br><span class="line">person = teacher; <span class="comment">// 多态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123; <span class="comment">//通配符</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 该方法可以接收任何类型的List,例如 List&lt;String&gt;、List&lt;Integer&gt; 等</span></span><br><span class="line"></span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; personList; <span class="comment">//只接收Person或Person子类</span></span><br><span class="line">List&lt;? <span class="built_in">super</span> Student&gt; personList <span class="comment">//只接收Student或Student父类</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>泛型擦除</strong>：编译器在对源代码进行编译的时候将泛型换成了泛型指定的上限类&lt;T extends 上限类型&gt;，如果没有指定泛型的上限，编译器则会使用Object类替代。简单的说在编译完成后的字节码文件中其实是没有泛型的概念的，源代码中的泛型被编译器用Object或者泛型指定的类给替换掉了。</p>
<p><strong>将所有泛型类型参数替换为其上限类型 (Upper Bound)。</strong></p>
<ul>
<li>例如，List&lt;String&gt; 会被替换为 List&lt;Object&gt;，因为 Object 是 String 的上限类型。</li>
<li>如果没有指定上限类型，则默认使用 Object 作为上限类型。</li>
</ul>
<p><strong>插入类型转换代码，以保证类型安全。</strong></p>
<ul>
<li>例如，从 List&lt;Object&gt; 中获取元素时，编译器会插入 (String) 强制类型转换代码，以确保获取到的元素是 String 类型。</li>
</ul>
<p><strong>作用</strong>：声明了一个泛型为String的List集合，并向集合中添加了一个字符串“abc”，接着通过反射向集合list中添加了一个整数类型123，通过输出结果可以看到两个值都被添加到了集合中</p>
</blockquote>
<p><code>Class&lt;T&gt;</code> 中的 <code>T</code> <strong>并非 Class 类本身的泛型参数</strong>，而是表示这个 Class 对象所代表的类型的泛型参数。 Class 类本身不是泛型类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用泛型方法创建类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">createInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> createInstance(String.class);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> createInstance(Integer.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用泛型方法创建类，需要使用类型转换，并且失去编译时的类型安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">createInstance</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) createInstance(String.class); <span class="comment">// 需要强制类型转换</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> (Integer) createInstance(Integer.class); <span class="comment">// 需要强制类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 潜在的运行时错误：</span></span><br><span class="line">    Class&lt;?&gt; unknownClass = Class.forName(<span class="string">&quot;java.lang.Double&quot;</span>); <span class="comment">//假设不知道具体的类型</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">wrongType</span> <span class="operator">=</span> (Integer) createInstance(unknownClass); <span class="comment">// 运行时会抛出 ClassCastException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h2 id="Equal与HashCode">Equal与HashCode</h2>
<p><strong>核心思想</strong></p>
<p>在 Java 中，<code>equals()</code> 和 <code>hashCode()</code> 是定义’'在 <code>java.lang.Object</code> 类中的两个基本方法。它们共同协作，主要用于<strong>判断对象的等价性</strong>，尤其是在使用哈希集合（如 <code>HashSet</code>, <code>HashMap</code>）时。</p>
<ol>
<li><code>equals(Object obj)</code>: 用于判断两个对象在<strong>逻辑上</strong>是否相等。</li>
<li><code>hashCode()</code>: 返回一个对象的哈希码（一个 <code>int</code> 值），主要用于在哈希表中快速定位对象。</li>
</ol>
<p>它们之间有一条至关重要的<strong>契约（Contract）</strong>，必须严格遵守。</p>
<hr>
<p>一、<code>equals()</code> 方法详解</p>
<ol>
<li>默认行为</li>
</ol>
<p>如果你不重写 <code>equals()</code> 方法，它会继承自 <code>Object</code> 类。<code>Object</code> 类的 <code>equals()</code> 默认实现是使用 <code>==</code> 操作符来比较两个对象的内存地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.java 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着，只有当两个引用指向<strong>同一个内存地址</strong>中的对象时，默认的 <code>equals()</code> 才会返回 <code>true</code>。这被称为<strong>引用相等性</strong>。</p>
<ol start="2">
<li>为何要重写 <code>equals()</code>？</li>
</ol>
<p>在实际开发中，我们通常关心的是对象的<strong>内容</strong>是否相等，即<strong>逻辑相等性</strong>。</p>
<p><strong>举个例子：</strong><br>
我们有一个 <code>Person</code> 类，如果两个 <code>Person</code> 对象的 <code>name</code> 和 <code>age</code> 都相同，我们就认为这两个对象是相等的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsExample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;p1 == p2 ? &quot;</span> + (p1 == p2));         <span class="comment">// 输出: false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;p1.equals(p2) ? &quot;</span> + p1.equals(p2)); <span class="comment">// 输出: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>p1</code> 和 <code>p2</code> 是两个独立的对象，它们在内存中有不同的地址。因此，<code>==</code> 和默认的 <code>equals()</code> 都返回 <code>false</code>。但这不符合我们的业务逻辑，我们希望它们是相等的。因此，我们需要重写 <code>equals()</code> 方法。</p>
<ol start="3">
<li>如何正确重写 <code>equals()</code>？</li>
</ol>
<p>重写 <code>equals()</code> 必须遵守以下五个原则（契约）：</p>
<ol>
<li><strong>自反性 (Reflexive):</strong> 对于任何非空引用 <code>x</code>，<code>x.equals(x)</code> 必须返回 <code>true</code>。</li>
<li><strong>对称性 (Symmetric):</strong> 对于任何非空引用 <code>x</code> 和 <code>y</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>，那么 <code>y.equals(x)</code> 也必须返回 <code>true</code>。</li>
<li><strong>传递性 (Transitive):</strong> 对于任何非空引用 <code>x</code>、<code>y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 为 <code>true</code> 且 <code>y.equals(z)</code> 为 <code>true</code>，那么 <code>x.equals(z)</code> 也必须为 <code>true</code>。</li>
<li><strong>一致性 (Consistent):</strong> 对于任何非空引用 <code>x</code> 和 <code>y</code>，只要比较对象的信息没有被修改，多次调用 <code>x.equals(y)</code> 应该始终返回相同的结果。</li>
<li><strong>非空性 (Non-null):</strong> 对于任何非空引用 <code>x</code>，<code>x.equals(null)</code> 必须返回 <code>false</code>。</li>
</ol>
<p><strong>一个标准的 <code>equals()</code> 实现模板：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Person 类中添加</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 检查是否为同一对象引用，提高效率</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查 obj 是否为 null，以及类型是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 obj 强制转换为正确的类型</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 比较所有关键字段是否相等</span></span><br><span class="line">    <span class="comment">// 基本类型用 == 比较</span></span><br><span class="line">    <span class="comment">// 对象类型用 Objects.equals() 比较（它能优雅地处理 null 情况）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age == other.age &amp;&amp;</span><br><span class="line">           java.util.Objects.equals(<span class="built_in">this</span>.name, other.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>二、<code>hashCode()</code> 方法详解</p>
<ol>
<li>什么是哈希码？</li>
</ol>
<p><code>hashCode()</code> 方法返回一个 <code>int</code> 类型的整数，这个整数被称为哈希码。哈希码的主要作用是为基于哈希的集合（如 <code>HashSet</code>, <code>HashMap</code>, <code>Hashtable</code>）提供支持。</p>
<p>当向这些集合中添加一个对象时，集合会先调用该对象的 <code>hashCode()</code> 方法得到一个哈希码，然后根据这个哈希码快速地定位到对象应该存放的**“桶（bucket）”**的位置。这大大提高了查找、添加和删除元素的效率。</p>
<ol start="2">
<li><code>equals()</code> 和 <code>hashCode()</code> 之间神圣的契约</li>
</ol>
<p>这是理解这两个方法的关键所在：</p>
<blockquote>
<p><strong>如果两个对象通过 <code>equals()</code> 方法比较是相等的，那么它们的 <code>hashCode()</code> 方法必须返回相同的值。</strong></p>
</blockquote>
<p><strong>反过来不一定成立：</strong></p>
<blockquote>
<p>如果两个对象的 <code>hashCode()</code> 返回值相同，它们通过 <code>equals()</code> 比较<strong>不一定</strong>相等（这种情况称为“哈希冲突”）。</p>
</blockquote>
<ol start="3">
<li>为什么必须遵守这个契约？</li>
</ol>
<p><strong>我们来看一个反面教材：只重写 <code>equals()</code>，不重写 <code>hashCode()</code>。</strong></p>
<p>我们使用上面已经重写了 <code>equals()</code> 的 <code>Person</code> 类，但暂时不重写 <code>hashCode()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashCodeExample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;p1.equals(p2) ? &quot;</span> + p1.equals(p2)); <span class="comment">// 输出: true (因为我们重写了 equals)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们期望 HashSet 中只能存放一个“张三”</span></span><br><span class="line">        Set&lt;Person&gt; personSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        personSet.add(p1);</span><br><span class="line">        personSet.add(p2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Set size: &quot;</span> + personSet.size()); <span class="comment">// 输出: 2 (！！！问题出现了)</span></span><br><span class="line">        System.out.println(personSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题分析：</strong><br>
为什么 <code>HashSet</code> 中包含了两个我们认为是“相等”的对象？</p>
<ol>
<li><code>personSet.add(p1)</code>：<code>HashSet</code> 计算 <code>p1</code> 的哈希码（此时使用的是 <code>Object</code> 类的默认实现，基于内存地址），找到一个桶放进去。</li>
<li><code>personSet.add(p2)</code>：<code>HashSet</code> 计算 <code>p2</code> 的哈希码（同样基于内存地址）。因为 <code>p1</code> 和 <code>p2</code> 是不同对象，它们的默认哈希码几乎肯定不同。</li>
<li><code>HashSet</code> 根据 <code>p2</code> 的哈希码找到了一个<strong>不同的桶</strong>。</li>
<li>由于 <code>p1</code> 和 <code>p2</code> 被放入了不同的桶，<code>HashSet</code> 甚至<strong>没有机会</strong>去调用 <code>equals()</code> 方法进行比较，它直接就认为 <code>p2</code> 是一个新元素，并将其添加进去。</li>
</ol>
<p><strong>结论：</strong> 违反了契约，导致哈希集合无法正常工作！</p>
<ol start="4">
<li>如何正确重写 <code>hashCode()</code>？</li>
</ol>
<p>重写 <code>hashCode()</code> 的原则是，让它的计算过程依赖于 <code>equals()</code> 方法中用到的那些字段。</p>
<p><strong>一个标准的 <code>hashCode()</code> 实现模板：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Person 类中添加</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 Objects.hash() 辅助方法，它简单、安全且能处理 null</span></span><br><span class="line">    <span class="keyword">return</span> java.util.Objects.hash(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现的传统方式（了解即可）：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Override</span></span><br><span class="line"><span class="comment">public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">    int result = 1;</span></span><br><span class="line"><span class="comment">    // 选择一个质数（通常是 31）</span></span><br><span class="line"><span class="comment">    int prime = 31;</span></span><br><span class="line"><span class="comment">    result = prime * result + age;</span></span><br><span class="line"><span class="comment">    result = prime * result + ((name == null) ? 0 : name.hashCode());</span></span><br><span class="line"><span class="comment">    return result;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>Objects.hash()</code> 是 JDK 7 引入的工具方法，它能帮你轻松、正确地生成哈希码，推荐使用。</p>
<hr>
<p>三、完整正确示例</p>
<p>下面是一个遵循了所有契约和最佳实践的 <code>Person</code> 类，以及演示其在 <code>HashMap</code> 中正确工作的 <code>main</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个正确实现了 equals() 和 hashCode() 的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 检查是否为同一个对象引用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 检查是否为 null，以及类型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 强制类型转换</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 比较关键字段</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 hashCode 方法</span></span><br><span class="line"><span class="comment">     * 必须保证 equals() 返回 true 的两个对象，其 hashCode() 返回值也必须相等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Objects.hash() 来根据 equals() 中使用的字段生成哈希码</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;p1.equals(p2): &quot;</span> + p1.equals(p2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;p1.equals(p3): &quot;</span> + p1.equals(p3)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;p1.hashCode(): &quot;</span> + p1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p2.hashCode(): &quot;</span> + p2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p3.hashCode(): &quot;</span> + p3.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p1 和 p2 的 hashCode 是否相等: &quot;</span> + (p1.hashCode() == p2.hashCode())); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 测试 HashSet ---&quot;</span>);</span><br><span class="line">        Set&lt;Person&gt; personSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        personSet.add(p1);</span><br><span class="line">        personSet.add(p2); <span class="comment">// p2 因为和 p1 equals，所以无法加入</span></span><br><span class="line">        personSet.add(p3);</span><br><span class="line">        System.out.println(<span class="string">&quot;Set size: &quot;</span> + personSet.size()); <span class="comment">// 输出: 2，正确！</span></span><br><span class="line">        System.out.println(personSet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 测试 HashMap ---&quot;</span>);</span><br><span class="line">        Map&lt;Person, String&gt; personMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        personMap.put(p1, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 我们用 p2 作为 key 去获取值，p2 和 p1 是逻辑相等的</span></span><br><span class="line">        <span class="comment">// HashMap 会计算 p2 的哈希码，找到 p1 所在的桶，</span></span><br><span class="line">        <span class="comment">// 然后用 equals() 比较，发现 p2.equals(p1) 为 true，</span></span><br><span class="line">        <span class="comment">// 于是成功找到了 p1 对应的值。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> personMap.get(p2); </span><br><span class="line">        System.out.println(<span class="string">&quot;用 p2 作为 key 获取到的城市是: &quot;</span> + city); <span class="comment">// 输出: 北京，正确！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结与最佳实践</p>
<ol>
<li><strong>要么都重写，要么都不重写。</strong> 如果你只重写了 <code>equals()</code> 而不重写 <code>hashCode()</code>，你的对象将无法在哈希集合中正常工作。</li>
<li><strong><code>equals()</code> 的实现</strong>：遵循五个原则，使用 <code>instanceof</code> 或 <code>getClass()</code> 检查类型，并使用 <code>Objects.equals()</code> 比较对象字段以避免空指针。</li>
<li><strong><code>hashCode()</code> 的实现</strong>：确保其计算仅依赖于 <code>equals()</code> 中使用的字段。最简单、最推荐的方式是使用 <code>Objects.hash(...)</code>。</li>
<li><strong>使用 IDE 自动生成</strong>：现代的 IDE（如 IntelliJ IDEA, Eclipse）都可以自动为你生成正确且高效的 <code>equals()</code> 和 <code>hashCode()</code> 方法，这是一个非常好的实践。</li>
<li><strong>不可变性</strong>：如果一个对象被用作 <code>HashMap</code> 的键或存入 <code>HashSet</code>，最好将其设计为不可变的。因为如果对象在存入集合后其内容（参与 <code>hashCode</code> 和 <code>equals</code> 计算的字段）发生了改变，会导致该对象在集合中“丢失”，无法被正确找到。</li>
</ol>
<br>
<h2 id="类加载">类加载</h2>
<h3 id="概念">概念</h3>
<ol>
<li>
<p><strong>加载 (Loading)</strong>：</p>
<ul>
<li>通过类的全限定名（例如 java.lang.String）查找并读取类的二进制数据（.class 文件）。</li>
<li>将类的静态结构信息（例如类名、方法名、字段名、访问权限等）<strong>存储在方法区中，并创建一个代表该类的 Class 对象，该Class对象内保存了指向方法区中这些结构信息的引用，该对象唯一。</strong></li>
<li>加载阶段通常由类加载器完成，Java 提供三种内置的类加载器：
<ul>
<li><strong>Bootstrap ClassLoader</strong>：负责加载 Java 核心类库（rt.jar 等）。</li>
<li><strong>Extension ClassLoader</strong>：负责加载 Java 扩展类库（jre/lib/ext 目录下的类）。</li>
<li><strong>Application ClassLoader</strong>：负责加载应用程序类路径（CLASSPATH）上的类。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>链接 (Linking)</strong>：</p>
<ul>
<li>
<p><strong>验证 (Verification)</strong>：确保加载的类文件符合 Java 虚拟机规范，防止恶意代码破坏 JVM。</p>
</li>
<li>
<p><strong>准备 (Preparation)</strong>：为类的静态变量分配内存空间，并设置默认初始值（例如，int 类型为 0）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;  <span class="comment">//为value分配内存, 且设置值为0</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="number">123</span>  <span class="comment">//为v2分配内存, 且设置值为123</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;  <span class="comment">//不会为str分配内存，该变量为实例变量，创建Test对象时分配内存；&quot;123&quot;为字面量，将放入全局字符串常量池保存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>解析 (Resolution)</strong>：将符号引用（例如类名、方法名）转换为直接引用（例如内存地址）。</p>
</li>
</ul>
</li>
<li>
<p><strong>初始化 (Initialization)（非必定发生）</strong>：</p>
<ul>
<li>执行类的静态初始化代码块（static {}）和静态变量的初始化语句。</li>
<li>初始化阶段类变量才会被赋予我们在代码中声明的值。JVM会根据语句执行顺序对类对象进行初始化。</li>
<li>只有在类被主动使用时才会进行初始化，例如：
<ul>
<li>创建类的实例。</li>
<li><strong>访问类的静态变量。</strong></li>
<li><strong>调用类的静态方法。</strong></li>
<li>反射调用 Test 类。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>初始化发生条件：</p>
<p>① 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</p>
<p>② 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</p>
<p>③ 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>④ 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>⑤ 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</p>
<p>⑥ 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        ++x;</span><br><span class="line">        ++y;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton构造方法执行，x = &quot;</span> + x +<span class="string">&quot;,y = &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton.x = &quot;</span> + singleton.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton.x = &quot;</span> + singleton.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行顺序和输出结果分析：</strong></p>
<ol>
<li>
<p><strong>类加载：</strong></p>
<ul>
<li>
<p>主类<code>Singleton</code>的加载：读取<code>Singleton.class</code>文件，获取类的结构信息，在方法区创建<code>Singleton</code>类的 Class 对象</p>
<blockquote>
<p>主类即存在main方法的类</p>
</blockquote>
</li>
<li>
<p>主类<code>Singleton</code>的链接：验证，准备和解析。准备阶段将为静态变量<code>singleton</code>, <code>x</code>, <code>y</code>分配内存空间，并设置默认值。其中，<code>singleton</code>：引用类型的默认值为 <code>null</code>。<code>x</code>：<code>int</code> 类型的默认值为 <code>0</code>。<code>y</code>： 虽然 <code>y</code> 被显式初始化为 <code>0</code>，但在准备阶段，只会赋予默认值，所以 <code>y</code> 也会被初始化为 <code>0</code>。</p>
<blockquote>
<p>这三个静态变量存放在方法区静态变量区中</p>
</blockquote>
</li>
<li>
<p>主类<code>Singleton</code>的初始化：</p>
<ul>
<li>静态变量 <code>singleton</code> 初始化：<code>private static Singleton singleton = new Singleton();</code>
<ul>
<li>这行代码会创建一个 <code>Singleton</code> 实例，进而调用 <code>Singleton</code> 的构造方法。</li>
</ul>
</li>
<li>构造方法执行：
<ul>
<li><code>++x;</code>  // 此时 x 还没有初始化，默认值为 0，所以 x 变为 1</li>
<li><code>++y;</code>  // y 已初始化为 0，所以 y 变为 1</li>
<li><code>System.out.println(&quot;Singleton构造方法执行，x = &quot; + x +&quot;,y = &quot; + y);</code></li>
<li>输出：<code>Singleton构造方法执行，x = 1,y = 1</code></li>
</ul>
</li>
<li>静态变量 <code>x</code> 和 <code>y</code> 初始化：
<ul>
<li><code>public static int x;</code>  // 无动作 (构造方法中已经修改)</li>
<li><code>public static int y = 0;</code> // y 被赋值为 0 (覆盖了构造方法中的修改)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>main 方法执行：</strong></p>
<ul>
<li><code>System.out.println(&quot;singleton.x = &quot; + singleton.x);</code>
<ul>
<li>输出：<code>singleton.x = 1</code></li>
</ul>
</li>
<li><code>System.out.println(&quot;singleton.x = &quot; + singleton.y);</code>
<ul>
<li>输出：<code>singleton.y = 0</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>最终输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Singleton构造方法执行，x = 1,y = 1</span><br><span class="line">singleton.x = 1</span><br><span class="line">singleton.y = 0</span><br></pre></td></tr></table></figure>
<h3 id="JVM类加载机制">JVM类加载机制</h3>
<p>类加载器</p>
<ul>
<li><strong>启动类加载器</strong>: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</li>
<li><strong>扩展类加载器</strong>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器</strong>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
<li><strong>自定义类加载器</strong>: 因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:
<ul>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。</li>
</ul>
</li>
</ul>
<p>类加载类型</p>
<ol>
<li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
<li><strong>双亲委派机制</strong>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li>
</ol>
<h3 id="双亲委派机制过程">双亲委派机制过程</h3>
<ol>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
<h2 id="反射">反射</h2>
<p>类的Class对象在<strong>类加载的加载部分</strong>时被创建，保存于<strong>堆</strong>。</p>
<p><strong>反射的核心 API</strong></p>
<p>Java 反射机制主要由 java.lang.reflect 包中的类和接口提供支持，其中最常用的类包括：</p>
<ul>
<li><strong>Class 类:</strong> 代表一个类的类型信息，可以通过 Class 对象获取类的所有信息。</li>
<li><strong>Field 类:</strong> 代表类的成员变量，可以通过 Field 对象获取和设置变量的值。</li>
<li><strong>Method 类:</strong> 代表类的方法，可以通过 Method 对象调用方法。</li>
<li><strong>Constructor 类:</strong> 代表类的构造函数，可以通过 Constructor 对象创建类的实例。</li>
</ul>
<p><strong>获取方式：</strong></p>
<ol>
<li><strong>通过类名获取:</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>通过对象获取:</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); </span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line"></span><br><span class="line">Class&lt;Person&gt; personClass=(Class&lt;Person&gt;)person.getClass();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>通过类字面量获取:</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;, Age: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造函数并创建实例</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取成员变量并设置值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        nameField.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有变量</span></span><br><span class="line">        nameField.set(obj, <span class="string">&quot;Jane Doe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法并调用</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">printInfoMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;printInfo&quot;</span>);</span><br><span class="line">        printInfoMethod.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>import 类将告知编译器该类的位置，<strong>不会触发类加载</strong></p>
<p><strong>对于一个 Test.java 文件：</strong></p>
<ul>
<li><strong>只有被主类（包含 main() 方法的类）直接或间接使用到的类才会被加载、链接(和初始化)。</strong> 主类将默认进行加载、链接和初始化。</li>
<li><strong>如果 Test.java 中的其他类没有被主类直接或间接使用，那么这些类</strong> <strong>不会被加载</strong> <strong>。</strong></li>
</ul>
<p>触发类加载的时候一般为：</p>
<ol>
<li>
<p><strong>创建 <code>Test</code> 类的实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">myTestObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(); </span><br></pre></td></tr></table></figure>
<p>当执行到 <code>new Test()</code> 时，JVM 发现 <code>Test</code> 类还没有被加载，就会启动类加载过程。</p>
<p>这种情况会一口气完成加载、链接和初始化三个过程。</p>
<p>因为创建实例需要用到类的所有信息，包括静态变量的初始值、实例变量的定义等，所以必须完成初始化。</p>
</li>
<li>
<p><strong>访问 <code>Test</code> 类的静态成员（变量或方法）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> Test.value; <span class="comment">// 访问静态变量</span></span><br><span class="line">Test.someStaticMethod(); <span class="comment">// 调用静态方法 (假设存在 someStaticMethod)</span></span><br></pre></td></tr></table></figure>
<p>访问 <code>Test.value</code> 或调用 <code>Test.someStaticMethod()</code> 时，需要用到 <code>Test</code> 类的信息，会触发类加载。</p>
<p><strong>如果访问的是静态常量（<code>final static</code>），则只会进行加载和链接，不会进行初始化。</strong></p>
<ul>
<li>因为静态常量在编译阶段就已经确定了值，并存储在类的常量池中，不需要等到初始化阶段。</li>
</ul>
<p><strong>如果访问的是静态变量，则会完成加载、链接和初始化三个过程。</strong></p>
<ul>
<li>因为静态变量的初始值可能需要在初始化阶段执行代码才能确定。</li>
</ul>
</li>
<li>
<p><strong>使用反射机制操作 <code>Test</code> 类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; testClass = Class.forName(<span class="string">&quot;com.example.Test&quot;</span>); <span class="comment">// 假设 Test 类在 com.example 包下</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>Class.forName()</code> 获取 <code>Test</code> 类的 <code>Class</code> 对象时，也会触发类加载。</p>
<p><strong>默认情况下，只会进行加载和链接，不会进行初始化。</strong></p>
<ul>
<li><code>Class.forName()</code> 方法可以指定是否进行初始化，默认是不进行初始化的。</li>
</ul>
<p><strong>如果调用 <code>Class.forName()</code> 方法时，第二个参数传入了 <code>true</code>，则会完成加载、链接和初始化三个过程。</strong></p>
<ul>
<li>例如：<code>Class.forName(&quot;com.example.Test&quot;, true, classLoader);</code></li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="注解与APT">注解与APT</h2>
<p>注解( @interface)是一种定义类型</p>
<p>@interface 是一个关键字，用于定义注解类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthRequired &#123;</span><br><span class="line">    String <span class="title function_">role</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;admin&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>元注解</strong></p>
<p>元注解是用于注解其他注解的注解，Java 提供了以下元注解：</p>
<ul>
<li><strong>@Retention:</strong> 指定注解的生命周期，可选值：
<ul>
<li><code>RetentionPolicy.SOURCE</code>：仅保留在源代码中，编译时会被丢弃。</li>
<li><code>RetentionPolicy.CLASS</code>：保留在字节码文件中，但运行时不可见。</li>
<li><code>RetentionPolicy.RUNTIME</code>：保留在字节码文件中，运行时可见，可以通过反射获取。</li>
</ul>
</li>
<li><strong>@Target:</strong> 指定注解可以应用于哪些元素，可选值：
<ul>
<li><code>ElementType.TYPE</code>：类、接口、枚举</li>
<li><code>ElementType.FIELD</code>：字段</li>
<li><code>ElementType.METHOD</code>：方法</li>
<li><code>ElementType.PARAMETER</code>：方法参数</li>
<li><code>ElementType.CONSTRUCTOR</code>：构造函数</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：局部变量</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：注解</li>
<li><code>ElementType.PACKAGE</code>：包</li>
</ul>
</li>
<li><strong>@Documented:</strong> 指定将注解包含在 Javadoc 文档中。</li>
<li><strong>@Inherited:</strong> 指定子类可以继承父类的注解。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@interface</span> AuthRequired &#123;</span><br><span class="line"> String <span class="title function_">role</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;admin&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"> <span class="meta">@AuthRequired(role = &quot;user&quot;)</span> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反射机制获取注解信息</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> MyService.class.getMethod(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (method.isAnnotationPresent(AuthRequired.class)) &#123;</span><br><span class="line"> <span class="type">AuthRequired</span> <span class="variable">auth</span> <span class="operator">=</span> method.getAnnotation(AuthRequired.class);</span><br><span class="line"> <span class="type">String</span> <span class="variable">requiredRole</span> <span class="operator">=</span> auth.role();  <span class="comment">// 拿到了doSomething方法的注解内容</span></span><br><span class="line"> <span class="comment">// ... 进行权限验证</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Factory &#123;</span><br><span class="line"></span><br><span class="line"> Class <span class="title function_">type</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> String <span class="title function_">id</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Factory(id = &quot;Rectangle&quot;, type = IShape.class)</span>  <span class="comment">// 为Rectangle类贴上了标签，说明其id和type</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Draw a Rectangle&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注解像标签：</strong> @AuthRequired 注解就像一个标签，贴在了 doSomething 函数上。</p>
<p><strong>属性像标签内容：</strong> role = “user” 就像标签上的文字，描述了这个注解的具体信息。</p>
<p><strong>元数据：</strong> 注解和它的属性值一起构成了元数据，这些元数据并不会改变 doSomething 函数本身的代码和行为，而是在程序运行时，可以通过反射机制读取这些元数据，从而实现一些额外的功能，例如权限验证。</p>
</blockquote>
<p><strong>Java APT (Annotation Processing Tool)</strong></p>
<p>Java APT（注解处理器）是 Java 编译器提供的一种机制，它允许开发者在编译期处理注解，生成额外的代码或进行其他操作。</p>
<p><strong>APT 的工作原理</strong></p>
<ol>
<li><strong>扫描注解:</strong> 在编译 Java 代码时，编译器会扫描源代码中的注解。</li>
<li><strong>调用注解处理器:</strong> 如果发现有注解处理器注册处理了某个注解，编译器会调用相应的注解处理器。</li>
<li><strong>处理注解:</strong> 注解处理器可以读取、分析和处理注解信息，并生成新的代码文件或资源文件。</li>
<li><strong>编译生成最终的 class 文件:</strong> 编译器将生成的代码或资源文件与源代码一起编译，生成最终的 class 文件。</li>
</ol>
<p><strong>创建注解处理器</strong></p>
<ol>
<li><strong>实现 javax.annotation.processing.Processor 接口:</strong> 注解处理器需要实现 Processor 接口，并实现其中的方法，例如 process() 方法。</li>
<li><strong>注册注解处理器:</strong> 在 META-INF/services/javax.annotation.processing.Processor 文件中声明注解处理器的全限定名，以便编译器可以找到它。</li>
</ol>
<p><strong>注解处理器 API</strong></p>
<p>javax.annotation.processing 包提供了一些 API，用于在注解处理器中访问和处理注解信息：</p>
<ul>
<li><strong>ProcessingEnvironment:</strong> 提供访问编译器环境的方法，例如获取 Elements、Types、Filer 等对象。</li>
<li><strong>Elements:</strong> 表示程序元素的接口，例如包、类、方法、字段等。</li>
<li><strong>Types:</strong> 提供类型相关的操作，例如获取类型的父类、接口等。</li>
<li><strong>Filer:</strong> 用于创建新的源文件或资源文件。</li>
</ul>
<h2 id="匿名内部类与Lambda表达式">匿名内部类与Lambda表达式</h2>
<ul>
<li><strong>Lambda 表达式没有自己的 this 指针。</strong> 在 Lambda 表达式内部，this 关键字仍然指向外部类实例。</li>
<li><strong>Lambda 表达式可以隐式地访问外部类的成员变量和方法。</strong></li>
</ul>
<h2 id="引用">引用</h2>
<p><strong>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）</strong></p>
<p><strong>完整示例：对比四种引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 强引用（Strong Reference）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">strongRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">        System.out.println(<span class="string">&quot;强引用创建: &quot;</span> + strongRef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 软引用（Soft Reference）</span></span><br><span class="line">        SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;软引用创建: &quot;</span> + softRef.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 弱引用（Weak Reference）</span></span><br><span class="line">        WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;弱引用创建: &quot;</span> + weakRef.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 虚引用（Phantom Reference），需要 ReferenceQueue</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; refQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), refQueue);</span><br><span class="line">        System.out.println(<span class="string">&quot;虚引用创建: &quot;</span> + phantomRef.get()); <span class="comment">// 永远是 null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发 GC</span></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">// 等待 GC 执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 GC 之后的情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;GC 后强引用: &quot;</span> + strongRef);</span><br><span class="line">        System.out.println(<span class="string">&quot;GC 后软引用: &quot;</span> + softRef.get()); <span class="comment">// 可能存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;GC 后弱引用: &quot;</span> + weakRef.get()); <span class="comment">// 一定被回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;GC 后虚引用: &quot;</span> + phantomRef.get()); <span class="comment">// 仍然是 null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 ReferenceQueue 里是否有对象被回收</span></span><br><span class="line">        Reference&lt;?&gt; ref = refQueue.poll();</span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;虚引用对象已被 GC 回收，并加入 ReferenceQueue&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;虚引用对象尚未被 GC 回收&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">强引用创建: java.lang.Object@7d4991ad</span><br><span class="line">软引用创建: java.lang.Object@28d93b30</span><br><span class="line">弱引用创建: java.lang.Object@1b6d3586</span><br><span class="line">虚引用创建: null</span><br><span class="line">GC 后强引用: java.lang.Object@7d4991ad</span><br><span class="line">GC 后软引用: java.lang.Object@28d93b30</span><br><span class="line">GC 后弱引用: null</span><br><span class="line">GC 后虚引用: null</span><br><span class="line">虚引用对象已被 GC 回收，并加入 ReferenceQueue</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>解析</strong></p>
<p><strong>1. 强引用</strong></p>
<ul>
<li>变量 <code>strongRef</code> 直接持有 <code>new Object()</code>，所以即使 GC 运行，它仍然不会被回收。</li>
<li>强引用指的是通过 <code>new</code> 对象创建的引用，垃圾回收器即使是内存不足也不会回收强引用指向的对象。</li>
</ul>
<p><strong>2. 软引用</strong></p>
<ul>
<li>在此示例中，GC 后 <code>softRef.get()</code> 仍然不为 <code>null</code>，说明对象没有被回收。</li>
<li>软引用是通过 <code>SoftRefrence</code> 实现的，它的生命周期比强引用短，在内存不足，抛出OOM之前，垃圾回收器会回收软引用引用的对象。软引用常见的使用场景是存储一些内存敏感的缓存，当内存不足时会被回收。</li>
</ul>
<p><strong>3. 弱引用</strong></p>
<ul>
<li><code>weakRef</code> 只被 <code>WeakReference</code> 持有，没有强引用存在，所以 <strong>GC 运行时立即回收</strong>，导致 <code>weakRef.get()</code> 变成 <code>null</code>。</li>
<li>弱引用是通过 <code>WeakRefrence</code> 实现的，它的生命周期比软引用还短，GC只要扫描到弱引用的对象就会回收。弱引用常见的使用场景也是存储一些内存敏感的缓存。</li>
</ul>
<p><strong>4. 虚引用</strong></p>
<ul>
<li><code>phantomRef.get()</code> <strong>始终返回 <code>null</code></strong>，所以直接打印 <code>null</code>。</li>
<li>但是，GC 运行时，<code>phantomRef</code> 被放入 <code>ReferenceQueue</code>，说明对象已被销毁。</li>
<li>虚引用是通过 <code>FhantomReference</code> 实现的，它的生命周期最短，随时可能被回收。如果一个对象只被虚引用引用，我们无法通过虚引用来访问这个对象的任何属性和方法。它的作用仅仅是保证对象在finalize后，做某些事情。虚引用常见的使用场景是跟踪对象被垃圾回收的活动，当一个虚引用关联的对象被垃圾回收器回收之前会收到一条系统通知。</li>
</ul>
<p><strong>实际应用场景</strong></p>
<p><strong>1. 软引用（SoftReference）：用于缓存</strong></p>
<ul>
<li>适用于<strong>图片缓存</strong>，如 Android 的 Bitmap 缓存，保证内存不足时自动释放。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; imageCache = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(loadImage());</span><br></pre></td></tr></table></figure>
<p><strong>2. 弱引用（WeakReference）：WeakHashMap</strong></p>
<ul>
<li>适用于<strong>弱引用缓存</strong>，如 <code>WeakHashMap</code>，当没有其他强引用时，自动删除缓存项。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakHashMap&lt;String, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">cache.put(<span class="string">&quot;key&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>
<p><strong>3. 虚引用（PhantomReference）：管理资源</strong></p>
<ul>
<li>用于跟踪对象何时被回收，例如<strong>安全释放文件、关闭数据库连接等</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhantomReference&lt;Object&gt; phantom = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, refQueue);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>强引用</strong>：普通引用，GC 不会回收。</li>
<li><strong>软引用</strong>：用于缓存，内存不足时回收。</li>
<li><strong>弱引用</strong>：用于 <code>WeakHashMap</code>，GC 发现就回收。</li>
<li><strong>虚引用</strong>：对象销毁时执行清理任务。</li>
</ul>
<h2 id="JUC">JUC</h2>
<h3 id="JMM">JMM</h3>
<p>Java Memory Model，Java内存模型，关于多线程环境下的共享变量可见性、指令重排等方式的设计</p>
<p>Java使用<strong>共享内存并发模型</strong></p>
<p>在共享内存并发模型中，多个线程或进程共享同一块内存区域，所有线程都可以读取和写入这些共享内存中的数据。为了确保多个线程或进程之间的同步，通常需要使用锁（如互斥锁、读写锁等）或其他同步机制。</p>
<blockquote>
<p>存在其他并发内存模型：消息传递并发模型</p>
<p>在消息传递并发模型中，线程或进程通过发送和接收消息来进行通信。每个线程或进程都有自己的私有内存区域，不能直接访问其他线程或进程的内存。当需要交换信息时，它们通过消息传递机制来进行。这种模型不涉及共享内存，因此不需要锁等同步机制，通常更易于避免竞态条件。</p>
</blockquote>
<p><strong>特性</strong></p>
<ul>
<li>可见性：当一个线程修改了共享变量的值，其他线程立即可见（通过 <code>volatile</code> 关键字实现）</li>
<li>原子性：操作为一个整体，不会被其他操作打断（禁止对 <code>volatile</code> 变量的操作进行指令重排序）</li>
<li>有序性：程序执行顺序按照代码先后顺序执行（通过关键字 <code>synchronized</code> 和 <code>volatile</code> 实现）</li>
</ul>
<blockquote>
<p>volatile 禁止指令重排</p>
<p>volatile 修饰变量要么在堆，要么在元空间</p>
<p>准确来说不是禁止了指令重排，而是确保volatile关键字修饰的变量的写入指令之前的指令重排后仍在其之前，volatile关键字修饰的变量的读取指令之后的指令重排后仍在其之后</p>
<ul>
<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面操作的更改肯定已经全部进行，且结果对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将 volatile 变量的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</li>
</ul>
</blockquote>
<p><strong>内存</strong></p>
<ul>
<li>主内存：堆中对象实例</li>
<li>工作内存：线程栈</li>
</ul>
<p><strong>Happens-Before 关系</strong>：</p>
<ul>
<li><strong>Happens-Before</strong> 关系是 JMM 中定义的一个重要概念，确保在某些操作发生之后，其他操作的结果是可见的。</li>
<li>比如，某个线程对共享变量的写操作，在另一个线程的读操作之前发生，Java 保证第一个线程的写操作会在第二个线程的读操作之前“可见”。</li>
<li>JMM 定义了多个规则来确定操作之间的 Happens-Before 关系，例如：
<ul>
<li>程序顺序规则：一个线程中的操作按代码顺序执行。</li>
<li>锁规则：释放锁的操作 happens-before 后续的获取锁操作。</li>
<li>volatile 规则：对一个 <code>volatile</code> 变量的写操作 happens-before 后续对该变量的读操作。</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal">ThreadLocal</h3>
<p>每个<strong>线程类</strong>持有 <code>ThreadLocalMap</code> 实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的定义（简化版）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 每个线程持有一个 ThreadLocalMap 实例</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ThreadLocalMap</code> 为 key-value结构</p>
<ul>
<li>
<p>key 为 <code>ThreadLocal</code> 对象，弱引用</p>
</li>
<li>
<p>value 为 通过 <code>threadLocal.set()</code> 设置的值，强引用</p>
</li>
</ul>
<p>由于线程池中的线程<strong>复用</strong>，线程任务结束后，可能出现 key 的 <code>ThreadLocal</code> 对象被回收，<code>ThreadLocalMap</code> 中的 value 仍然存在的情况。</p>
<p>由于 key 已经被回收，<code>ThreadLocalMap</code> 中的 entry 会变成 <strong>key = null, value = Object</strong> 的状态。这种情况下，<code>value</code> 无法被垃圾回收，因为线程仍然持有对 <code>ThreadLocalMap</code> 的引用，而 <code>ThreadLocalMap</code> 仍然引用着 <code>Object</code> 对象。如果 <code>Object</code> 对象占用较大内存（如 <code>byte[] info</code> 分配了 1MB），在长时间运行的应用中，这种内存泄漏会导致内存不断增长，最终引发 <code>OutOfMemoryError</code>。</p>
<h3 id="锁">锁</h3>
<h4 id="锁分类">锁分类</h4>
<p><strong>公平锁与非公平锁</strong></p>
<p><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁，线程直接进入同步队列中排队，队列中最先到的线程先获得锁。<strong>非公平锁</strong>是多个线程加锁时每个线程都会先去尝试获取锁，如果刚好获取到锁，那么线程无需等待，直接执行，如果获取不到锁才会被加入同步队列的队尾等待执行。</p>
<p><strong>排他锁与共享锁</strong></p>
<p><strong>排他锁</strong>也叫独占锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。<strong>共享锁</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p><strong>可重入锁与非可重入锁</strong></p>
<p><strong>可重入锁 (ReentrantLock):</strong></p>
<ul>
<li><strong>定义:</strong> 同一个线程可以多次获取同一把锁，而不会导致死锁。</li>
<li><strong>实现机制:</strong> 可重入锁通常使用一个计数器来跟踪线程获取锁的次数。
<ul>
<li>当线程第一次获取锁时，计数器加 1。</li>
<li>如果同一个线程再次获取该锁，计数器继续加 1。</li>
<li>当线程释放锁时，计数器减 1。只有当计数器变为 0 时，锁才会真正被释放，其他线程才能获取。</li>
</ul>
</li>
<li><strong>Java 中的实现:</strong> ReentrantLock 类、synchronized 关键字（隐式实现）。</li>
</ul>
<p><strong>非可重入锁 (Non-reentrant Lock):</strong></p>
<ul>
<li><strong>定义:</strong> 如果一个线程已经获取了某个锁，在释放该锁之前，不能再次获取该锁。</li>
<li><strong>Java 中的实现:</strong> Java 中没有直接提供非可重入锁的实现，需要开发者自行实现。</li>
</ul>
<p><strong>乐观锁与悲观锁</strong></p>
<p><strong>乐观锁 (Optimistic Lock):</strong></p>
<ul>
<li><strong>定义:</strong> 乐观地认为并发冲突发生的概率较低，因此不会一开始就加锁，而是 <strong>在更新数据时检查是否发生了冲突</strong>。</li>
<li><strong>实现机制:</strong> 通常使用 <strong>版本号</strong> 或 <strong>时间戳</strong> 来检测冲突。
<ul>
<li>在读取数据时，获取数据的版本号或时间戳。</li>
<li>在更新数据时，比较当前版本号或时间戳与之前获取的是否一致。</li>
<li>如果一致，则更新数据；如果不一致，则说明发生了冲突，需要进行处理（例如重试或回滚）。</li>
</ul>
</li>
<li><strong>Java 中的实现:</strong> 可以使用 AtomicInteger、AtomicLong 等原子类实现乐观锁，或者使用 CAS (Compare and Swap) 操作实现。</li>
</ul>
<p><strong>悲观锁 (Pessimistic Lock):</strong></p>
<ul>
<li><strong>定义:</strong> 悲观地认为并发冲突发生的概率较高，因此 <strong>在操作数据时都会先获取锁</strong>，防止其他线程同时访问或修改数据。</li>
<li><strong>实现机制:</strong> 通常使用 <strong>互斥锁</strong> 来实现，例如 Java 中的 synchronized 关键字和 ReentrantLock 类。</li>
<li><strong>Java 中的实现:</strong> synchronized 关键字、ReentrantLock 类等。</li>
</ul>
<p><strong>可中断锁与不可中断锁</strong></p>
<p><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</p>
<p><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</p>
<h4 id="锁状态">锁状态</h4>
<blockquote>
<p>锁升级后希望获得这个锁的线程均需要重新竞争该锁，包括原本就持有该锁的线程；</p>
<p>CAS 操作的期望值为空，当前值为空或者持有该锁的线程ID/指针，修改值为自己的线程ID/指针</p>
</blockquote>
<p>java中的锁是针对于对象的；当对象状态为偏向锁时，<code>Mark Word</code>存储的是偏向的线程 ID；当状态为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁时，<code>Mark Word</code>为指向堆中的 monitor（监视器）对象的指针。</p>
<p><strong>Mark Word</strong>：这是对象头的一部分，用于存储对象的哈希码、GC 分代年龄、锁状态标志、偏向锁线程 ID、偏向时间戳等信息。其中，锁状态标志位就指示了当前对象是否被锁定以及锁的类型。</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>29 bit 或 61 bit</th>
<th>1 bit 是否是偏向锁？</th>
<th>2 bit 锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>无锁</td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程 ID</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>10</td>
</tr>
<tr>
<td>GC 标记</td>
<td></td>
<td>此时这一位不用于标识偏向锁</td>
<td>11</td>
</tr>
</tbody>
</table>
<p><strong>无锁状态：</strong></p>
<p>对象未被任何线程锁定。</p>
<p><strong>偏向锁状态：</strong></p>
<blockquote>
<p>自用自出</p>
</blockquote>
<p>第一次进入同步块时：</p>
<ul>
<li>当 <code>Thread-1</code> 第一次进入 <code>exampleMethod()</code> 方法时，会请求获取 <code>exampleMethod()</code> 的锁。此时，JVM 会为该线程创建一个偏向锁，并在 <code>BiasedLockExample </code> 实例的对象头的 <code>Mark Word</code> 中记录下 <code>Thread-1</code> 的线程 ID。</li>
</ul>
<p>第二次进入同步块时：</p>
<ul>
<li>如果同一个线程 <code>Thread-1</code> 再次访问 <code>exampleMethod()</code> 方法，由于 <code>Mark Word</code> 中记录了它自己的线程 ID，JVM 会直接通过检查 <code>Mark Word</code> 来验证该线程已经持有锁。如果锁确实是偏向于 <code>Thread-1</code>，则无需使用 CAS 操作来加锁，直接进入方法。</li>
</ul>
<p>其他线程尝试进入同步块时：</p>
<ul>
<li>
<p>当 <code>Thread-2</code> 尝试进入 <code>exampleMethod()</code> 方法时，它会看到 <code>Mark Word</code></p>
<p>中已经记录了 <code>Thread-1</code> 的线程 ID，这就表示有其他线程持有该锁。此时会进行如下的操作：</p>
<ul>
<li>CAS 操作：JVM 会尝试使用 CAS 来将 <code>Mark Word</code> 中的线程 ID 替换成 <code>Thread-2</code> 的线程 ID。</li>
<li>成功：如果 <code>Thread-1</code> 已经退出并释放了锁（例如它已经执行完毕），<code>Mark Word</code> 会成功更新为 <code>Thread-2</code> 的线程 ID。此时，锁仍然是偏向锁，<code>Thread-2</code> 可以继续执行该同步块的代码，不需要进行其他复杂的加锁操作。</li>
<li>失败：如果 <code>Thread-1</code> 仍然持有锁（即它没有退出方法），CAS 操作会失败。此时， JVM 会在一个<strong>安全点</strong>暂停 <code>Thread-1</code> 的执行，撤销偏向锁与锁升级，恢复 <code>Thread-1</code>  的执行；此时，<code>Thread-1</code> 和 <code>Thread-2</code> 均不再持有该锁，该锁状态为轻量级锁无所属线程状态；<strong>线程 1 和线程 2 重新竞争轻量级锁</strong>， 接下来的锁竞争会使用轻量级锁的机制来进行（通过自旋等方式进行争抢）。</li>
</ul>
</li>
</ul>
<p><strong>撤销偏向锁的过程</strong>：</p>
<ul>
<li>JVM 会遍历 <code>Thread-1</code> 的栈帧，检查是否存在锁记录。如果存在，JVM 会清除与偏向锁相关的锁记录，并且会将 <code>Mark Word</code> 中保存的 <code>Thread-1</code> 的线程 ID 置为 <code>0</code>，表示没有线程持有该锁。</li>
<li><strong>重置偏向锁标识</strong>：偏向锁的标识位会被重置为 <code>00</code>，即表示没有持有锁，也没有任何线程占用该锁。</li>
</ul>
<p><strong>轻量级锁状态：</strong></p>
<blockquote>
<p>其他线程cas抢锁</p>
</blockquote>
<p>JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为 Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 里面。</p>
<p>然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p>
<p><strong>轻量级锁的竞争过程：</strong></p>
<ul>
<li><strong>自旋</strong>：当一个线程（如 <code>Thread-1</code> 或 <code>Thread-2</code>）尝试获取轻量级锁时，它会首先检查 <code>Mark Word</code>，并通过 <strong>CAS 操作</strong> 尝试将 <code>Mark Word</code> 中的值修改为指向自己线程栈中的锁记录（通常是一个指向栈帧的指针）。</li>
<li>如果 <strong>CAS 成功</strong>，该线程就成功获取锁，并且进入同步块。</li>
<li>如果 <strong>CAS 失败</strong>（表示另一个线程已经成功获得了锁），线程会继续自旋，尝试再次获取锁。自旋操作是一种轻量级的争用机制，通常会在短时间内尝试多次，避免系统进入阻塞状态。</li>
</ul>
<p><strong>如果自旋失败</strong>：</p>
<ul>
<li>如果自旋的次数过多，或者多个线程持续争抢该锁，轻量级锁会升级为 <strong>重量级锁</strong>（修改锁标识位为10）；当线程2反复抢线程1持有的轻量级锁时，JVM会将该锁升级为重量级锁。升级过程中，JVM会强制暂停线程1，并撤销其持有的轻量级锁，然后两个线程会重新竞争这个重量级锁。</li>
</ul>
<p><strong>重量级锁状态：</strong></p>
<p>当多个线程竞争同一个对象的锁，并且竞争激烈时，就会使用重量级锁（例如 ReentrantLock）。重量级锁会导致线程阻塞和上下文切换，性能开销较大。</p>
<h3 id="线程与同步">线程与同步</h3>
<img src="/2025/01/17/Java/image-20240729104740287.png" class="" title="image-20240729104740287">
<p><strong>LockSupport, wait()/notify() 和 join()</strong></p>
<p><strong>机制区别</strong></p>
<ul>
<li><strong>LockSupport:</strong> 基于<strong>许可证</strong>机制，每个线程都有一个许可证，park() 消耗许可证，unpark() 颁发许可证。</li>
<li><strong>wait()/notify():</strong> 基于<strong>锁对象</strong>，线程需要先获取锁对象的监视器锁，才能调用 wait() 进入等待，notify() 唤醒等待相同锁对象的线程。</li>
<li><strong>join():</strong> 基于<strong>线程生命周期</strong>，让一个线程等待另一个线程执行完毕。</li>
</ul>
<p><strong>锁依赖</strong></p>
<ul>
<li><strong>LockSupport:</strong> 不依赖于任何锁，可以直接阻塞和唤醒线程。</li>
<li><strong>wait()/notify()</strong> 和 **join(): ** 都需要在获取锁的前提下才能使用，并且 wait()/notify() 还要求操作相同的锁对象。</li>
</ul>
<p><strong>精确性</strong></p>
<ul>
<li><strong>LockSupport:</strong> 可以更精确地控制线程的阻塞和唤醒，例如可以指定要唤醒的线程。</li>
<li><strong>wait()/notify():</strong> notify() 方法随机唤醒一个线程，不够精确。</li>
<li><strong>join():</strong> 只能等待目标线程执行完毕，无法实现更细粒度的控制。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>LockSupport:</strong> 适用于更底层的线程同步场景，例如实现自定义同步工具类。</li>
<li><strong>wait()/notify():</strong> 适用于经典的生产者-消费者模型等场景。</li>
<li><strong>join():</strong> 适用于需要等待某个线程执行完毕后再继续执行的场景。</li>
</ul>
<h4 id="Thread-join">Thread.join()</h4>
<blockquote>
<p>谁调用ThreadX.join()，谁加入线程X的等待队列，等待线程X执行完成</p>
</blockquote>
<p><strong>对于线程 ThreadA 和线程 ThreadB:</strong></p>
<p>若 ThreadA 在运行过程中执行 ThreadB.join()，</p>
<p><strong>ThreadA 进入 WAITING 状态:</strong> ThreadB.join() 会让 ThreadA 立即进入 WAITING 状态，<strong>并且ThreadA 会无限期地等待 ThreadB 完成，直到 ThreadB 执行完毕才会继续执行</strong>。<strong>ThreadA 将释放任何已持有的锁</strong>。</p>
<p><strong>ThreadB 状态可能不变:</strong> 和之前一样，ThreadB.join() 的调用不会直接改变 ThreadB 的状态。ThreadB 会按照其自身逻辑和状态继续执行或等待。</p>
<p><strong>ThreadB 执行完毕:</strong> 当 ThreadB 执行完毕后，ThreadA 会被唤醒，从 WAITING 状态恢复到 RUNNABLE 状态，<strong>并尝试重新获取之前释放的锁（如果有）</strong>，然后继续执行 ThreadB.join() 之后的代码。</p>
<p><strong>Thread.join(1000)</strong></p>
<p>若 ThreadA 在运行过程中执行 ThreadB.join(1000)，</p>
<p><strong>ThreadA 进入 TIMED_WAITING 状态：</strong> join(1000) 会让 ThreadA 立即进入 TIMED_WAITING（超时等待）状态，最多等待 1000 毫秒（1 秒）。<strong>ThreadA 将释放任何已持有的锁</strong>。</p>
<p><strong>ThreadB 状态可能不变：</strong> ThreadB.join(1000) 的调用不会直接改变 ThreadB 的状态。ThreadB 会按照其自身逻辑和状态继续执行或等待。</p>
<p><strong>两种情况后的 ThreadA：</strong></p>
<ul>
<li><strong>情况一： ThreadB 在 1000 毫秒内执行完毕:</strong> ThreadA 会被唤醒，从 TIMED_WAITING 状态恢复到 RUNNABLE 状态，<strong>并尝试重新获取之前释放的锁（如果有）</strong>，然后继续执行 ThreadB.join(1000) 之后的代码。</li>
<li><strong>情况二： ThreadB 在 1000 毫秒内没有执行完毕:</strong> 1000 毫秒后，ThreadA 会自动被唤醒，从 TIMED_WAITING 状态恢复到 RUNNABLE 状态，<strong>并尝试重新获取之前释放的锁（如果有）</strong>，继续执行 ThreadB.join(1000) 之后的代码。</li>
</ul>
<h4 id="wait-和-notify">wait() 和 notify()</h4>
<ul>
<li>
<p><strong>wait() 和 notify() 方法必须在同步代码块 (synchronized) 或同步方法中使用。</strong></p>
</li>
<li>
<p><strong>调用 wait() 和 notify() 方法的对象必须是该同步代码块或同步方法所对应的锁对象。</strong></p>
</li>
</ul>
<p><strong>Object.wait()</strong></p>
<p>让当前线程（假设是 ThreadA）<strong>无限期地释放锁对象，并进入 WAITING 状态</strong>，直到其他线程（例如 ThreadB）调用 notify() 或 notifyAll() 方法唤醒它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前线程为 ThreadA</span></span><br><span class="line"><span class="keyword">synchronized</span>(lockObject) &#123; <span class="comment">// lockObject 是共享锁对象，ThreadA 为 Running 状态，ThreadB 为 Block 状态</span></span><br><span class="line">  <span class="keyword">while</span> (!someCondition) &#123; <span class="comment">// someCondition 是线程等待的条件</span></span><br><span class="line">    lockObject.wait(); <span class="comment">// ThreadA 释放锁，进入 WAITING 状态；ThreadB 进入 Ready 状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// someCondition 为 true，ThreadA 被唤醒后，会重新尝试获取锁</span></span><br><span class="line">  <span class="comment">// ... 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Object.wait(1000)</strong></p>
<p>让当前线程（假设是 ThreadA）释放锁对象，并进入 TIMED_WAITING（超时等待）状态，<strong>最多等待 1000 毫秒</strong>。在这段时间内，有两种情况可以让 ThreadA 被唤醒：</p>
<ul>
<li><strong>其他线程调用 notify() 或 notifyAll() 方法</strong></li>
<li><strong>等待时间超过 1000 毫秒</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前线程为 ThreadA</span></span><br><span class="line"><span class="keyword">synchronized</span>(lockObject) &#123; <span class="comment">// lockObject 是共享锁对象</span></span><br><span class="line">  <span class="keyword">while</span> (!someCondition) &#123; <span class="comment">// someCondition 是线程等待的条件</span></span><br><span class="line">    lockObject.wait(<span class="number">1000</span>); <span class="comment">// ThreadA 释放锁，进入 TIMED_WAITING 状态</span></span><br><span class="line">  <span class="comment">// someCondition 为 true 或等待超时，ThreadA 会重新尝试获取锁</span></span><br><span class="line">  <span class="comment">// 若此时该锁无法获取到，ThreadA将进入block状态等待获取lockObject对象的锁</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread.sleep() 与 Object.wait() 对比</p>
<ul>
<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li>
</ul>
<p><strong>Object.notify()</strong></p>
<ul>
<li><strong>作用:</strong> 随机唤醒<strong>一个</strong>正在等待<strong>相同锁对象</strong>的线程。</li>
<li><strong>注意：</strong>
<ul>
<li>notify() 方法<strong>不会立即释放锁</strong>。被唤醒的线程需要等待调用 notify() 的线程释放锁之后，才能真正地获取锁并继续执行。</li>
<li>如果有多个线程正在等待同一个锁对象，notify() 方法只会随机唤醒其中一个，而其他线程仍然会继续等待。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 ThreadA 内调用 lockObject.wait() 进入等待状态</span></span><br><span class="line"><span class="comment">// 当前线程为 ThreadB</span></span><br><span class="line"><span class="keyword">synchronized</span>(lockObject) &#123;</span><br><span class="line">  <span class="comment">// ... 其他线程执行的操作 ... </span></span><br><span class="line"></span><br><span class="line">  lockObject.notify(); <span class="comment">// 随机唤醒一个等待 lockObject 的线程 (可能是 ThreadA)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 调用 notify() 的线程继续执行，直到释放锁 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Object.notifyAll()</strong></p>
<ul>
<li><strong>作用:</strong> 唤醒<strong>所有</strong>正在等待<strong>相同锁对象</strong>的线程。</li>
<li><strong>注意：</strong>
<ul>
<li>和 notify() 方法一样，notifyAll() 方法<strong>也不会立即释放锁</strong>。</li>
<li>被唤醒的线程需要竞争锁，只有成功获取锁的线程才能继续执行。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 ThreadA 和其他线程都在等待 lockObject</span></span><br><span class="line"><span class="comment">// 当前线程为 ThreadB</span></span><br><span class="line"><span class="keyword">synchronized</span>(lockObject) &#123;</span><br><span class="line">  <span class="comment">// ... 其他线程执行的操作 ... </span></span><br><span class="line"></span><br><span class="line">  lockObject.notifyAll(); <span class="comment">// 唤醒所有等待 lockObject 的线程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 调用 notifyAll() 的线程继续执行，直到释放锁 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额外：使用synchronized和wait/notify实现线程的顺序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequentialExecution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">currentThread</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 用于标识当前应该执行的线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (currentThread != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait(); <span class="comment">// 等待轮到线程 A</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread A is running&quot;</span>);</span><br><span class="line">                currentThread = <span class="number">2</span>; <span class="comment">// 设置下一个线程为 B</span></span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (currentThread != <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait(); <span class="comment">// 等待轮到线程 B</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread B is running&quot;</span>);</span><br><span class="line">                currentThread = <span class="number">3</span>; <span class="comment">// 设置下一个线程为 C</span></span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">C</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (currentThread != <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait(); <span class="comment">// 等待轮到线程 C</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread C is running&quot;</span>);</span><br><span class="line">                currentThread = <span class="number">1</span>; <span class="comment">// 重置为初始状态（可选）</span></span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">        C.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LockSupport">LockSupport</h4>
<p><strong>许可证机制</strong></p>
<p>LockSupport 的许可证机制可以理解为每个线程都拥有一个虚拟的 “许可证”，每个线程最多只有一个许可证：</p>
<ul>
<li><strong>初始状态：</strong> 线程刚创建时，默认<strong>没有</strong>许可证。</li>
<li><strong>park() 行为：</strong>
<ul>
<li>如果线程<strong>有</strong>许可证，调用 park() 会<strong>立即返回</strong>，并<strong>消耗</strong>掉这个许可证。</li>
<li>如果线程<strong>没有</strong>许可证，调用 park() 会<strong>阻塞线程</strong>，直到获得许可证。</li>
</ul>
</li>
<li><strong>unpark() 行为：</strong>
<ul>
<li>如果线程<strong>没有</strong>许可证，调用 unpark() 会<strong>颁发</strong>一个许可证给该线程。</li>
<li>如果线程<strong>已经</strong>有许可证，调用 unpark() <strong>不会</strong>产生任何效果，许可证<strong>不会累积</strong>。</li>
</ul>
</li>
</ul>
<p><strong>LockSupport 的阻塞和唤醒</strong></p>
<p>LockSupport 通过操作线程的 <strong>Parker</strong> 对象来实现阻塞和唤醒。每个线程都有一个 Parker 对象，它内部维护了线程的阻塞状态和许可证信息。</p>
<ul>
<li><strong>park() 阻塞线程：</strong> park() 方法会调用 Parker 对象的 park() 方法，将线程的状态设置为 WAITING 或 PARKED，并挂起线程，直到获得许可证。</li>
<li><strong>unpark() 唤醒线程：</strong> unpark() 方法会调用 Parker 对象的 unpark() 方法，将线程的状态设置为 RUNNABLE，并通知操作系统调度该线程</li>
</ul>
<p><strong>状态与中断</strong></p>
<p><strong>BLOCKED 状态 (阻塞状态)</strong></p>
<ul>
<li><strong>成因:</strong> 线程在尝试获取某个锁时，如果该锁已经被其他线程持有，则当前线程会进入 BLOCKED 状态。</li>
<li><strong>中断的影响:</strong> BLOCKED 状态的线程<strong>不会</strong>响应中断请求。即使调用了 interrupt() 方法，线程也不会立即退出阻塞状态。只有当线程获取到锁之后，才会检查中断状态。</li>
</ul>
<p><strong>WAITING 状态 (等待状态)</strong></p>
<ul>
<li><strong>成因:</strong> 线程调用了 wait()、join()（无超时） 或 park() 方法，进入无限期等待状态。</li>
<li><strong>中断的影响:</strong> WAITING 状态的线程<strong>可以</strong>被中断唤醒。当调用 interrupt() 方法时，线程会抛出 InterruptedException，并退出等待状态。进入 <strong>RUNNABLE (可运行)</strong> 状态</li>
</ul>
<p><strong>TIMED_WAITING 状态 (超时等待状态)</strong></p>
<ul>
<li><strong>成因:</strong> 线程调用了 wait(timeout)、join(timeout)、sleep(timeout) 或 parkNanos(nanos) 方法，进入有限时间等待状态。</li>
<li><strong>中断的影响:</strong> TIMED_WAITING 状态的线程<strong>可以</strong>被中断唤醒。 当调用 interrupt() 方法时，线程会抛出 InterruptedException，并退出等待状态。进入 <strong>RUNNABLE (可运行)</strong> 状态</li>
</ul>
<p><strong>中断后状态</strong></p>
<p>中断后程序会进入 <strong>RUNNABLE (可运行)</strong> 状态，但是不意味着程序可以立即向后执行代码</p>
<ul>
<li><strong>需要获取资源:</strong> 线程需要重新获取之前释放的资源，例如：
<ul>
<li>如果是通过 wait() 进入 WAITING 状态的，需要重新获取 wait() 方法所属对象的锁。此时线程若在 synchronized 块中，会等待获取对象的锁，若获取不到，会进入 BLOCKED 状态。</li>
<li>如果是通过 join() 进入 WAITING 状态的，需要等待 join() 的目标线程执行完毕。</li>
</ul>
</li>
<li><strong>需要 CPU 调度:</strong> 线程还需要等待 CPU 的调度，才能真正地执行代码。</li>
</ul>
<h3 id="CAS">CAS</h3>
<p>Compare-and-Swap，乐观锁</p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)，旧值；</li>
<li>N：新值(new)</li>
</ul>
<p>比较并交换的过程如下：</p>
<p>判断 V 是否等于 E，如果等于，将 V 的值设置为 N（原子操作更新）；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。</p>
<blockquote>
<p>存在ABA问题，即 V 被线程1 从A修改为B修改为A ；线程2 预期值为 A，在比较时发现 V   的值 A 与 预期值E 相同，认为 V 没有收到修改，实则不然；</p>
<p>解决办法：加入版本号控制</p>
</blockquote>
<p>Unsafe类 native方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,Object expected, Object x)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">int</span> expected,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">long</span> expected,<span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure>
<p>AtomicInteger类 getAndIncrement</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();  <span class="comment">// 取得AtomicInteger里存储的数值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;  <span class="comment">// 加1</span></span><br><span class="line">                <span class="comment">// compareAndSet即为CAS操作，current的值为旧值，变量为AtomicInteger，新值为next的值，尝试将AtomicInteger的值设置为next</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSet(current, next))   <span class="comment">// 调用compareAndSet执行原子更新操作</span></span><br><span class="line">                    <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>标准的CAS</p>
<ol>
<li>
<p>compareAndSet方法首先判断AtomicInteger是否等于current；</p>
</li>
<li>
<p>如果当前值 = current ，说明AtomicInteger的值没有被其他线程修改；</p>
</li>
<li>
<p>如果当前值 != current，说明AtomicInteger的值被其他线程修改了，<code>compareAndSet()</code>返回False，循环继续，无法返回current；</p>
</li>
</ol>
<h3 id="AQS">AQS</h3>
<p><strong>CLH队列</strong></p>
<p>双向链表，通过head和tail记录头节点和尾节点，元素类型为Node</p>
<p>线程获取？失败时，AQS将线程和相关信息封装为Node加入CLH队列，同时阻塞该线程</p>
<p>ref: <a href="https://developer.aliyun.com/article/779674?spm=a2c6h.13262185.profile.72.4c5f3bc8ppEWYX">https://developer.aliyun.com/article/779674?spm=a2c6h.13262185.profile.72.4c5f3bc8ppEWYX</a></p>
<img src="/2025/01/17/Java/20201206223144780.png" class="" title="aqs">
<img src="/2025/01/17/Java/java-thread-x-juc-aqs-1.png" class="" title="image">
<ul>
<li>
<p>state</p>
<p>volatile，方法 <code>compareAndSetState()</code> 使用CAS</p>
<p>相关方法： <code>getState()</code>, <code>setState()</code>, <code>compareAndSetState()</code></p>
<blockquote>
<p>在 ReentrantLock 中，通过 state 判断当前线程状态；</p>
<p>state值为1说明资源正在被使用，值为0说明资源未被使用；</p>
<p>发生重入则 setState(getState() + 1);</p>
</blockquote>
</li>
<li>
<p>exclusiveOwnerThread</p>
<p>当前独占资源的线程</p>
</li>
<li>
<p>内部类Node</p>
<ul>
<li>
<p>等待标记 SHARED, EXCLUSIVE</p>
</li>
<li>
<p>静态常量 CANCELLED, SIGNAL, CONDITION, PROPAGATE</p>
<p>这些常量定义了 Node 的 waitStatus 状态，它们控制着等待队列的行为：</p>
<blockquote>
<ul>
<li>CANCELLED = 1: 表示节点对应的线程因为超时、中断等原因被取消了等待。 被取消的节点需要从队列中移除。</li>
<li>SIGNAL = -1: 表示当前节点的后继节点（next）需要被唤醒（unpark）。 当一个线程释放锁或发出信号时，它会将前一个节点的 waitStatus 设置为 SIGNAL，通知后继节点尝试获取锁。</li>
<li>CONDITION = -2: 表示节点当前在 condition 队列中等待 condition 满足。 与主同步队列（AQS 队列）是分开的，等待 Condition.signal() 唤醒后，节点会被转移到主同步队列中，重新竞争锁。</li>
<li>PROPAGATE = -3: 只用于共享模式。表示当前节点的共享锁释放操作，不仅需要唤醒后继节点，而且要将释放操作传播（propagate）到后续节点，因为后续节点可能也可以获取到共享锁。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>volatile int waitStatus</strong>: 节点的等待状态，包括上面的四种常量所描述的，使用 volatile 保证可见性。</p>
</li>
<li>
<p><strong>volatile Node prev</strong>: 指向前驱节点的指针。</p>
</li>
<li>
<p><strong>volatile Node next</strong>: 指向后继节点的指针。</p>
</li>
<li>
<p><strong>volatile Thread thread</strong>: 节点关联的线程。</p>
</li>
<li>
<p>**Node nextWaiter: <strong>仅在 Condition 中使用</strong>。 它指向下一个等待 condition 的节点。 在 AQS 的主同步队列中，它用作共享/独占模式的标识。 如果 nextWaiter == SHARED，则表示该节点是在共享模式下等待的线程。</p>
</li>
</ul>
</li>
<li>
<p>内部类ConditionObject</p>
<p>该类维护了一个条件等待队列，实现了Condition接口</p>
</li>
<li>
<p>方法</p>
<p>tryAcquire方法，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。</p>
<p>addWaiter方法完成的功能是将调用此方法的线程封装成为一个结点并放入Sync queue</p>
</li>
</ul>
<p><strong>流程</strong></p>
<img src="/2025/01/17/Java/2a3c22e2ac6d0a8990f04e4920760b57.png" class="" title="aqs_process">
<p><code>acquire()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tryAcquire()</code> 为模板方法，由子类实现</p>
<p><code>acquireQueued()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在队列中的节点node通过acquireQueued()方法获取资源，忽略中断。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//自旋的操作，一个死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取传进来的node节点的前驱节点，赋值给p</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果p是头结点，node节点就是第二个节点，则再次去尝试获取资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//tryAcquire(arg)获取资源成功的话，则把node节点设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//把原来的头结点p的后驱节点设置为null，等待GC垃圾回收</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果p不是头结点，或者tryAcquire()获取资源失败，判断是否可以被park，也就是把线程阻塞起来</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">//&amp;&amp;前面如果返回true，将当前线程阻塞并检查是否被中断</span></span><br><span class="line">                <span class="comment">//如果阻塞过程中被中断，则置interrupted标志位为true。</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addWaiter()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">//把当前线程包装成Node节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//获取到尾结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">//判断尾结点是否为null，如果不为空，那就证明队列已经初始化了</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//已经初始化了，就直接把Node节点添加到队列的末尾</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="comment">//返回包含当前线程的节点Node</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果队列没有初始化，那就调用enq()方法</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//自旋操作，也就是死循环，只有加入队列成功才会return</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//把尾结点赋值给t</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">//如果为空，证明没有初始化，进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">//创建一个空的Node节点，并且设置为头结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                <span class="comment">//然后把头结点赋值给尾结点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是第一次循环为空，就已经创建了一个一个Node，那么第二次循环就不会为空了</span></span><br><span class="line">            <span class="comment">//如果尾结点不为空，就把传进来的node节点的前驱节点指向尾结点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//cas原子性操作，把传进来的node节点设置为尾结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">//把原来的尾结点的后驱节点指向传进来的node节点</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="synchronized">synchronized</h3>
<p><strong>悲观锁，可重入锁</strong></p>
<p>修饰<strong>实例方法</strong>/修饰静态方法  锁目标：该方法对应的<strong>对象</strong>/<strong>Class对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">       i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">       i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰代码块  锁目标：指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object) &#123; </span><br><span class="line">   <span class="comment">// 需要同步的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SynchronizedCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedCounter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();  <span class="comment">// thread1 join执行，加入thread1的等待队列</span></span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Count: &quot;</span> + counter.getCount()); <span class="comment">// 预期输出：20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantLock">ReentrantLock</h3>
<p>ReentrantLock 是<strong>悲观锁，可重入锁，可中断锁，重量级锁</strong></p>
<p>自声明使用的锁，类似于经典操作系统中所使用的案例锁；该锁一般放在堆区，由该进程中的线程共享使用；</p>
<blockquote>
<p>比synchronized更高级，依赖于API</p>
</blockquote>
<p>reentrant lock 内部类 Sync 继承 AQS</p>
<p>内部类 NonfairSync FairSync 继承 内部类 Sync</p>
<p>Condition 常用方法 await() 方法  signal() 方法   signalAll() 方法</p>
<p>await() 方法由线程调用，将自己加入condition的等待队列</p>
<p>signal() 方法？</p>
<p>主要功能和作用：</p>
<ol>
<li><strong>管理等待线程的队列</strong>： <code>ConditionObject</code> 使用 <code>Node</code> 来表示 <strong>等待队列</strong> 中的每一个线程。每个线程在调用 <code>await()</code> 时会被封装成一个 <code>Node</code> 对象，加入到 <code>ConditionObject</code> 的等待队列中。该队列是一个单向链表，<code>ConditionObject</code> 通过这个队列管理线程的等待与唤醒。</li>
<li>线程的挂起和唤醒：
<ul>
<li><code>await()</code>：当线程调用 <code>await()</code> 方法时，它会进入 <strong>条件等待队列</strong>，并且该线程会被挂起，直到满足某些条件后被唤醒。</li>
<li><code>signal()</code> 和 <code>signalAll()</code>：这些方法用于唤醒等待在 <code>ConditionObject</code> 上的线程。当调用 <code>signal()</code> 或 <code>signalAll()</code> 时，<code>ConditionObject</code> 会检查队列中的线程，并将这些线程移回到 <strong>同步队列</strong>（AQS 的 CLH 队列），使它们有机会重新竞争锁。</li>
</ul>
</li>
<li><strong>节点转移</strong>： 当线程被唤醒时，<code>ConditionObject</code> 会将节点从等待队列中移除，并通过 <code>AQS</code> 中的 <strong>CLH 同步队列</strong> 继续参与锁竞争。<code>Node</code> 节点在这里充当了 <strong>“等待”状态和“竞争锁”状态”</strong> 之间的桥梁。</li>
</ol>
<p><code>ReentrantLock</code> 的 <code>ConditionObject</code> ，当调用 <code>ConditionObject</code> 的 <code>signal()</code> 方法时，唤醒的线程会被送回到 <code>ReentrantLock</code> 的 <strong>CLH 队列</strong> 中，以继续竞争锁。</p>
<h3 id="Atomic">Atomic</h3>
<p>Atomic类 底层 <code>unsafe.getAndAddInt</code> volatile的变量和CAS</p>
<p><code>ReentrantLock</code>  底层 unsafe 的 park/unpark</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unsafe 类 getAndAddInt 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object paramObject, <span class="type">long</span> paramLong, <span class="type">int</span> paramInt)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">do</span></span><br><span class="line">      <span class="variable">i</span> <span class="operator">=</span> getIntVolatile(paramObject, paramLong);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Concurrent-HashMap">Concurrent HashMap</h3>
<p><code>ConcurrentHashMap</code> 是 Java 提供的线程安全 <code>Map</code> 实现，其在 <strong>JDK 1.7</strong> 和 <strong>JDK 1.8</strong> 采用了不同的机制来提高并发性能：</p>
<hr>
<p><strong>JDK 1.7：分段锁（Segment Locking）</strong></p>
<p><strong>设计结构</strong></p>
<p>在 JDK 1.7 版本中，<code>ConcurrentHashMap</code> 采用了 <strong>分段锁（Segment Locking）</strong> 机制，即 <strong>将整个 HashMap 拆分成多个小的 Segment（段）</strong>，每个 Segment 维护一个独立的 <code>HashMap</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line"> ├── Segment 0 （锁 0）</span><br><span class="line"> ├── Segment 1 （锁 1）</span><br><span class="line"> ├── Segment 2 （锁 2）</span><br><span class="line"> ├── ...</span><br><span class="line"> ├── Segment N-1 （锁 N-1）</span><br></pre></td></tr></table></figure>
<p><strong>每个 <code>Segment</code> 维护自己的 HashMap 和锁，所以不同的 <code>Segment</code> 之间可以并行访问，减少锁竞争。</strong></p>
<hr>
<p><strong>主要操作</strong></p>
<ol>
<li><strong>put 操作</strong>
<ul>
<li>计算 key 的 hash 值，定位到对应的 <code>Segment</code>。</li>
<li>获取 <code>Segment</code> 的锁，执行 <code>put</code> 操作。</li>
<li>释放锁。</li>
</ul>
</li>
<li><strong>get 操作</strong>
<ul>
<li>计算 key 的 hash 值，找到 <code>Segment</code>。</li>
<li><strong>不需要加锁</strong>，直接访问数据，提高性能。</li>
</ul>
</li>
<li><strong>扩容（rehash）</strong>
<ul>
<li>只有一个 <code>Segment</code> 扩容，不影响其他 <code>Segment</code>，降低 <code>rehash</code> 的性能损耗。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>JDK 1.8：CAS + Synchronized</strong></p>
<p>从 JDK 1.8 开始，<code>ConcurrentHashMap</code> <strong>移除了 <code>Segment</code>，改用 <code>Node[]</code> 作为底层数据结构，并结合 CAS（无锁操作）+ <code>synchronized</code>（锁竞争）</strong> 机制。</p>
<p><strong>设计结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line"> ├── Node 0 （CAS 操作）</span><br><span class="line"> ├── Node 1 （无锁）</span><br><span class="line"> ├── Node 2 （synchronized）</span><br><span class="line"> ├── ...</span><br><span class="line"> ├── Node N-1 （CAS 操作）</span><br></pre></td></tr></table></figure>
<ul>
<li>采用 <strong>数组 + 链表 + 红黑树</strong> 结构，类似 <code>HashMap</code>。</li>
<li><strong>数据分布在 <code>Node[]</code> 中，不再使用 <code>Segment[]</code></strong>，简化结构。</li>
<li>采用 <strong>CAS + synchronized</strong> 控制并发，提升性能。</li>
</ul>
<hr>
<p><strong>主要优化</strong></p>
<ol>
<li><strong>put 操作</strong>
<ul>
<li>如果目标桶（<code>Node[]</code>）为空，使用 <strong>CAS 操作</strong> 直接插入，避免加锁。</li>
<li>如果目标桶有数据：
<ul>
<li>若无并发冲突，采用 <strong>无锁操作</strong> 修改数据。</li>
<li>若有并发冲突，使用 <strong>synchronized</strong> 锁定该桶，避免数据竞争。</li>
</ul>
</li>
<li><strong>链表长度超过 8 时，自动转为红黑树，提高查询效率。</strong></li>
</ul>
</li>
<li><strong>get 操作</strong>
<ul>
<li>直接读取 <code>Node[]</code>，无锁操作，提高性能。</li>
</ul>
</li>
<li><strong>扩容（rehash）</strong>
<ul>
<li><code>ConcurrentHashMap</code> 采用 <strong>多线程并发扩容</strong>，不同线程可以同时帮助迁移数据，提升扩容效率。</li>
</ul>
</li>
</ol>
<blockquote>
<p>在 Java 中，<code>ConcurrentHashMap</code> 和 <code>HashMap</code> 对于插入空键和空值的处理方式是不同的。</p>
<p><code>ConcurrentHashMap</code></p>
<ul>
<li><strong>不允许插入空键</strong>：<code>ConcurrentHashMap</code> 不允许插入空键（<code>null</code> key）。如果你尝试插入一个空键，会抛出 <code>NullPointerException</code>。</li>
<li><strong>不允许插入空值</strong>：<code>ConcurrentHashMap</code> 也不允许插入空值（<code>null</code> value）。同样，如果你尝试插入一个空值，会抛出 <code>NullPointerException</code>。</li>
</ul>
<p><strong>原因</strong>：<code>ConcurrentHashMap</code> 的设计目标是支持高并发的场景。为了确保线程安全性和一致性，<code>ConcurrentHashMap</code> 在内部使用了复杂的锁机制和并发控制策略。允许空键或空值会增加实现的复杂性，并且可能导致歧义或不确定的行为。因此，<code>ConcurrentHashMap</code> 直接禁止了空键和空值的使用。</p>
<p><code>HashMap</code></p>
<ul>
<li><strong>允许插入空键</strong>：<code>HashMap</code> 允许插入空键（<code>null</code> key）。你可以将一个键设置为 <code>null</code>，并且 <code>HashMap</code> 会将其视为一个有效的键。</li>
<li><strong>允许插入空值</strong>：<code>HashMap</code> 也允许插入空值（<code>null</code> value）。你可以将值设置为 <code>null</code>，并且 <code>HashMap</code> 会将其视为一个有效的值。</li>
</ul>
<p><strong>原因</strong>：<code>HashMap</code> 的设计目标是为单线程环境提供高效的键值对存储。它没有并发控制的需求，因此可以更灵活地处理空键和空值。允许空键和空值可以简化某些场景下的使用，例如在需要表示“不存在”或“未定义”的情况下。</p>
</blockquote>
<h3 id="线程池">线程池</h3>
<p><strong><code>Executor</code> 接口</strong></p>
<p><code>Executor</code> 是 Java 并发包 (<code>java.util.concurrent</code>) 中的一个核心接口，用于将任务的提交与任务的执行分离。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(command).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        executor.execute(() -&gt; System.out.println(<span class="string">&quot;Task executed by Executor&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>Executors</code> 工具类</strong></p>
<p><code>Executors</code> 是一个工具类，提供了许多静态工厂方法，用于创建不同类型的线程池。这些线程池是 <code>ExecutorService</code> 接口的实现（<code>ExecutorService</code> 是 <code>Executor</code> 的子接口），可以更方便地管理线程池。</p>
<p><code>Executors</code> 的主要作用是：<strong>简化线程池的创建</strong>。它提供了以下常见的线程池类型：</p>
<ul>
<li><strong>固定大小线程池</strong>：<code>Executors.newFixedThreadPool(int nThreads)</code></li>
<li><strong>单线程池</strong>：<code>Executors.newSingleThreadExecutor()</code></li>
<li><strong>缓存线程池</strong>：<code>Executors.newCachedThreadPool()</code></li>
<li><strong>调度线程池</strong>：<code>Executors.newScheduledThreadPool(int corePoolSize)</code></li>
</ul>
<p><strong><code>ThreadPoolExecutor</code> 类</strong></p>
<p><code>ThreadPoolExecutor</code> 是 <code>ExecutorService</code> 接口的一个实现类，提供了更丰富的线程池管理功能。它允许你配置核心线程数、最大线程数、线程空闲时间、任务队列等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">            <span class="number">4</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">            <span class="number">60</span>, <span class="comment">// 线程空闲时间</span></span><br><span class="line">            TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;() <span class="comment">// 任务队列</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        executor.execute(() -&gt; System.out.println(<span class="string">&quot;Task 1 executed by ThreadPoolExecutor&quot;</span>));</span><br><span class="line">        executor.execute(() -&gt; System.out.println(<span class="string">&quot;Task 2 executed by ThreadPoolExecutor&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程池线程生命周期</strong></p>
<img src="/2025/01/17/Java/java-thread-x-executors-2.png" class="" title="img">
<p><strong>EXECUTE流程</strong></p>
<img src="/2025/01/17/Java/02ede02b26c85d797a995abf520e08b5.png" class="" title="threadPool">
<p><strong>线程池类型</strong></p>
<p><code>newFixedThreadPool</code></p>
<p>它会创建固定数量的线程，并且这些线程会一直存活，直到线程池被显式地关闭（通过调用 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法），即使线程池没有可执行任务时，也不会释放线程。</p>
<p><code>FixedThreadPool</code>的工作队列为无界队列<code>LinkedBlockingQueue</code>(队列容量为<code>Integer.MAX_VALUE</code>), 这会导致以下问题:</p>
<ul>
<li>线程池里的线程数量不超过<code>corePoolSize</code>,这导致了<code>maximumPoolSize</code>和<code>keepAliveTime</code>将会是个无用参数</li>
<li>由于使用了无界队列, 所以<code>FixedThreadPool</code>永远不会拒绝, 即饱和策略失效</li>
</ul>
<p><code>newSingleThreadExecutor</code></p>
<p>初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行.</p>
<p>由于使用了无界队列, 所以SingleThreadPool永远不会拒绝, 即饱和策略失效</p>
<p><code>newCachedThreadPool</code></p>
<p>线程池的线程数可达到<code>Integer.MAX_VALUE</code>，即2147483647，内部使用<code>SynchronousQueue</code>作为阻塞队列； 和<code>newFixedThreadPool</code>创建的线程池不同，<code>newCachedThreadPool</code>在没有任务执行时，当线程的空闲时间超过<code>keepAliveTime</code>，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 执行过程与前两种稍微不同:</p>
<ul>
<li>主线程调用<code>SynchronousQueue</code>的<code>offer()</code>方法放入task, 倘若此时线程池中有空闲的线程尝试读取 <code>SynchronousQueue</code>的task, 即调用了<code>SynchronousQueue</code>的<code>poll()</code>, 那么主线程将该task交给空闲线程. 否则执行(2)</li>
<li>当线程池为空或者没有空闲的线程, 则创建新的线程执行任务.</li>
<li>执行完任务的线程倘若在60s内仍空闲, 则会被终止. 因此长时间空闲的<code>CachedThreadPool</code>不会持有任何线程资源</li>
</ul>
<hr>
<p>著作权归@pdai所有 原文链接：<a href="https://pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html">https://pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html</a></p>
<p><strong>拒绝策略</strong></p>
<p><code>handler </code> 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:</p>
<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>
<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>
</ul>
<p><strong>配置线程池需要考虑因素</strong></p>
<p>从任务的优先级，任务的执行时间长短，任务的性质(CPU密集/ IO密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。</p>
<p>性质不同的任务可用使用不同规模的线程池分开处理:</p>
<ul>
<li>CPU密集型: 尽可能少的线程，N_cpu+1</li>
<li>IO密集型: 尽可能多的线程, N_cpu*2，比如数据库连接池</li>
<li>混合型: CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分</li>
</ul>
<p><strong>线程池关闭</strong></p>
<p><code>shutdown()</code></p>
<ul>
<li><strong>功能:</strong> 启动一个<strong>平滑关闭</strong>过程。</li>
<li><strong>行为:</strong>
<ul>
<li>阻止新任务提交到线程池。</li>
<li>允许线程池中已提交的任务（包括正在执行和等待执行的任务）完成。</li>
<li>线程池不会立即停止执行，而是等待所有已提交的任务执行完毕后，才真正关闭。</li>
</ul>
</li>
<li><strong>返回值:</strong> 无返回值。</li>
<li><strong>使用场景:</strong> 适用于希望线程池优雅关闭，确保所有已提交的任务都得到处理的情况。</li>
</ul>
<p><code>shutdownNow()</code></p>
<ul>
<li><strong>功能:</strong> 尝试<strong>强制关闭</strong>线程池。</li>
<li><strong>行为:</strong>
<ul>
<li>阻止新任务提交到线程池。</li>
<li>尝试停止所有正在执行的任务（通过中断线程的方式）。</li>
<li>跳过所有等待执行的任务，并返回一个包含这些未执行任务的 List。</li>
</ul>
</li>
<li><strong>返回值:</strong> 返回 List&lt;Runnable&gt;，其中包含在 shutdown 时等待执行的任务列表。</li>
<li><strong>使用场景:</strong> 适用于需要立即停止线程池，而不关心未完成任务的情况。例如，在应用程序遇到严重错误需要立即退出时。</li>
</ul>
<h2 id="JVM">JVM</h2>
<p><a href="https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/">https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/</a></p>
-1722133033018.JPG)
<h3 id="文件">文件</h3>
<blockquote>
<p>一个 <strong>.class</strong> <strong>文件对应一个 Class 文件常量池!!!</strong></p>
</blockquote>
<p><strong>Class 文件常量池 ：</strong></p>
<ul>
<li><strong>存储类和接口的常量信息：</strong> Class 文件常量池是 Class 文件中的一部分，它存储了编译时就已经确定的各种字面量和符号引用，主要包括：
<ul>
<li><strong>字面量 (Literals):</strong> 基本数据类型的值、字符串、null 值等。</li>
<li><strong>符号引用 (Symbolic References):</strong> 类和接口的全限定名、字段名、方法名、方法描述符等。</li>
</ul>
</li>
<li><strong>支持类加载和链接：</strong> 在类加载的过程中，JVM 会读取 Class 文件常量池中的信息，并在运行时将符号引用解析为直接引用。</li>
</ul>
<p><strong>Class 文件常量池和字符串常量池的关系：</strong></p>
<ul>
<li><strong>字符串常量池是 Class 文件常量池的一部分：</strong> Class 文件常量池中包含一个特殊的区域，专门用来存储字符串字面量，这个区域就是字符串常量池。</li>
<li><strong>类加载时，字符串常量池的内容会被加载到全局字符串池(运行时)：</strong> 这样，不同的类就可以共享相同的字符串对象，节省内存空间。</li>
</ul>
<h3 id="JVM内存">JVM内存</h3>
<h4 id="Nonheap（非堆）"><strong>Nonheap（非堆）</strong></h4>
<p><strong>方法区/元空间可能类信息</strong></p>
<ul>
<li><strong>className, superClassName, accessFlags, interfaceNames, sourceFile</strong>: 这些是类的基本信息，属于元数据，存储在方法区/元空间。</li>
<li><strong>fieldTable</strong>: 字段信息表，包含每个字段的描述信息，存储在方法区/元空间。</li>
<li><strong>methodTable</strong>: 方法信息表，包含每个方法的描述信息，存储在方法区/元空间。</li>
<li><strong>instanceSize</strong>: 实例大小是类级别的信息。</li>
<li><strong>innerClasses, enclosingMethod, genericSignature, runtimeVisibleTypeAnnotations, bootstrapMethods, version, minorVersion, majorVersion, constantValueAttributes, methodHandles, exceptions, nestMembers, nestHost, permittedSubclasses, recordComponents</strong>: 这些信息都属于类的元数据，存储在方法区/元空间。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Class Info  <span class="comment">// 仅供参考，存在错误</span></span><br><span class="line">|</span><br><span class="line">+---&gt; className<span class="punctuation">:</span> <span class="string">&quot;com/example/MyClass&quot;</span></span><br><span class="line">+---&gt; superClassName<span class="punctuation">:</span> <span class="string">&quot;java/lang/Object&quot;</span></span><br><span class="line">+---&gt; accessFlags<span class="punctuation">:</span> <span class="number">0x0021</span> (PUBLIC | SUPER)</span><br><span class="line">+---&gt; interfaceNames<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;java/lang/Runnable&quot;</span><span class="punctuation">,</span> <span class="string">&quot;java/io/Serializable&quot;</span><span class="punctuation">]</span></span><br><span class="line">+---&gt; fieldTable<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      +---&gt; FieldInfo <span class="punctuation">&#123;</span></span><br><span class="line">|      |       fieldName<span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       fieldType<span class="punctuation">:</span> <span class="string">&quot;I&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       accessFlags<span class="punctuation">:</span> <span class="number">0x0002</span> (PRIVATE)<span class="punctuation">,</span></span><br><span class="line">|      |       attributes<span class="punctuation">:</span> <span class="punctuation">[</span>ConstantValue<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">|      |     <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">|      +---&gt; FieldInfo <span class="punctuation">&#123;</span></span><br><span class="line">|      |       fieldName<span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       fieldType<span class="punctuation">:</span> <span class="string">&quot;Ljava/lang/String;&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       accessFlags<span class="punctuation">:</span> <span class="number">0x0004</span> (PROTECTED)<span class="punctuation">,</span></span><br><span class="line">|      |       attributes<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">|      |     <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">|      +---&gt; FieldInfo <span class="punctuation">&#123;</span></span><br><span class="line">|      |       fieldName<span class="punctuation">:</span> <span class="string">&quot;constValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       fieldType<span class="punctuation">:</span> <span class="string">&quot;I&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       accessFlags<span class="punctuation">:</span> <span class="number">0x0009</span> (PUBLIC | STATIC)<span class="punctuation">,</span></span><br><span class="line">|      |       attributes<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">|      |     <span class="punctuation">&#125;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; methodTable<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      +---&gt; MethodInfo <span class="punctuation">&#123;</span></span><br><span class="line">|      |       methodName<span class="punctuation">:</span> <span class="string">&quot;&lt;init&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       methodSignature<span class="punctuation">:</span> <span class="string">&quot;()V&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       accessFlags<span class="punctuation">:</span> <span class="number">0x0001</span> (PUBLIC)<span class="punctuation">,</span></span><br><span class="line">|      |       attributes<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      |         Code<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">|      |           maxStack<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">|      |           maxLocals<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">|      |           code<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">0x2A</span><span class="punctuation">,</span> <span class="number">0xB7</span><span class="punctuation">,</span> <span class="number">0x00</span><span class="punctuation">,</span> <span class="number">0x01</span><span class="punctuation">,</span> <span class="number">0xB1</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">|      |           exceptionTable<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">|      |           lineNumberTable<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      |             <span class="punctuation">&#123;</span>start_pc<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> line_number<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span></span><br><span class="line">|      |           <span class="punctuation">]</span></span><br><span class="line">|      |         <span class="punctuation">&#125;</span></span><br><span class="line">|      |       <span class="punctuation">]</span></span><br><span class="line">|      |     <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">|      +---&gt; MethodInfo <span class="punctuation">&#123;</span></span><br><span class="line">|      |       methodName<span class="punctuation">:</span> <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       methodSignature<span class="punctuation">:</span> <span class="string">&quot;()V&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      |       accessFlags<span class="punctuation">:</span> <span class="number">0x0001</span> (PUBLIC)<span class="punctuation">,</span></span><br><span class="line">|      |       attributes<span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">]</span></span><br><span class="line">|      |     <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">|      +---&gt; MethodInfo <span class="punctuation">&#123;</span></span><br><span class="line">|              methodName<span class="punctuation">:</span> <span class="string">&quot;&lt;clinit&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">|              methodSignature<span class="punctuation">:</span> <span class="string">&quot;()V&quot;</span><span class="punctuation">,</span></span><br><span class="line">|              accessFlags<span class="punctuation">:</span> <span class="number">0x0008</span> (STATIC)<span class="punctuation">,</span></span><br><span class="line">|              attributes<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|                Code<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">|                  maxStack<span class="punctuation">:</span> ...<span class="punctuation">,</span></span><br><span class="line">|                  maxLocals<span class="punctuation">:</span> ...<span class="punctuation">,</span></span><br><span class="line">|                  code<span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">|                  exceptionTable<span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">|                  lineNumberTable<span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">]</span></span><br><span class="line">|                <span class="punctuation">&#125;</span></span><br><span class="line">|              <span class="punctuation">]</span></span><br><span class="line">|            <span class="punctuation">&#125;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; constantPool<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">:</span> Unused</span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Utf8_info <span class="punctuation">&#123;</span> <span class="string">&quot;com/example/MyClass&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Class_info <span class="punctuation">&#123;</span> name_index<span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Utf8_info <span class="punctuation">&#123;</span> <span class="string">&quot;java/lang/Object&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Class_info <span class="punctuation">&#123;</span> name_index<span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Utf8_info <span class="punctuation">&#123;</span> <span class="string">&quot;id&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">6</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Utf8_info <span class="punctuation">&#123;</span> <span class="string">&quot;I&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">7</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Utf8_info <span class="punctuation">&#123;</span> <span class="string">&quot;name&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">8</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Utf8_info <span class="punctuation">&#123;</span> <span class="string">&quot;Ljava/lang/String;&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">9</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Utf8_info <span class="punctuation">&#123;</span> <span class="string">&quot;&lt;init&gt;&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ConstantPoolInfo<span class="punctuation">[</span><span class="number">10</span><span class="punctuation">]</span><span class="punctuation">:</span> CONSTANT_Utf8_info <span class="punctuation">&#123;</span> <span class="string">&quot;()V&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">|      +---&gt; ... (more constant pool entries)</span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; sourceFile<span class="punctuation">:</span> <span class="string">&quot;MyClass.java&quot;</span></span><br><span class="line">+---&gt; innerClasses<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      <span class="punctuation">&#123;</span></span><br><span class="line">|        innerClassName<span class="punctuation">:</span> <span class="string">&quot;InnerClass&quot;</span><span class="punctuation">,</span></span><br><span class="line">|        outerClassName<span class="punctuation">:</span> <span class="string">&quot;com/example/MyClass&quot;</span><span class="punctuation">,</span></span><br><span class="line">|        innerName<span class="punctuation">:</span> <span class="string">&quot;InnerClass&quot;</span><span class="punctuation">,</span></span><br><span class="line">|        innerClassAccessFlags<span class="punctuation">:</span> <span class="number">0x0009</span> (PUBLIC | STATIC)</span><br><span class="line">|      <span class="punctuation">&#125;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; enclosingMethod<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">+---&gt; genericSignature<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">+---&gt; runtimeVisibleAnnotations<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      @java.lang.Deprecated<span class="punctuation">,</span></span><br><span class="line">|      @java.lang.SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; runtimeVisibleTypeAnnotations<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">+---&gt; bootstrapMethods<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">+---&gt; version<span class="punctuation">:</span> <span class="number">52.0</span></span><br><span class="line">+---&gt; minorVersion<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">+---&gt; majorVersion<span class="punctuation">:</span> <span class="number">52</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Meta Info  <span class="comment">// 仅供参考，存在错误</span></span><br><span class="line">|</span><br><span class="line">+---&gt; classMetadata<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">|      <span class="comment">// 包含上述Class信息的所有内容</span></span><br><span class="line">|    <span class="punctuation">&#125;</span></span><br><span class="line">+---&gt; methodMetadata<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      <span class="punctuation">&#123;</span></span><br><span class="line">|        methodName<span class="punctuation">:</span> <span class="string">&quot;&lt;init&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">|        compiledCode<span class="punctuation">:</span> &lt;native code address&gt;<span class="punctuation">,</span></span><br><span class="line">|        interpreterEntry<span class="punctuation">:</span> &lt;interpreter entry point&gt;<span class="punctuation">,</span></span><br><span class="line">|        nativeEntry<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">|        bytecodeSize<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">|        maxStack<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">|        maxLocals<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">|        exceptionTable<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">|        invocationCounter<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">|        backedgeCounter<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">|      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">|      <span class="punctuation">&#123;</span></span><br><span class="line">|        methodName<span class="punctuation">:</span> <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">|        <span class="comment">// ... similar structure to &lt;init&gt;</span></span><br><span class="line">|      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">|      <span class="punctuation">&#123;</span></span><br><span class="line">|        methodName<span class="punctuation">:</span> <span class="string">&quot;&lt;clinit&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">|        <span class="comment">// ... similar structure to &lt;init&gt;</span></span><br><span class="line">|      <span class="punctuation">&#125;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; fieldLayout<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      <span class="punctuation">&#123;</span>fieldName<span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span> offset<span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">|      <span class="punctuation">&#123;</span>fieldName<span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span> offset<span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">&#125;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; vtableLength<span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">+---&gt; vtable<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      &lt;address of Object.hashCode&gt;<span class="punctuation">,</span></span><br><span class="line">|      &lt;address of Object.equals&gt;<span class="punctuation">,</span></span><br><span class="line">|      &lt;address of Object.toString&gt;<span class="punctuation">,</span></span><br><span class="line">|      &lt;address of MyClass.run&gt;<span class="punctuation">,</span></span><br><span class="line">|      &lt;address of Object.finalize&gt;</span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; itableLength<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">+---&gt; itable<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      <span class="punctuation">&#123;</span></span><br><span class="line">|        interface<span class="punctuation">:</span> <span class="string">&quot;java/lang/Runnable&quot;</span><span class="punctuation">,</span></span><br><span class="line">|        methods<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|          <span class="punctuation">&#123;</span>methodName<span class="punctuation">:</span> <span class="string">&quot;run&quot;</span><span class="punctuation">,</span> methodAddress<span class="punctuation">:</span> &lt;address of MyClass.run&gt;<span class="punctuation">&#125;</span></span><br><span class="line">|        <span class="punctuation">]</span></span><br><span class="line">|      <span class="punctuation">&#125;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; instanceSize<span class="punctuation">:</span> <span class="number">24</span> bytes</span><br><span class="line">+---&gt; staticFieldValues<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">+---&gt; constantValueAttributes<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      <span class="punctuation">&#123;</span>fieldIndex<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> constantValue<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">&#125;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; methodHandles<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">+---&gt; exceptions<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">+---&gt; nestMembers<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">+---&gt; nestHost<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">+---&gt; permittedSubclasses<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">+---&gt; recordComponents<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br></pre></td></tr></table></figure>
<p><strong>静态变量 (Static Variables)：</strong></p>
<ul>
<li>静态变量的值和其描述信息（如字段名、类型等）都存储在<strong>方法区/元空间</strong>。更具体地说：
<ul>
<li>描述信息存储在方法区/元空间的 fieldTable 中。</li>
<li>值也存储在方法区/元空间中，与类的其他静态数据一起。</li>
</ul>
</li>
</ul>
<p>当 Java 代码访问静态变量时，会发生以下步骤:</p>
<ol>
<li>虚拟机根据变量名找到对应的 <strong>Class 对象</strong>。</li>
<li>在 Class 对象的 <strong>fieldTable</strong> 中找到该静态变量的 <strong>FieldInfo</strong> 结构体。</li>
<li><strong>直接从方法区/元空间</strong> 中读取该静态变量的值，而<strong>不需要通过内存地址间接访问</strong>。</li>
</ol>
<blockquote>
<p>一个类在 JVM 内存中对应一个运行时常量池！</p>
</blockquote>
<p><strong>运行时常量池 (Runtime Constant Pool)（多个）：</strong></p>
<ul>
<li><strong>运行时常量池是方法区的一部分</strong>，每个类或接口都对应一个运行时常量池。</li>
<li><strong>它是 Class 文件常量池的运行时表示形式。</strong></li>
<li>当类加载器将 Class 文件加载到内存时，会为该类创建运行时常量池，并将 Class 文件常量池中的内容加载到其中。</li>
</ul>
<p>运行时常量池中存储的内容主要包括：</p>
<ul>
<li><strong>字面量 (Literals):</strong> 例如数字、字符串、null 值等。</li>
<li><strong>符号引用 (Symbolic References):</strong> 例如类和接口的全限定名、字段名、方法名、方法描述符等。</li>
</ul>
<p>示例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">species</span> <span class="operator">=</span> <span class="string">&quot;Human&quot;</span>;  <span class="comment">// 静态变量</span></span><br><span class="line"> <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BRAND</span> <span class="operator">=</span> <span class="string">&quot;Tesla&quot;</span>; <span class="comment">// 静态常量</span></span><br><span class="line"> <span class="keyword">public</span> String model;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String model)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.model = model;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当这两个类都被加载到 JVM 中后，方法区中大致会存储以下信息：</strong></p>
<p><strong>1.  类信息:</strong></p>
<ul>
<li><code>Person</code> 类的类型信息： 包括类的完整名称 (<code>Person</code>)、父类 (<code>java.lang.Object</code>)、接口（无）、访问修饰符 (<code>public</code>) 等。</li>
<li><code>Car</code> 类的类型信息： 包括类的完整名称 (<code>Car</code>)、父类 (<code>java.lang.Object</code>)、接口（无）、访问修饰符 (<code>public</code>) 等。</li>
</ul>
<p><strong>2.  字段信息:</strong></p>
<ul>
<li><code>Person.species</code>:  字段名、类型 (<code>java.lang.String</code>)、访问修饰符 (<code>public static</code>)。</li>
<li><code>Person.name</code>:  字段名、类型 (<code>java.lang.String</code>)、访问修饰符 (<code>public</code>)。</li>
<li><code>Car.BRAND</code>:  字段名、类型 (<code>java.lang.String</code>)、访问修饰符 (<code>public static final</code>)。</li>
<li><code>Car.model</code>:  字段名、类型 (<code>java.lang.String</code>)、访问修饰符 (<code>public</code>)。</li>
</ul>
<p><strong>3. 方法信息:</strong></p>
<ul>
<li><code>Person</code> 类的构造方法和任何其他方法的名称、返回类型、参数列表、访问修饰符、方法体（字节码）。</li>
<li><code>Car</code> 类的构造方法和任何其他方法的名称、返回类型、参数列表、访问修饰符、方法体（字节码）。</li>
</ul>
<p><strong>4.  运行时常量池:</strong></p>
<blockquote>
<p>主要用于存储常量值（如字符串字面量的引用（<code>&quot;Human&quot;</code>的引用）、数字字面量（10）等），这些值在编译时已确定，不会发生改变。</p>
</blockquote>
<ul>
<li><code>Person</code> 类的运行时常量池： 包含字符串字面量的引用 <code>&quot;Human&quot;</code>、“name” 等，以及 <code>Person</code> 构造方法、<code>species</code> 字段的符号引用等。</li>
<li><code>Car</code> 类的运行时常量池： 包含字符串字面量的引用 <code>&quot;Tesla&quot;</code>、“model” 等，以及 <code>Car</code> 构造方法、<code>BRAND</code> 字段的符号引用等。</li>
</ul>
<p><strong>5.  静态变量:</strong></p>
<blockquote>
<p>存储于非堆，运行时可发送改变</p>
</blockquote>
<ul>
<li><code>Person.species</code>:  存储实际的值 <code>&quot;Human&quot;</code>。</li>
<li><code>Car.BRAND</code>:  存储实际的值 <code>&quot;Tesla&quot;</code>。</li>
</ul>
<p><strong>6. Class 对象:</strong></p>
<ul>
<li><code>Person.class</code> 对象：存储 <code>Person</code> 类的类型信息、字段信息、方法信息等的引用。</li>
<li><code>Car.class</code> 对象：存储 <code>Car</code> 类的类型信息、字段信息、方法信息等的引用。</li>
</ul>
<h4 id="Heap-堆"><strong>Heap (堆)</strong></h4>
<img src="/2025/01/17/Java/image-20240728103642872.png" class="" title="image-20240728103642872">
<p><strong>普通对象</strong></p>
<p><strong>Class对象</strong>！！！</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Class Object  <span class="comment">// 仅供参考，存在错误</span></span><br><span class="line">|</span><br><span class="line">+---&gt; classLoader<span class="punctuation">:</span> SystemClassLoader</span><br><span class="line">+---&gt; protectionDomain<span class="punctuation">:</span> ProtectionDomain <span class="punctuation">&#123;</span></span><br><span class="line">|      codeSource<span class="punctuation">:</span> CodeSource <span class="punctuation">&#123;</span> location<span class="punctuation">:</span> <span class="string">&quot;file:/path/to/MyClass.class&quot;</span><span class="punctuation">,</span> certs<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">|      permissions<span class="punctuation">:</span> Permissions <span class="punctuation">&#123;</span> ... <span class="punctuation">&#125;</span></span><br><span class="line">|    <span class="punctuation">&#125;</span></span><br><span class="line">+---&gt; className<span class="punctuation">:</span> <span class="string">&quot;com.example.MyClass&quot;</span></span><br><span class="line">+---&gt; packageName<span class="punctuation">:</span> <span class="string">&quot;com.example&quot;</span></span><br><span class="line">+---&gt; modifiers<span class="punctuation">:</span> <span class="number">0x0021</span> (PUBLIC | SUPER)</span><br><span class="line">+---&gt; superClass<span class="punctuation">:</span> Class object for <span class="string">&quot;java.lang.Object&quot;</span></span><br><span class="line">+---&gt; interfaces<span class="punctuation">:</span> <span class="punctuation">[</span>Class object for <span class="string">&quot;java.lang.Runnable&quot;</span><span class="punctuation">,</span> Class object for <span class="string">&quot;java.io.Serializable&quot;</span><span class="punctuation">]</span></span><br><span class="line">+---&gt; declaredFields<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      Field object for <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      Field object for <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      Field object for <span class="string">&quot;constValue&quot;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; declaredMethods<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      Method object for <span class="string">&quot;&lt;init&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">|      Method object for <span class="string">&quot;run&quot;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; declaredConstructors<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      Constructor object for <span class="string">&quot;&lt;init&gt;&quot;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; annotations<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      @java.lang.Deprecated<span class="punctuation">,</span></span><br><span class="line">|      @java.lang.SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; innerClasses<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">|      Class object for <span class="string">&quot;com.example.MyClass$InnerClass&quot;</span></span><br><span class="line">|    <span class="punctuation">]</span></span><br><span class="line">+---&gt; enclosingMethod<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">+---&gt; enclosingClass<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">+---&gt; genericInfo<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">+---&gt; typeParameters<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">+---&gt; enumConstants<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">+---&gt; classVersion<span class="punctuation">:</span> <span class="number">52.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Class 对象本身是 Java 对象，存储在堆上。Class 对象包含指向方法区/元空间的指针，用于访问类的元数据信息，例如 <code>fieldTable</code>, <code>methodTable</code>, <code>constantPool</code> 等。</p>
<ul>
<li><strong>methodTable 指针</strong>: Class 对象中的 methodTable 指针指向方法区/元空间中存储的方法信息数组。</li>
<li><strong>Runtime Constant Pool 指针</strong>: Class 对象包含一个指向运行时常量池的指针，该常量池也位于方法区/元空间。</li>
</ul>
</blockquote>
<p><strong>全局字符串池 (String Pool)（JDK7 以后）:</strong></p>
<ul>
<li><strong>全局字符串池</strong> 是 JVM 级别维护的字符串常量池，所有类共享。</li>
<li>每个类或接口都有自己的<strong>字符串常量池</strong>，存储在该类或接口的字节码文件中。</li>
<li>类加载时，类的字符串常量池中的字符串会被加载到全局字符串池中。</li>
<li>String.intern() 方法可以将一个字符串手动添加到全局字符串池中。</li>
</ul>
<p><strong>classLoader</strong>: 类加载器是 Java 对象，存储在堆上。</p>
<p><strong>protectionDomain</strong>: 保护域对象也是 Java 对象，存储在堆上。</p>
<p><strong>runtimeAnnotations</strong>: 运行时注解是 Java 对象，存储在堆上。</p>
<h4 id="Thread-线程"><strong>Thread (线程)</strong></h4>
<p><strong>虚拟机栈 (JVM Stack)</strong></p>
<ul>
<li><strong>每个线程私有</strong>，随着线程的创建而创建，销毁而销毁。</li>
<li><strong>存储 Java 方法执行的信息：</strong> 每个方法在执行时都会创建一个栈帧 (Stack Frame) 并压入虚拟机栈，栈帧中存储了：
<ul>
<li><strong>局部变量表 (Local Variable Array):</strong> 存储方法参数和方法内部定义的局部变量。</li>
<li><strong>操作数栈 (Operand Stack):</strong> 用于存储方法执行过程中产生的中间结果。</li>
<li><strong>动态链接 (Dynamic Linking):</strong> 存储方法返回值的地址、异常处理表等信息。</li>
</ul>
</li>
<li><strong>方法执行完后，对应的栈帧会出栈，释放内存空间。</strong></li>
<li><strong>如果线程请求的栈深度超过了虚拟机栈所允许的最大深度，会抛出 StackOverflowError 异常。</strong></li>
<li><strong>如果虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</strong></li>
</ul>
<p><strong>本地方法栈 (Native Method Stack)</strong></p>
<ul>
<li><strong>与虚拟机栈类似，也是线程私有的。</strong></li>
<li><strong>为 native 方法服务：</strong> native 方法是指使用 Java 以外的语言（例如 C/C++）编写的方法。</li>
<li><strong>不同的虚拟机实现方式不同：</strong> 有些虚拟机（例如 HotSpot VM）直接将本地方法栈和虚拟机栈合二为一。</li>
</ul>
<p><strong>程序计数器 (Program Counter Register)</strong></p>
<p>记录当前线程执行的字节码指令地址。</p>
<blockquote>
<p>协程</p>
</blockquote>
<h3 id="GC">GC</h3>
<img src="/2025/01/17/Java/image-20240728103642872.png" class="" title="image-20240728103642872">
<h4 id="堆内存划分"><strong>堆内存划分</strong></h4>
<p>Java 的堆内存主要被划分为两个区域：</p>
<ul>
<li><strong>新生代 (Young Generation) 4 Minor GC:</strong>  存放新创建的对象。由于大多数对象的生命周期都比较短，因此新生代的空间相对较小，垃圾回收也比较频繁。新生代又可以细分为三个区域：
<ul>
<li><strong>Eden 区:</strong> 新创建的对象首先被分配到这里, 空间不足时触发Minor GC</li>
<li><strong>Survivor 区 (From, To) 4 Major GC:</strong>  经历过一次 Minor GC 后仍然存活的对象会被复制到 Survivor 区。新生代有两个 Survivor 区，每次 Minor GC 只使用其中一个，另一个处于闲置状态。<strong>复制算法</strong></li>
</ul>
</li>
<li><strong>老年代 (Old Generation):</strong>  存放生命周期较长的对象，例如缓存数据、数据库连接等。老年代的空间比较大，垃圾回收频率也相对较低。<strong>标记-清除/标记-整理算法</strong></li>
</ul>
<h4 id="垃圾收集类型">垃圾收集类型</h4>
<blockquote>
<p>传统垃圾收集器（大部分阶段）会触发STW，现代低延迟垃圾收集器（小阶段）触发STW</p>
</blockquote>
<p>Java 中的垃圾收集主要分为两大类：</p>
<ul>
<li>
<p><strong>部分收集 (Partial GC):</strong>  只收集部分堆内存空间，频率较高。</p>
<ul>
<li>
<p><strong>新生代收集 (Minor GC/Young GC):</strong>  回收 Eden 区和一个 Survivor 区 (From Survivor 区) 的对象。</p>
<p>触发条件：</p>
<ul>
<li>当 Eden 区空间不足时就会触发 Minor GC。</li>
</ul>
</li>
<li>
<p><strong>老年代收集 (Major GC/Old GC):</strong>  收集老年代的垃圾。</p>
<p>触发条件：</p>
<ul>
<li>老年代空间不足。</li>
<li>Minor GC 后存活的对象晋升到老年代，导致老年代空间不足。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>整堆收集 (Full GC):</strong>  收集整个堆内存空间的垃圾，包括新生代，老年代，永久代/元空间。Full GC 的频率很低，但是执行时间比较长，会造成应用程序的停顿。</p>
</li>
</ul>
<blockquote>
<p><strong>JDK6 update 24 后回收规则</strong></p>
<p>在 JDK6 update 24 之后，为了更好地控制 Full GC 的触发时机，引入了新的回收规则：</p>
<p><strong>只要老年代的连续空间大于新生代空间总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</strong></p>
<ul>
<li><strong>老年代的连续空间:</strong>  指老年代中最大的一块连续可用空间。</li>
<li><strong>新生代空间总大小:</strong>  指 Eden 区和两个 Survivor 区的总大小。</li>
<li><strong>历次晋升的平均大小:</strong>  指历次 Minor GC 后晋升到老年代的对象的平均大小。</li>
</ul>
<p><strong>该规则的意义:</strong></p>
<ul>
<li>尽可能避免 Full GC 的发生，因为 Full GC 的成本很高。</li>
<li>当老年代的连续空间不足以容纳新生代的对象时，即使进行 Minor GC 也无法避免 Full GC，因此直接进行 Full GC 反而效率更高。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>永久代垃圾回收</strong></p>
<p>永久代内存区域也会进行垃圾回收。永久代的垃圾收集主要包废弃常量和无用的类（被类加载器卸载的Class）。永久代触发垃圾回收的条件比较困难，需要同时满足以下三点：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>
<li>加载该类的ClassLoader已经被回收；</li>
<li>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；</li>
</ul>
</blockquote>
<h4 id="对象转移">对象转移</h4>
<p><strong>对象晋升</strong></p>
<p>当 Eden 区空间不足时，会触发 Minor GC。Minor GC 会将 Eden 区中存活的对象复制到 Survivor 区。如果 Survivor 区也满了，则会将部分存活的对象晋升到老年代。</p>
<p><strong>晋升规则:</strong></p>
<ul>
<li>每个对象都有一个年龄计数器，每经历一次 Minor GC，年龄计数器就加 1。当对象的年龄达到一定阈值 (默认是 15) 时，就会被晋升到老年代。</li>
<li>如果 Survivor 区中相同年龄的对象总大小超过 Survivor 区空间的一半，则年龄大于等于该年龄的对象也会被晋升到老年代。！！！</li>
</ul>
<h4 id="垃圾回收算法"><strong>垃圾回收算法</strong></h4>
<p>在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。</p>
<p><strong>标记算法：引用计数算法</strong></p>
<blockquote>
<p>Java垃圾回收没有采用该方法</p>
</blockquote>
<p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p>缺点：</p>
<ol>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li>
<li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ol>
<p>参考链接：<a href="https://juejin.cn/post/6981812825735987208">https://juejin.cn/post/6981812825735987208</a></p>
<p><strong>标记算法：可达性分析算法</strong></p>
<blockquote>
<p>Java垃圾回收使用了该算法</p>
</blockquote>
<p>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></p>
<p>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</p>
<p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</p>
<p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
<img src="/2025/01/17/Java/image-20240814154833539.png" class="" title="image-20240814154833539">
<blockquote>
<p>GC Roots 可以是以下元素：</p>
<p><strong>虚拟机栈中引用的对象</strong></p>
<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
<p>本地方法栈内JNI（通常说的本地方法）引用的对象</p>
<p><strong>方法区中类静态属性引用的对象</strong></p>
<ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
<p><strong>方法区中常量引用的对象</strong></p>
<ul>
<li>比如：字符串常量池（StringTable）里的引用</li>
</ul>
<p><strong>所有被同步锁synchronized持有的对象</strong></p>
<p><strong>Java虚拟机内部的引用</strong></p>
<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li>
</ul>
<p><strong>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</strong></p>
</blockquote>
<p>参考链接：<a href="https://juejin.cn/post/6981812825735987208">https://juejin.cn/post/6981812825735987208</a></p>
<p><strong>清除算法：标记-清除算法</strong></p>
<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>
<ol>
<li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
<ul>
<li>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li>
</ul>
</li>
<li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
</ol>
<img src="/2025/01/17/Java/image-20240814161729364.png" class="" title="image-20240814161729364">
<blockquote>
<p>被清除的对象实际上是被加入到了空闲内存列表，下次分配内存时该区域为可用区域，直接覆盖写入新内容</p>
</blockquote>
<p><strong>清除算法：复制算法</strong></p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<img src="/2025/01/17/Java/image-20240814161933420.png" class="" title="image-20240814161933420">
<p><strong>新生代垃圾回收使用复制算法，Eden区和S0区存活对象整体复制到S1区</strong></p>
<img src="/2025/01/17/Java/image-20240814162137394.png" class="" title="image-20240814162137394">
<p><strong>清除算法：标记-压缩算法</strong></p>
<p>标记-压缩算法 等价于进行 标记-清除算法+内存碎片整理</p>
<ol>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</li>
</ol>
<img src="/2025/01/17/Java/image-20240814162220131.png" class="" title="image-20240814162220131">
<h4 id="常见垃圾收集器">常见垃圾收集器</h4>
<hr>
<blockquote>
<p>年轻代垃圾收集器</p>
</blockquote>
<p><strong>Serial GC</strong></p>
<ul>
<li><strong>特点</strong>：单线程、使用“复制算法”进行垃圾回收。</li>
<li><strong>工作方式</strong>：仅使用一个线程进行垃圾收集，会<strong>暂停所有应用线程</strong>（Stop-The-World，STW）。</li>
<li><strong>优点</strong>：简单高效，适合单线程或小内存环境。</li>
<li><strong>适用场景</strong>：桌面应用、小型应用、单核CPU。</li>
<li><strong>配置参数</strong>：<code>-XX:+UseSerialGC</code>。</li>
</ul>
<p><strong>ParNew GC</strong></p>
<ul>
<li><strong>特点</strong>：多线程版的Serial GC，使用“复制算法”。</li>
<li><strong>工作方式</strong>：通过多线程并行回收年轻代，依然存在STW。</li>
<li><strong>优点</strong>：适合多核CPU环境，常与老年代的CMS GC搭配。</li>
<li><strong>适用场景</strong>：多线程应用程序。</li>
<li><strong>配置参数</strong>：<code>-XX:+UseParNewGC</code>。</li>
</ul>
<p><strong>Parallel Scavenge GC</strong></p>
<ul>
<li><strong>特点</strong>：多线程、注重<strong>吞吐量</strong>，使用“复制算法”。</li>
<li><strong>工作方式</strong>：多线程并行回收，优化吞吐量（GC时间与应用运行时间的比值）。</li>
<li><strong>优点</strong>：可调节GC暂停时间与吞吐量之间的平衡。</li>
<li><strong>适用场景</strong>：需要高吞吐量的后台应用程序。</li>
<li><strong>配置参数</strong>：<code>-XX:+UseParallelGC</code>。</li>
<li>常用调优参数：
<ul>
<li><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code>：设置最大GC暂停时间。</li>
<li><code>-XX:GCTimeRatio=&lt;N&gt;</code>：设置吞吐量比例。</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>老年代垃圾收集器</p>
</blockquote>
<p><strong>Serial Old GC</strong></p>
<ul>
<li><strong>特点</strong>：Serial GC的老年代版本，使用<strong>标记-整理算法</strong>。</li>
<li><strong>工作方式</strong>：单线程，存在STW。</li>
<li><strong>适用场景</strong>：单线程或小型应用，或与年轻代的Serial GC搭配。</li>
<li><strong>配置参数</strong>：<code>-XX:+UseSerialOldGC</code>。</li>
</ul>
<p><strong>CMS (Concurrent Mark-Sweep) GC</strong></p>
<ul>
<li><strong>特点</strong>：低延迟、并发回收，使用<strong>标记-清除算法</strong>。</li>
<li><strong>工作方式</strong>：通过多个阶段（初始标记、并发标记、重新标记、并发清除）回收垃圾。</li>
<li><strong>优点</strong>：降低STW时间，适合低延迟应用。</li>
<li><strong>缺点</strong>：可能产生<strong>碎片化</strong>，需要触发<strong>Full GC</strong>。</li>
<li><strong>适用场景</strong>：对响应时间敏感的应用。</li>
<li><strong>配置参数</strong>：<code>-XX:+UseConcMarkSweepGC</code>。</li>
<li>常用调优参数：
<ul>
<li><code>-XX:CMSInitiatingOccupancyFraction=&lt;N&gt;</code>：设置老年代使用率达到多少时触发GC。</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>整堆垃圾收集器</p>
</blockquote>
<p><strong>G1 (Garbage First) GC</strong></p>
<ul>
<li><strong>特点</strong>：分区收集，使用<strong>混合算法</strong>（标记-整理为主，标记-清除为辅）。</li>
<li><strong>工作方式</strong>：将堆划分为多个独立的区域（Region），并优先回收垃圾最多的区域。</li>
<li><strong>优点</strong>：可控的GC暂停时间，减少碎片化。</li>
<li><strong>适用场景</strong>：需要大内存且要求低延迟的应用。</li>
<li><strong>配置参数</strong>：<code>-XX:+UseG1GC</code>。</li>
<li>常用调优参数：
<ul>
<li><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code>：设置目标最大暂停时间。</li>
</ul>
</li>
</ul>
<p><strong>ZGC (Z Garbage Collector)</strong></p>
<ul>
<li><strong>特点</strong>：超低延迟、使用<strong>标记-移动算法</strong>，几乎不受堆大小影响。</li>
<li><strong>工作方式</strong>：通过并发标记和整理，确保STW时间通常在<strong>几毫秒内</strong>。</li>
<li><strong>优点</strong>：支持非常大的堆内存（TB级），适合极低延迟需求。</li>
<li><strong>缺点</strong>：内存占用稍高。</li>
<li><strong>适用场景</strong>：金融系统、在线交易系统等高实时性场景。</li>
<li><strong>配置参数</strong>：<code>-XX:+UseZGC</code>。</li>
<li>常用调优参数：
<ul>
<li><code>-XX:MaxHeapSize=&lt;size&gt;</code>：设置最大堆内存。</li>
</ul>
</li>
</ul>
<p><strong>Shenandoah GC</strong></p>
<ul>
<li><strong>特点</strong>：低延迟、并发回收，使用<strong>标记-整理算法</strong>。</li>
<li><strong>工作方式</strong>：与ZGC类似，目标是最小化STW时间。</li>
<li><strong>优点</strong>：支持大堆内存，延迟极低。</li>
<li><strong>适用场景</strong>：高实时性应用。</li>
<li><strong>配置参数</strong>：<code>-XX:+UseShenandoahGC</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>GC</th>
<th>主要算法</th>
<th>多线程支持</th>
<th>优势</th>
<th>劣势</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial</td>
<td>复制算法</td>
<td>否</td>
<td>简单高效</td>
<td>暂停时间长</td>
<td>单线程、小型应用</td>
</tr>
<tr>
<td>ParNew</td>
<td>复制算法</td>
<td>是</td>
<td>并行回收年轻代</td>
<td>STW时间仍存在</td>
<td>多线程环境</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>复制算法</td>
<td>是</td>
<td>高吞吐量</td>
<td>暂停时间不确定</td>
<td>后台批量处理应用</td>
</tr>
<tr>
<td>Serial Old</td>
<td>标记-整理算法</td>
<td>否</td>
<td>简单高效</td>
<td>单线程</td>
<td>搭配Serial GC</td>
</tr>
<tr>
<td>CMS</td>
<td>标记-清除算法</td>
<td>是</td>
<td>低延迟、并发回收</td>
<td>内存碎片</td>
<td>响应时间敏感的应用</td>
</tr>
<tr>
<td>G1</td>
<td>标记-整理算法</td>
<td>是</td>
<td>可控延迟、减少碎片化</td>
<td>调优复杂</td>
<td>大堆内存、低延迟需求</td>
</tr>
<tr>
<td>ZGC</td>
<td>标记-移动算法</td>
<td>是</td>
<td>超低延迟</td>
<td>内存开销高</td>
<td>超大内存、极低延迟场景</td>
</tr>
<tr>
<td>Shenandoah</td>
<td>标记-整理算法</td>
<td>是</td>
<td>超低延迟</td>
<td>内存使用率高</td>
<td>低延迟场景</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>reinforce-learning-record</title>
    <url>/2024/06/10/reinforce-learning-record/</url>
    <content><![CDATA[<p>reinforce learning</p>
<span id="more"></span>
<h1>reinforce learning record</h1>
<h2 id="数学基础">数学基础</h2>
<p>一阶优化与二阶优化</p>
<p>在优化问题中，<strong>一阶优化算法</strong>和<strong>二阶优化算法</strong>是两类重要的优化方法，它们主要区别在于利用了目标函数的哪些信息：</p>
<p><strong>一阶优化算法</strong></p>
<ul>
<li><strong>定义</strong>：一阶优化算法仅利用目标函数的一阶导数（梯度）信息进行优化。</li>
<li><strong>特点</strong>：
<ol>
<li><strong>梯度信息</strong>：依赖梯度来指引优化方向。</li>
<li><strong>计算成本低</strong>：梯度的计算通常比二阶导数（Hessian矩阵）简单，因此更高效。</li>
<li><strong>适用性广</strong>：常用于高维问题或目标函数复杂的情况。</li>
</ol>
</li>
<li><strong>常见算法</strong>：
<ul>
<li><strong>梯度下降法（Gradient Descent, GD）</strong>：$ x_{k+1} = x_k - \eta \nabla f(x_k)$ 其中，$\eta$ 是学习率，$\nabla f(x_k)$ 是目标函数在 $x_k$ 处的梯度。</li>
<li><strong>随机梯度下降（SGD）</strong>：在大规模数据下随机选择小批量样本计算梯度，适合机器学习训练。</li>
<li><strong>动量法（Momentum）</strong>、<strong>Adam优化器</strong>：改进了基础的梯度下降，具有更快的收敛速度。</li>
</ul>
</li>
</ul>
<p><strong>二阶优化算法</strong></p>
<ul>
<li>
<p><strong>定义</strong>：二阶优化算法利用目标函数的一阶导数（梯度）和二阶导数（Hessian矩阵）信息。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ol>
<li><strong>曲率信息</strong>：Hessian矩阵包含关于目标函数曲率的信息，因此二阶优化算法能够更准确地找到极值点。</li>
<li><strong>更快收敛</strong>：在理想条件下，具有二次收敛速度。</li>
<li><strong>计算成本高</strong>：Hessian矩阵的计算和存储对于高维问题非常昂贵。</li>
</ol>
</li>
<li>
<p><strong>常见算法</strong>：</p>
<ul>
<li><strong>牛顿法（Newton’s Method）</strong>：使二阶泰勒展开式的导数为0的点，迭代至$\nabla f(x_k)$为极小，$x_{k+1} = x_k - [\nabla^2 f(x_k)]^{-1} \nabla f(x_k)$ ，其中，$[\nabla^2 f(x_k)]^{-1}$ 是Hessian矩阵的逆。</li>
<li><strong>拟牛顿法（Quasi-Newton Methods）</strong>：通过近似Hessian矩阵降低计算复杂度，例如 BFGS 和 L-BFGS。</li>
<li><strong>信赖域方法（Trust Region Methods）</strong>：结合Hessian信息限制更新步长，适合复杂非线性优化。</li>
</ul>
</li>
</ul>
<h2 id="机器学习模型">机器学习模型</h2>
<img src="/2024/06/10/reinforce-learning-record/00e7457c373413b80db70c958566dd84.png" class="" title="ma learning">
<h2 id="MRP">MRP</h2>
<img src="/2024/06/10/reinforce-learning-record/image-20240610205131367.png" class="" title="image-20240610205131367">
<h3 id="回报">回报</h3>
<p>在一个马尔可夫奖励过程中，从第t时刻状态 S_t 开始，直到终止状态时，所有奖励的衰减之和称为<strong>回报</strong>（Return），表示为 G_t</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610203108806.png" class="" title="image-20240610203108806">
<ul>
<li>R_t表示在时刻t获得的奖励</li>
<li><strong>到达状态S_i</strong>，得到奖励r(s)；若在时刻t到达状态S_i，则<strong>R_t=r(S_i)</strong></li>
<li>对于某状态序列<img src="/2024/06/10/reinforce-learning-record/image-20240610203423677.png" class="" title="image-20240610203423677">我们有对应于该状态序列的奖励G<img src="/2024/06/10/reinforce-learning-record/image-20240610203434567.png" class="" title="image-20240610203434567"></li>
</ul>
<h3 id="价值函数">价值函数</h3>
<p>在马尔可夫奖励过程中，一个状态的期望回报（即从这个状态出发的未来累积奖励的期望）被称为这个状态的<strong>价值</strong>（value）。所有状态的价值就组成了<strong>价值函数</strong>（value function），价值函数的输入为某个状态，输出为这个状态的价值。</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610203509585.png" class="" title="image-20240610203509585">
<ul>
<li>对于某个状态s，从该状态出发可得到的状态序列有很多条</li>
<li>对于某个状态s，价值函数为<strong>从该状态出发，可能存在的所有状态序列的奖励的均值</strong></li>
</ul>
<p>贝尔曼方程</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610203841177.png" class="" title="image-20240610203841177">
<h2 id="MDP">MDP</h2>
<p>与MRP相比，奖励与状态和动作相关</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610205112917.png" class="" title="image-20240610205112917">
<h3 id="策略">策略</h3>
<p>策略表示在状态s下采取动作a的<strong>概率</strong>，为<strong>概率</strong>，可能为1</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610204522539.png" class="" title="image-20240610204522539">
<h3 id="状态价值函数">状态价值函数</h3>
<p>在 MDP 中基于策略 $\pi$ 的状态价值函数（state-value function），定义为从状态s出发遵循策略Π能获得的期望回报</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610204014373.png" class="" title="image-20240610204014373">
<blockquote>
<p>价值是回报的期望</p>
<p>下标 π 用来<strong>指明这个期望是在什么概率分布下计算的</strong>。</p>
<ul>
<li>在概率论和统计中，期望算子的下标通常用来表示期望是关于哪个随机变量的分布，或者是在哪个参数（定义了分布）的条件下计算的。例如，$E_X[f(X)]$ 表示对随机变量 $X$ 的函数 $f(X)$ 求期望，其中 $X$ 的分布是已知的。</li>
</ul>
</blockquote>
<h3 id="动作价值函数">动作价值函数</h3>
<p>在 MDP 中，由于动作的存在，我们额外定义一个<strong>动作价值函数</strong>（action-value function）。表示在 MDP 遵循策略Π时，对当前状态s执行动作a得到的期望回报</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610204152914.png" class="" title="image-20240610204152914">
<ul>
<li><strong>采取动作a到达状态s</strong>，得到奖励R</li>
</ul>
<h3 id="状态价值函数与动作价值函数关系">状态价值函数与动作价值函数关系</h3>
<img src="/2024/06/10/reinforce-learning-record/image-20240610213003398.png" class="" title="image-20240610213003398">
<ul>
<li>从状态s出发，可能采取动作a1, a2, a3, …;对于每个可能采取的动作，均有动作价值Q，则状态s的状态价值为所有动作价值的期望</li>
</ul>
<img src="/2024/06/10/reinforce-learning-record/image-20240610213050168.png" class="" title="image-20240610213050168">
<ul>
<li>在状态s执行动作a后，得到奖励r(s,a)；由于可能到达多个不同的状态s’，动作价值为即时奖励r(s,a)+可能到达的所有状态的价值的期望</li>
</ul>
<h3 id="最优策略">最优策略</h3>
<p>策略之间的偏序关系</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612093758370.png" class="" title="image-20240612093758370">
<p>最优策略为 对于任意的策略，均有最优策略优于或不差于其他策略</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612093948192.png" class="" title="image-20240612093948192">
<img src="/2024/06/10/reinforce-learning-record/image-20240612093958259.png" class="" title="image-20240612093958259">
<p>最优状态价值与最优动作价值的关系</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612094048209.png" class="" title="image-20240612094048209">
<h3 id="贝尔曼期望方程">贝尔曼期望方程</h3>
<p>采取策略Π</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610204627264.png" class="" title="image-20240610204627264">
<ul>
<li>对于状态s，s的状态价值为 ( 折损的 <strong>所有可达的下一状态的价值的期望</strong> + <strong>到达所有可达的下一状态的r(s’,a)的期望</strong> )</li>
<li>对于状态s和动作a，在状态s进行动作a的价值为 ( <strong>在状态s执行动作a的r(s,a)的期望</strong>(实际上就是r(s,a)) + 折损的 <strong>在执行动作a后所有可达的下一状态的所有可执行动作的价值的期望</strong> )</li>
</ul>
<img src="/2024/06/10/reinforce-learning-record/shiow.PNG" class="" title="shiow">
<p>图中情况为每个动作只会到达一个状态&amp;应该直接将动作视为一个节点，图为树</p>
<br>
<h3 id="贝尔曼最优方程">贝尔曼最优方程</h3>
<p>存在策略*，使对于任意的状态s，均有基于策略*状态价值函数大于基于策略Π的状态价值函数</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610205402396.png" class="" title="image-20240610205402396">
<ul>
<li>对于状态价值：非最优形式是求期望，最优形式是直接选取当前状态，所有动作中，未来状态序列中价值最大的</li>
<li>对于动作价值：非最优形式是求期望，最优形式是直接选取下一状态，所有动作中，未来状态序列中动作价值最大的</li>
</ul>
<br>
<h3 id="状态访问分布">状态访问分布</h3>
<p>状态访问分布定义<br>
$$<br>
\nu^{\pi_\theta}(s) = (1-\gamma)\sum_{k=0}^\infty \gamma^k Pr(s_k=s|s_0,\pi_\theta)<br>
$$<br>
补充：</p>
<p>在策略梯度定理中，$ν^{π_θ}(s)$ <strong>被定义为</strong> $η(s) / ∑_{s’} η(s’)$。<br>
$$<br>
η(s) = ∑_{k=0}^∞ γ^k d^{π_θ}(s_0 → s, k)<br>
$$</p>
<p>$$<br>
\begin{aligned}<br>
\sum_s \eta(s)<br>
&amp;= \sum_s \mathbb{E}<em>{s_0}\left[\sum</em>{k=0}^{\infty} \gamma^k P(S_k = s | S_0 = s_0, \pi_\theta)\right]<br>
\\<br>
&amp;= \mathbb{E}<em>{s_0}\left[\sum_s \sum</em>{k=0}^{\infty} \gamma^k P(S_k = s | S_0 = s_0, \pi_\theta)\right]<br>
\\<br>
&amp;= \mathbb{E}<em>{s_0}\left[\sum</em>{k=0}^{\infty} \sum_s \gamma^k P(S_k = s | S_0 = s_0, \pi_\theta)\right]<br>
\\<br>
&amp;= \mathbb{E}<em>{s_0}\left[\sum</em>{k=0}^{\infty} \gamma^k \left(\sum_s P(S_k = s | S_0 = s_0, \pi_\theta)\right)\right]<br>
\\<br>
&amp;= \mathbb{E}<em>{s_0}\left[\sum</em>{k=0}^{\infty} \gamma^k \cdot 1\right]<br>
\\<br>
&amp;= \mathbb{E}<em>{s_0}\left[\sum</em>{k=0}^{\infty} \gamma^k\right]<br>
\\<br>
&amp;= \mathbb{E}_{s_0}\left[\frac{1}{1 - \gamma}\right]<br>
\\<br>
&amp;= \frac{1}{1 - \gamma}</p>
<p>\end{aligned}<br>
$$</p>
<br>
<h2 id="策略迭代算法-基于策略函数的">策略迭代算法/基于策略函数的</h2>
<blockquote>
<p>策略迭代的核心思想是<strong>交替进行策略评估和策略提升</strong>，直到策略收敛到最优。</p>
</blockquote>
<p><strong>策略评估：</strong></p>
<p>基于当前策略Π，在已知状态转移函数的情况下（即我们可以知道采取动作a后有多高的几率到达哪个状态），使用<strong>贝尔曼期望方程</strong>迭代更新状态价值函数</p>
<p>ps: 原文中迭代更新状态价值函数是通过</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610213050168.png" class="" title="image-20240610213050168">
<img src="/2024/06/10/reinforce-learning-record/image-20240610213003398.png" class="" title="image-20240610213003398">
<p>以上两个公式实现的，也即</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qsa_list = []</span><br><span class="line">	<span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  <span class="comment"># 迷宫环境，四相运动</span></span><br><span class="line">		qsa = <span class="number">0</span>  <span class="comment"># 当前动作的动作价值</span></span><br><span class="line">        <span class="keyword">for</span> res <span class="keyword">in</span> self.env.P[s][a]:  <span class="comment"># 有模型，即状态转移函数已知</span></span><br><span class="line">        	p, next_state, r, done = res</span><br><span class="line">            qsa += p * (r + self.gamma * self.v[next_state] * (<span class="number">1</span> - done))  <span class="comment"># 第一个公式，计算该动作的价值(开头的p为动作成功概率)</span></span><br><span class="line">         qsa_list.append(self.pi[s][a] * qsa)  <span class="comment"># 乘采取该动作的几率</span></span><br><span class="line">	new_v[s] = <span class="built_in">sum</span>(qsa_list)  <span class="comment"># 第二个公式，根据所有动作的价值计算状态价值</span></span><br></pre></td></tr></table></figure>
<br>
<p><strong>策略提升：</strong></p>
<p>由于</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610213003398.png" class="" title="image-20240610213003398">
<p>故修改策略，使得动作价值最大的动作以更高的概率(若最大值唯一，该动作将成为唯一被选取动作；若不唯一，这些动作将均分概率1)被选取，可使新策略下的状态价值函数增大，也即<img src="/2024/06/10/reinforce-learning-record/image-20240611150030644.png" class="" title="image-20240611150030644"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qsa_list = []</span><br><span class="line">	<span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  <span class="comment"># 迷宫环境，四相运动</span></span><br><span class="line">    	qsa = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> res <span class="keyword">in</span> self.env.P[s][a]:</span><br><span class="line">        	p, next_state, r, done = res</span><br><span class="line">            qsa += p * (r + self.gamma * self.v[next_state] * (<span class="number">1</span> - done))</span><br><span class="line">        qsa_list.append(qsa)</span><br><span class="line">     maxq = <span class="built_in">max</span>(qsa_list)</span><br><span class="line">     cntq = qsa_list.count(maxq)  <span class="comment"># 计算有几个动作得到了最大的Q值</span></span><br><span class="line">     <span class="comment"># 让这些动作均分概率</span></span><br><span class="line">     self.pi[s] = [<span class="number">1</span> / cntq <span class="keyword">if</span> q == maxq <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> q <span class="keyword">in</span> qsa_list]</span><br></pre></td></tr></table></figure>
<p>target: 修改<strong>策略</strong>，使在新策略下，有基于新策略的状态价值函数大于原策略的状态价值函数</p>
<br>
<p>完整策略迭代算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PolicyIteration</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 策略迭代算法 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, env, theta, gamma</span>):</span><br><span class="line">        <span class="comment"># 初始化函数，接受环境对象env、策略评估收敛阈值theta和折扣因子gamma</span></span><br><span class="line">        self.env = env  <span class="comment"># 保存环境对象</span></span><br><span class="line">        self.v = [<span class="number">0</span>] * self.env.ncol * self.env.nrow  <span class="comment"># 初始化价值函数v为0，大小为环境的格子数</span></span><br><span class="line">        self.pi = [[<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>]</span><br><span class="line">                   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.env.ncol * self.env.nrow)]  <span class="comment"># 初始化策略pi为均匀随机策略，每个状态有4个动作，每个动作的概率为0.25</span></span><br><span class="line">        self.theta = theta  <span class="comment"># 策略评估的收敛阈值</span></span><br><span class="line">        self.gamma = gamma  <span class="comment"># 折扣因子，用于计算未来奖励的折扣</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">policy_evaluation</span>(<span class="params">self</span>):  <span class="comment"># 策略评估</span></span><br><span class="line">        cnt = <span class="number">1</span>  <span class="comment"># 计数器，记录策略评估的迭代次数</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            max_diff = <span class="number">0</span>  <span class="comment"># 用于记录价值函数的最大变化量</span></span><br><span class="line">            new_v = [<span class="number">0</span>] * self.env.ncol * self.env.nrow  <span class="comment"># 初始化新的价值函数</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(self.env.ncol * self.env.nrow):  <span class="comment"># 当次地图扫描</span></span><br><span class="line">                qsa_list = []  <span class="comment"># 用于存储状态s下所有动作的Q值</span></span><br><span class="line">                <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  <span class="comment"># 遍历所有动作</span></span><br><span class="line">                    qsa = <span class="number">0</span>  <span class="comment"># 初始化Q(s,a)为0</span></span><br><span class="line">                    <span class="keyword">for</span> res <span class="keyword">in</span> self.env.P[s][a]:  <span class="comment"># 遍历状态s下执行动作a的所有可能结果</span></span><br><span class="line">                        p, next_state, r, done = res  <span class="comment"># 获取转移概率p、下一个状态next_state、奖励r和是否终止done</span></span><br><span class="line">                        qsa += p * (r + self.gamma * self.v[next_state] * (<span class="number">1</span> - done))  <span class="comment"># 计算Q(s,a)的值，考虑折扣因子gamma</span></span><br><span class="line">                    qsa_list.append(self.pi[s][a] * qsa)  <span class="comment"># 将Q(s,a)乘以策略pi(s,a)并加入列表</span></span><br><span class="line">                new_v[s] = <span class="built_in">sum</span>(qsa_list)  <span class="comment"># 计算状态s的新价值函数值</span></span><br><span class="line">                max_diff = <span class="built_in">max</span>(max_diff, <span class="built_in">abs</span>(new_v[s] - self.v[s]))  <span class="comment"># 更新当次地图扫描中最大变化量</span></span><br><span class="line">            self.v = new_v  <span class="comment"># 更新价值函数</span></span><br><span class="line">            <span class="keyword">if</span> max_diff &lt; self.theta: <span class="keyword">break</span>  <span class="comment"># 如果最大变化量小于阈值theta，则退出循环</span></span><br><span class="line">            cnt += <span class="number">1</span>  <span class="comment"># 增加迭代次数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;策略评估进行%d轮后完成&quot;</span> % cnt)  <span class="comment"># 打印策略评估的迭代次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">policy_improvement</span>(<span class="params">self</span>):  <span class="comment"># 策略提升</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(self.env.nrow * self.env.ncol):  <span class="comment"># 遍历所有状态</span></span><br><span class="line">            qsa_list = []  <span class="comment"># 用于存储状态s下所有动作的Q值</span></span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  <span class="comment"># 遍历所有动作</span></span><br><span class="line">                qsa = <span class="number">0</span>  <span class="comment"># 初始化Q(s,a)为0</span></span><br><span class="line">                <span class="keyword">for</span> res <span class="keyword">in</span> self.env.P[s][a]:  <span class="comment"># 遍历状态s下执行动作a的所有可能结果</span></span><br><span class="line">                    p, next_state, r, done = res  <span class="comment"># 获取转移概率p、下一个状态next_state、奖励r和是否终止done</span></span><br><span class="line">                    qsa += p * (r + self.gamma * self.v[next_state] * (<span class="number">1</span> - done))  <span class="comment"># 计算Q(s,a)的值，考虑折扣因子gamma</span></span><br><span class="line">                qsa_list.append(qsa)  <span class="comment"># 将Q(s,a)加入列表</span></span><br><span class="line">            maxq = <span class="built_in">max</span>(qsa_list)  <span class="comment"># 找到状态s下所有动作的最大Q值</span></span><br><span class="line">            cntq = qsa_list.count(maxq)  <span class="comment"># 计算有多少个动作得到了最大Q值</span></span><br><span class="line">            <span class="comment"># 让这些动作均分概率，其他动作的概率为0</span></span><br><span class="line">            self.pi[s] = [<span class="number">1</span> / cntq <span class="keyword">if</span> q == maxq <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> q <span class="keyword">in</span> qsa_list]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;策略提升完成&quot;</span>)  <span class="comment"># 打印策略提升完成</span></span><br><span class="line">        <span class="keyword">return</span> self.pi  <span class="comment"># 返回更新后的策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">policy_iteration</span>(<span class="params">self</span>):  <span class="comment"># 策略迭代</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            self.policy_evaluation()  <span class="comment"># 进行策略评估</span></span><br><span class="line">            old_pi = copy.deepcopy(self.pi)  <span class="comment"># 深拷贝当前策略，用于比较</span></span><br><span class="line">            new_pi = self.policy_improvement()  <span class="comment"># 进行策略提升</span></span><br><span class="line">            <span class="keyword">if</span> old_pi == new_pi: <span class="keyword">break</span>  <span class="comment"># 如果策略不再变化，则退出循环</span></span><br><span class="line">                </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_agent</span>(<span class="params">agent, action_meaning, disaster=[], end=[]</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;状态价值：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(agent.env.nrow):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(agent.env.ncol):</span><br><span class="line">            <span class="comment"># 为了输出美观,保持输出6个字符</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%6.6s&#x27;</span> % (<span class="string">&#x27;%.3f&#x27;</span> % agent.v[i * agent.env.ncol + j]), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;策略：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(agent.env.nrow):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(agent.env.ncol):</span><br><span class="line">            <span class="comment"># 一些特殊的状态,例如悬崖漫步中的悬崖</span></span><br><span class="line">            <span class="keyword">if</span> (i * agent.env.ncol + j) <span class="keyword">in</span> disaster:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;****&#x27;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> (i * agent.env.ncol + j) <span class="keyword">in</span> end:  <span class="comment"># 目标状态</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;EEEE&#x27;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = agent.pi[i * agent.env.ncol + j]</span><br><span class="line">                pi_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(action_meaning)):</span><br><span class="line">                    pi_str += action_meaning[k] <span class="keyword">if</span> a[k] &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;o&#x27;</span></span><br><span class="line">                <span class="built_in">print</span>(pi_str, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">env = CliffWalkingEnv()</span><br><span class="line">action_meaning = [<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>]</span><br><span class="line">theta = <span class="number">0.001</span></span><br><span class="line">gamma = <span class="number">0.9</span></span><br><span class="line">agent = PolicyIteration(env, theta, gamma)</span><br><span class="line">agent.policy_iteration()</span><br><span class="line">print_agent(agent, action_meaning, <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">37</span>, <span class="number">47</span>)), [<span class="number">47</span>])</span><br></pre></td></tr></table></figure>
<br>
<h2 id="价值迭代算法-基于价值函数的">价值迭代算法/基于价值函数的</h2>
<blockquote>
<p>价值迭代的核心思想是<strong>直接通过最大化价值函数来找到最优策略</strong>，不需要显式地维护策略。</p>
</blockquote>
<p>使用贝尔曼最优方程</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611191853492.png" class="" title="image-20240611191853492">
<p>的迭代形式</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611152610430.png" class="" title="image-20240611152610430">
<p>进行价值迭代；</p>
<p>使用</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611152643864.png" class="" title="image-20240611152643864">
<p>从迭代完成的状态价值函数中获取策略，即 从当前状态出发，哪个动作的 (即时奖励+下一状态价值) 最大，策略就为哪个动作</p>
<br>
<p>最优状态价值是选择此时使最优动作价值最大的那一个动作时的状态价值</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611153610316.png" class="" title="image-20240611153610316">
<img src="/2024/06/10/reinforce-learning-record/image-20240610213050168.png" class="" title="image-20240610213050168">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max_diff = <span class="number">0</span></span><br><span class="line">new_v = [<span class="number">0</span>] * self.env.ncol * self.env.nrow  <span class="comment"># 迷宫环境，初始化状态价值</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(self.env.ncol * self.env.nrow):</span><br><span class="line">    qsa_list = []</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        qsa = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> res <span class="keyword">in</span> self.env.P[s][a]:</span><br><span class="line">            p, next_state, r, done = res</span><br><span class="line">            qsa += p * (r + self.gamma * self.v[next_state] * (<span class="number">1</span> - done))</span><br><span class="line">        qsa_list.append(qsa)  <span class="comment"># 记录状态s下的所有Q(s,a)价值</span></span><br><span class="line">     new_v[s] = <span class="built_in">max</span>(qsa_list)  <span class="comment"># 取最大作为新状态价值</span></span><br><span class="line">     max_diff = <span class="built_in">max</span>(max_diff, <span class="built_in">abs</span>(new_v[s] - self.v[s]))</span><br><span class="line">self.v = new_v</span><br><span class="line"><span class="keyword">if</span> max_diff &lt; self.theta: <span class="keyword">break</span>  <span class="comment"># 满足收敛条件,退出评估迭代</span></span><br><span class="line">cnt += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<br>
<p>完整价值迭代算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValueIteration</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 价值迭代算法 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, env, theta, gamma</span>):</span><br><span class="line">        <span class="comment"># 初始化函数，接受环境对象env、价值收敛阈值theta和折扣因子gamma</span></span><br><span class="line">        self.env = env  <span class="comment"># 保存环境对象</span></span><br><span class="line">        self.v = [<span class="number">0</span>] * self.env.ncol * self.env.nrow  <span class="comment"># 初始化价值函数v为0，大小为环境的格子数</span></span><br><span class="line">        self.theta = theta  <span class="comment"># 价值收敛阈值</span></span><br><span class="line">        self.gamma = gamma  <span class="comment"># 折扣因子，用于计算未来奖励的折扣</span></span><br><span class="line">        <span class="comment"># 初始化策略pi为None，表示在价值迭代结束后再计算策略</span></span><br><span class="line">        self.pi = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.env.ncol * self.env.nrow)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">value_iteration</span>(<span class="params">self</span>):</span><br><span class="line">        cnt = <span class="number">0</span>  <span class="comment"># 计数器，记录价值迭代的轮数</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            max_diff = <span class="number">0</span>  <span class="comment"># 用于记录价值函数的最大变化量</span></span><br><span class="line">            new_v = [<span class="number">0</span>] * self.env.ncol * self.env.nrow  <span class="comment"># 初始化新的价值函数</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(self.env.ncol * self.env.nrow):  <span class="comment"># 遍历所有状态</span></span><br><span class="line">                qsa_list = []  <span class="comment"># 用于存储状态s下所有动作的Q值</span></span><br><span class="line">                <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  <span class="comment"># 遍历所有动作</span></span><br><span class="line">                    qsa = <span class="number">0</span>  <span class="comment"># 初始化Q(s,a)为0</span></span><br><span class="line">                    <span class="keyword">for</span> res <span class="keyword">in</span> self.env.P[s][a]:  <span class="comment"># 遍历状态s下执行动作a的所有可能结果</span></span><br><span class="line">                        p, next_state, r, done = res  <span class="comment"># 获取转移概率p、下一个状态next_state、奖励r和是否终止done</span></span><br><span class="line">                        qsa += p * (r + self.gamma * self.v[next_state] * (<span class="number">1</span> - done))  <span class="comment"># 计算Q(s,a)的值，考虑折扣因子gamma</span></span><br><span class="line">                    qsa_list.append(qsa)  <span class="comment"># 将Q(s,a)加入列表</span></span><br><span class="line">                new_v[s] = <span class="built_in">max</span>(qsa_list)  <span class="comment"># 更新状态s的价值函数为所有动作Q值的最大值</span></span><br><span class="line">                max_diff = <span class="built_in">max</span>(max_diff, <span class="built_in">abs</span>(new_v[s] - self.v[s]))  <span class="comment"># 更新最大变化量</span></span><br><span class="line">            self.v = new_v  <span class="comment"># 更新价值函数</span></span><br><span class="line">            <span class="keyword">if</span> max_diff &lt; self.theta: <span class="keyword">break</span>  <span class="comment"># 如果最大变化量小于阈值theta，则退出循环</span></span><br><span class="line">            cnt += <span class="number">1</span>  <span class="comment"># 增加迭代次数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;价值迭代一共进行%d轮&quot;</span> % cnt)  <span class="comment"># 打印价值迭代的轮数</span></span><br><span class="line">        self.get_policy()  <span class="comment"># 根据最终的价值函数导出策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_policy</span>(<span class="params">self</span>):  <span class="comment"># 根据价值函数导出一个贪婪策略</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(self.env.nrow * self.env.ncol):  <span class="comment"># 遍历所有状态</span></span><br><span class="line">            qsa_list = []  <span class="comment"># 用于存储状态s下所有动作的Q值</span></span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  <span class="comment"># 遍历所有动作</span></span><br><span class="line">                qsa = <span class="number">0</span>  <span class="comment"># 初始化Q(s,a)为0</span></span><br><span class="line">                <span class="keyword">for</span> res <span class="keyword">in</span> self.env.P[s][a]:  <span class="comment"># 遍历状态s下执行动作a的所有可能结果</span></span><br><span class="line">                    p, next_state, r, done = res  <span class="comment"># 获取转移概率p、下一个状态next_state、奖励r和是否终止done</span></span><br><span class="line">                    qsa += p * (r + self.gamma * self.v[next_state] * (<span class="number">1</span> - done))  <span class="comment"># 计算Q(s,a)的值，考虑折扣因子gamma</span></span><br><span class="line">                qsa_list.append(qsa)  <span class="comment"># 将Q(s,a)加入列表</span></span><br><span class="line">            maxq = <span class="built_in">max</span>(qsa_list)  <span class="comment"># 找到状态s下所有动作的最大Q值</span></span><br><span class="line">            cntq = qsa_list.count(maxq)  <span class="comment"># 计算有多少个动作得到了最大Q值</span></span><br><span class="line">            <span class="comment"># 让这些动作均分概率，其他动作的概率为0</span></span><br><span class="line">            self.pi[s] = [<span class="number">1</span> / cntq <span class="keyword">if</span> q == maxq <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> q <span class="keyword">in</span> qsa_list]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境初始化</span></span><br><span class="line">env = CliffWalkingEnv()  <span class="comment"># 创建一个悬崖漫步环境</span></span><br><span class="line">action_meaning = [<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>]  <span class="comment"># 动作的含义，分别表示上、下、左、右</span></span><br><span class="line">theta = <span class="number">0.001</span>  <span class="comment"># 价值收敛阈值</span></span><br><span class="line">gamma = <span class="number">0.9</span>  <span class="comment"># 折扣因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建价值迭代算法对象</span></span><br><span class="line">agent = ValueIteration(env, theta, gamma)</span><br><span class="line">agent.value_iteration()  <span class="comment"># 执行价值迭代</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印策略和路径</span></span><br><span class="line">print_agent(agent, action_meaning, <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">37</span>, <span class="number">47</span>)), [<span class="number">47</span>])</span><br></pre></td></tr></table></figure>
<br>
<h2 id="策略迭代-价值迭代对比">策略迭代&amp;价值迭代对比</h2>
<ul>
<li>策略迭代的核心思想是<strong>交替进行策略评估和策略提升</strong>，直到策略收敛到最优。</li>
<li>价值迭代的核心思想是<strong>直接通过最大化价值函数来找到最优策略</strong>，不需要显式地维护策略。</li>
</ul>
<p>因此，价值迭代函数 <code>value_iteration</code> 和策略评估函数 <code>policy_evaluation</code> 有着一样的实现</p>
<br>
<p><strong>动作价值更新</strong>和<strong>状态价值更新</strong>是价值函数更新的两种方式，可以用于<strong>策略迭代</strong>、<strong>价值迭代</strong>或其他算法。</p>
<ul>
<li>状态价值迭代和动作价值迭代是等价的，只是更新的对象不同。</li>
<li>在价值迭代中，通常使用状态价值迭代，因为它的计算量较小。</li>
</ul>
<br>
<h2 id="有模型-无模型-在线策略-离线策略">有模型&amp;无模型+在线策略&amp;离线策略</h2>
<p><strong>有模型强化学习：</strong></p>
<p>智能体学习环境的状态转移函数</p>
<p>环境的状态转移函数已知</p>
<p>智能体可以直接根据状态转移函数得到在对环境进行动作a后环境的下一状态</p>
<p># 状态转移函数P[state][action] = [(p, next_state, reward, done)]包含转移成功概率，下一个状态，奖励和是否完成</p>
<ul>
<li>Dyna-Q</li>
<li>Monte Carlo Tree Search (MCTS)</li>
<li>PILCO (Probabilistic Inference for Learning Control)</li>
</ul>
<p><strong>无模型强化学习：</strong></p>
<p>智能体通过与环境交互学习状态和奖励之间的映射关系</p>
<p>环境的状态转移函数未知</p>
<p>智能体必须通过与环境的交互才能得到环境的下一状态</p>
<ul>
<li>Q-learning</li>
<li>SARSA</li>
<li>Deep Q-Network (DQN)</li>
<li>Policy Gradient methods (e.g., REINFORCE, A2C, PPO)</li>
</ul>
<br>
<p>样本：当前状态，下一状态，采取动作，奖励</p>
<p><strong>在线策略学习：</strong></p>
<p>不保存样本</p>
<p><strong>离线策略学习：</strong></p>
<p>使用经验回放池保存样本</p>
<br>
<h2 id="算法">算法</h2>
<h3 id="蒙特卡洛方法">蒙特卡洛方法</h3>
<p>Value-based + online</p>
<p>从某状态s出发，基于策略Π，获得一条状态序列，该状态序列对应一个回报G；该过程为一次采样。</p>
<p>反复采样，得到N个状态序列+回报和M，由大数定律，可得该状态的状态价值</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611161858965.png" class="" title="image-20240611161858965">
<p>使用增量更新方法</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611161157050.png" class="" title="image-20240611161157050">
<p>补：增量更新原理</p>
<p>新均值 = 旧均值 + 1/总量 * (新值 - 旧均值)</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611161942958.png" class="" title="image-20240611161942958">
<br>
<h3 id="时序差分算法">时序差分算法</h3>
<p>Value-based + online</p>
<p>类似于蒙特卡洛，更新状态s的状态价值时，不使用完整的状态序列，在得到下一状态时立即对状态s的状态价值进行更新</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611162513650.png" class="" title="image-20240611162513650">
<p>蒙特卡洛使用第三行对状态价值进行更新，时序差分使用第四行对状态价值进行更新</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611162624769.png" class="" title="image-20240611162624769">
<ul>
<li>只向前走了一步的蒙特卡洛</li>
<li>使用下一状态的状态价值代替了很长的状态序列的回报(状态价值本身就是所有未来时刻的回报期望和)</li>
<li>增量更新体现在 减号前部分为 (新 状态s的状态价值)，减号后部分为 (旧 状态s的状态价值)</li>
</ul>
<br>
<h3 id="Sarsa算法">Sarsa算法</h3>
<p>Value-based + online</p>
<p>类似于时序差分算法，对动作价值进行更新，目标是估计 <strong>ε-greedy策略的动作价值函数</strong></p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611191221769.png" class="" title="image-20240611191221769">
<p>算法</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612100452913.png" class="" title="image-20240612100452913">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">td_error = r + self.gamma * self.Q_table[s1, a1] - self.Q_table[s0, a0]</span><br><span class="line">self.Q_table[s0, a0] += self.alpha * td_error</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Q表的变化其实是从后向前蔓延的</p>
<p>一个全0的Q表，当某一步产生奖励后，该步对应的Q值出现了值，然后在每一轮的更新中，值向前扩散</p>
<p>我们可以把这个过程形象地比喻成：</p>
<ul>
<li>
<p><strong>“宝藏”被发现：</strong> 当智能体在某一步 <code>(s, a)</code> 执行后，到达 <code>s'</code> 并获得了奖励 <code>r</code> (尤其是正奖励，可以看作找到了“宝藏”的第一丝线索)，那么 <code>Q(s, a)</code> 会首先直接受到这个 <code>r</code> 的影响而更新。如果这是第一次获得奖励，那么这个 <code>Q(s, a)</code> 就从0变成了非0值。</p>
</li>
<li>
<p><strong>“消息”向前传递：</strong></p>
<ul>
<li>在<strong>下一轮</strong>的训练中，如果智能体再次访问到状态 <code>s_prev</code>，并且它采取的动作 <code>a_prev</code> 能够引导它到达之前那个状态 <code>s</code>（也就是宝藏线索更近一步的状态），那么在更新 <code>Q(s_prev, a_prev)</code> 时，会使用到 <code>Q(s, a_selected_in_s)</code>（对于SARSA）或 <code>max_a' Q(s, a')</code>（对于Q-learning）。</li>
<li>因为 <code>Q(s, ...)</code> 已经因为上一轮的奖励而有了一个非零值，这个值就会通过折扣因子 <code>γ</code> “打折”后，贡献给 <code>Q(s_prev, a_prev)</code> 的更新。</li>
<li>这就好比，状态 <code>s</code> 告诉了状态 <code>s_prev</code>：“嘿，从你这里走某条路到我这里，我这里有点好东西（或者预示着好东西）！”</li>
</ul>
</li>
<li>
<p><strong>逐层蔓延/扩散：</strong> 这个过程会不断重复。状态 <code>s_prev</code> 的更新值又会影响到更早访问它的状态 <code>s_prev_prev</code>，以此类推。就像水波一样，从奖励产生的地方（或目标状态附近）开始，价值信息逐渐向起始状态或远离目标的状态扩散。</p>
</li>
</ul>
</blockquote>
<br>
<h3 id="Q-learning算法">Q-learning算法</h3>
<p>Value-based + offline</p>
<p>对动作价值进行更新，目标是估计 <strong>最优策略的动作价值函数</strong></p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611194333945.png" class="" title="image-20240611194333945">
<p>算法</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612100509915.png" class="" title="image-20240612100509915">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">td_error = r + self.gamma * self.Q_table[s1].<span class="built_in">max</span>() - self.Q_table[s0, a0]</span><br><span class="line">self.Q_table[s0, a0] += self.alpha * td_error</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对比Sarsa和Q-learning</p>
<p>实际上，$r_t$和$R_t$在各自的算法中都表示在时间步$t$时环境反馈的即时奖励，但在更新公式中的使用方式略有不同。Sarsa算法使用下一个动作$a_{t+1}$的动作价值$Q(s_{t+1}, a_{t+1})$，而Q-learning算法使用下一状态$s_{t+1}$下最优动作的动作价值$\max_{a’} Q(s’, a’)$。</p>
<p>Sarsa 是<strong>在线策略</strong>（on-policy）算法， Q-learning 是<strong>离线策略</strong>（off-policy）算法，因为目标策略和行为策略分离，Q-learning 可以采用非常具有探索性的行为策略（甚至是完全随机的策略），同时仍然学习最优的Q值。这使得它在探索未知环境时可能更有效率。SARSA 学习的价值函数直接受到其探索行为的影响。如果探索策略包含了一些“愚蠢”的动作，SARSA计算出的Q值会反映这些“愚蠢”动作的后果。</p>
<p>说人话就是，Q-learning在实际行动中“大胆尝试”，但在学习和评估时则“以最优为目标”。</p>
</blockquote>
<br>
<blockquote>
<p>Q: 为什么Q-leanring中的Q表的值是从：一个全0的Q表，当某一步产生奖励后，该步对应的Q值出现了值，然后在每一轮的更新中，值向前扩散；为什么我们不直接从终点出发（从有reward的地方出发），反向向前推进，直接一次遍历得到Q表呢？这不是更快吗？</p>
<p>A: 你提出的想法非常好，也非常有洞察力！你所描述的“从终点出发，反向向前推进，直接一次遍历得到Q表”的方法，其实非常接近甚至就是一种经典的**动态规划（Dynamic Programming, DP）<strong>方法，比如</strong>价值迭代（Value Iteration）<strong>或</strong>策略迭代（Policy Iteration）**中的一部分。</p>
<p>那么，为什么Q-learning不直接这么做呢？主要原因在于它们解决问题的<strong>前提假设和适用场景</strong>不同：</p>
<ol>
<li>
<p><strong>模型未知 vs. 模型已知 (Model-Free vs. Model-Based)</strong></p>
<ul>
<li><strong>你描述的方法 (类似DP)：</strong> 这种方法通常需要我们<strong>已知环境的模型 (Model-Based)</strong>。也就是说，你需要知道：
<ul>
<li><strong>状态转移概率 P(s’ | s, a):</strong> 在状态s执行动作a后，转移到状态s’的概率。</li>
<li><strong>奖励函数 R(s, a, s’):</strong> 在状态s执行动作a并转移到状态s’后能获得的奖励。</li>
<li>有了这些信息，你才能从终点（或有奖励的地方）准确地反向推算出前一个状态采取什么动作能达到这个奖励状态，以及这个动作的价值。例如，在价值迭代中，我们会用贝尔曼最优方程 <code>V*(s) = max_a Σ_&#123;s'&#125; P(s'|s,a) [R(s,a,s') + γV*(s')]</code> 来更新所有状态的价值，这确实是从“结果”倒推。</li>
</ul>
</li>
<li><strong>Q-learning：</strong> Q-learning是一种<strong>模型无关 (Model-Free)</strong> 的强化学习算法。它<strong>不需要事先知道环境的模型</strong>。智能体就像一个在未知迷宫中探索的人，它只能通过与环境交互（尝试动作、观察结果和奖励）来学习。它不知道“墙的另一边是什么”，也不知道“走这条路一定能拿到奶酪”。</li>
</ul>
</li>
<li>
<p><strong>学习方式：通过经验学习 vs. 通过规划学习</strong></p>
<ul>
<li><strong>你描述的方法 (类似DP)：</strong> 这是在<strong>规划 (Planning)</strong>。你拥有了完整的地图（模型），然后你可以在脑海中或纸上进行推演，计算出最优路径。</li>
<li><strong>Q-learning：</strong> 这是在<strong>学习 (Learning)</strong>。智能体通过一次次的<strong>试错 (trial-and-error)</strong> 来积累经验。
<ul>
<li>初始Q表为0，表示对环境一无所知。</li>
<li>当某一步产生奖励时，Q-learning会更新该<code>(状态, 动作)</code>对的Q值。这个Q值代表了“在那个状态下执行那个动作，期望未来能获得的总回报（包括即时奖励）”。</li>
<li>“值向前扩散”（实际上是奖励信息通过贝尔曼方程反向传播）的过程，是智能体逐渐认识到“哦，原来这个动作最终能导向那个有奖励的状态，所以这个动作的价值也应该高一些”。这个“扩散”是基于实际探索到的路径和奖励。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>你描述的方法 (类似DP)：</strong> 非常适合于模型已知且状态空间不至于过大的问题，例如棋盘游戏（规则已知）、最短路径问题（地图已知）。它的计算效率在模型已知时通常更高。</li>
<li><strong>Q-learning：</strong> 非常适合于模型未知或模型非常复杂难以精确描述的环境，例如机器人控制（物理模型复杂）、很多现实世界的交互问题。它可以通过与真实环境或模拟环境交互来学习。</li>
</ul>
</li>
</ol>
<p><strong>为什么Q-learning的“扩散”看起来慢？</strong></p>
<ul>
<li><strong>探索的必要性：</strong> 因为模型未知，Q-learning需要通过探索（比如ε-greedy策略）来发现新的路径和潜在的奖励。如果它只走已知的“好路”，可能永远发现不了更好的路径。</li>
<li><strong>采样效率：</strong> Q-learning是基于采样的，它只更新实际经历过的<code>(状态, 动作)</code>对。如果一个状态很少被访问，或者某个通往奖励的路径很长，那么奖励信息就需要很多轮迭代才能慢慢“传播”回去。</li>
<li><strong>在线学习：</strong> Q-learning可以进行在线学习，即在与环境交互的过程中不断更新Q表，适应环境的变化。而DP通常是离线进行的，假设环境模型固定。</li>
</ul>
<p><strong>总结一下：</strong></p>
<ul>
<li>如果你<strong>有完整的环境模型</strong>（知道所有状态转移和奖励），那么你描述的从终点反向传播的方法（如价值迭代）确实是更直接和高效的，能够一次性（或经过几次迭代）计算出Q表。</li>
<li>Q-learning的设计初衷是为了解决<strong>模型未知</strong>的问题。它通过与环境交互、逐步探索和利用贝尔曼方程来学习Q值，这个过程看起来像是“奖励向前扩散”，但本质上是奖励信息通过经验逐步反向传播更新先前状态的价值。</li>
</ul>
<p>所以，不是Q-learning“傻”，而是它被设计用来解决一类更普遍（模型未知）的问题，为此它采用了通过经验学习的方式，这种方式的特性就是逐步更新和信息传播。</p>
</blockquote>
<br>
<h3 id="DQN-DDQN">DQN/DDQN</h3>
<p>Value-based + offline</p>
<p><strong>DQN</strong></p>
<p>将Q-learning的Q表换成net</p>
<p>网络的损失函数</p>
<img src="/2024/06/10/reinforce-learning-record/image-20250322111503025.png" class="" title="image-20250322111503025">
<blockquote>
<p>DQN网络旨在让Q(s,a)更新到逼近最优动作的动作价值$r + \max_{a’} Q(s’, a’)$</p>
<p>单网络存在问题：</p>
<p>在 DQN 中，损失函数TD本身依赖于神经网络的输出 <em>Q</em>(<em>s</em>′,<em>a</em>′)。这意味着：</p>
<ul>
<li>当我们更新神经网络的参数时，<em>Q</em>(<em>s</em>′,<em>a</em>′) 也会发生变化。</li>
<li>这种变化会导致 TD 目标不断改变，从而使得训练过程变得不稳定。</li>
</ul>
</blockquote>
<p>训练网络每步更新，目标网络每隔C步进行一次更新；</p>
<p>使用目标网络计算最优动作价值（最优动作选取使用目标网络），最小化损失函数更新训练网络；</p>
<br>
<p><strong>Double DQN</strong></p>
<p>DQN在<strong>选择和评估动作使用的是同一套神经网络</strong>，如果神经网络在估算Q值时存在误差（尤其是正向误差），这种误差会在选择和评估动作的过程中被放大。具体来说：</p>
<ul>
<li>当神经网络高估某个动作的Q值时，该动作更可能被选为最优动作。</li>
<li>被选中的动作的Q值又被用于计算目标Q值，进一步放大了高估的影响。</li>
<li>这种正向误差会在更新过程中逐步累积，导致Q值严重偏离真实值。</li>
</ul>
<p>Double DQN通过两套独立网络分别选择和评估动作，有效降低了过估计问题，使目标Q值更接近真实值。</p>
<p>这种改进在动作空间较大的任务中尤为重要，能够显著提升算法的稳定性和性能。</p>
<img src="/2024/06/10/reinforce-learning-record/image-20250322111831741.png" class="" title="image-20250322111831741">
<br>
<h3 id="策略梯度算法-REINFORCE">策略梯度算法(REINFORCE)</h3>
<p>Policy-based + online</p>
<p>定义策略学习的目标函数为，s0为初始状态</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612100629893.png" class="" title="image-20240612100629893">
<blockquote>
<p>期望是关于 $s_0$ 的期望，这意味着 $s_0$ 的初始化存在相应的分布</p>
</blockquote>
<p>目标是修改参数θ，使J(θ)取最大；即对θ求导</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240610213003398.png" class="" title="image-20240610213003398">
<img src="/2024/06/10/reinforce-learning-record/image-20240612100732404.png" class="" title="image-20240612100732404">
<p>上述公式还可以表示为：<br>
$$<br>
\nabla_{\theta} J(\theta) = \mathbb{E}<em>{s \sim \nu^{\pi</em>{\theta}}, a \sim \pi_{\theta}(\cdot | s)} \left[ A^{\pi_{\theta}}(s, a) \nabla_{\theta} \log \pi_{\theta}(a | s) \right]<br>
$$</p>
<br>
<p>公式推导：<br>
$$<br>
\begin{align*}<br>
\nabla_\theta V^{\pi_\theta} (s) &amp;= \nabla_\theta \left(\sum_{a \in A} \pi_\theta (a|s) Q^{\pi_\theta} (s, a)\right) \<br>
&amp;= \sum_{a \in A} \left(\nabla_\theta \pi_\theta (a|s) Q^{\pi_\theta} (s, a) + \pi_\theta (a|s) \nabla_\theta Q^{\pi_\theta} (s, a)\right) \<br>
&amp;= \sum_{a \in A} \left(\nabla_\theta \pi_\theta (a|s) Q^{\pi_\theta} (s, a) + \pi_\theta (a|s) \nabla_\theta \sum_{s’,r} p(s’,r|s,a) (r + \gamma V^{\pi_\theta} (s’))\right) \<br>
&amp;= \sum_{a \in A} \left(\nabla_\theta \pi_\theta (a|s) Q^{\pi_\theta} (s, a) + \gamma \pi_\theta (a|s) \sum_{s’,r} p(s’,r|s,a) \nabla_\theta V^{\pi_\theta} (s’)\right) \<br>
&amp;= \sum_{a \in A} \left(\nabla_\theta \pi_\theta (a|s) Q^{\pi_\theta} (s, a) + \gamma \pi_\theta (a|s) \sum_{s’} p(s’|s,a) \nabla_\theta V^{\pi_\theta} (s’)\right)<br>
\end{align*}<br>
$$<br>
3行 -&gt; 4行：第二项的第一项reward与策略参数无关，约去；</p>
<p>为了简化表示，我们让 $\phi(s) = \sum_{a\in A} \nabla_{\theta}\pi_{\theta}(a|s)Q^{\pi\theta}(s,a)$，定义 $d^{\pi\theta}(s \to x, k)$ 为 策略 $\pi$ 从状态 $s$ 出发 $k$ 步后到达状态 $x$ 的概率。我们继续推导：<br>
$$<br>
\begin{align*}<br>
\nabla_\theta V^{\pi_\theta}(s) &amp;= \phi(s) + \gamma \sum_a \pi_\theta(a|s) \sum_{s’} P(s’|s,a) \nabla_\theta V^{\pi_\theta}(s’) \<br>
&amp;= \phi(s) + \gamma \sum_a \sum_{s’} \pi_\theta(a|s) P(s’|s,a) \nabla_\theta V^{\pi_\theta}(s’) \<br>
&amp;= \phi(s) + \gamma \sum_{s’} d^{\pi_\theta}(s \to s’, 1) \nabla_\theta V^{\pi_\theta}(s’) \<br>
&amp;= \phi(s) + \gamma \sum_{s’} d^{\pi_\theta}(s \to s’, 1) \left[\phi(s’) + \gamma \sum_{s’‘} d^{\pi_\theta}(s’ \to s’‘, 1) \nabla_\theta V^{\pi_\theta}(s’‘)\right] \<br>
&amp;= \phi(s) + \gamma \sum_{s’} d^{\pi_\theta}(s \to s’, 1) \phi(s’) + \gamma^2 \sum_{s’‘} d^{\pi_\theta}(s \to s’‘, 2) \nabla_\theta V^{\pi_\theta}(s’‘) \<br>
&amp;= \phi(s) + \gamma \sum_{s’} d^{\pi_\theta}(s \to s’, 1) \phi(s’) + \gamma^2 \sum_{s’‘} d^{\pi_\theta}(s \to s’‘, 2) \phi(s’‘) \<br>
&amp;\quad + \gamma^3 \sum_{s’‘’} d^{\pi_\theta}(s \to s’‘’, 3) \nabla_\theta V^{\pi_\theta}(s’‘’) \<br>
&amp;= \cdots \<br>
&amp;= \sum_{x \in S} \sum_{k=0}^\infty \gamma^k d^{\pi_\theta}(s \to x, k) \phi(x)<br>
\end{align*}<br>
$$<br>
3行 -&gt; 4行：对贝尔曼期望方程 $V^π(s) = Σ_{a∈A} π(a|s) (r(s, a) + γ Σ_{s’∈S} p(s’|s, a)V^π(s’))$ 求导得到（其实就是第一步的套娃</p>
<p>定义 $\eta(s) = \mathbb{E}<em>{s_0}[\sum</em>{k=0}^{\infty} \gamma^k d^{\pi_\theta}(s_0 \to s, k)]$，它代表从初始状态 $s_0$出发，在策略 $\pi_{\theta}$ 下，未来能够访问到状态 $s$ 的衰减频率，</p>
<p>至此，回到目标函数：<br>
$$<br>
\begin{align*}<br>
\nabla_\theta J(\theta) &amp;= \nabla_\theta \mathbb{E}<em>{s_0}[V^{\pi</em>\theta}(s_0)] \<br>
&amp;= \sum_s \mathbb{E}<em>{s_0}\left[\sum</em>{k=0}^{\infty} \gamma^k d^{\pi_\theta}(s_0 \to s, k)\right]\phi(s) \<br>
&amp;= \sum_s \eta(s)\phi(s) \<br>
&amp;= \left(\sum_s \eta(s)\right)\sum_s \frac{\eta(s)}{\sum_s \eta(s)}\phi(s) \<br>
&amp;\propto \sum_s \frac{\eta(s)}{\sum_s \eta(s)}\phi(s) \<br>
&amp;= \sum_s \nu^{\pi_\theta}(s)\sum_a Q^{\pi_\theta}(s, a)\nabla_\theta \pi_\theta(a|s)<br>
\end{align*}<br>
$$</p>
<p>第4行 -&gt; 第5行</p>
<p>$\eta(s)$ 显然大于等于 0，$\sum_s \eta(s)$ 是一个正标量，由于将梯度乘以一个正标量不会改变梯度的方向，因此，对于梯度上升算法来说，我们可以省略掉这个正的标量因子</p>
<br>
<p>目标：最大化函数J(θ)</p>
<p>算法</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240611200059062.png" class="" title="image-20240611200059062">
<p>时刻t向后的回报即为(动作)价值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reward_list = transition_dict[<span class="string">&#x27;rewards&#x27;</span>]</span><br><span class="line">state_list = transition_dict[<span class="string">&#x27;states&#x27;</span>]</span><br><span class="line">action_list = transition_dict[<span class="string">&#x27;actions&#x27;</span>]</span><br><span class="line"></span><br><span class="line">G = <span class="number">0</span></span><br><span class="line">self.optimizer.zero_grad()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(reward_list))):  <span class="comment"># 从最后一步算起</span></span><br><span class="line">    reward = reward_list[i]  <span class="comment"># 取时间步i获得的奖励</span></span><br><span class="line">    state = torch.tensor([state_list[i]],</span><br><span class="line">                         dtype=torch.<span class="built_in">float</span>).to(self.device)  <span class="comment"># 取时间步i的状态</span></span><br><span class="line">    action = torch.tensor([action_list[i]]).view(-<span class="number">1</span>, <span class="number">1</span>).to(self.device)  <span class="comment"># 取时间步i的动作</span></span><br><span class="line">    log_prob = torch.log(self.policy_net(state).gather(<span class="number">1</span>, action))</span><br><span class="line">    <span class="comment"># self.policy_net(state)： 将状态输入策略网络，得到所有可能动作的概率分布。</span></span><br><span class="line">	<span class="comment"># .gather(1, action): 从概率分布中选取实际执行动作对应的概率值。</span></span><br><span class="line">	<span class="comment"># torch.log(...): 对选取的概率值取对数，得到对数概率</span></span><br><span class="line">    G = self.gamma * G + reward  <span class="comment"># G累计了从当前时间步i到episode结束的所有奖励</span></span><br><span class="line">    loss = -log_prob * G  <span class="comment"># loss对应公式中符号α后的部分</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播计算梯度</span></span><br><span class="line">self.optimizer.step()  <span class="comment"># 梯度下降，实际上是对策略进行求导</span></span><br></pre></td></tr></table></figure>
<br>
<h3 id="Actor-Critic">Actor-Critic</h3>
<p>(Value + Policy)-based + offline</p>
<p><strong>Actor采用策略迭代算法更新，Critic采用价值(状态价值)迭代算法更新</strong>，Actor的更新依赖于于Critic计算的优势函数；</p>
<p>策略函数梯度</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612110026419.png" class="" title="image-20240612110026419">
<p>其中，ψ_t 可为不同值，表示不同的方法</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612110241521.png" class="" title="image-20240612110241521">
<blockquote>
<p>注意，理论上来说，在收敛模型上上述6种方法得到的值是一致的，这六种方法都是基于策略梯度定理（Policy Gradient Theorem）的不同实现形式</p>
</blockquote>
<p>价值函数的损失函数与梯度</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612110951796.png" class="" title="image-20240612110951796">
<img src="/2024/06/10/reinforce-learning-record/image-20240612111022161.png" class="" title="image-20240612111022161">
<p>Actor基于策略函数，使用上图中的第6种的 <code>td_delta</code> 作为动作价值，使用Critic的价值函数得到动作价值的值；</p>
<p>Critic基于价值函数，用于最小化当前状态的价值估计与时序差分目标之间的差异，反向传播时对 <code>td_delta</code> 做了 <code>.detach()</code></p>
<br>
<p>基于<strong>时序差分(TD)<strong>方法的</strong>Actor-Critic</strong>算法</p>
<img src="/2024/06/10/reinforce-learning-record/image-20240612110750284.png" class="" title="image-20240612110750284">
<p>价值网络使用时序差分(TD)更新，策略网络使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">states = torch.tensor(transition_dict[<span class="string">&#x27;states&#x27;</span>],</span><br><span class="line">                              dtype=torch.<span class="built_in">float</span>).to(self.device)</span><br><span class="line">actions = torch.tensor(transition_dict[<span class="string">&#x27;actions&#x27;</span>]).view(-<span class="number">1</span>, <span class="number">1</span>).to(</span><br><span class="line">            self.device)</span><br><span class="line">rewards = torch.tensor(transition_dict[<span class="string">&#x27;rewards&#x27;</span>],</span><br><span class="line">                               dtype=torch.<span class="built_in">float</span>).view(-<span class="number">1</span>, <span class="number">1</span>).to(self.device)</span><br><span class="line">next_states = torch.tensor(transition_dict[<span class="string">&#x27;next_states&#x27;</span>],</span><br><span class="line">                                   dtype=torch.<span class="built_in">float</span>).to(self.device)</span><br><span class="line">dones = torch.tensor(transition_dict[<span class="string">&#x27;dones&#x27;</span>],</span><br><span class="line">                             dtype=torch.<span class="built_in">float</span>).view(-<span class="number">1</span>, <span class="number">1</span>).to(self.device)</span><br><span class="line"><span class="comment"># 当前状态，动作、奖励、下一个状态和结束标志</span></span><br><span class="line"></span><br><span class="line">td_target = rewards + self.gamma * self.critic(next_states) * (<span class="number">1</span> - dones)</span><br><span class="line"><span class="comment"># 价值网络(critic)</span></span><br><span class="line"><span class="comment"># self.critic(next_states) 使用价值网络(critic)预测下一个状态的价值。</span></span><br><span class="line"><span class="comment"># (1 - dones) 用于处理 episode 结束的情况，如果 dones 为 1 (True)，则表示 episode 结束，此时不需要考虑未来的奖励。</span></span><br><span class="line">td_delta = td_target - self.critic(states)  </span><br><span class="line"><span class="comment"># 计算时序差分误差，即目标值与当前状态价值的差。</span></span><br><span class="line"></span><br><span class="line">log_probs = torch.log(self.actor(states).gather(<span class="number">1</span>, actions))</span><br><span class="line"><span class="comment"># 策略网络(actor)</span></span><br><span class="line"><span class="comment"># self.actor(states) 使用策略网络预测每个动作的概率。</span></span><br><span class="line"><span class="comment"># .gather(1, actions) 从预测的概率分布中选择实际采取的动作对应的概率。torch.log 计算对数概率。</span></span><br><span class="line"></span><br><span class="line">critic_loss = torch.mean(</span><br><span class="line">	F.mse_loss(self.critic(states), td_target.detach()))</span><br><span class="line"><span class="comment"># 计算价值网络的损失函数。(价值网络给出的当前状态价值)和(r+价值网络给出的下一状态的状态价值)的均方误差，即((a-b)^2)/2</span></span><br><span class="line"><span class="comment"># 使用 td_target.detach() 阻止梯度通过 td_target 向策略网络回传。</span></span><br><span class="line">actor_loss = torch.mean(-log_probs * td_delta.detach())</span><br><span class="line"><span class="comment"># 计算策略网络的损失函数。策略函数梯度</span></span><br><span class="line"><span class="comment"># 使用 td_delta.detach() 阻止梯度通过 td_delta 向价值网络回传。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.actor_optimizer.zero_grad()</span><br><span class="line">self.critic_optimizer.zero_grad()</span><br><span class="line">actor_loss.backward()  <span class="comment"># 计算策略网络的梯度</span></span><br><span class="line">critic_loss.backward()  <span class="comment"># 计算价值网络的梯度</span></span><br><span class="line">self.actor_optimizer.step()  <span class="comment"># 更新策略网络的参数</span></span><br><span class="line">self.critic_optimizer.step()  <span class="comment"># 更新价值网络的参数</span></span><br></pre></td></tr></table></figure>
<br>
<h3 id="TRPO">TRPO</h3>
<p>在TRPO中，优化目标为最大化 新策略与旧策略的价值差 $J(θ’)- J(θ) $ ，通过近似方法（相似策略下状态分布函数不变假设与<strong>重要性采样</strong>）将原目标  $J(θ’)- J(θ) $  近似为下图，且满足<strong>KL散度</strong>约束（<strong>约束</strong>策略为相似策略）</p>
<img src="/2024/06/10/reinforce-learning-record/image-20250324141848364.png" class="" title="image-20250324141848364">
<h4 id="整体流程">整体流程</h4>
<p><strong>策略性能差异 (Policy Performance Difference)</strong></p>
<p>我们的目标是找到一个新策略 $π_θ’$，使其性能  $J(θ’)$ 优于或等于当前策略 $π_θ$ 的性能 $J(θ)$。策略性能的差异可以被精确地表示为与优势函数 $A$ 相关的期望：</p>
<p>$$<br>
J(\theta’) - J(\theta) = \mathbb{E}<em>{s_0, a_0, … \sim \pi</em>{\theta’}} \left[ \sum_{t=0}^{\infty} \gamma^t A^{\pi_{\theta}}(s_t, a_t) \right]<br>
$$</p>
<p>其中，$A^{\pi_{\theta}}(s, a) = Q^{\pi_{\theta}}(s, a) - V^{\pi_{\theta}}(s)$ 是旧策略 $π_θ$ 的优势函数。这个等式是策略梯度理论中的一个基本恒等式。它表明，<strong>新策略带来的性能提升，等于在新策略的轨迹上，累积旧策略优势函数的期望</strong>。</p>
<blockquote>
<p>$$<br>
\begin{aligned}<br>
J(\theta) &amp;= \mathbb{E}<em>{\tau \sim \pi</em>{\theta}} \left[ \sum_{t=0}^{\infty} \gamma^t r_t \right] \<br>
&amp;= \mathbb{E}<em>{s_0 \sim \rho_0} \left[ \mathbb{E}</em>{\tau \sim \pi_{\theta} | s_0} \left[ \sum_{t=0}^{\infty} \gamma^t r_t \right] \right] \quad \text{(根据全期望定律分解)} \<br>
&amp;= \mathbb{E}<em>{s_0 \sim \rho_0} \left[ V^{\pi</em>{\theta}}(s_0) \right] \quad \text{(根据 } V^{\pi} \text{ 的定义)}<br>
\end{aligned}<br>
$$<br>
$$<br>
\nabla_{\theta} J(\theta) = \mathbb{E}<em>{s \sim \nu^{\pi</em>{\theta}}, a \sim \pi_{\theta}(\cdot | s)} \left[ A^{\pi_{\theta}}(s, a) \nabla_{\theta} \log \pi_{\theta}(a | s) \right]<br>
$$</p>
</blockquote>
<p><strong>引入状态访问分布 (State-Visitation Distribution)</strong></p>
<p>上述公式中的期望是基于新策略 $π_θ’$ 的轨迹采样的，这在优化时非常不便，因为 $θ’$ 是我们正在求解的变量。为了解决这个问题，我们将期望拆解，并引入状态访问分布 $ν^{\pi_{\theta’}}(s)$：</p>
<p>$$<br>
J(\theta’) - J(\theta) = \sum_{s} \nu^{\pi_{\theta’}}(s) \sum_{a} \pi_{\theta’}(a|s) A^{\pi_{\theta}}(s, a)<br>
$$</p>
<p>其中 $\nu^{\pi_{\theta’}}(s) = \sum_{t=0}^\infty \gamma^t P(s_t=s | \pi_{\theta’})$ 是新策略下的折扣状态访问频率。这个公式仍然依赖于新策略的访问分布 $ν^{\pi_{\theta’}}$，问题依然存在。</p>
<p><strong>构造代理目标函数 (Surrogate Objective)</strong></p>
<p>由于 $ν^{\pi_{\theta’}}$ 依赖于 $θ’$，导致目标函数难以优化。TRPO提出，如果新旧策略足够接近，那么它们的状态访问分布也应该很相似。因此，我们可以用旧策略的状态访问分布 $ν^{\pi_{\theta}}(s)$ 来近似 $ν^{\pi_{\theta’}}(s)$。</p>
<p>基于这个近似，我们构造一个<strong>代理目标函数 (Surrogate Objective)</strong> $L_{\theta}(\theta’)$：</p>
<p>$$<br>
L_{\theta}(\theta’) = \sum_{s} \nu^{\pi_{\theta}}(s) \sum_{a} \pi_{\theta’}(a|s) A^{\pi_{\theta}}(s, a)<br>
$$</p>
<p>这个代理目标函数 $L_{\theta}(\theta’)$ 有两个很好的性质：</p>
<ol>
<li>$L_{\theta}(\theta) = 0$。</li>
<li>$\nabla_{\theta’} L_{\theta}(\theta’)|<em>{\theta’=\theta} = \nabla</em>{\theta’} J(\theta’)|_{\theta’=\theta}$。<br>
这意味着 $L$ 在 $θ’ = θ$ 处的梯度和真实目标 $J$ 的梯度完全一样，优化 $L$ 的初始方向是正确的。</li>
</ol>
<p><strong>应用重要性采样 (Importance Sampling)</strong></p>
<p>代理目标 $L_{\theta}(\theta’)$ 仍然需要在每个状态 $s$ 下，根据新策略 $π_{\theta’}$ 采样动作 $a$。为了能够在完全使用旧策略 $π_{\theta}$ 产生的数据上进行计算，我们引入<strong>重要性采样 (Importance Sampling)</strong>：</p>
<p>$$<br>
\sum_{a} \pi_{\theta’}(a|s) A^{\pi_{\theta}}(s, a) = \mathbb{E}<em>{a \sim \pi</em>{\theta’}}[A^{\pi_{\theta}}(s, a)] = \mathbb{E}<em>{a \sim \pi</em>{\theta}} \left[ \frac{\pi_{\theta’}(a|s)}{\pi_{\theta}(a|s)} A^{\pi_{\theta}}(s, a) \right]<br>
$$</p>
<p>将此式带入 $L_{\theta}(\theta’)$，我们得到最终可以用样本来估计的代理目标：</p>
<p>$$<br>
L_{\theta}(\theta’) = \mathbb{E}<em>{s \sim \nu^{\pi</em>{\theta}}, a \sim \pi_{\theta}} \left[ \frac{\pi_{\theta’}(a|s)}{\pi_{\theta}(a|s)} A^{\pi_{\theta}}(s, a) \right]<br>
$$</p>
<p><strong>引入信赖域约束 (Trust Region Constraint)</strong></p>
<p>直接最大化 $L_{\theta}(\theta’)$ 是危险的，因为我们的推导基于一个核心假设：$π_{\theta’}$ 与 $π_{\theta}$ 足够接近。如果一次更新步长太大，导致 $π_{\theta’}$ 偏离 $π_{\theta}$ 太远，那么 $ν^{\pi_{\theta’}} \approx \nu^{\pi_{\theta}}$ 的近似就会失效，$L$ 的提升将不再保证 $J$ 的提升，可能导致策略崩溃。</p>
<p>为了确保这个近似的有效性，TRPO引入了一个<strong>信赖域 (Trust Region)</strong>，通过约束新旧策略的**KL散度 (KL Divergence)**来限制策略更新的幅度。</p>
<p>$$<br>
\mathbb{E}<em>{s \sim \nu^{\pi</em>{\theta}}} \left[ D_{KL}(\pi_{\theta}(\cdot|s) || \pi_{\theta’}(\cdot|s)) \right] \leq \delta<br>
$$</p>
<p>其中 $\delta$ 是一个超参数，代表了我们信任该近似的“半径”。</p>
<p>综上所述，TRPO的每一步更新实际上是在求解一个带约束的优化问题：</p>
<p>$$<br>
\begin{aligned}<br>
\text{maximize}<em>{\theta’} \quad &amp; L</em>{\theta}(\theta’) = \mathbb{E}<em>{s \sim \nu^{\pi</em>{\theta}}, a \sim \pi_{\theta}} \left[ \frac{\pi_{\theta’}(a|s)}{\pi_{\theta}(a|s)} A^{\pi_{\theta}}(s, a) \right] \<br>
\text{subject to} \quad &amp; \mathbb{E}<em>{s \sim \nu^{\pi</em>{\theta}}} \left[ D_{KL}(\pi_{\theta}(\cdot|s) || \pi_{\theta’}(\cdot|s)) \right] \leq \delta<br>
\end{aligned}<br>
$$</p>
<p>这个公式完整地描述了TRPO的核心思想：<strong>在确保新策略不会与旧策略偏离太远（信赖域约束）的前提下，最大化一个能够近似真实性能提升的代理目标函数</strong>。这就是TRPO能够实现稳定单调策略提升的理论保障。</p>
<br>
<h4 id="近似处理">近似处理</h4>
<p>在策略优化中，我们希望找到新策略，使其期望回报最大化。但是，由于计算新策略的状态部分困难，有如下假设：</p>
<p>TRPO假设：<strong>当新旧策略非常接近时，状态分布的变化可以忽略</strong>，即<strong>新策略的状态分布和旧策略的状态分布一致</strong></p>
<blockquote>
<p>合理性：如果策略更新步幅很小（通过后续的KL散度或信任域约束），新旧策略生成的轨迹相似，因此状态分布的差异是“高阶小量”，可以被忽略。这类似于泰勒展开中的一阶近似。</p>
</blockquote>
<p>状态分布被近似为旧策略，但是动作选择使用新策略，为了处理动作分布的差异，TRPO使用<strong>重要性采样</strong>（Importance Sampling），即图中的新旧策略概率比值；</p>
<p>最后，状态分布使用旧策略的，动作选择使用旧策略的，加权计算新策略的改进量。</p>
<img src="/2024/06/10/reinforce-learning-record/image-20250322151444000.png" class="" title="image-20250322151444000">
<img src="/2024/06/10/reinforce-learning-record/image-20250322151537751.png" class="" title="image-20250322151537751">
<blockquote>
<p>重要性采样是什么?</p>
<img src="/2024/06/10/reinforce-learning-record/image-20250611134637079.png" class="" title="image-20250611134637079">
</blockquote>
<br>
<h4 id="近似约束与求解">近似约束与求解</h4>
<p>由于这里使用了近似，所以需要引入约束，使近似可行。因此，为了保证新旧策略足够接近，TRPO 使用了<strong>库尔贝克-莱布勒</strong>（Kullback-Leibler，KL）散度来衡量策略之间的距离。</p>
<img src="/2024/06/10/reinforce-learning-record/image-20250322162045699.png" class="" title="image-20250322162045699">
<br>
<h4 id="广义优势">广义优势</h4>
<p>多步时序差分的指数加权平均</p>
<img src="/2024/06/10/reinforce-learning-record/image-20250325154631583.png" class="" title="image-20250325154631583">
<blockquote>
<p>广义优势是干嘛的？</p>
<p>优势是优化目标里的那个 $A^{\pi_{\theta}}(s_{t}, a_{t})$，定义是： $A^{\pi_{\theta}}(s_t, a_t) = Q^{\pi_{\theta}}(s_t, a_t) - V^{\pi_{\theta}}(s_t) = \left( r(s,a) + \gamma E_{s’ \sim P(\cdot|s,a)}[V^{\pi}(s’)] \right) - V^{\pi}(s)$，优势函数告诉我们：在状态 <code>s</code> 下，选择动作 <code>a</code> <strong>相比于遵循当前策略 <code>π</code> 的平均表现</strong>，是更好还是更差。</p>
<p>广义优势其实就是将单步优势变成了多步优势，使得优势更加平均；</p>
<p>单步TD误差（$\lambda=0$）：方差相对较低，但如果值函数估计 $V^{\pi_{\theta}}$ 不准，会有较高的偏差。<br>
蒙特卡洛（MC）优势估计（相当于GAE中 $\lambda=1$）：使用从当前时刻到回合结束的完整回报来估计 $Q^{\pi_{\theta}}(s_t, a_t)$，然后减去 $V^{\pi_{\theta}}(s_t)$。这种方法偏差低（因为它不依赖于后续的值函数估计，只依赖于当前的 $V^{\pi_{\theta}}(s_t)$），但方差非常高，因为它累积了多个时间步的随机性。</p>
</blockquote>
<blockquote>
<p>Critic网络和Actor网络在哪里？</p>
<p><strong>广义优势的计算依赖于 Critic</strong>，Critic网络的核心任务是学习一个值函数 <code>V(s)</code>，用于评估在某个状态 <code>s</code> 下的期望累积回报。在GAE的计算中，<code>V(s_t)</code> 和 <code>V(s_&#123;t+1&#125;)</code> 这两个关键的组成部分<strong>直接由Critic网络输出</strong>。因此，GAE的准确性直接受到Critic网络估计准确性的影响。如果Critic估计不准，那么计算出的GAE也会不准确。</p>
<ul>
<li><strong>Critic网络</strong>：直接参与GAE的计算，提供状态值 <code>V(s)</code>，是计算TD误差 <code>δ_t</code> 和进而计算 <code>A_t^GAE</code> 的基础。</li>
<li><strong>Actor网络</strong>：
<ul>
<li>生成用于计算GAE的经验数据（状态、动作、奖励），Actor网络根据当前策略与环境进行交互，生成一系列的轨迹 (episodes)，即 <code>(s_0, a_0, r_0, s_1, a_1, r_1, ..., s_T, a_T, r_T)</code>。这些收集到的状态 <code>s_t</code>、<code>s_&#123;t+1&#125;</code> 和奖励 <code>r_t</code> 是计算GAE所必需的原始数据。</li>
<li>是GAE最终服务的对象。GAE计算出来后，用于指导Actor网络参数的更新，使其学习到更好的策略。GAE计算出来的优势 <code>A_t^GAE</code> 用于评估在状态 <code>s_t</code> 下采取动作 <code>a_t</code> 相对于平均动作的好坏程度。这个优势值随后被用于构建TRPO的目标函数（或其替代目标函数）的梯度，以更新Actor网络的参数 <code>θ</code>。</li>
</ul>
</li>
</ul>
</blockquote>
<br>
<h4 id="算法-2">算法</h4>
<img src="/2024/06/10/reinforce-learning-record/image-20250322211023368.png" class="" title="image-20250322211023368">
<br>
<h3 id="PPO-clip">PPO-clip</h3>
<p>基于AC和TRPO的，替换<strong>KL散度约束</strong>实现近似为<strong>惩罚优化/裁剪目标优化</strong>实现近似</p>
<img src="/2024/06/10/reinforce-learning-record/image-20250325200037093.png" class="" title="image-20250325200037093">
<blockquote>
<p>说白了就是把约束去掉变成无约束问题，更加易于求解</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">states = torch.tensor(transition_dict[<span class="string">&#x27;states&#x27;</span>],</span><br><span class="line">                      dtype=torch.<span class="built_in">float</span>).to(self.device)</span><br><span class="line">actions = torch.tensor(transition_dict[<span class="string">&#x27;actions&#x27;</span>]).view(-<span class="number">1</span>, <span class="number">1</span>).to(</span><br><span class="line">    self.device)</span><br><span class="line">rewards = torch.tensor(transition_dict[<span class="string">&#x27;rewards&#x27;</span>],</span><br><span class="line">                       dtype=torch.<span class="built_in">float</span>).view(-<span class="number">1</span>, <span class="number">1</span>).to(self.device)</span><br><span class="line">next_states = torch.tensor(transition_dict[<span class="string">&#x27;next_states&#x27;</span>],</span><br><span class="line">                           dtype=torch.<span class="built_in">float</span>).to(self.device)</span><br><span class="line">dones = torch.tensor(transition_dict[<span class="string">&#x27;dones&#x27;</span>],</span><br><span class="line">                     dtype=torch.<span class="built_in">float</span>).view(-<span class="number">1</span>, <span class="number">1</span>).to(self.device)</span><br><span class="line">td_target = rewards + self.gamma * self.critic(next_states) * (<span class="number">1</span> -</span><br><span class="line">                                                               dones)</span><br><span class="line">td_delta = td_target - self.critic(states)</span><br><span class="line">advantage = rl_utils.compute_advantage(self.gamma, self.lmbda,</span><br><span class="line">                                       td_delta.cpu()).to(self.device)</span><br><span class="line">old_log_probs = torch.log(self.actor(states).gather(<span class="number">1</span>,</span><br><span class="line">                                                    actions)).detach()</span><br><span class="line"></span><br><span class="line"><span class="comment"># epochs中对actor进行迭代</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.epochs):</span><br><span class="line">    log_probs = torch.log(self.actor(states).gather(<span class="number">1</span>, actions))</span><br><span class="line">    ratio = torch.exp(log_probs - old_log_probs)</span><br><span class="line">    surr1 = ratio * advantage</span><br><span class="line">    surr2 = torch.clamp(ratio, <span class="number">1</span> - self.eps,</span><br><span class="line">                        <span class="number">1</span> + self.eps) * advantage  <span class="comment"># 截断</span></span><br><span class="line">    actor_loss = torch.mean(-torch.<span class="built_in">min</span>(surr1, surr2))  <span class="comment"># PPO损失函数</span></span><br><span class="line">    critic_loss = torch.mean(</span><br><span class="line">        F.mse_loss(self.critic(states), td_target.detach()))</span><br><span class="line">    self.actor_optimizer.zero_grad()</span><br><span class="line">    self.critic_optimizer.zero_grad()</span><br><span class="line">    actor_loss.backward()</span><br><span class="line">    critic_loss.backward()</span><br><span class="line">    self.actor_optimizer.step()</span><br><span class="line">    self.critic_optimizer.step()</span><br></pre></td></tr></table></figure>
<br>
<h3 id="DDPG">DDPG</h3>
<p>确定性策略</p>
<img src="/2024/06/10/reinforce-learning-record/image-20250323105541258.png" class="" title="image-20250323105541258">
<p>4个网络，价值目标+训练网络，策略目标+训练网络</p>
<p>动作选择引入噪声</p>
<p>价值网络更新使用类似于DDQN的思路更新，残差计算时使用目标网络值-训练网络值</p>
<p>策略网络使用？（证明好复杂</p>
<p>价值目标网络和策略目标网络使用软更新</p>
<h2 id="部分心得">部分心得</h2>
<h3 id="AC分离">AC分离</h3>
<p><strong>关于DQN算法中网络的构成</strong></p>
<ul>
<li><strong>Deep Q-Network (DQN):</strong> 当状态空间或动作空间变得非常大时，我们使用神经网络来近似Q函数，这就是DQN。
<ul>
<li>DQN的核心是一个<strong>Q网络 (Q-Network)</strong>。这个网络输入状态 <code>s</code>，输出对应状态下所有可能动作的Q值。例如，如果环境有3个离散动作，输入状态 <code>s</code>，网络会输出 <code>[Q(s, a1), Q(s, a2), Q(s, a3)]</code>。</li>
<li><strong>动作选择 (Policy Derivation):</strong> 在DQN中，策略（如何选择动作）是根据Q网络输出的Q值<strong>派生</strong>出来的，通常使用ε-greedy策略：
<ul>
<li>以 <code>1-ε</code> 的概率选择具有最大Q值的动作：<code>a = argmax_a' Q(s, a')</code></li>
<li>以 <code>ε</code> 的概率随机选择一个动作（用于探索）。</li>
</ul>
</li>
<li><strong>所以，DQN中并没有一个独立的、参数化的“Actor网络”来直接输出策略 <code>π(a|s)</code> 或确定性动作 <code>a = μ(s)</code>。</strong> 它的“行为” (acting) 是由Q网络的结果驱动的。Q网络本身是一个<strong>价值网络 (Value Network)</strong>。</li>
</ul>
</li>
</ul>
<p>因此，Q-learning及其深度版本DQN本质上是<strong>基于值 (Value-based)</strong> 的方法，它们学习一个值函数（Q函数），然后从这个值函数中隐式地或显式地导出策略。它们没有像Actor-Critic方法那样显式地学习一个独立的策略网络（Actor）。</p>
<br>
<p><strong>为什么会出现Actor-Critic网络的分离？</strong></p>
<p>Actor-Critic (AC) 架构将策略学习和价值学习分离开来，由两个独立的（或部分共享参数的）网络（或函数逼近器）来承担：</p>
<ol>
<li>
<p><strong>Actor (策略网络 <code>π_θ(a|s)</code>)</strong>:</p>
<ul>
<li>负责学习策略，即在给定状态 <code>s</code> 下应该采取什么动作 <code>a</code>（或动作的概率分布）。</li>
<li>它的目标是最大化期望累积回报。</li>
<li>参数为 <code>θ</code>。</li>
</ul>
</li>
<li>
<p><strong>Critic (价值网络 <code>V_φ(s)</code> 或 <code>Q_φ(s,a)</code>)</strong>:</p>
<ul>
<li>负责评估Actor所选择的策略的好坏。它学习一个值函数，这个值函数可以是对当前策略下状态 <code>s</code> 的价值 <code>V(s)</code>（状态值函数），或者是状态-动作对 <code>(s,a)</code> 的价值 <code>Q(s,a)</code>（动作值函数）。</li>
<li>它的目标是尽可能准确地估计价值。</li>
<li>参数为 <code>φ</code>。</li>
</ul>
</li>
</ol>
<p><strong>分离的主要原因和优势如下：</strong></p>
<ol>
<li>
<p><strong>降低策略梯度的方差 (Variance Reduction) - 这是最核心的原因：</strong></p>
<ul>
<li>纯粹的策略梯度方法（如REINFORCE）直接使用蒙特卡洛回报 <code>G_t</code> 来估计策略梯度。这种回报的方差通常非常大，因为一个好的动作可能因为后续一系列坏的随机事件而导致低回报，反之亦然。高方差使得学习过程不稳定且收敛缓慢。</li>
<li>Critic通过学习一个值函数（如 <code>V(s)</code>）提供了一个<strong>基线 (baseline)</strong>。策略梯度可以使用<strong>优势函数 (Advantage Function)</strong> <code>A(s, a) = Q(s, a) - V(s)</code> 或者 <code>A(s, a) = r_t + γV(s_&#123;t+1&#125;) - V(s_t)</code> (TD误差) 来更新。</li>
<li>优势函数衡量了在状态 <code>s</code> 下采取动作 <code>a</code> 相对于在该状态下采取平均动作的好坏程度。使用优势函数代替原始回报 <code>G_t</code> 可以显著降低梯度的方差，因为我们减去了一个与当前状态相关的期望值，使得梯度信号更集中于动作本身的好坏，而不是状态本身的好坏或后续轨迹的随机性。</li>
<li><strong>更稳定的学习信号：</strong> Critic为Actor提供了一个更稳定、方差更低的学习信号，指导Actor如何调整其策略。</li>
</ul>
</li>
<li>
<p><strong>处理连续动作空间的能力：</strong></p>
<ul>
<li><strong>Value-based方法 (如DQN)</strong> 在处理高维或连续动作空间时会遇到困难。如果动作是连续的，<code>argmax_a Q(s, a)</code> 变成了一个在每个时间步都需要解决的复杂优化问题。</li>
<li><strong>Actor-Critic方法</strong> 中的Actor可以直接输出连续动作（例如，输出高斯分布的均值和方差），或者直接输出确定性动作，这使得它们非常适合连续动作空间。</li>
</ul>
</li>
<li>
<p><strong>学习随机策略的能力：</strong></p>
<ul>
<li>Actor可以直接参数化一个随机策略 <code>π(a|s)</code>，这在某些情况下是必要的（例如，部分可观察环境，或者为了更好的探索）。</li>
<li>虽然可以通过ε-greedy从Q值导出随机性，但Actor可以直接学习更复杂的随机策略。</li>
</ul>
</li>
<li>
<p><strong>更快的收敛（有时）：</strong></p>
<ul>
<li>由于方差降低和更有效的信用分配，AC方法有时可以比纯策略梯度方法或某些纯价值方法收敛更快。Critic的引导可以帮助Actor更快地找到好的策略方向。</li>
</ul>
</li>
<li>
<p><strong>模块化和灵活性：</strong></p>
<ul>
<li>Actor和Critic可以有不同的网络结构、学习率，甚至可以使用不同的优化算法。这种模块化设计提供了更大的灵活性。</li>
<li>例如，在A2C/A3C中，Actor和Critic可以共享底层的特征提取层，然后在顶部分别有各自的输出头。</li>
</ul>
</li>
</ol>
<p><strong>总结一下Actor-Critic分离的动机：</strong></p>
<ul>
<li><strong>核心：</strong> Critic帮助Actor进行更有效的学习，主要是通过<strong>降低策略梯度的方差</strong>。</li>
<li><strong>适用性：</strong> 使强化学习算法能更好地应用于<strong>连续动作空间</strong>。</li>
<li><strong>策略表达：</strong> 方便学习<strong>随机策略</strong>。</li>
</ul>
<p>所以，Actor-Critic的分离是一种权衡和结合：Actor负责“做什么”，Critic负责“做得怎么样”，两者协同工作，使得算法在具有挑战性的环境中表现更好，学习更稳定。</p>
<br>
<p><strong>说明案例</strong></p>
<p>好的，我们来举一个具体的例子来说明蒙特卡洛回报 <code>G_t</code> 的高方差问题，以及为什么它会导致学习不稳定。</p>
<p><strong>场景设定：</strong></p>
<p>假设我们有一个简单的环境，智能体从一个起始状态 <code>S_0</code> 开始，可以采取两个动作：<code>A_left</code> 或 <code>A_right</code>。</p>
<ul>
<li><strong>动作效果：</strong>
<ul>
<li><code>A_left</code>：有 70% 的概率立即获得 +10 的奖励并结束回合 (win)；有 30% 的概率立即获得 -5 的奖励并结束回合 (lose)。</li>
<li><code>A_right</code>：进入一个中间状态 <code>S_intermediate</code>。</li>
</ul>
</li>
<li><strong>中间状态 <code>S_intermediate</code>：</strong>
<ul>
<li>从 <code>S_intermediate</code> 开始，无论采取什么后续动作（假设只有一个默认动作），有 50% 的概率获得 +100 的巨大奖励并结束回合 (big win)；有 50% 的概率获得 -100 的巨大惩罚并结束回合 (big loss)。</li>
</ul>
</li>
</ul>
<p><strong>智能体的策略：</strong></p>
<p>假设智能体的策略网络 <code>π_θ(a|S_0)</code> 在起始状态 <code>S_0</code> 对两个动作的输出概率是可调整的。我们的目标是学习到在 <code>S_0</code> 时应该选择哪个动作。</p>
<p><strong>纯粹的策略梯度 (REINFORCE) 如何工作：</strong></p>
<p>REINFORCE算法的策略梯度更新规则大致如下：<br>
<code>∇_θ J(θ) ≈ E [ Σ_t ∇_θ log π_θ(a_t|s_t) * G_t ]</code></p>
<p>其中 <code>G_t</code> 是从时间步 <code>t</code> 开始到回合结束的累积折扣回报。为了简化，我们假设折扣因子 <code>γ = 1</code>，并且我们只关注在 <code>S_0</code> 处做的第一个决策。所以，<code>G_0</code> 就是整个回合的总回报。</p>
<p><strong>分析高方差问题：</strong></p>
<p>我们来分析在 <code>S_0</code> 采取不同动作时 <code>G_0</code> 的情况：</p>
<ol>
<li>
<p><strong>如果智能体在 <code>S_0</code> 选择 <code>A_left</code>：</strong></p>
<ul>
<li>有 70% 的概率，<code>G_0 = +10</code>。</li>
<li>有 30% 的概率，<code>G_0 = -5</code>。</li>
<li><code>A_left</code> 的期望回报 = <code>0.7 * 10 + 0.3 * (-5) = 7 - 1.5 = 5.5</code>。这是一个相当不错的稳定正回报。</li>
</ul>
</li>
<li>
<p><strong>如果智能体在 <code>S_0</code> 选择 <code>A_right</code>：</strong></p>
<ul>
<li>智能体进入 <code>S_intermediate</code>。</li>
<li>然后，有 50% 的概率，<code>G_0 = +100</code>。</li>
<li>有 50% 的概率，<code>G_0 = -100</code>。</li>
<li><code>A_right</code> 的期望回报 = <code>0.5 * 100 + 0.5 * (-100) = 50 - 50 = 0</code>。从期望上看，这个动作并不好。</li>
</ul>
</li>
</ol>
<p><strong>高方差如何影响学习：</strong></p>
<p>假设智能体通过多次试验来学习。</p>
<ul>
<li>
<p><strong>考虑 <code>A_left</code>：</strong></p>
<ul>
<li>大部分情况下，智能体采取 <code>A_left</code> 会得到 <code>+10</code> 的回报。<code>log π_θ(A_left|S_0)</code> 这一项会乘以一个正数，使得策略更倾向于 <code>A_left</code>。</li>
<li>少数情况下，得到 <code>-5</code>。<code>log π_θ(A_left|S_0)</code> 会乘以一个负数，略微抑制 <code>A_left</code>。</li>
<li>回报的方差相对较小（值在 -5 到 10 之间波动）。</li>
</ul>
</li>
<li>
<p><strong>考虑 <code>A_right</code>：</strong></p>
<ul>
<li>一半情况下，智能体采取 <code>A_right</code> 会得到 <code>+100</code> 的巨大回报。<code>log π_θ(A_right|S_0)</code> 会乘以一个非常大的正数。这会<strong>极大地</strong>增强选择 <code>A_right</code> 的倾向。</li>
<li>另一半情况下，智能体采取 <code>A_right</code> 会得到 <code>-100</code> 的巨大惩罚。<code>log π_θ(A_right|S_0)</code> 会乘以一个非常大的负数。这会<strong>极大地</strong>抑制选择 <code>A_right</code> 的倾向。</li>
<li>回报的方差非常大（在 -100 和 +100 之间剧烈波动）。</li>
</ul>
</li>
</ul>
<p><strong>学习过程中的问题：</strong></p>
<ol>
<li>
<p><strong>不稳定的梯度估计：</strong> 假设智能体当前策略对 <code>A_left</code> 和 <code>A_right</code> 的概率相近。</p>
<ul>
<li>如果某一批次的经验中，恰好多次采取 <code>A_right</code> 都碰上了 <code>+100</code> 的好运气，那么梯度更新会强烈地让智能体未来更倾向于选择 <code>A_right</code>，尽管 <code>A_right</code> 的期望回报是0，不如 <code>A_left</code> 的期望回报5.5。</li>
<li>反之，如果多次采取 <code>A_right</code> 都碰上了 <code>-100</code> 的坏运气，梯度更新会强烈地让智能体避开 <code>A_right</code>。</li>
<li>这种基于少数样本的剧烈波动使得梯度的方向非常不稳定。</li>
</ul>
</li>
<li>
<p><strong>“好的动作可能因为后续一系列坏的随机事件而导致低回报”：</strong><br>
在这个例子中，<code>A_left</code> 本身是一个期望回报为正 (5.5) 的好动作。但如果智能体尝试 <code>A_left</code>，有 30% 的几率得到 <code>-5</code>。如果此时它也尝试了 <code>A_right</code> 并且碰巧得到了 <code>+100</code>，那么算法可能会错误地认为 <code>A_right</code> 比 <code>A_left</code> 好得多，尽管只是因为 <code>A_right</code> 后续的随机性导致了一个偶然的高回报。</p>
</li>
<li>
<p><strong>“坏的动作可能因为后续一系列好的随机事件而导致高回报”：</strong><br>
<code>A_right</code> 本身是一个期望回报为零的动作（不如 <code>A_left</code>）。但是，如果智能体尝试 <code>A_right</code>，有 50% 的概率得到 <code>+100</code> 的高回报。如果它恰好在少数几个样本中都经历了这种情况，算法会错误地强化这个“坏”动作。</p>
</li>
<li>
<p><strong>缓慢收敛：</strong> 为了克服这种高方差，算法需要收集大量的样本，才能让 <code>G_t</code> 的平均效果逐渐接近其真实期望。如果方差很大，就需要更多的样本来获得一个可靠的梯度估计，这导致收敛缓慢。智能体的策略可能会在好坏之间来回摆动很长时间。</p>
</li>
</ol>
<p><strong>Actor-Critic如何帮助：</strong></p>
<p>如果使用Actor-Critic：</p>
<ul>
<li>
<p>Critic会学习状态值函数 <code>V(s)</code>。</p>
<ul>
<li>理想情况下，<code>V(S_0)</code> 会学习到接近 <code>5.5</code>（如果最优策略是选 <code>A_left</code>）。</li>
<li><code>V(S_intermediate)</code> 会学习到接近 <code>0</code>。</li>
</ul>
</li>
<li>
<p>当计算优势 <code>A(s, a)</code> 时：</p>
<ul>
<li>对于 <code>A_left</code> 得到 <code>+10</code>：<code>A(S_0, A_left) = r + γV(end) - V(S_0) = 10 + 0 - V(S_0)</code>。如果 <code>V(S_0)</code> 接近 <code>5.5</code>，优势就是 <code>4.5</code>。</li>
<li>对于 <code>A_left</code> 得到 <code>-5</code>：<code>A(S_0, A_left) = -5 + 0 - V(S_0)</code>。如果 <code>V(S_0)</code> 接近 <code>5.5</code>，优势就是 <code>-10.5</code>。</li>
<li>对于 <code>A_right</code> 得到 <code>+100</code>：智能体先到达 <code>S_intermediate</code>（假设这里没有立即奖励），然后得到 <code>+100</code>。<br>
优势的计算会更像是 <code>δ_0 = r_0 + γV(S_intermediate) - V(S_0)</code>。如果 <code>r_0=0</code>（立即奖励为0），<code>δ_0 = γV(S_intermediate) - V(S_0)</code>。如果 <code>V(S_intermediate)</code> 接近0，<code>V(S_0)</code> 接近5.5，那么这个初始TD误差是负的。后续的TD误差 <code>δ_1 = 100 + γV(end) - V(S_intermediate) = 100 - V(S_intermediate)</code> 会是大的正值。GAE会将这些TD误差组合起来。<br>
更简单地看，如果Critic已经比较准确，<code>A(S_0, A_right) = Q(S_0, A_right) - V(S_0)</code>。<code>Q(S_0, A_right)</code> 的期望是0。如果 <code>V(S_0)</code> 是基于当前混合策略的平均值，那么优势值会更好地反映 <code>A_right</code> 相对于当前平均表现的好坏，而不是其绝对回报的剧烈波动。</li>
</ul>
</li>
</ul>
<p>通过引入基线 <code>V(S_0)</code>，优势函数 <code>A(S_0, a)</code> 的波动幅度会减小。例如，即使 <code>A_right</code> 得到了 <code>+100</code>，如果 <code>V(S_0)</code> 已经学到了一个比较高的值（比如因为当前策略有时会选 <code>A_left</code>），那么 <code>+100 - V(S_0)</code> 相比于直接使用 <code>+100</code> 作为权重，其绝对值可能更小，或者其相对其他动作的优势更合理。</p>
<p>这个例子清晰地展示了：</p>
<ul>
<li>蒙特卡洛回报 <code>G_t</code> 的值可以有很大的波动范围。</li>
<li>这种波动不是由动作本身的好坏唯一决定的，而是受到了后续大量随机事件的强烈影响。</li>
<li>使用这种高方差的回报来指导策略更新，会导致梯度估计非常嘈杂，使得学习不稳定且效率低下。</li>
</ul>
<p>而引入Critic和优势函数，就是为了从回报中剥离掉那些与当前状态价值相关但与当前动作选择无关的部分，从而得到一个更纯粹、更低方差的信号来指导Actor的学习。</p>
<br>
<h3 id="心得">心得</h3>
<p>控制状态空间大小，尽量选择有限状态空间</p>
<p>eg: 将state中的一些值int化</p>
<br>
<p>状态空间的表示值尽量接近</p>
<p>采用标准化技术将state内的值均一化</p>
<p>eg: [1, 200, 9999] -&gt; [0.001, 0.99, 0.9999]</p>
<br>
<p>更好的初始化</p>
<br>
<p>reward设置</p>
<p>惩罚和奖励设置插值不要过大, 防止惩罚拟合过快</p>
<p>+2, -200 -&gt; +2, 0</p>
<br>
<h3 id="GRPO相关">GRPO相关</h3>
<p>在强化学习中，<strong>优势函数 (Advantage Function)</strong> <code>A(s, a)</code> 的标准定义是：</p>
<p><code>A(s, a) = Q(s, a) - V(s)</code></p>
<p>这里的每个部分代表：</p>
<ul>
<li><code>s</code> (State): 状态。在LLM的场景中，这通常是输入的<strong>提示（Prompt）</strong>，例如 “What is 2+2?”。</li>
<li><code>a</code> (Action): 动作。在LLM中，这是模型生成的<strong>回答（Response）</strong>，例如 “4”。</li>
<li><code>Q(s, a)</code> (Q-Value): <strong>动作价值函数</strong>。它代表在状态 <code>s</code> 下，执行动作 <code>a</code> 后，期望能获得的总回报。简单来说，就是**“这个具体回答有多好？”**。在RLHF中，这个值通常由奖励模型（Reward Model）直接给出，即 <code>R(s, a)</code>。</li>
<li><code>V(s)</code> (Value): <strong>状态价值函数</strong>。它代表在状态 <code>s</code> 下，遵循当前策略（policy），所能获得的<strong>平均期望回报</strong>。简单来说，就是**“对于这个提示，我的模型平均能回答得多好？”**。</li>
</ul>
<p>所以，优势函数的直观理解是：</p>
<p><strong><code>A(s, a) = (执行特定动作 a 的价值) - (在该状态 s 下的平均价值)</code></strong></p>
<p>它衡量的是，某个具体的回答（<code>a</code>）相比于当前模型对于该提示（<code>s</code>）的“平均水平”来说，是<strong>更好还是更差</strong>。</p>
<ul>
<li>如果 <code>A(s, a) &gt; 0</code>，说明这个回答比模型的平均表现要好，我们应该增加生成这个回答的概率。</li>
<li>如果 <code>A(s, a) &lt; 0</code>，说明这个回答比模型的平均表现要差，我们应该降低生成这个回答的概率。</li>
</ul>
<br>
<p>使用均值代替GAE：</p>
<p><strong>我们不需要一个复杂的神经网络去 <em>学习</em> <code>V(s)</code>，我们可以直接在当前批次的数据中 <em>估算</em> 它。</strong></p>
<p><code>V(s)</code> 的定义是“在状态 <code>s</code> 下的<strong>期望回报</strong>”。期望值在数学上可以通过大量的采样来近似。</p>
<p>这个方法的具体步骤如下（用你的例子 “What is 2+2?”）：</p>
<ol>
<li>
<p><strong>状态 (State)</strong>: <code>s</code> = “What is 2+2?”</p>
</li>
<li>
<p><strong>采样多个动作 (Sample Actions)</strong>: 使用当前策略（LLM），针对同一个提示 <code>s</code> 生成 <code>k</code> 个不同的回答（比如 <code>k=4</code>）。</p>
<ul>
<li><code>a1</code> = “4”</li>
<li><code>a2</code> = “3”</li>
<li><code>a3</code> = “D”</li>
<li><code>a4</code> = “C”</li>
</ul>
</li>
<li>
<p><strong>获取每个动作的回报 (Get Rewards)</strong>: 用奖励模型（Reward Model）为每个回答打分。</p>
<ul>
<li><code>R(s, a1)</code> = 10.0 (非常好的回答)</li>
<li><code>R(s, a2)</code> = 2.0 (错误的数学计算)</li>
<li><code>R(s, a3)</code> = -5.0 (无关的回答)</li>
<li><code>R(s, a4)</code> = -5.0 (无关的回答)</li>
</ul>
</li>
<li>
<p><strong>估算 V(s) - 核心步骤</strong>: 我们用这 <code>k</code> 个回报的<strong>统计均值</strong>来作为 <code>V(s)</code> 的一个近似估计值 <code>V̂(s)</code>。</p>
<ul>
<li><code>V̂(s) ≈ mean(10.0, 2.0, -5.0, -5.0) = (10+2-5-5) / 4 = 0.5</code></li>
<li>这个 <code>0.5</code> 就代表了我们对当前模型在回答“What is 2+2?”这个问题上的**“平均表现”**的估计。</li>
</ul>
</li>
<li>
<p><strong>计算优势函数 A(s, a)</strong>: 现在我们可以为每一个采样出的回答计算其优势值了。</p>
<ul>
<li><code>A(s, a1) = R(s, a1) - V̂(s) = 10.0 - 0.5 = 9.5</code> (远高于平均，非常好)</li>
<li><code>A(s, a2) = R(s, a2) - V̂(s) = 2.0 - 0.5 = 1.5</code> (略高于平均)</li>
<li><code>A(s, a3) = R(s, a3) - V̂(s) = -5.0 - 0.5 = -5.5</code> (远低于平均，很差)</li>
<li><code>A(s, a4) = R(s, a4) - V̂(s) = -5.0 - 0.5 = -5.5</code> (远低于平均，很差)</li>
</ul>
</li>
</ol>
<p>这种方法是<strong>用经验均值（Empirical Mean）来代替期望值（Expectation）</strong>。根据大数定律，当采样数量 <code>k</code> 足够大时，样本均值会收敛于真实的期望值。</p>
<ul>
<li><strong>价值网络 V(s)</strong>: 试图学习一个<strong>函数</strong>，对于任何输入 <code>s</code>，都能输出一个期望回报。它具有泛化能力，但需要额外训练和内存。</li>
<li><strong>取均值 V̂(s)</strong>: 不学习函数，而是<strong>即时计算</strong>。它直接利用当前策略的表现来估算期望回报。这是一种“无模型”（model-free）的估算方式。</li>
</ul>
]]></content>
      <categories>
        <category>Reinforce Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-learning-record</title>
    <url>/2024/10/01/Spring-learning-record/</url>
    <content><![CDATA[<p>Spring相关学习记录</p>
<span id="more"></span>
<h1>网络相关</h1>
<p>案例</p>
<p><strong>处理 GET 请求的流程举例 (以一个简单的 Java Web 应用为例):</strong></p>
<p>假设用户在浏览器中访问 <a href="http://www.example.com/products/123%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96%E4%BA%A7%E5%93%81">http://www.example.com/products/123，这是一个获取产品</a> ID 为 123 的产品的 GET 请求。</p>
<ol>
<li>
<p><strong>客户端 (浏览器) 发起请求:</strong> 浏览器将 GET 请求发送到 <a href="http://www.example.com">www.example.com</a>。</p>
</li>
<li>
<p><strong>反向代理服务器 (如果存在):</strong> 反向代理服务器接收请求。它可能执行一些操作，例如检查缓存，如果缓存命中则直接返回结果。如果没有缓存，则将请求转发到 Web 服务器。</p>
</li>
<li>
<p><strong>Web 服务器 (例如 Apache/Nginx):</strong> Web 服务器接收请求，根据配置将请求转发到相应的应用服务器。</p>
<p>对于静态内容（如 HTML 文件、图片、CSS 和 JavaScript 文件），Web 服务器可以直接从文件系统中读取并返回给客户端，无需涉及应用服务器，从而显著提升性能。Web 服务器通过配置文件中的规则（例如，Nginx 中的 location 指令）来识别静态文件请求，通常根据 URL 路径或文件扩展名进行匹配。例如，请求 /images/logo.png 或 /styles.css，Web 服务器会直接返回对应的文件。 此外，Web服务器还可以设置缓存过期时间，例如通过expires指令，进一步优化对静态资源的访问速度。</p>
<p>对于动态内容，Web 服务器则充当反向代理的角色，将请求转发到后端的应用服务器。例如，URL 路径 /products 可能对应一个需要数据库交互的产品列表页面，Web 服务器会将该请求转发到专门处理产品相关请求的应用服务器。转发规则同样在配置文件中定义，可以基于 URL 路径、请求方法等进行匹配。例如，所有 /api/ 开头的请求都可能被转发到特定的应用服务器。</p>
</li>
<li>
<p><strong>应用服务器 (例如 Tomcat):</strong> 应用服务器接收请求。</p>
<ul>
<li><strong>路由:</strong> 应用服务器根据 URL 路径 /products/123 确定哪个控制器 (Controller) 和方法 (Method) 应该处理这个请求。例如，它可能将请求路由到 ProductController 的 getProduct 方法。</li>
<li><strong>控制器:</strong> ProductController 的 getProduct 方法被调用。该方法从 URL 中提取产品 ID (123)。</li>
<li><strong>服务层 (可选):</strong> 控制器调用服务层 (Service Layer) 的方法来获取产品数据。服务层封装了业务逻辑，例如从数据库中检索产品信息。</li>
<li><strong>数据访问层 (DAO):</strong> 服务层调用数据访问层 (Data Access Object) 的方法来与数据库交互。DAO 负责执行数据库查询。</li>
<li><strong>数据库:</strong> 数据库服务器接收查询请求，返回产品 ID 为 123 的产品数据。</li>
<li><strong>返回数据:</strong> DAO 将数据返回给服务层，服务层将数据返回给控制器。</li>
<li><strong>视图渲染 (可选):</strong> 控制器将数据传递给视图渲染引擎 (例如 JSP, Thymeleaf)，生成 HTML 响应。如果返回的是 JSON 数据，则跳过此步骤。</li>
</ul>
</li>
<li>
<p><strong>应用服务器返回响应:</strong> 应用服务器将生成的 HTML 响应或 JSON 数据返回给 Web 服务器。</p>
</li>
<li>
<p><strong>Web 服务器返回响应:</strong> Web 服务器将响应返回给反向代理服务器 (如果存在)。</p>
</li>
<li>
<p><strong>反向代理服务器返回响应:</strong> 反向代理服务器将响应返回给客户端 (浏览器)。</p>
</li>
<li>
<p><strong>浏览器渲染:</strong> 浏览器接收 HTML 响应并渲染页面，或者处理 JSON 数据。</p>
</li>
</ol>
<h2 id="servlet">servlet</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WebServlet注解表示这是一个Servlet，并映射到地址/:</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置响应类型:</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取输出流:</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        <span class="comment">// 写入响应:</span></span><br><span class="line">        pw.write(<span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 最后不要忘记flush强制输出:</span></span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignInServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span>  <span class="comment">// 会接收所有未匹配的路径，相当于 /*</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程</p>
<ol>
<li><strong>客户端发送GET请求:</strong> 客户端浏览器向服务器发送一个HTTP GET请求到指定的URL（例如/）。</li>
<li><strong>服务器接收请求:</strong> 服务器（例如Tomcat）接收到请求。</li>
<li><strong>Servlet容器匹配Servlet:</strong> Servlet容器根据URL找到对应的Servlet（本例中是HelloServlet）。</li>
<li><strong>Servlet容器创建request和response对象:</strong> Servlet容器创建HttpServletRequest和HttpServletResponse对象。HttpServletRequest封装了客户端请求的信息（例如请求头、参数等），HttpServletResponse用于构建服务器的响应。</li>
<li><strong>Servlet容器调用doGet方法:</strong> Servlet容器调用HelloServlet的doGet方法，并将创建的HttpServletRequest和HttpServletResponse对象作为参数传入。</li>
<li><strong>Servlet处理请求:</strong> 在doGet方法中，使用req对象获取客户端请求的信息，并使用resp对象构建响应。例如，设置响应的内容类型、写入响应内容等。</li>
<li><strong>Servlet容器发送响应:</strong> doGet方法执行完毕后，Servlet容器将resp对象中封装的响应信息发送回客户端。</li>
</ol>
<blockquote>
<p>一个Servlet类在服务器中只有一个实例，但对于每个HTTP请求，Web服务器会使用多线程执行请求。因此，一个Servlet的<code>doGet()</code>、<code>doPost()</code>等处理请求的方法是多线程并发执行的。如果Servlet中定义了字段，要注意多线程并发访问的问题.</p>
</blockquote>
<h2 id="Redirect-与-Forward">Redirect 与 Forward</h2>
<p>Redirect透过HTTP 301 和 302实现</p>
<p>浏览器收到302响应后，它会立刻根据<code>Location</code>的指示发送一个新的<code>GET /hello</code>请求，这个过程就是重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 302 临时重定向</span></span><br><span class="line"><span class="type">String</span> <span class="variable">redirectToUrl</span> <span class="operator">=</span> <span class="string">&quot;/hello&quot;</span> + (name == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;?name=&quot;</span> + name);</span><br><span class="line">resp.sendRedirect(redirectToUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 301 永久重定向，浏览器会缓存/hi到/hello这个重定向的关联，下次请求/hi的时候，浏览器就直接发送/hello请求了</span></span><br><span class="line">resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); <span class="comment">// 301</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;/hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/morning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForwardServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/hello&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Session-与-Cookie">Session 与 Cookie</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, name);</span><br></pre></td></tr></table></figure>
<p>流程:</p>
<ol>
<li>
<p>HttpSession session = req.getSession();: 这一行代码获取或创建一个与当前请求关联的 HttpSession 对象。如果<strong>请求报文</strong>中包含的会话 ID（<code>Cookie: JSESSIONID=ABCDEF1234567890</code>），服务器会尝试检索与该 ID 关联的现有会话。如果找不到或会话 ID 无效，服务器会创建一个新的会话，并生成一个新的会话 ID。</p>
</li>
<li>
<p>session.setAttribute(“user”, name);: 这一行代码将名为 “user” 的属性及其值 name 存储到会话对象中。此数据存储在服务器端，而不是直接发送到客户端。</p>
<blockquote>
<p>HttpSession 对象保存在服务器端。存储在 Session 中的值代表了与特定客户端会话相关的数据。例如，在用户登录后，可以将用户名存储在 Session 中，以便在后续请求中识别用户身份，而无需用户每次都重新登录。其他常见的例子包括：</p>
<ul>
<li>购物车中的商品</li>
<li>用户的偏好设置</li>
<li>用户的浏览历史</li>
<li>游戏中的分数</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>设置 Cookie：</strong> 当服务器处理完请求并准备发送响应时，如果创建了新的会话或现有会话被修改，服务器会将 Set-Cookie 头添加到响应中。这个头包含新创建的或更新的会话 ID。客户端（通常是浏览器）收到此头后，会将会话 ID 存储在一个 cookie 中。</p>
<blockquote>
<p>只有当以下几种情况发生时，服务器才会更新或发送新的 Cookie：</p>
<ol>
<li><strong>创建新的会话：</strong> 当客户端第一次访问需要会话的资源时，服务器会创建一个新的 HttpSession 对象，并生成一个新的会话 ID，然后通过 Set-Cookie 头将新的会话 ID 发送给客户端。</li>
<li><strong>会话 ID 重新生成（较少见）：</strong> 出于安全考虑，服务器可能会在某些情况下重新生成会话 ID，例如用户登录后。这时服务器会发送一个新的 Set-Cookie 头，其中包含新的会话 ID。</li>
<li><strong>会话过期时间更新（如果配置了）：</strong> 如果服务器配置了会话的过期时间，并且在会话过程中更新了过期时间，服务器可能会发送一个新的 Set-Cookie 头来更新 Cookie 中的过期时间信息。</li>
<li><strong>其他与会话相关的 Cookie 属性更改：</strong> 例如，如果服务器更改了 Cookie 的 HttpOnly、Secure、Path 或 Domain 属性，则需要发送新的 Set-Cookie 头来更新客户端的 Cookie。</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>后续请求：</strong> 客户端在后续请求中会自动将这个 cookie 发送回服务器。服务器根据 cookie 中的会话 ID 检索相应的 HttpSession 对象，从而维护会话状态。</p>
</li>
</ol>
<p>除了使用Cookie机制可以实现Session外，还可以通过隐藏表单、URL末尾附加ID来追踪Session。</p>
<h2 id="JSP">JSP</h2>
<p>JSP（JavaServer Pages）是一种用于创建动态 Web 页面的技术。它允许您在 HTML 页面中嵌入 Java 代码，从而生成动态内容。Tomcat 在处理 JSP 页面时扮演着关键角色，其过程如下：</p>
<ol>
<li>
<p><strong>翻译阶段 (Translation):</strong> 当浏览器第一次请求 JSP 页面时，Tomcat 的 JSP 引擎会将 JSP 页面翻译成一个 Java Servlet 源文件。这个源文件包含了 JSP 页面中的所有 HTML、Java 代码以及 JSP 指令。  这个转换过程主要包括以下步骤：</p>
<ul>
<li><strong>解析 JSP 指令:</strong>  JSP 指令（例如 <code>&lt;%@ page ... %&gt;</code>, <code>&lt;%@ include ... %&gt;</code>, <code>&lt;%@ taglib ... %&gt;</code>）会被解析并用于配置生成的 Servlet。</li>
<li><strong>将 HTML 转换为 Java 代码:</strong> JSP 页面中的 HTML 代码会被转换为 <code>out.write()</code> 语句，其中 <code>out</code> 是 <code>JspWriter</code> 对象，用于将内容输出到客户端。</li>
<li><strong>嵌入 Java 代码:</strong>  JSP 页面中的 Java 代码片段（例如 <code>&lt;% ... %&gt;</code> 和 <code>&lt;%= ... %&gt;</code>）会被直接嵌入到生成的 Servlet 的 <code>_jspService()</code> 方法中。</li>
</ul>
</li>
<li>
<p><strong>编译阶段 (Compilation):</strong> 翻译生成的 Java Servlet 源文件会被 Java 编译器编译成一个 Java Servlet class 文件 (<code>.class</code> 文件)。</p>
</li>
<li>
<p><strong>加载阶段 (Loading):</strong> Tomcat 的类加载器会将编译好的 Servlet class 文件加载到内存中。</p>
</li>
<li>
<p><strong>实例化阶段 (Instantiation):</strong> Tomcat 创建 Servlet 的一个实例。</p>
</li>
<li>
<p><strong>初始化阶段 (Initialization):</strong> Tomcat 调用 Servlet 的 <code>init()</code> 方法，对 Servlet 进行初始化。 这通常只发生一次，在 Servlet 第一次被请求时。</p>
</li>
<li>
<p><strong>请求处理阶段 (Request Processing):</strong>  当浏览器请求 JSP 页面时，Tomcat 会调用 Servlet 的 <code>_jspService()</code> 方法。这个方法包含了 JSP 页面中的所有逻辑，并负责生成动态内容。  <code>_jspService()</code> 方法会根据 HTTP 请求的类型 (GET, POST 等) 执行相应的逻辑。</p>
</li>
<li>
<p><strong>销毁阶段 (Destruction):</strong> 当 Tomcat 关闭或需要卸载 Servlet 时，会调用 Servlet 的 <code>destroy()</code> 方法，释放资源。</p>
</li>
</ol>
<p><strong>简而言之，Tomcat 将 JSP 页面转换为 Servlet，然后像对待其他 Servlet 一样处理它。 这意味着 JSP 页面最终会被转换成 Java 代码，并在服务器端执行。</strong></p>
<p><strong>示例：</strong></p>
<p>假设有一个简单的 JSP 页面 <code>hello.jsp</code>：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello, &lt;%= <span class="keyword">new</span> <span class="title class_">java</span>.util.Date() %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>Tomcat 会将其转换为类似以下的 Servlet 代码 (简化版)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello_jsp</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">JspWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">    out.write(<span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;html&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;head&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;title&gt;Hello JSP&lt;/title&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/head&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;body&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;h1&gt;Hello, &quot;</span>);</span><br><span class="line">    out.print(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date());</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/h1&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/body&gt;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/html&gt;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，HTML 代码被转换为 <code>out.write()</code> 语句，而 Java 代码 <code>&lt;%= new java.util.Date() %&gt;</code> 被嵌入到 <code>_jspService()</code> 方法中。  最终，这个 Servlet 会被编译并执行，生成动态的 HTML 页面并返回给浏览器。</p>
<h2 id="Filter">Filter</h2>
<p><strong>过滤器链 (FilterChain):</strong> Servlet 容器会根据 web.xml 或注解中的配置，将匹配 URL 模式的过滤器组成一个链条。当请求到达时，容器会依次调用链上的过滤器。</p>
<p><strong>chain.doFilter():</strong> 这个方法是将控制权交给过滤器链中的下一个实体。</p>
<ul>
<li><strong>如果有下一个过滤器:</strong> 控制权会转移到下一个过滤器，执行其 doFilter() 方法。</li>
<li><strong>如果没有下一个过滤器:</strong> 控制权会转移到目标 servlet，执行其 service() 方法 (进而调用 doGet(), doPost() 等)。</li>
</ul>
<p><strong>过滤器执行顺序:</strong> 过滤器链的执行顺序与它们在 web.xml 中的声明顺序或注解的顺序相同。</p>
<p><strong>请求处理流程:</strong> 一个请求的完整过滤流程如下：</p>
<ul>
<li>请求到达服务器。</li>
<li>服务器根据 URL 匹配过滤器链。</li>
<li>第一个过滤器执行 doFilter() 方法。</li>
<li>第一个过滤器调用 chain.doFilter()，将控制权交给下一个过滤器或 servlet。</li>
<li>重复步骤 4，直到最后一个过滤器执行完毕。</li>
<li>目标 servlet 执行 service() 方法处理请求。</li>
<li>响应返回客户端，过滤器链反向执行，每个过滤器可以对响应进行处理。</li>
</ul>
<h2 id="Listener">Listener</h2>
<p>一个web项目一个ServletContext对象</p>
<blockquote>
<p>即使一个项目中有多个 Servlet，它们都共享同一个 ServletContext。ServletContext 代表整个 Web 应用程序，它提供了一种在不同 Servlet 之间共享信息和资源的机制。</p>
</blockquote>
<h1>Spring</h1>
<p><a href="https://liaoxuefeng.com/books/java/spring/index.html">https://liaoxuefeng.com/books/java/spring/index.html</a></p>
<h2 id="IoC">IoC</h2>
<p>Inversion of Control 控制反转</p>
<ul>
<li>核心是 BeanFactory 和 ApplicationContext</li>
<li>通过反射机制实例化bean并创建bean之间的依赖关系</li>
<li>管理bean的生命周期</li>
</ul>
<h2 id="AoP">AoP</h2>
<p>Aspect-Oriented-Programming 面向切面编程</p>
<ul>
<li>核心是ProxyFactory</li>
<li>两种代理方式：JDK动态代理和CGLIB</li>
<li>通过织入切面来实现功能的统一维护</li>
</ul>
<h3 id="JDK动态代理和CGLIB">JDK动态代理和CGLIB</h3>
<p><a href="https://open8gu.com/framework/spring/tc8yg7e1e6aa7khd/">https://open8gu.com/framework/spring/tc8yg7e1e6aa7khd/</a></p>
<p><strong>无法AOP/bean的情况</strong></p>
<p>1.类为final类且没有实现接口</p>
<p>注意：final类可以通过反射创建</p>
<blockquote>
<p>如果类实现了接口，可以通过JDK动态代理的方式实现AOP；如果类不为Final，可以通过CGLIB继承的方式实现AOP</p>
</blockquote>
<p>2.构造函数为private的类</p>
<p>注意：构造函数为private的类仍然可以使用反射创建，即使通过反射，访问 <code>private</code> 构造函数也需要额外的权限（如调用 <code>setAccessible(true)</code>），而 Spring 默认不会这样做，因为这可能违反类的设计意图。</p>
<h2 id="IoC容器与IoC对象">IoC容器与IoC对象</h2>
<p><strong>Bean 对象</strong>通常被称为<strong>IoC 对象</strong>，它们是由 Spring 的 <strong>IoC 容器</strong>负责管理的对象。</p>
<p>Spring IoC 容器的创建过程：</p>
<ul>
<li>
<p><strong>基于 XML 配置</strong>：当加载 XML 配置文件时，容器会初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有spring注解哦，此时spring容器尚未启动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);  <span class="comment">// 启动spring容器并基于application.xml扫描并创建bean</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 UserService Bean</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 login 方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- application.xml --&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;emailService&quot;</span> class=<span class="string">&quot;com.example.EmailService&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">&quot;emailService&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>基于 Java 配置类</strong>：当有 <code>@Configuration</code> 类时，Spring 会通过 Java 配置类创建 IoC 容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);  <span class="comment">// 基于AppConfig.java 扫描</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AppConfig.java</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(emailService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EmailService <span class="title function_">emailService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmailService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="注解">注解</h2>
<p><strong>构造性注解</strong>: 被构造性注解标记的类，Spring会自动使用无参构造函数创建该类的Bean</p>
<ul>
<li>
<p>@Component: 这是最通用的构造型注解，可以用于标记任何需要被 Spring 管理的类。</p>
</li>
<li>
<p>@Service: 用于标记服务层组件，通常包含业务逻辑。</p>
</li>
<li>
<p>@Repository: 用于标记数据访问层组件，例如 DAO (Data Access Object) 类。</p>
</li>
<li>
<p>@Controller:</p>
<ul>
<li>用于标记 Web 层控制器组件，例如 Spring MVC 中的控制器类。</li>
<li>使用 @Controller，需要在每个处理 RESTful 请求的方法上添加 @ResponseBody 注解，以便将返回值作为响应体发送。</li>
</ul>
</li>
<li>
<p>@Configuration: 用于标记配置类，通常包含 @Bean 注解标记的方法，用于创建 Bean。</p>
</li>
<li>
<p>@RestController:</p>
<ul>
<li>用于标记 RESTful Web 服务的控制器组件，相当于 @Controller 和 @ResponseBody 的组合。</li>
<li>使用 @RestController，所有方法的返回值都将自动作为响应体发送，无需额外添加 @ResponseBody 注解。</li>
<li>编写REST接口需要定义<code>@RestController</code>，然后，每个方法都是一个API接口，输入和输出只要能被Jackson序列化或反序列化为JSON就没有问题。</li>
</ul>
</li>
</ul>
<p><strong>依赖注入注解：</strong></p>
<ul>
<li>
<p>@Autowired：用于自动注入依赖</p>
<ul>
<li>默认按照类型（byType）装配依赖对象。如果有多个相同类型的 Bean，会尝试按照名称（byName）进行匹配。如果没有匹配的 Bean，会抛出异常。</li>
<li>可以作用于构造函数、字段、Setter 方法等。</li>
</ul>
</li>
<li>
<p>@Resource：用于注入依赖</p>
<ul>
<li>默认按照名称（byName）装配依赖对象。名称可以通过 name 属性指定，如果没有指定，则默认使用字段名或 setter 方法的参数名作为名称。如果找不到名称匹配的 Bean，会回退到按照类型（byType）进行匹配。如果仍然找不到匹配的 Bean，会抛出异常。</li>
<li>可以用于字段和 setter 方法上，不能用于构造函数和配置方法上。</li>
</ul>
</li>
<li>
<p>@Value：用于注入属性值，可以注入配置文件中的值、系统属性、环境变量等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValueExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;&#125;访问外部属性（配置文件、系统属性、环境变量）,简单变量替换</span></span><br><span class="line">    <span class="comment">// #&#123;&#125;运行时计算表达式，动态计算值、条件判断、集合操作等</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注入 application.properties 或 application.yml 中的属性值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入系统属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.home&#125;&quot;)</span>  <span class="comment">// 等同于 System.getProperty(&quot;user.home&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userHome;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入环境变量 (需要先设置环境变量)</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;MY_ENV_VAR&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String myEnvVar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 SpEL 表达式设置默认值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.description:Default Description&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appDescription;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入字面量</span></span><br><span class="line">    <span class="meta">@Value(&quot;A hardcoded value&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String hardcodedValue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入数组 (application.properties: app.features=feature1,feature2,feature3)</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.features&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String[] appFeatures;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入 List (需要 Spring Boot 2.4 以上版本， application.properties: app.colors=red,green,blue)</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;$&#123;app.colors&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> java.util.List&lt;String&gt; appColors;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 + 2&#125;&quot;)</span> <span class="comment">// 计算 1 + 2 的结果，结果为 3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;T(java.lang.Math).random() * 100.0&#125;&quot;)</span> <span class="comment">// 调用 Math.random() 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> randomNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;beanName.methodName()&#125;&quot;)</span> <span class="comment">// 调用 Spring Bean 的方法</span></span><br><span class="line">    <span class="keyword">private</span> String result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printValues</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;App Name: &quot;</span> + appName);</span><br><span class="line">        System.out.println(<span class="string">&quot;User Home: &quot;</span> + userHome);</span><br><span class="line">        System.out.println(<span class="string">&quot;My Env Var: &quot;</span> + myEnvVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;App Description: &quot;</span> + appDescription);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hardcoded Value: &quot;</span> + hardcodedValue);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;App Features: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String feature : appFeatures) &#123;</span><br><span class="line">            System.out.print(feature + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;App Colors: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String color : appColors) &#123;</span><br><span class="line">            System.out.print(color + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// application.properties 示例</span></span><br><span class="line"><span class="comment">// app.name=My Application</span></span><br><span class="line"><span class="comment">// app.description=A great application</span></span><br><span class="line"><span class="comment">// app.features=feature1,feature2,feature3</span></span><br><span class="line"><span class="comment">// app.colors=red,green,blue</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>生命周期注解：</strong></p>
<ul>
<li>@PostConstruct：用于标记初始化方法，在 Bean 创建后执行。</li>
<li>@PreDestroy：用于标记销毁方法，在 Bean 销毁前执行。</li>
</ul>
<p><strong>AOP 相关注解：</strong></p>
<ul>
<li>
<p>@Aspect：用于标记切面类。</p>
<p>一个切面类可以对<strong>多个类的多个方法</strong>进行切面增强，</p>
<p>多切面类示例：例如，可以创建一个 LoggingAspect 用于日志记录，创建一个 SecurityAspect 用于安全控制，创建一个 TransactionAspect 用于事务管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 在执行UserService的每个方法前执行:</span></span><br><span class="line">    <span class="comment">// 切面增强UserService类的所有公共方法</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Before] do access check...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行MailService的每个方法前后执行:</span></span><br><span class="line">    <span class="comment">// 切面增强MailService类的所有公共方法</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] start &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] done &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>  <span class="comment">// 配合@Aspect使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring的IoC容器发现配置类存在该注解后，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。</p>
</li>
<li>
<p>@Before、@After、@Around 等：用于定义切点和增强。</p>
</li>
</ul>
<p><strong>事务管理注解：</strong></p>
<ul>
<li>
<p>@Transactional：用于声明事务，可以作用于类或方法</p>
<ul>
<li>
<p>表示被标记类的所有<code>public</code>方法/被标记方法具有事务支持</p>
</li>
<li>
<p>类的方法或方法执行过程中如果抛出异常，回滚发生</p>
</li>
<li>
<p>可以针对指定异常抛出，发生回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>Web 相关注解：</strong></p>
<ul>
<li>
<p>@RequestMapping：</p>
<p>将 HTTP 请求映射到控制器方法;</p>
<p>定义 URL 映射规则，例如 /users、/users/{id} 等;</p>
<p>指定 HTTP 请求方法，例如 GET、POST、PUT、DELETE 等;</p>
<p>定义请求参数，例如 @RequestParam、@PathVariable 等.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>@GetMapping、@PostMapping 等：@RequestMapping 的特化，用于简化请求映射的配置。</p>
</li>
<li>
<p>@PathVariable：用于获取 URL 中的路径变量。</p>
</li>
<li>
<p>@RequestParam：用于获取请求参数。</p>
</li>
<li>
<p>@RequestBody：用于将 HTTP 请求体转换为方法参数。</p>
</li>
<li>
<p>@ResponseBody:</p>
<ul>
<li>方法的返回值转换为指定的格式，例如 JSON 或 XML，并将其作为响应体发送给客户端。</li>
<li>应用于方法上, 只对该方法生效; 应用于类上, 对该类中的所有方法生效。</li>
</ul>
</li>
</ul>
<p><strong>测试相关注解：</strong></p>
<ul>
<li>@SpringBootTest：用于标记 Spring Boot 测试类。</li>
<li>@MockBean：用于模拟 Bean，方便进行单元测试。</li>
</ul>
<p><strong>其他注解：</strong></p>
<ul>
<li>@Scope：用于指定 Bean 的作用域。</li>
<li>@ComponentScan
<ul>
<li>如果某类被注解<code>@ComponentScan</code>标注，则会扫描标注该注解的类所在包及其子包中的所有组件（包括 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 等）</li>
<li>如果被 <code>@ComponentScan</code> 标注的 <code>MyApplication</code> 类位于 <code>com.example</code> 包下，Spring 会默认扫描 <code>com.example</code> 包及其所有子包，例如 <code>com.example.domain</code>。</li>
</ul>
</li>
<li>@Lazy：用于延迟初始化 Bean。</li>
<li>@Profile：用于根据不同的环境激活不同的 Bean。</li>
<li>@Conditional：用于根据条件创建 Bean。</li>
<li><strong>@PropertySource:</strong>
<ul>
<li><strong>作用:</strong> 将外部属性文件加载到 Spring 的 Environment 中。这些属性文件可以是 properties 文件、yaml 文件或其他格式的文件。</li>
<li><strong>使用场景:</strong> 主要用于导入配置文件，例如 application.properties、application.yml 等，或者自定义的配置文件。</li>
<li><strong>绑定方式:</strong> @PropertySource <strong>不会</strong>直接将属性绑定到 Java Bean 上。它只是将属性加载到 Environment 中，使用 @Value 注解或 Environment 对象来访问这些属性。</li>
</ul>
</li>
<li><strong>@ConfigurationProperties:</strong>
<ul>
<li><strong>作用:</strong> 将配置文件中的属性绑定到一个 Java Bean 上。</li>
<li><strong>使用场景:</strong> 主要用于将一组相关的配置属性组织成一个 Java Bean，方便管理和使用。</li>
<li><strong>绑定方式:</strong> @ConfigurationProperties 会自动将配置文件中与 Bean 属性名称匹配的属性值注入到 Bean 中。支持松散绑定（relaxed binding），例如 my-property 可以绑定到 myProperty 属性。</li>
</ul>
</li>
</ul>
<h3 id="Resource-与-Autowired"><code>@Resource</code> 与 <code>@Autowired</code></h3>
<p><strong><code>@Autowired</code> 和 <code>@Resource</code> 的注入方式</strong></p>
<p><strong>字段注入：</strong></p>
<ul>
<li>
<p>直接在字段上使用 <code>@Autowired</code> 或 <code>@Resource</code>，Spring 会通过反射将依赖注入到字段中。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnotherComponent anotherComponent;<span class="comment">// 字段注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>setter 方法注入：</strong></p>
<ul>
<li>
<p>在 setter 方法上使用 <code>@Autowired</code> 或 <code>@Resource</code>，Spring 会调用该 setter 方法注入依赖。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AnotherComponent anotherComponent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAnotherComponent</span><span class="params">(AnotherComponent anotherComponent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.anotherComponent = anotherComponent;<span class="comment">// setter 注入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>构造方法注入：</strong></p>
<ul>
<li>
<p>在构造方法上使用 <code>@Autowired</code>，Spring 会通过构造方法注入依赖。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnotherComponent anotherComponent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyComponent</span><span class="params">(AnotherComponent anotherComponent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.anotherComponent = anotherComponent;<span class="comment">// 构造方法注入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>构造方法注入与显式使用 <code>@Autowired</code> 或 <code>@Resource</code></strong></p>
<ul>
<li>
<p><strong>Spring 4.3 及以上版本</strong>：</p>
<ul>
<li>
<p>如果类只有一个构造方法，Spring 会自动将其用于依赖注入，<strong>不需要显式添加 <code>@Autowired</code></strong>。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnotherComponent anotherComponent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyComponent</span><span class="params">(AnotherComponent anotherComponent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.anotherComponent = anotherComponent;<span class="comment">// 自动注入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这是 Spring 官方推荐的构造方法注入方式。</p>
</li>
</ul>
</li>
<li>
<p><strong>多个构造方法</strong>：</p>
<ul>
<li>
<p>如果类有多个构造方法，必须显式使用 <code>@Autowired</code> 来指定哪个构造方法用于依赖注入。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnotherComponent anotherComponent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyComponent</span><span class="params">(AnotherComponent anotherComponent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.anotherComponent = anotherComponent;<span class="comment">// 显式注入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.anotherComponent = <span class="literal">null</span>;<span class="comment">// 默认构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>@Resource</code> 不支持构造方法注入：</p>
<ul>
<li><code>@Resource</code> 只能用于字段注入和 setter 方法注入，<strong>不能用于构造方法注入</strong>。</li>
</ul>
</li>
</ul>
<p><strong><code>@Resource</code> 的设计目的和行为</strong></p>
<p><strong>设计目的：</strong></p>
<ul>
<li><code>@Resource</code> 是 Java 标准注解（<code>javax.annotation.Resource</code>），最初是为 Java EE 设计的，用于依赖注入。不依赖于特定的框架，可以在任何符合 Java EE 标准的应用中使用。</li>
<li>默认按名称（byName）进行注入。如果没有指定名称，则会按类型（byType）进行注入。</li>
<li>默认情况下，如果找不到匹配的 bean，会抛出异常。可以通过 <code>@Resource(name = &quot;beanName&quot;, type = MyBean.class)</code> 来指定类型，避免异常。</li>
</ul>
<p><strong>行为：</strong></p>
<ul>
<li><code>@Resource</code> 只能用于<strong>字段注入</strong>和<strong>setter 方法注入</strong>，因为它依赖于 Java 的反射机制来直接访问字段或调用 setter 方法。</li>
<li><code>@Resource</code> 不支持构造方法注入，因为它没有设计用于处理构造方法的逻辑。</li>
</ul>
<p><strong><code>@Autowired</code> 的设计目的和行为</strong></p>
<p><strong>设计目的：</strong></p>
<ul>
<li><code>@Autowired</code> 是 Spring 框架的注解，依赖于 Spring 框架。</li>
<li>默认按类型（byType）进行注入。如果有多个相同类型的 bean，会按名称（byName）进行匹配，同时支持<strong>构造方法注入</strong>。</li>
<li>默认情况下，Spring 会要求被注入的 bean 必须存在，否则会抛出异常。可以通过 <code>@Autowired(required = false)</code> 来允许注入为 <code>null</code>。</li>
</ul>
<p><strong>行为：</strong></p>
<ul>
<li><code>@Autowired</code> 可以用于<strong>字段注入</strong>、<strong>setter 方法注入</strong>和<strong>构造方法注入</strong>。</li>
<li>对于构造方法注入，<code>@Autowired</code> 会通过 Spring 的依赖注入机制，选择合适的构造方法并注入依赖。</li>
</ul>
<h2 id="BeanFactory-FactoryBean">BeanFactory &amp; FactoryBean</h2>
<p>ref: <a href="https://open8gu.com/framework/spring/dhzlrik2ylop354g/">https://open8gu.com/framework/spring/dhzlrik2ylop354g/</a></p>
<p><strong>BeanFactory</strong></p>
<p><code>BeanFactory</code> 是 Spring 中用于管理 Bean 生命周期的核心组件，Spring 官方文档将其称为 IOC 容器，它即是我们一般俗称的 “Spring 容器”。</p>
<p><code>BeanFactory</code> 是最顶级的接口，里面定义了获取和创建 Bean 的最基本方法，它下面又根据功能和抽象级别细分五个接口：</p>
<ul>
<li><strong>ListableBeanFactory</strong>：扩展了对 Bean 的批量操作，比如获取所有 Bean 的名称，或者按照类型获取 Bean 等（我们常用的 <code>getBeansOfType</code> 方法就是它提供的）。</li>
<li><strong>HierarchicalBeanFactory</strong>：用于支持层次性的 <code>BeanFactory</code> 结构，从而实现 <code>BeanFactory</code> 的嵌套，形成父子关系。</li>
<li><strong>AutowireCapableBeanFactory</strong>：用于提供提供对 Bean 自动装配的支持。</li>
<li><strong>ConfigurableBeanFactory</strong>：它继承了 <code>AutowireCapableBeanFactory</code> 和 <code>SingletonBeanRegistry</code> ，用于提供包括 <code>Scope</code> 管理、类加载器、上级工厂、表达式解析器……等等各种配置项。</li>
<li><strong>ConfigurableListableBeanFactory</strong>：继承了 <code>ConfigurableBeanFactory</code> 和 <code>ListableBeanFactory</code>，是集全部 <code>BeanFactory</code> 接口之大成者。</li>
</ul>
<p>它的最底层实现类是 <code>DefaultListableBeanFactory</code>，它直接或间接实现了所有 <code>BeanFactory</code> 接口，是在项目中最常用的实现类。</p>
<p>在比较早期的版本中，Spring 基于 <code>DefaultListableBeanFactory</code> 提供了 <code>XmlBeanFactory</code> 它相当于一个具备根据 XML 文件加载 Bean 定义功能的 <code>DefaultListableBeanFactory</code>。</p>
<p>而在更高的版本，Spring 则提供了 <code>ApplicationContext</code> 接口，它继承了 <code>BeanFactory</code>，并且额外通过其他接口获得了加载资源、国际化、时间等扩展功能。</p>
<p><strong>FactoryBean</strong></p>
<p>Spring 中的 <code>FactoryBean</code> 是一个特殊的接口，实现了该接口的 Bean 变为专门用来创建某种特定类型对象的工厂。</p>
<p>它被广泛用于创建一些：</p>
<ul>
<li><strong>无法通过正常的构造函数创建的对象</strong>：比较典型的是各种代理，比如 Dubbo 使用 <code>ReferenceBean</code> 创建 RPC 接口的代理对象，Mybatis 使用 <code>MapperFactoryBean</code> 来创建 Mapper 接口代理。</li>
<li><strong>创建过程比较复杂的对象</strong>：比较典型的是 <code>SqlSession</code>， 比如 JPA 和 Myabtis 都选择通过一个 <code>SqlSessionFactoryBean</code> 来创建它。</li>
</ul>
<p>该接口中定义了<strong>三个方法</strong>，分别是：</p>
<ul>
<li><code>getObject</code> ：用于从工厂中获取一个 Bean 实例。</li>
<li><code>getObjectType</code>：获取实例的类型。</li>
<li><code>isSingleton</code>：判断这个 Bean 是否是单例的。</li>
</ul>
<p>通常情况下，如果 <code>FactoryBean</code> 的 <code>isSingleton</code> 方法返回 <code>true</code>，则其生产的对象就会是单例的，反之则为多例的。不过，如果 <code>FactoryBean</code> 本身是多例的，那么无论<code>isSingleton</code> 方法是否返回 <code>true</code>， 其产物也将变为多例的。</p>
<p>我们可以通过 <code>FactoryBean</code> 的 beanName 从 Spring 容器获得<strong>其生产的对象</strong>，而当需要从 Spring 容器中获取 <code>FactoryBean</code> 本身时，需要在 beanName 前加 <code>&amp;</code> 符号。</p>
<h2 id="Bean的创建">Bean的创建</h2>
<h3 id="使用构造函数注入-使用-Setter-方法注入">使用构造函数注入 &amp;&amp; 使用 Setter 方法注入</h3>
<p>构造方法注入</p>
<ul>
<li>不可变性：依赖通过构造方法注入后，通常会被声明为 <code>final</code>，确保依赖不可变。</li>
<li>强制依赖：构造方法要求所有依赖必须在实例化时注入，确保 Bean 在创建后是完全初始化的。</li>
</ul>
<p>setter方法注入</p>
<ul>
<li>灵活性：Setter 方法允许在 Bean 实例化之后注入依赖，因此可以动态地修改依赖。</li>
<li>可选依赖：依赖可以通过 setter 方法设置为可选，即使没有注入依赖，Bean 仍然可以正常工作。</li>
</ul>
<p><strong>构造函数注入</strong></p>
<p>假设我们有两个类：<code>UserService</code> 和 <code>EmailService</code>，<code>UserService</code> 依赖于 <code>EmailService</code>。</p>
<p><strong>EmailService 类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Sending email to &quot;</span> + to + <span class="string">&quot;:\nSubject: &quot;</span> + subject + <span class="string">&quot;\nBody: &quot;</span> + body);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UserService 类：</strong></p>
<p>使用构造函数注入 <code>EmailService</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EmailService emailService;  <span class="comment">// 目标字段可以是 final，但不强制必须是 final，强烈建议在构造函数注入时将依赖字段声明为 final，因为这可以确保依赖在对象创建时被完全初始化，而且不会在对象生命周期中被修改，从而提供更高的安全性和不可变性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数注入</span></span><br><span class="line">    <span class="comment">// 这里没有使用@Autowired，但是属性emailService被自动注入bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(EmailService emailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username, String email)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 用户注册逻辑 ...</span></span><br><span class="line">        emailService.sendEmail(email, <span class="string">&quot;Welcome!&quot;</span>, <span class="string">&quot;Thank you for registering.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Setter 方法注入</strong></p>
<p>仍使用 <code>UserService</code> 和 <code>EmailService</code>，使用 Setter 方法注入 <code>EmailService</code>。</p>
<p><strong>EmailService 类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email to &quot;</span> + to + <span class="string">&quot;:\nSubject: &quot;</span> + subject + <span class="string">&quot;\nBody: &quot;</span> + body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UserService 类：</strong></p>
<p>使用 Setter 方法注入 <code>EmailService</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;  </span><br><span class="line">    <span class="comment">// 依赖不能是 final 的！！！，final 字段必须在对象构造时被赋值（即通过构造函数进行初始化）</span></span><br><span class="line">    <span class="comment">// 即使字段的访问级别是 private，Spring 仍然可以使用反射来绕过 Java 的访问控制机制，直接为私有字段设置值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter 方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 将Setter方法标记为@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmailService</span><span class="params">(EmailService emailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username, String email)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 用户注册逻辑 ...</span></span><br><span class="line">        emailService.sendEmail(email, <span class="string">&quot;Welcome!&quot;</span>, <span class="string">&quot;Thank you for registering.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>为什么不直接将 <code>@Autowired</code> 标记在属性上？</strong></p>
<p>实际上，<strong>Spring 支持将 <code>@Autowired</code> 直接标记在属性上</strong>，这种方式叫做<strong>字段注入</strong>（Field Injection）。这种注入方式不需要提供 <code>set</code> 方法，Spring 会直接通过反射为属性注入依赖。然而，字段注入通常被认为是<strong>不推荐的做法</strong>，原因如下：</p>
<p><strong>字段注入的缺点：</strong></p>
<ol>
<li><strong>不利于测试</strong>：直接将 <code>@Autowired</code> 注解标记在字段上，依赖会通过反射注入。这样会让单元测试变得困难，因为无法直接通过构造函数或 Setter 方法传递 mock 对象，而是必须使用像 <code>ReflectionTestUtils</code> 这样的工具来手动设置私有字段的依赖。</li>
<li><strong>违背封装原则</strong>：字段注入直接修改类的私有属性，违背了对象的封装性原则。在面向对象编程中，通常希望属性通过构造函数或 Setter 方法来进行操作，而不是直接被外部干预。</li>
<li><strong>无法支持 <code>final</code> 关键字</strong>：如果使用字段注入，属性不能声明为 <code>final</code>，因为 <code>final</code> 属性必须在构造函数中初始化，而不是通过反射。这限制了对不可变性的支持。<code>final</code>字段的值一旦被赋值后，在运行时是不可变的。这意味着在对象的生命周期内，<code>final</code>字段的值不能被重新赋值。无论是通过直接赋值、构造函数赋值，还是通过初始化块赋值，一旦赋值完成，就不能再修改。</li>
</ol>
</blockquote>
<p>不显示使用注解</p>
<p>如果只使用 <code>@Component</code> 注解，而没有使用 <code>@Autowired</code> 或 <code>@Resource</code> 注解，Spring 仍然会将该类注册为一个 Bean，但<strong>不会自动注入它的依赖</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AnotherComponent anotherComponent; <span class="comment">// 不会自动注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果希望 Spring 自动注入依赖，必须使用以下方式之一：</p>
<ul>
<li>
<p><code>@Autowired</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnotherComponent anotherComponent;<span class="comment">// 自动注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>@Resource</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AnotherComponent anotherComponent;<span class="comment">// 自动注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>构造方法注入</strong>（推荐）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnotherComponent anotherComponent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyComponent</span><span class="params">(AnotherComponent anotherComponent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.anotherComponent = anotherComponent;<span class="comment">// 自动注入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>使用@Component或@Bean声明</strong></p>
<p><code>@Bean</code> 注解的作用是告诉 Spring 容器，这个方法返回的对象应该被注册为一个 Bean，并且这个 Bean 可以被其他组件通过依赖注入的方式使用。Spring 容器会负责管理这个 Bean 的生命周期，包括创建、初始化、销毁等。</p>
<ul>
<li><strong>对于大多数 Bean，使用 @Component (或其衍生注解) 进行声明，并让 Spring 自动扫描和注册。</strong> 这是最简洁和推荐的方式。</li>
<li><strong>只有在需要更细粒度的控制，例如自定义初始化、作用域或条件化创建 Bean 时，才需要在config类中使用 @Bean 方法。</strong></li>
<li><strong>始终为 @Bean 方法创建一个对应的类，即使它非常简单。</strong> 避免使用匿名内部类或 Lambda 表达式创建 Bean，除非有非常特殊的理由。</li>
</ul>
<p><strong>Spring 注入时 bean 的选择：</strong></p>
<ol>
<li><strong>@Autowired 注解:</strong> 在 createJdbcTemplate 方法中，@Autowired 注解告诉 Spring 需要注入一个 DataSource 类型的 Bean。</li>
<li><strong>类型匹配:</strong> Spring 容器会扫描所有带有 @Bean 注解的方法，并将其返回值注册为 Bean。当需要注入 DataSource 类型 Bean 时，Spring 会查找容器中所有类型为 DataSource 的 Bean。</li>
<li><strong>唯一 Bean:</strong> 在本例中，只有一个方法 createDataSource 返回 DataSource 类型的 Bean。因此，Spring 可以明确地将 createDataSource 方法创建的 Bean 注入到 createJdbcTemplate 方法的参数中。</li>
<li><strong>名称匹配（如果存在多个同类型 Bean）:</strong> 如果有多个 DataSource 类型的 Bean，@Autowired 默认会按照类型进行匹配。如果匹配到多个，则会尝试按照名称进行匹配。你可以使用 @Qualifier 注解来指定要注入的 Bean 的名称</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;  <span class="comment">// 将被spring正确注入</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FactoryBean">FactoryBean</h3>
<p>实现了FactoryBean接口的类将被Spring视为工厂Bean</p>
<p>Spring会将工厂Bean创建后保存在IoC容器中，并在注入该工厂Bean的时候，使用工厂Bean创建Bean进行注入；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myConnection&quot;)</span> <span class="comment">// bean name</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnectionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;MyConnection&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter methods for properties (url, username, password) -  injected via Spring</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyConnection <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Create and return a new MyConnection object</span></span><br><span class="line">        <span class="comment">// This is where the object creation logic resides</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Creating a new MyConnection object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyConnection</span>(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyConnection.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Return false for a new instance each time</span></span><br><span class="line">        <span class="comment">// return true;  // Return true for a singleton instance</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple connection class (replace with your actual connection logic)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConnection</span><span class="params">(String url, String username, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123; <span class="keyword">return</span> url;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; <span class="keyword">return</span> username;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;<span class="keyword">return</span> password;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyConnection myConnection; <span class="comment">// 注意，这里注入的是myConnection对象而不是myConnectionFactoryBean对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using MyConnection: &quot;</span> + myConnection.getUrl());</span><br><span class="line">        <span class="comment">// ... use the myConnection object ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取 FactoryBean 本身：</strong></p>
<p>如果需要获取 FactoryBean 实例本身，而不是它创建的对象，可以在 Bean 的名称前面加上 &amp; 符号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyConnectionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> (MyConnectionFactoryBean) applicationContext.getBean(<span class="string">&quot;&amp;myConnection&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>封装复杂的创建逻辑：</strong> 当 Bean 的创建逻辑比较复杂时，可以使用 FactoryBean 将其封装起来，使配置更加简洁。</li>
<li><strong>延迟初始化：</strong> FactoryBean 的 getObject() 方法只有在需要的时候才会被调用，可以实现 Bean 的延迟初始化。</li>
<li><strong>创建不同类型的对象：</strong> FactoryBean 可以根据不同的配置创建不同类型的对象。</li>
<li><strong>与第三方库集成：</strong> 可以使用 FactoryBean 来集成第三方库，例如创建数据库连接、缓存连接等。</li>
</ul>
<h3 id="初始化与销毁">初始化与销毁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span>  <span class="comment">// 创建后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init mail service with zoneId = &quot;</span> + <span class="built_in">this</span>.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span>  <span class="comment">// 销毁前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutdown mail service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环依赖">循环依赖</h3>
<p>循环依赖存在三种场景：</p>
<ol>
<li>通过构造方法进行依赖注入时产生的循环依赖问题</li>
<li>通过setter方法进行依赖注入且是在多例模式下产生的循环依赖问题</li>
<li>通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题</li>
</ol>
<p>Spring 在处理 Bean 创建时，会使用 <strong>三级缓存</strong> 来处理依赖注入中的循环依赖问题：</p>
<ul>
<li><strong>一级缓存</strong>（<code>singletonObjects</code>）：存储完全初始化好的 Bean。</li>
<li><strong>二级缓存</strong>（<code>earlySingletonObjects</code>）：存储部分初始化的 Bean（即属性注入完成，但构造器还未执行完毕的 Bean）。</li>
<li><strong>三级缓存</strong>（<code>singletonFactories</code>）：存储还没有初始化的 Bean 的工厂方法，用于延迟创建 Bean。</li>
</ul>
<p><strong>Spring 解决 Bean 依赖的流程</strong></p>
<ol>
<li>检查 <code>singletonObjects</code>：
<ul>
<li><code>singletonObjects</code> 是 Spring 容器中存储完全初始化好的单例 Bean 的缓存。</li>
<li>如果 <code>singletonObjects</code> 中存在 Bean B，说明 B 已经完成初始化，Spring 会直接将其注入到 Bean A 中。</li>
</ul>
</li>
<li>检查 <code>earlySingletonObjects</code>：
<ul>
<li><code>earlySingletonObjects</code> 是 Spring 容器中存储“早期单例 Bean”的缓存。这些 Bean 已经通过工厂创建，但可能还没有完成属性注入和初始化。</li>
<li>如果 <code>earlySingletonObjects</code> 中存在 Bean B，说明 B 已经通过工厂创建，但可能还在初始化过程中。Spring 会将其注入到 Bean A 中，以避免循环依赖问题。</li>
</ul>
</li>
<li>检查 <code>singletonFactories</code>：
<ul>
<li><code>singletonFactories</code> 是 Spring 容器中存储单例 Bean 工厂的缓存。这些工厂用于创建 Bean 的早期引用（即未完全初始化的 Bean）。</li>
<li>如果 <code>singletonFactories</code> 中存在 Bean B 的工厂，Spring 会调用该工厂创建 B 的早期引用，并将其放入 <code>earlySingletonObjects</code> 中，然后注入到 Bean A 中。</li>
</ul>
</li>
<li>如果以上缓存中都不存在 B：
<ul>
<li>如果 <code>singletonObjects</code>、<code>earlySingletonObjects</code> 和 <code>singletonFactories</code> 中都不存在 Bean B，说明 B 还没有开始创建。</li>
<li>Spring 会先创建 Bean B，完成其初始化后，再继续创建 Bean A。</li>
</ul>
</li>
</ol>
<h2 id="Spring-Bean-的生命周期">Spring Bean 的生命周期</h2>
<p>ref: <a href="https://open8gu.com/framework/spring/cssibafmgio4g44c/">https://open8gu.com/framework/spring/cssibafmgio4g44c/</a></p>
<ol>
<li><strong>实例化 Bean：</strong>
<ul>
<li><strong>组件扫描（Component Scanning）：</strong> Spring 根据配置的包路径，扫描所有带有构造型注解的类（例如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 等），并将这些类注册为 Spring 容器中的 Bean。</li>
<li><strong>推断构造方法：</strong> Spring 会根据 Bean 的类定义，选择合适的构造方法进行实例化。如果没有显式指定构造方法，Spring 会使用默认的无参构造方法。</li>
<li><strong>创建对象：</strong> 通过反射机制或工厂方法创建 Bean 的实例。此时，对象的属性还未被填充，Bean 处于未初始化状态。</li>
</ul>
</li>
<li><strong>填充属性 (依赖注入)：</strong>
<ul>
<li><strong>解析依赖关系：</strong> Spring 容器根据配置信息解析 Bean 的依赖关系，确定需要注入的其他 Bean 或值。</li>
<li><strong>依赖注入：</strong> 通过注解（如 <code>@Autowired</code>、<code>@Resource</code>）或 XML 配置，将依赖的 Bean 注入到当前 Bean 的属性中。Spring 支持字段注入、构造器注入和 Setter 方法注入等多种注入方式。</li>
</ul>
</li>
<li><strong>Aware 接口回调：</strong>
<ul>
<li><strong>Aware 接口：</strong> 如果 Bean 实现了 Spring 的 Aware 接口（例如 <code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>ApplicationContextAware</code> 等），Spring 容器会回调相应的方法，将 Bean 的名称、BeanFactory、ApplicationContext 等信息注入到 Bean 中。</li>
<li><strong>回调时机：</strong> 这些回调方法在 Bean 的属性注入之后、初始化之前被调用。</li>
</ul>
</li>
<li><strong>BeanPostProcessor 的前置处理：</strong>
<ul>
<li><strong>前置处理：</strong> Spring 容器会调用所有实现了 <code>BeanPostProcessor</code> 接口的 <code>postProcessBeforeInitialization()</code> 方法，对 Bean 进行前置处理。</li>
<li><strong>自定义处理：</strong> 开发者可以在 <code>BeanPostProcessor</code> 中对 Bean 进行一些自定义的处理，例如修改 Bean 的属性、添加 Bean 的代理等。这个阶段是 Bean 初始化前的最后机会进行干预。</li>
</ul>
</li>
<li><strong>初始化：</strong>
<ul>
<li><strong>InitializingBean 接口：</strong> 如果 Bean 实现了 <code>InitializingBean</code> 接口，Spring 容器会调用其 <code>afterPropertiesSet()</code> 方法，执行初始化逻辑。</li>
<li><strong>自定义初始化方法：</strong> 如果 Bean 定义了 <code>init-method</code> 属性，Spring 容器会调用指定的初始化方法。</li>
<li><strong>资源初始化：</strong> 在初始化阶段，开发者可以在初始化方法中进行一些资源的初始化工作，例如打开数据库连接、加载配置文件等。</li>
</ul>
</li>
<li><strong>BeanPostProcessor 的后置处理：</strong>
<ul>
<li><strong>后置处理：</strong> Spring 容器会调用所有实现了 <code>BeanPostProcessor</code> 接口的 <code>postProcessAfterInitialization()</code> 方法，对 Bean 进行后置处理。</li>
<li><strong>AOP 代理：</strong> 在这个阶段，开发者可以在 <code>BeanPostProcessor</code> 中对 Bean 进行 AOP 代理，例如使用 Spring AOP 创建代理对象。</li>
<li><strong>代理对象：</strong> 如果 Bean 被 AOP 代理，那么此时返回的 Bean 就是代理对象，而不是原始的 Bean 对象。</li>
</ul>
</li>
<li><strong>放入单例池 (可选)：</strong>
<ul>
<li><strong>单例 Bean：</strong> 如果 Bean 的作用域是单例 (<code>singleton</code>)，Spring 容器会将 Bean 放入单例池中，方便下次获取时直接使用。</li>
<li><strong>代理对象：</strong> 如果 Bean 被 AOP 代理，则放入单例池的是代理对象，而不是原始的 Bean 对象。</li>
</ul>
</li>
<li><strong>Bean 对象：</strong>
<ul>
<li><strong>完成创建：</strong> 此时，Bean 的创建过程已经完成，Bean 处于就绪状态，可以被应用程序使用。</li>
<li><strong>生命周期：</strong> Bean 的生命周期从此时开始，直到容器销毁它。</li>
</ul>
</li>
<li><strong>销毁：</strong>
<ul>
<li><strong>销毁阶段：</strong> 当 Spring 容器关闭或 Bean 的作用域结束时，Spring 容器会销毁 Bean。</li>
<li><strong>DisposableBean 接口：</strong> 如果 Bean 实现了 <code>DisposableBean</code> 接口，Spring 容器会调用其 <code>destroy()</code> 方法，执行销毁逻辑。</li>
<li><strong>自定义销毁方法：</strong> 如果 Bean 定义了 <code>destroy-method</code> 属性，Spring 容器会调用指定的销毁方法。</li>
<li><strong>资源释放：</strong> 在销毁阶段，开发者可以在销毁方法中进行一些资源的释放工作，例如关闭数据库连接、清理缓存等。</li>
</ul>
</li>
</ol>
<h2 id="Spring数据库相关">Spring数据库相关</h2>
<h3 id="JDBC">JDBC</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String jdbcUsername;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">// 创建数据库连接池，并作为bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        config.setJdbcUrl(jdbcUrl);</span><br><span class="line">        config.setUsername(jdbcUsername);</span><br><span class="line">        config.setPassword(jdbcPassword);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;autoCommit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">// 创建JdbcTemplate，注入DataSource</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>JdbcTemplate用法</strong></p>
<p>配置类实现 JdbcTemplate Bean 的创建，注入到User类jdbcTemplate属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意传入的是ConnectionCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute((Connection conn) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:</span></span><br><span class="line">        <span class="comment">// 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)) &#123;</span><br><span class="line">            ps.setObject(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                            rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 需要传入SQL语句，以及PreparedStatementCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute(<span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>, (PreparedStatement ps) -&gt; &#123;</span><br><span class="line">        <span class="comment">// PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:</span></span><br><span class="line">        ps.setObject(<span class="number">1</span>, name);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入SQL，参数和RowMapper实例:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT * FROM users WHERE email = ?&quot;</span>,</span><br><span class="line">            (ResultSet rs, <span class="type">int</span> rowNum) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 将ResultSet的当前行映射为一个JavaBean:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;,</span><br><span class="line">            email);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>jdbcTemplate.queryForObject() 方法的第二个参数是一个 RowMapper 接口的实现。RowMapper 接口定义了一个 mapRow(ResultSet rs, int rowNum) 方法，它的作用就是将 ResultSet 的每一行数据映射成一个 Java 对象。</p>
</blockquote>
<p><strong>声明式事务</strong></p>
<p><code>PlatformTransactionManager</code>表示事务管理器；</p>
<p><code>TransactionStatus</code>表示事务；</p>
<blockquote>
<p>Spring为了同时支持JDBC和JTA两种事务模型，故使用<code>PlatformTransactionManager</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开启事务:</span></span><br><span class="line">    tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="comment">// 相关JDBC操作:</span></span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="comment">// 提交事务:</span></span><br><span class="line">    txManager.commit(tx);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务:</span></span><br><span class="line">    txManager.rollback(tx);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 启用声明式</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>声明式事务透过AOP代理的方式，为UserService类创建代理对象，该代理对象拥有属性txManager，并使每个方法事务化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService$$EnhancerBySpringCGLIB</span> <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">PlatformTransactionManager</span> <span class="variable">txManager</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">            target.register(email, password, name);</span><br><span class="line">            txManager.commit(tx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            txManager.rollback(tx);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>事务回滚</strong></p>
<p>默认情况下，如果发生了<code>RuntimeException</code>，Spring的声明式事务将自动回滚</p>
<p>如果要针对Checked Exception回滚事务，需要在<code>@Transactional</code>注解中写出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">buyProducts</span><span class="params">(<span class="type">long</span> productId, <span class="type">int</span> num)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JDBC事务传播">JDBC事务传播</h3>
<p>Spring的声明式事务为事务传播定义分级，默认传播级别 <code>REQUIRED</code></p>
<p><code>REQUIRED</code>：表示如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。</p>
<p><code>SUPPORTS</code>：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；</p>
<p><code>MANDATORY</code>：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；</p>
<p><code>REQUIRES_NEW</code>：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；</p>
<p><code>NOT_SUPPORTED</code>：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；</p>
<p><code>NEVER</code>：和<code>NOT_SUPPORTED</code>相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；</p>
<p><code>NESTED</code>：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。</p>
<blockquote>
<p><strong>Spring使用ThreadLocal获知当前是否存在事务</strong></p>
<p>Spring将JDBC相关的<code>Connection</code>和<code>TransactionStatus</code>实例绑定到<code>ThreadLocal</code>。如果一个事务方法从<code>ThreadLocal</code>未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从<code>ThreadLocal</code>获取的JDBC连接以及<code>TransactionStatus</code>。</p>
<p>因此，事务能正确传播的前提是，方法调用必须在一个线程内。</p>
</blockquote>
<h3 id="结合Hibernate">结合Hibernate</h3>
<p>将关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping</p>
<p>对于表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    createdAt <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `email` (`email`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>对于java对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span>  <span class="comment">// @Entity 注解标记 User 类为一个实体，表示它对应数据库中的一个表。</span></span><br><span class="line"><span class="meta">@Table(name=&quot;users&quot;)</span>  <span class="comment">// 指定对应的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span>  <span class="comment">// @Id 注解标记 getId() 方法返回的值作为主键。</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// @Column 注解用于映射实体类的属性到数据库表的列。</span></span><br><span class="line">    <span class="comment">// @Column 注解在 getEmail() 方法上，Hibernate 会根据约定推断出对应的字段名为 email (去掉get，并将首字母小写)。</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个属性到数据库列的映射用<code>@Column()</code>标识，<code>nullable</code>指示列是否允许为<code>NULL</code>，<code>updatable</code>指示该列是否允许被用在<code>UPDATE</code>语句，<code>length</code>指示<code>String</code>类型的列的长度（如果没有指定，默认是<code>255</code>）。</p>
<p>对于主键，还需要用<code>@Id</code>标识，自增主键再追加一个<code>@GeneratedValue</code>，以便Hibernate能读取到自增主键的值。</p>
<blockquote>
<p>Hibernate 使用反射机制来访问和操作实体类的字段。@Column 注解标注在 getter 方法上只是一种便捷的声明方式，它实际上是告诉 Hibernate “这个 getter 方法对应的字段需要映射到数据库的列”。</p>
<p>Hibernate 使用一种基于约定的命名策略。它会查找符合 JavaBean 规范的 getter/setter 方法，并根据方法名推断出对应的字段名。</p>
<p>具体规则如下:</p>
<ul>
<li>对于 getter 方法，去掉 get 或 is 前缀，并将剩余部分的首字母小写。例如，getEmail() 对应字段 email，isActivated() 对应字段 activated。</li>
<li>对于 setter 方法，去掉 set 前缀，并将剩余部分的首字母小写。例如，setEmail(String email) 对应字段 email。</li>
</ul>
</blockquote>
<p>可通过继承映射超类实现子类的映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span>  <span class="comment">// 映射超类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span>  <span class="comment">// 暫く，要求 JPA 忽略该字段，不要将其持久化到数据库中。这意味着 createdDateTime 字段不会在数据库表中拥有对应的列。</span></span><br><span class="line">    <span class="keyword">public</span> ZonedDateTime <span class="title function_">getCreatedDateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(<span class="built_in">this</span>.createdAt).atZone(ZoneId.systemDefault());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrePersist</span>  <span class="comment">// 指定在实体持久化到数据库之前要执行的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        setCreatedAt(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建</p>
<p>SessionFactory 是一个重量级对象，通常在应用启动时创建一次，并在线程之间共享。它用于创建 Session 对象。</p>
<p>Session 是一个轻量级对象，代表与数据库的一次交互。每次操作数据库都需要创建一个新的 Session 对象。在Spring架构中通过SessionFactory Bean的注入获得Session Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span> <span class="comment">// 使用 classpath</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span> String jdbcUrl,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span> String jdbcUsername,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span> String jdbcPassword)</span> &#123;</span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">        dataSource.setUrl(jdbcUrl);</span><br><span class="line">        dataSource.setUsername(jdbcUsername);</span><br><span class="line">        dataSource.setPassword(jdbcPassword);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里创建了 LocalSessionFactoryBean 对象，在类中要求注入时，会注入 SessionFactory 对象，由于 SessionFactory 对象是单例Bean，故 SessionFactory 并没有被反复创建注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    LocalSessionFactoryBean <span class="title function_">createSessionFactory</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">LocalSessionFactoryBean</span> <span class="variable">sessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalSessionFactoryBean</span>();</span><br><span class="line">        sessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sessionFactoryBean.setPackagesToScan(<span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>); <span class="comment">// 扫描 Entity 类</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>); <span class="comment">// 或 create-drop, validate</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.dialect&quot;</span>, <span class="string">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>); <span class="comment">// 根据数据库选择方言</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        sessionFactoryBean.setHibernateProperties(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> LocalSessionFactoryBean sessionFactoryBean)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取 SessionFactory 对象</span></span><br><span class="line">        <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> sessionFactoryBean.getObject();  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HibernateTransactionManager</span>(sessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>LocalSessionFactoryBean </code>是 Spring 提供的一个用于创建和配置 Hibernate <code>SessionFactory </code>的工厂 bean，实际上按照逻辑而言，<code>LocalSessionFactoryBean </code>应该为<code>SessionFactory FactoryBean </code>，因为它创建的是<code>SessionFactory </code> 。一般而言，<code>SessionFactory </code> 在创建后为单例 bean，不会出现创建多个<code>SessionFactory </code>的情况。在类需要使用<code>SessionFactory </code>时，Spring 注入<code>SessionFactory </code></p>
<p><strong>如果我们每个类需要的是Session，为什么我们不直接使用<code>SessionFactoryBean </code>注入原型 Session Bean到每个类中呢？</strong></p>
<ol>
<li><strong>Session 的生命周期管理困难:</strong> Session 代表与数据库的一次会话，它的生命周期应该与特定的操作（例如一次数据库事务）绑定。 如果将 Session 作为原型 bean 注入，就需要手动管理 Session 的生命周期，包括创建、关闭和事务管理。 这会使代码变得复杂，容易出错，并且难以维护。</li>
<li><strong>线程安全问题:</strong> Session 不是线程安全的。 如果将原型 Session bean 注入到单例 bean 中，并且在并发环境下使用，可能会导致数据不一致或其他并发问题。</li>
<li><strong>资源管理问题:</strong> Session 持有数据库连接等资源。 如果不正确地管理 Session 的生命周期，可能会导致资源泄露。</li>
<li><strong>违反 Hibernate 的设计理念:</strong> Hibernate 的设计理念是将 Session 的生命周期与事务绑定。 通过 SessionFactory.openSession() 或 SessionFactory.getCurrentSession() 获取 Session，可以确保 Session 的生命周期与事务同步，并由 Hibernate 管理资源。 直接注入 Session bean 会破坏这种设计。</li>
</ol>
</blockquote>
<p>CRUD</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 启用声明式事务管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setEmail(email);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setCreatedAt(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession(); <span class="comment">// 获取当前 Session</span></span><br><span class="line">        session.persist(user);</span><br><span class="line">        <span class="keyword">return</span> user; <span class="comment">// 不需要手动 commit，Spring 会自动处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span> <span class="comment">// 只读事务</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="keyword">return</span> session.get(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span> <span class="comment">// 只读事务</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="keyword">return</span> session.createQuery(<span class="string">&quot;FROM User&quot;</span>, User.class).list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id, String name)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, id);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            user.setName(name);</span><br><span class="line">            session.merge(user); <span class="comment">// 或 session.update(user)</span></span><br><span class="line">            <span class="comment">// 不需要手动 commit，Spring 会自动处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理用户不存在的情况...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.getCurrentSession();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session.get(User.class, id);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            session.delete(user);</span><br><span class="line">            <span class="comment">// 不需要手动 commit，Spring 会自动处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用DAO层代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">get</span><span class="params">(Long id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line">	<span class="comment">// session在这里使用~</span></span><br><span class="line">    <span class="comment">// ... 实现 UserDao 接口中的方法，进行数据库操作 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 使用 userDao 获得数据 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结合MyBatis">结合MyBatis</h3>
<p>@Mapper 注解</p>
<ul>
<li><strong>自动生成 Mapper 接口的实现类:</strong> @Mapper 注解会告诉 MyBatis 为标注的接口生成一个实现类，并将该实现类注册到 Spring 容器中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RuleTreeNodeDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询规则树节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeId    规则树ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          规则树节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;RuleTreeNodePO&gt; <span class="title function_">queryRuleTreeNodeList</span><span class="params">(Long treeId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询规则树节点数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeId    规则树ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          节点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">queryTreeNodeCount</span><span class="params">(Long treeId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询规则树节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeId    规则树ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;RuleTreeNodePO&gt; <span class="title function_">queryTreeRulePoint</span><span class="params">(Long treeId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>映射 SQL 语句:</strong> MyBatis 使用 XML 文件或注解的方式将 SQL 语句与 Java 方法关联起来。例如，queryRuleTreeNodeList 方法会对应一个 SQL 查询语句，该语句用于查询规则树节点。</p>
<p><strong>参数绑定:</strong> MyBatis 会将 Java 方法的参数绑定到 SQL 语句中的参数占位符。例如，queryRuleTreeNodeList 方法的 treeId 参数会被绑定到 SQL 语句中的 #{treeId} 占位符。</p>
<p><strong>结果映射:</strong> MyBatis 会将 SQL 查询结果映射到 Java 对象。例如，queryRuleTreeNodeList 方法的返回值类型是 <code>List&lt;RuleTreeNodePO&gt;</code>，MyBatis 会将查询结果的每一行映射到一个 <code>RuleTreeNodePO</code> 对象，并将这些对象添加到一个 List 中返回。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.bugstack.xfg.frame.infrastructure.dao.RuleTreeNodeDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;ruleTreeNodeMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;cn.bugstack.xfg.frame.infrastructure.po.RuleTreeNodePO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tree_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;treeId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;node_type&quot;</span> <span class="attr">property</span>=<span class="string">&quot;nodeType&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;node_value&quot;</span> <span class="attr">property</span>=<span class="string">&quot;nodeValue&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;rule_key&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ruleKey&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;rule_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ruleDesc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryRuleTreeNodeList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ruleTreeNodeMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT id, tree_id, node_type, node_value, rule_key, rule_desc</span><br><span class="line">        FROM rule_tree_node</span><br><span class="line">        where tree_id = #&#123;treeId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryTreeNodeCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        select count(id) from rule_tree_node where tree_id = #&#123;treeId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryTreeRulePoint&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ruleTreeNodeMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT distinct (rule_key), rule_desc</span><br><span class="line">        FROM rule_tree_node</span><br><span class="line">        where tree_id = #&#123;treeId&#125; and rule_key is not null</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="JDBC与Hibernate-JPA-MyBatis">JDBC与Hibernate, JPA, MyBatis</h3>
<p>ORM，也是建立在JDBC的基础上，通过ResultSet到JavaBean的映射，实现各种查询。有自动跟踪Entity修改的全自动化ORM如Hibernate和JPA，需要为每个Entity创建代理，也有完全自己映射，连INSERT和UPDATE语句都需要手动编写的MyBatis，但没有任何透明的Proxy。</p>
<h3 id="Spring-Transaction">Spring Transaction</h3>
<p>在Bean内使用 <code>@Transactional</code> 注解是最推荐的方式，基于AOP实现</p>
<p>注意以下几点：</p>
<ul>
<li><strong>被 @Transactional 注解的方法不能是 private 的</strong> Spring AOP 的代理机制无法拦截 private 方法，因此 @Transactional 注解在 private 方法上不会生效。</li>
<li><strong>方法内使用 try-catch 处理异常</strong> 可以在 @Transactional 方法内部使用 try-catch 块来处理异常。但是，如果捕获了异常并且<strong>没有重新抛出</strong>，Spring 的事务管理机制就无法感知到异常的发生，从而导致事务不会回滚。 如果希望事务在特定异常发生时回滚，你需要在 catch 块中重新抛出异常，或者抛出一个 Spring 能够识别的异常类型（例如 RuntimeException 或其子类）。</li>
<li><strong>方法抛出的异常是 RuntimeException</strong> Spring 的事务管理机制默认只对 RuntimeException（运行时异常）及其子类进行回滚。 但是，你可以通过 @Transactional 注解的 rollbackFor 属性来指定需要回滚的其他异常类型。 例如，你可以指定 rollbackFor = Exception.class 来让事务在任何异常发生时都回滚。 你也可以使用 noRollbackFor 属性来指定不回滚的异常类型。</li>
</ul>
<h3 id="MyBatis">MyBatis</h3>
<p><strong><code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 区别</strong></p>
<ul>
<li><code>#&#123;&#125;</code> 是预编译处理，会将参数替换为?</li>
<li><code>$&#123;&#125;</code> 是字符串替换，直接将参数拼接到SQL中，存在SQL注入风险</li>
</ul>
<p>在 MyBatis 中，注解 <code>@Select</code> 用来定义 SQL 查询。对于以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM user WHERE user_name = #&#123;username&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">getUserByName</span><span class="params">(String username)</span>;</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<ol>
<li><strong>查询执行</strong>：当你调用 <code>getUserByName</code> 方法时，MyBatis 将接收传入的 <code>username</code> 参数，并将其注入到 SQL 语句中替换 <code>#&#123;username&#125;</code> 占位符。</li>
<li><strong>SQL 查询</strong>：MyBatis 会在数据库中执行替换后的 SQL 查询。</li>
<li><strong>结果映射</strong>：查询结果将映射到 <code>User</code> 对象。MyBatis 使用 <strong>结果映射</strong> 机制，将查询得到的数据库记录中的字段与 <code>User</code> 类的属性进行匹配。映射的依据通常是字段名称和属性名称相同。</li>
</ol>
<p>结果处理</p>
<ul>
<li><strong>自动映射</strong>：MyBatis 会根据 <code>User</code> 类的属性名称与 <code>SELECT</code> 语句返回的列名称进行映射。例如，如果数据库中的 <code>user</code> 表有 <code>id</code>, <code>user_name</code>, <code>password</code> 等字段，MyBatis 会自动将这些列的值填充到 <code>User</code> 类的 <code>id</code>, <code>userName</code>, <code>password</code> 等相应的属性中。</li>
<li><strong>映射规则</strong>：默认情况下，MyBatis 使用 <strong>驼峰命名规则</strong>，即如果数据库中列的名称是 <code>user_name</code>，它会映射到 Java 类中的 <code>userName</code> 属性。如果属性和列名不匹配，你可能需要使用 <code>@Results</code> 或 XML 配置来手动指定映射关系。</li>
</ul>
<p>结果返回</p>
<ul>
<li><strong>返回对象</strong>：<code>getUserByName</code> 方法会返回一个 <code>User</code> 对象，如果查询到的结果为空，方法将返回 <code>null</code>。</li>
<li><strong>错误处理</strong>：如果查询返回了多行，而该方法定义为返回单个 <code>User</code> 对象，MyBatis 将抛出异常。</li>
</ul>
<h2 id="Spring-MVC">Spring MVC</h2>
<p>标准的Maven Web工程目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring-web-mvc</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java  // Spring配置类</span><br><span class="line">        │               ├── DatabaseInitializer.java</span><br><span class="line">        │               ├── entity</span><br><span class="line">        │               │   └── User.java</span><br><span class="line">        │               ├── service</span><br><span class="line">        │               │   └── UserService.java</span><br><span class="line">        │               └── web</span><br><span class="line">        │                   └── UserController.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   ├── jdbc.properties  // 数据库连接配置文件，包含数据库URL、用户名、密码等信息。</span><br><span class="line">        │   └── logback.xml  // 日志配置文件，配置日志输出格式、级别等。</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   ├── templates</span><br><span class="line">            │   │   ├── _base.html</span><br><span class="line">            │   │   ├── index.html</span><br><span class="line">            │   │   ├── profile.html</span><br><span class="line">            │   │   ├── register.html</span><br><span class="line">            │   │   └── signin.html</span><br><span class="line">            │   └── web.xml  // 指导 Web 容器（例如 Tomcat）如何部署和运行应用, 一般包含Servlet信息,servlet-mapping信息, Filter信息, welcome页面信息.</span><br><span class="line">            └── static</span><br><span class="line">                ├── css</span><br><span class="line">                │   └── bootstrap.css</span><br><span class="line">                └── js</span><br><span class="line">                    └── jquery.js</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Spring Web MVC 的标准做法，通常只有一个 Servlet, 多个 Filter,</p>
</blockquote>
<h3 id="启动">启动</h3>
<p><strong>传统的部署方式 (WAR包部署到外部Tomcat):</strong></p>
<ol>
<li><strong>构建WAR包:</strong> 使用Maven或Gradle等构建工具将Spring MVC项目打包成WAR文件。</li>
<li><strong>部署WAR包:</strong> 将WAR文件复制到Tomcat的webapps目录下。</li>
<li><strong>Tomcat启动:</strong> 启动Tomcat服务器。</li>
<li><strong>WAR包解压:</strong> Tomcat会自动解压WAR文件，创建一个同名的Web应用目录。</li>
<li><strong>读取web.xml:</strong> Tomcat读取Web应用目录下的WEB-INF/web.xml文件。</li>
<li><strong>初始化DispatcherServlet:</strong> Tomcat根据web.xml中的配置，初始化DispatcherServlet。</li>
<li><strong>创建WebApplicationContext:</strong> DispatcherServlet初始化时，会根据contextConfigLocation参数指定的配置类（例如AppConfig）创建WebApplicationContext（Spring的IoC容器）。</li>
<li><strong>扫描和初始化Bean:</strong> WebApplicationContext会扫描指定的包，查找并初始化所有带有@Component、@Service、@Repository、@Controller等注解的Bean。</li>
<li><strong>初始化其他组件:</strong> WebApplicationContext还会初始化Spring MVC的其他组件，例如HandlerMapping、ViewResolver等。</li>
<li><strong>应用启动完成:</strong> Tomcat完成Web应用的启动，DispatcherServlet准备好接收HTTP请求。</li>
</ol>
<p><strong>嵌入式Tomcat:</strong></p>
<ol>
<li><strong>添加依赖:</strong> 在pom.xml中添加Spring Boot Starter Web依赖，该依赖包含了嵌入式Tomcat。</li>
<li><strong>编写启动类:</strong> 创建一个带有main()方法的启动类，使用@SpringBootApplication注解标记。</li>
<li><strong>运行main()方法:</strong> 运行启动类的main()方法。</li>
<li><strong>Spring Boot初始化:</strong> Spring Boot会进行自动配置，根据classpath中的依赖自动配置Spring MVC、嵌入式Tomcat等组件。</li>
<li><strong>启动嵌入式Tomcat:</strong> Spring Boot启动嵌入式Tomcat服务器。</li>
<li><strong>创建WebApplicationContext:</strong> 与传统方式类似，Spring Boot会创建WebApplicationContext。</li>
<li><strong>扫描和初始化Bean:</strong> WebApplicationContext扫描并初始化Bean。</li>
<li><strong>初始化DispatcherServlet:</strong> Spring Boot将DispatcherServlet注册到嵌入式Tomcat中。</li>
<li><strong>应用启动完成:</strong> 嵌入式Tomcat启动完成，DispatcherServlet准备好接收HTTP请求。</li>
</ol>
<blockquote>
<p>该方式完全运行在一个JVM内部</p>
<ul>
<li><strong>Spring Boot应用管理嵌入式Tomcat的生命周期:</strong> Spring Boot应用负责启动、停止和配置嵌入式Tomcat。</li>
<li><strong>嵌入式Tomcat提供Servlet容器的功能:</strong> 嵌入式Tomcat负责接收HTTP请求、管理Servlet生命周期、处理Servlet请求等。</li>
<li><strong>DispatcherServlet是运行在嵌入式Tomcat中的一个Servlet:</strong> DispatcherServlet依赖于嵌入式Tomcat提供的Servlet容器功能，它被注册到嵌入式Tomcat中，由嵌入式Tomcat负责调用它的service()方法来处理请求。</li>
</ul>
<p>DispatcherServlet的实例是由嵌入式Tomcat创建的，但它的初始化和配置是由Spring Boot完成的。 Spring Boot会将DispatcherSeHrvlet注册到嵌入式Tomcat中，并将其与Spring的WebApplicationContext关联起来。 这样，DispatcherServlet就可以访问Spring容器中的Bean，并使用Spring MVC的功能来处理请求。</p>
</blockquote>
<h3 id="HandlerMapping">HandlerMapping</h3>
<p><code>HandlerMapping</code>在Spring应用程序启动时进行初始化。它会扫描整个项目，缓存所有带有相关注解（如<code>@RequestMapping</code>、<code>@GetMapping</code>等）的Controller方法的<code>request</code>-<code>handler</code>映射到<code>HandlerMapping</code>的bean中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class="line">  ┌─────────────────────┐        ┌───────────┐   │</span><br><span class="line">│ │DelegatingFilterProxy│─│─│─ ─▶│AuthFilter │</span><br><span class="line">  └─────────────────────┘        └───────────┘   │</span><br><span class="line">│ ┌─────────────────────┐ │ │    ┌───────────┐</span><br><span class="line">  │  DispatcherServlet  │─ ─ ─ ─▶│Controllers│   │</span><br><span class="line">│ └─────────────────────┘ │ │    └───────────┘</span><br><span class="line">                                                 │</span><br><span class="line">│    Servlet Container    │ │  Spring Container</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<h3 id="REST-架构风格">REST 架构风格</h3>
<p>REST（Representational State Transfer）是一种设计 Web 服务的架构风格，它强调客户端和服务器之间的交互应该围绕 <strong>资源</strong> 展开，并使用标准的 HTTP 方法来操作这些资源。</p>
<ul>
<li><strong>资源（Resources）：</strong> REST 架构的核心是资源。任何可以被命名的信息都可以被认为是一个资源，例如一个文档、一张图片、一个用户、一个订单等。每个资源都有一个唯一的标识符（URI）。</li>
<li><strong>表述（Representations）：</strong> 资源的表述是资源在某个特定时刻的状态的展现形式。它可以是各种格式，例如 JSON、XML、HTML 等。客户端通过获取资源的表述来了解资源的状态。</li>
<li><strong>状态转移（State Transfer）：</strong> 客户端通过 HTTP 方法（例如 GET、POST、PUT、DELETE）与服务器交互，从而改变资源的状态。这些 HTTP 方法对应着不同的操作：
<ul>
<li><strong>GET:</strong> 获取资源的表述。</li>
<li><strong>POST:</strong> 创建新的资源。</li>
<li><strong>PUT:</strong> 更新现有资源。</li>
<li><strong>DELETE:</strong> 删除资源。</li>
</ul>
</li>
<li><strong>无状态（Stateless）：</strong> RESTful API 是无状态的，这意味着每个请求都包含了处理该请求所需的全部信息。服务器不存储客户端的任何状态信息，每个请求都是独立的。</li>
</ul>
<table>
<thead>
<tr>
<th>HTTP 方法</th>
<th>REST 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取资源</td>
<td>获取资源的表述</td>
</tr>
<tr>
<td>POST</td>
<td>创建资源</td>
<td>创建新的资源</td>
</tr>
<tr>
<td>PUT</td>
<td>更新资源</td>
<td>替换整个资源</td>
</tr>
<tr>
<td>PATCH</td>
<td>部分更新资源</td>
<td>更新资源的一部分</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
<td>删除资源</td>
</tr>
</tbody>
</table>
<p><strong>RESTful 请求</strong>是指符合 REST 架构风格的 HTTP 请求。它通常包含以下部分：</p>
<ul>
<li><strong>URL：</strong> 指向要操作的资源的唯一地址。</li>
<li><strong>HTTP 方法：</strong> 指示要执行的操作（GET、POST、PUT、DELETE 等）。</li>
<li><strong>请求头：</strong> 包含一些元数据，例如内容类型、授权信息等。</li>
<li><strong>请求体：</strong> 对于 POST 和 PUT 请求，可能包含要创建或更新的资源的数据。</li>
</ul>
<p><strong>例如：</strong></p>
<p>一个获取用户信息的 RESTful 请求可能是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /users/123</span><br></pre></td></tr></table></figure>
<h1>Spring Boot</h1>
<p><a href="https://liaoxuefeng.com/books/java/springboot/index.html">https://liaoxuefeng.com/books/java/springboot/index.html</a></p>
<p>这些自动创建的Bean就是Spring Boot的特色：AutoConfiguration。</p>
<p>当我们引入<code>spring-boot-starter-jdbc</code>时，启动时会自动扫描所有的<code>XxxAutoConfiguration</code>：</p>
<ul>
<li><code>DataSourceAutoConfiguration</code>：自动创建一个<code>DataSource</code>，其中配置项从<code>application.yml</code>的<code>spring.datasource</code>读取；</li>
<li><code>DataSourceTransactionManagerAutoConfiguration</code>：自动创建了一个基于JDBC的事务管理器；</li>
<li><code>JdbcTemplateAutoConfiguration</code>：自动创建了一个<code>JdbcTemplate</code>。</li>
</ul>
<p>因此，我们自动得到了一个<code>DataSource</code>、一个<code>DataSourceTransactionManager</code>和一个<code>JdbcTemplate</code>。</p>
<p>类似的，当我们引入<code>spring-boot-starter-web</code>时，自动创建了：</p>
<ul>
<li><code>ServletWebServerFactoryAutoConfiguration</code>：自动创建一个嵌入式Web服务器，默认是Tomcat；</li>
<li><code>DispatcherServletAutoConfiguration</code>：自动创建一个<code>DispatcherServlet</code>；</li>
<li><code>HttpEncodingAutoConfiguration</code>：自动创建一个<code>CharacterEncodingFilter</code>；</li>
<li><code>WebMvcAutoConfiguration</code>：自动创建若干与MVC相关的Bean。</li>
<li>…</li>
</ul>
<p>引入第三方<code>pebble-spring-boot-starter</code>时，自动创建了：</p>
<ul>
<li><code>PebbleAutoConfiguration</code>：自动创建了一个<code>PebbleViewResolver</code>。</li>
</ul>
<h2 id="注解-2">注解</h2>
<p>基于 Spring Boot 应用程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     SpringApplication.run(Application.class, args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 容器的创建是通过 <code>@SpringBootApplication</code> 注解触发的，它实际上是一个组合注解，包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</p>
<p><strong><code>SpringApplication.run()</code></strong>：这是 Spring Boot 应用程序的入口。这个方法启动了 Spring Boot 应用，并创建了 IoC 容器。<code>@SpringBootApplication</code> 会自动扫描指定的包路径下的所有类，并将它们注册到 IoC 容器中。</p>
<p>@Configurable</p>
<p>@Configurable 允许将 Spring 管理的 Bean 注入到通过 new 关键字创建的对象中。这在一些情况下非常有用，例如在使用遗留代码或无法直接使用 Spring 管理的库时。</p>
<p>被添加 @Configurable 注解的类，在被new创建时，AspectJ 的代码会拦截对象的创建过程，并使用 Spring 的 BeanFactory 将依赖注入到对象中（即不会new出新对象，将从Spring中获得已经创建的该类型的Bean作为new的结果）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        repository.save(<span class="string">&quot;some data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他地方使用 new 创建对象</span></span><br><span class="line"><span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">service.doSomething(); <span class="comment">// repository 已经被注入，可以正常使用</span></span><br></pre></td></tr></table></figure>
<p>@ConfigurationProperties</p>
<p>读取指定配置文件，将配置文件中相应的值注入到Bean中</p>
<blockquote>
<p>配置文件搜索位置</p>
<p>打包在应用程序中的特定于配置文件的应用程序属性（application-{profile}.properties 和 YAML 变体）</p>
<p>打包在应用程序中的应用程序属性（application.properties 和 YAML 变体）</p>
</blockquote>
<p>假设有以下配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件：application.properties  yml格式</span></span><br><span class="line"><span class="attr">rate-limiter:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">unknown-property:</span> <span class="string">some-value</span></span><br></pre></td></tr></table></figure>
<p>以及以下 Java Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：RateLimiterAopConfigProperties.java</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;rate-limiter&quot;, ignoreInvalidFields = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">200</span>;  <span class="comment">// 默认值200，会被配置文件覆盖</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters for enabled and limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 ignoreInvalidFields = true，unknown-property 将会被忽略，而 enabled 和 limit 将分别被设置为 true 和 100。</p>
<p>@EnableConfigurationProperties(…)</p>
<p>将一个类作为配置属性类，并启用属性绑定；<strong>被指定作为配置属性类可以没有任何 Spring 注解</strong></p>
<p>@Component + @ConfigurationProperties 的配置属性类 等于 @EnableConfigurationProperties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AliPayConfigProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPayConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;alipayClient&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AlipayClient <span class="title function_">alipayClient</span><span class="params">(AliPayConfigProperties properties)</span> &#123;  <span class="comment">// bean对象被注入作为传入参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(properties.getGatewayUrl(),</span><br><span class="line">                properties.getApp_id(),</span><br><span class="line">                properties.getMerchant_private_key(),</span><br><span class="line">                properties.getFormat(),</span><br><span class="line">                properties.getCharset(),</span><br><span class="line">                properties.getAlipay_public_key(),</span><br><span class="line">                properties.getSign_type());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>常用库</h1>
<h2 id="retrofit">retrofit</h2>
<p>Retrofit 是一个用于 Android 和 Java 的类型安全的 HTTP 客户端，它通过将 HTTP API 转换为 Java 接口，简化了网络请求的编写和管理。它利用注解来描述 HTTP 请求，并使用 OkHttp 库执行实际的网络操作。</p>
<p>一个Retrofit的Call对象通常只对应<strong>一次HTTP请求和一次HTTP响应</strong></p>
<p>Call&lt;T&gt; 的泛型T是用来指定该 HTTP 请求成功后，预期从服务器接收到的数据类型</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 API 接口，使用接口定义网络请求</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 @GET 注解指定 GET 请求，@Path 注解用于替换 URL 路径中的占位符 &#123;id&#125;</span></span><br><span class="line">    <span class="meta">@GET(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Query 注解添加查询参数</span></span><br><span class="line">    <span class="meta">@GET(&quot;/users&quot;)</span></span><br><span class="line">    Call&lt;List&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">(<span class="meta">@Query(&quot;page&quot;)</span> <span class="type">int</span> page, <span class="meta">@Query(&quot;per_page&quot;)</span> <span class="type">int</span> perPage)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @QueryMap 注解添加多个查询参数，以 Map 的形式传递</span></span><br><span class="line">    <span class="meta">@GET(&quot;/users&quot;)</span></span><br><span class="line">    Call&lt;List&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">(<span class="meta">@QueryMap</span> Map&lt;String, String&gt; options)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @POST 注解指定 POST 请求，@Headers 注解添加静态请求头, @Body 注解用于发送请求体，即被标记传入参数会直接作为post报文体</span></span><br><span class="line">    <span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line">    <span class="meta">@Headers(&#123;</span></span><br><span class="line"><span class="meta">            &quot;Content-Type: application/json&quot;,</span></span><br><span class="line"><span class="meta">            &quot;Accept: application/json&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Body</span> User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @FormUrlEncoded 注解指定 POST 请求的编码类型为 application/x-www-form-urlencoded，@Field 注解添加表单数据，即被标记的传入参数会拼接，作为post报文体</span></span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Field(&quot;name&quot;)</span> String name, <span class="meta">@Field(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @FieldMap 注解添加多个表单数据，以 Map 的形式传递</span></span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@FieldMap</span> Map&lt;String, String&gt; fields)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Multipart 注解指定 POST 请求为多部分请求，@Part 注解用于多部分请求中的每个部分；请求体会被分割成多个部分，每个部分都包含自己的内容类型、头部信息和数据；按照@Part进行切割，即file为块1，description为块2</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;/upload&quot;)</span></span><br><span class="line">    Call&lt;ResponseBody&gt; <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@Part(&quot;file&quot;)</span> RequestBody file, <span class="meta">@Part(&quot;description&quot;)</span> RequestBody description)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @PartMap 注解添加多个 Part，以 Map 的形式传递；按照一个键值对一块进行切割</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;/upload&quot;)</span></span><br><span class="line">    Call&lt;ResponseBody&gt; <span class="title function_">uploadMultipleFiles</span><span class="params">(<span class="meta">@PartMap</span> Map&lt;String, RequestBody&gt; files)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @PUT 注解指定 PUT 请求</span></span><br><span class="line">    <span class="meta">@PUT(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    Call&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> <span class="type">int</span> id, <span class="meta">@Body</span> User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @DELETE 注解指定 DELETE 请求，@Header 注解添加动态请求头</span></span><br><span class="line">    <span class="meta">@DELETE(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    Call&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> <span class="type">int</span> id, <span class="meta">@Header(&quot;Authorization&quot;)</span> String authToken)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetrofitExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 拦截器 拦截的是 OkHttp 发出的网络请求</span></span><br><span class="line">        <span class="comment">// 创建 HttpLoggingInterceptor，用于打印请求和响应的日志</span></span><br><span class="line">        <span class="type">HttpLoggingInterceptor</span> <span class="variable">loggingInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpLoggingInterceptor</span>();</span><br><span class="line">        loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); <span class="comment">// 设置日志级别为 BODY，打印请求和响应体</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建自定义拦截器，例如添加认证信息</span></span><br><span class="line">        <span class="type">Interceptor</span> <span class="variable">authInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">Request</span> <span class="variable">original</span> <span class="operator">=</span> chain.request(); <span class="comment">// 获取原始请求</span></span><br><span class="line">                <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> original.newBuilder() <span class="comment">// 创建新的请求构建器</span></span><br><span class="line">                        .header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer your_token_here&quot;</span>) <span class="comment">// 添加 Authorization 请求头</span></span><br><span class="line">                        .build(); <span class="comment">// 构建新的请求</span></span><br><span class="line">                <span class="keyword">return</span> chain.proceed(request); <span class="comment">// 执行请求</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 OkHttpClient，并添加拦截器</span></span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .addInterceptor(loggingInterceptor) <span class="comment">// 添加日志拦截器</span></span><br><span class="line">                .addInterceptor(authInterceptor) <span class="comment">// 添加认证拦截器</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Retrofit 实例</span></span><br><span class="line">        <span class="comment">// 注意：可以不显式的指定 OkHttpClient 实例，默认会创建</span></span><br><span class="line">        <span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.example.com/&quot;</span>) <span class="comment">// 设置 API 基地址</span></span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 添加 Gson 转换器</span></span><br><span class="line">                .client(okHttpClient) <span class="comment">// 设置 OkHttpClient</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 API 服务</span></span><br><span class="line">        <span class="type">ApiService</span> <span class="variable">apiService</span> <span class="operator">=</span> retrofit.create(ApiService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 GET 请求</span></span><br><span class="line">        Call&lt;User&gt; call = apiService.getUser(<span class="number">123</span>);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;User&gt;() &#123; <span class="comment">// 使用 enqueue() 方法异步执行请求</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> &#123; <span class="comment">// 请求成功的回调</span></span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful()) &#123; <span class="comment">// 检查响应是否成功</span></span><br><span class="line">                    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> response.body(); <span class="comment">// 获取响应体</span></span><br><span class="line">                    System.out.println(user);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Error: &quot;</span> + response.code()); <span class="comment">// 打印错误码</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;User&gt; call, Throwable t)</span> &#123; <span class="comment">// 请求失败的回调</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Failure: &quot;</span> + t.getMessage()); <span class="comment">// 打印错误信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 QueryMap 的示例</span></span><br><span class="line">        Map&lt;String, String&gt; options = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        options.put(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">        options.put(<span class="string">&quot;per_page&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">        Call&lt;List&lt;User&gt;&gt; callWithQueryMap = apiService.getUsers(options);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 FieldMap 的示例</span></span><br><span class="line">        Map&lt;String, String&gt; fields = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        fields.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">        fields.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;john.doe@example.com&quot;</span>);</span><br><span class="line">        Call&lt;User&gt; callWithFieldMap = apiService.createUser(fields);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 其他请求示例</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 User 类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重写 toString 方法，方便打印 User 对象的信息</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                    <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于 Multipart 请求的 RequestBody 接口 (需要添加 okhttp3 依赖)</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">RequestBody</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于接收响应体的 ResponseBody 接口 (需要添加 okhttp3 依赖)</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">ResponseBody</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Guava">Guava</h2>
<p>Guava 是 Google 开发的一个 Java 核心库，它提供了一组常用的实用工具类、扩展类和数据结构，旨在提高 Java 代码的效率、可读性和可维护性。Guava 的设计理念是补充 JDK 的不足，提供一些 JDK 缺少的功能，并对一些 JDK 中已有的功能进行改进和优化。</p>
<p><strong>缓存 (Caching):</strong> 提供了强大的缓存功能，支持多种缓存策略，例如：</p>
<ul>
<li>CacheBuilder: 用于构建缓存实例。</li>
<li>LoadingCache: 在缓存未命中时自动加载数据的缓存。</li>
</ul>
<p><strong>事件总线 (EventBus):</strong> 实现了发布-订阅模式，</p>
<p>…</p>
<h2 id="Spring-Security-jwt">Spring Security &amp; jwt</h2>
<p><strong>客户端接收JWT：</strong> 服务器将生成的JWT返回给客户端，通常放在HTTP Authorization header中，使用Bearer scheme。例如：Authorization: Bearer &lt;token&gt;。</p>
<p><strong>客户端携带JWT：</strong> 客户端在后续的请求中，将JWT添加到Authorization header中，发送给服务器。 JWT可以存储在客户端的localStorage、cookie或session storage中。</p>
<h3 id="jwt生成流程">jwt生成流程</h3>
<ol>
<li>服务器<strong>分别</strong>对头部和载荷进行 <strong>Base64Url 编码</strong> 。</li>
<li>将编码后的头部和载荷用 . 拼接在一起，例如 encodedHeader.encodedPayload。</li>
<li>将拼接后的字符串作为输入，<strong>使用密钥和指定的签名算法 (例如 HS256, RS256) 进行签名</strong>，得到一个签名值。 这个过程不是“加密”，更准确地说是“生成签名”。 对于HS256，是进行HMAC-SHA256哈希运算；对于RS256，是使用RSA私钥对数据进行签名。</li>
<li>将签名值进行 <strong>Base64Url 编码</strong>。</li>
<li>最终的JWT是由 <strong>编码后的头部、编码后的载荷和编码后的签名</strong> 三部分用 . 连接而成，例如 encodedHeader.encodedPayload.encodedSignature。</li>
</ol>
<h3 id="请求过程">请求过程</h3>
<p>在 Spring MVC 项目中，DispatcherServlet 是唯一的 Servlet，它充当前端控制器，负责接收所有请求并分发给相应的 Spring Bean（例如 Controller）进行处理。</p>
<p>Spring Security Filter 在 Servlet 容器（例如 Tomcat）的过滤器链中进行注册</p>
<p>客户端 --&gt; Nginx --&gt; Tomcat --&gt; Filter 1(Tomcat Filter) --&gt; Filter 2 --&gt; … --&gt; Spring Security Filter --&gt; … --&gt; DispatcherServlet --&gt; Controller</p>
<ol>
<li><strong>网络层:</strong>
<ul>
<li><strong>负载均衡器 (Load Balancer，可选):</strong> 如果服务器集群有多台机器，负载均衡器会将请求分发到其中一台服务器。</li>
<li><strong>反向代理 (Reverse Proxy，可选):</strong> 反向代理服务器可以作为服务器的前置，处理一些通用的任务，例如缓存、SSL 加密/解密、负载均衡等。例如 Nginx、Apache。</li>
</ul>
</li>
<li><strong>Servlet 容器 (例如 Tomcat、Jetty、Undertow):</strong>
<ul>
<li><strong>连接器 (Connector):</strong> 接收客户端的连接请求，并将其转换为 Servlet 容器可以处理的请求对象。</li>
<li><strong>引擎 (Engine):</strong> 负责处理所有请求。</li>
<li><strong>主机 (Host):</strong> 基于域名或 IP 地址将请求路由到相应的虚拟主机。</li>
<li><strong>上下文 (Context):</strong> 代表一个 Web 应用程序，包含 Servlet、过滤器、监听器等组件。</li>
</ul>
</li>
<li><strong>Spring Security 过滤器链 (Filter Chain):</strong>
<ul>
<li>请求进入 Servlet 容器后，会先经过一系列的过滤器。过滤器可以对请求进行预处理或后处理，例如身份验证、授权、日志记录、数据转换等。</li>
<li>过滤器链的执行顺序由 web.xml 或 Spring Security 配置决定。</li>
</ul>
</li>
<li><strong>Servlet (例如 Spring MVC 的 DispatcherServlet):</strong>
<ul>
<li>DispatcherServlet 是 Spring MVC 框架的核心组件，它负责将请求分发到相应的 Controller。</li>
<li>DispatcherServlet 会根据请求的 URL 和配置的处理器映射 (Handler Mapping) 找到对应的 Controller 方法。</li>
</ul>
</li>
<li><strong>拦截器 (Interceptor，可选):</strong>
<ul>
<li>拦截器可以在 Controller 方法执行前后进行一些处理，例如性能监控、日志记录等。</li>
</ul>
</li>
<li><strong>Controller:</strong>
<ul>
<li>Controller 接收请求参数，调用业务逻辑，并返回 ModelAndView 对象。</li>
</ul>
</li>
</ol>
<p>先身份验证，再权限判断</p>
<h3 id="身份认证流程">身份认证流程</h3>
<p><strong>带 JWT 请求的流程</strong></p>
<ol>
<li><strong>请求到达 <code>JwtRequestFilter</code></strong>
<ul>
<li>当用户发送一个带 JWT 的请求时，Spring Security 会首先通过 <code>JwtRequestFilter</code> 过滤器。</li>
<li><code>JwtRequestFilter</code> 会检查请求中的 Authorization 头部，提取 JWT 并验证其合法性。</li>
</ul>
</li>
<li><strong>JWT 验证</strong>
<ul>
<li><code>JwtRequestFilter</code> 会验证 JWT 是否有效（例如是否过期、是否篡改），并从中解析出用户的身份信息（如用户名）。</li>
<li>如果验证成功，<code>JwtRequestFilter</code> 会创建一个 <code>UsernamePasswordAuthenticationToken</code> 对象，该对象包含从 JWT 中解析出来的用户信息（如用户名）。</li>
<li><code>UsernamePasswordAuthenticationToken</code> 对象将被存储到 <code>SecurityContextHolder</code> 中，这样 Spring Security 就知道当前请求的用户身份。</li>
</ul>
</li>
<li><strong><code>SecurityContextHolder</code> 中的身份信息</strong>
<ul>
<li>由于用户身份已经通过 JWT 被验证，<code>SecurityContextHolder</code> 中的 <code>Authentication</code> 对象已包含了有效的身份信息。接下来的授权处理（如访问控制）会基于这个 <code>Authentication</code> 对象，而不需要重新通过 <code>AuthenticationManager</code> 进行身份验证。</li>
</ul>
</li>
<li><strong>授权过程（权限验证）</strong>
<ul>
<li>一旦身份信息存储在 <code>SecurityContextHolder</code> 中，Spring Security 会进行授权处理（根据用户的角色、权限等判断是否允许访问资源）。如果 JWT 解析成功且验证通过，Spring Security 会基于 <code>GrantedAuthority</code>（用户的角色和权限）进行权限验证。</li>
</ul>
</li>
<li><strong>无 <code>UsernamePasswordAuthenticationFilter</code> 参与</strong>
<ul>
<li>由于 JWT 已经通过 <code>JwtRequestFilter</code> 进行验证，<code>UsernamePasswordAuthenticationFilter</code> 不会再被触发。因此，整个认证过程不涉及传统的用户名/密码验证。</li>
</ul>
</li>
</ol>
<p><strong>不带 JWT 请求的流程</strong></p>
<ol>
<li><strong>请求到达 <code>UsernamePasswordAuthenticationFilter</code></strong>
<ul>
<li>当用户发送一个不带 JWT 的请求时（通常是通过用户名和密码登录），Spring Security 会通过 <code>UsernamePasswordAuthenticationFilter</code> 来处理该请求。</li>
<li><code>UsernamePasswordAuthenticationFilter</code> 会从请求中获取用户名和密码（通常来自表单提交），并将其封装成一个 <code>UsernamePasswordAuthenticationToken</code> 对象。</li>
</ul>
</li>
<li><strong>身份验证</strong>
<ul>
<li><code>UsernamePasswordAuthenticationFilter</code> 会将 <code>UsernamePasswordAuthenticationToken</code> 交给 <code>AuthenticationManager</code> 进行身份验证。此时，Spring Security 会调用你在 <code>SecurityConfig</code> 中配置的 <code>userDetailsService</code> 来加载用户信息。</li>
<li>在 <code>userDetailsService.loadUserByUsername()</code> 中，Spring Security 会从数据库中加载用户的用户名、密码和权限信息，并将其封装成 <code>UserDetails</code> 对象返回。</li>
<li><code>AuthenticationManager</code> 会对比请求中提供的密码与数据库中存储的密码（经过加密的），如果密码匹配，身份验证通过。</li>
</ul>
</li>
<li><strong>创建认证对象并存储到 <code>SecurityContextHolder</code></strong>
<ul>
<li>如果用户名和密码匹配成功，<code>AuthenticationManager</code> 会创建一个 <code>UsernamePasswordAuthenticationToken</code> 对象（包含用户的身份信息和权限）。</li>
<li>然后，<code>UsernamePasswordAuthenticationToken</code> 会被存储到 <code>SecurityContextHolder</code> 中，表示用户已经通过身份验证。</li>
</ul>
</li>
<li><strong>授权过程（权限验证）</strong>
<ul>
<li>在 <code>SecurityContextHolder</code> 中存储了有效的认证对象后，Spring Security 会根据用户的角色和权限进行授权判断，确保用户有权访问请求的资源。</li>
</ul>
</li>
<li><strong>会话管理与状态管理</strong>
<ul>
<li>如果你配置了会话管理（例如，<code>sessionCreationPolicy(SessionCreationPolicy.STATELESS)</code>），Spring Security 会根据配置创建相应的会话或确保无状态认证。</li>
</ul>
</li>
</ol>
<h1>项目结构</h1>
<p>DDD结构</p>
<ul>
<li>Domain (领域层)：
<ul>
<li>model:
<ul>
<li>aggregate (聚合): 核心业务对象，例如订单、用户等。</li>
<li>entity (实体): 具有唯一标识的对象。</li>
<li>valobj (值对象): 描述对象的某个特征，没有唯一标识，例如地址、颜色等。</li>
</ul>
</li>
<li>repository (仓储接口): 定义数据访问接口，具体实现放在基础设施层。</li>
<li>service (领域服务): 处理不属于任何实体或值对象的业务逻辑。</li>
</ul>
</li>
<li>Application (应用层)：协调领域对象完成用户用例，不包含业务逻辑。
<ul>
<li>config</li>
<li>Application.java</li>
</ul>
</li>
<li>Infrastructure (基础设施层)：提供技术实现，例如数据库访问、消息队列等。
<ul>
<li>dao</li>
<li>redis</li>
<li>gateway
<ul>
<li>dto</li>
</ul>
</li>
<li>adapter
<ul>
<li>port</li>
<li>repositroy</li>
</ul>
</li>
<li>security</li>
</ul>
</li>
<li>trigger
<ul>
<li>http
<ul>
<li>httpController.java</li>
</ul>
</li>
<li>job</li>
<li>listener</li>
</ul>
</li>
<li>types
<ul>
<li>common</li>
<li>enums</li>
<li>exception</li>
<li>utils</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
