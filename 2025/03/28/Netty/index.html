<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marigo1d.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Netty">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty">
<meta property="og:url" content="https://marigo1d.github.io/2025/03/28/Netty/index.html">
<meta property="og:site_name" content="Marigold">
<meta property="og:description" content="Netty">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter02_01.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter02_02.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter03_01.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter03_15.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter03_05.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter03_17.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter03_18.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter03_19.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter03_20.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter05_01.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter05_03.png">
<meta property="og:image" content="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_04.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter05_05.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter05_06.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/D693697CEDCDC16AC09A5CF4747129CE.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter06_03.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter06_01.png">
<meta property="og:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter06_02.png">
<meta property="article:published_time" content="2025-03-28T02:13:58.000Z">
<meta property="article:modified_time" content="2025-03-31T06:01:09.565Z">
<meta property="article:author" content="marigo1d">
<meta property="article:tag" content="Java, Design pattern">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://marigo1d.github.io/2025/03/28/Netty/chapter02_01.png">

<link rel="canonical" href="https://marigo1d.github.io/2025/03/28/Netty/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Netty | Marigold</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Marigold</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Salt, Pepper and Birds~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://marigo1d.github.io/2025/03/28/Netty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="marigo1d">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marigold">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Netty
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-03-28 10:13:58" itemprop="dateCreated datePublished" datetime="2025-03-28T10:13:58+08:00">2025-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-03-31 14:01:09" itemprop="dateModified" datetime="2025-03-31T14:01:09+08:00">2025-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>32 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Netty</p>
<span id="more"></span>
<h1>Netty&amp;Rela</h1>
<h2 id="Proactor-Reactor">Proactor &amp; Reactor</h2>
<h3 id="Proactor">Proactor</h3>
<p>主动执行者</p>
<ol>
<li><strong>异步操作</strong>：应用程序发起I/O操作后立即返回，不阻塞</li>
<li><strong>完成通知</strong>：当I/O操作完成后，系统通知应用程序</li>
<li><strong>事件分离</strong>：由专门的组件（如事件循环）负责分发完成事件</li>
<li><strong>回调处理</strong>：预先注册的回调函数处理完成事件</li>
</ol>
<h3 id="Reactor">Reactor</h3>
<p>反应器</p>
<ol>
<li><strong>事件驱动</strong>：应用程序注册感兴趣的事件（如可读、可写）</li>
<li><strong>同步非阻塞</strong>：使用非阻塞I/O，但同步等待事件就绪</li>
<li><strong>事件分离</strong>：由专门的组件（如事件循环）负责检测和分发事件</li>
<li><strong>回调处理</strong>：预先注册的事件处理器处理就绪事件</li>
</ol>
<h3 id="Diff">Diff</h3>
<ul>
<li><strong>Reactor</strong>：同步非阻塞模式，关注&quot;何时可读/可写&quot;, 非阻塞I/O, 应用程序主动读取/写入数据</li>
<li><strong>Proactor</strong>：异步模式，关注&quot;读/写已完成&quot;,  异步I/O, 操作系统完成I/O后通知应用程序</li>
</ul>
<p><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</p>
<p><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p>
<h2 id="Java-IO">Java IO</h2>
<p>适用场景区别</p>
<ol>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li>
<li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li>
<li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li>
</ol>
<h3 id="BIO">BIO</h3>
<img src="/2025/03/28/Netty/chapter02_01.png" class="" title="img">
<p>在Java的BIO（Blocking I/O）模型中，当用户发送数据到服务器的socket内核缓冲区后，用户进程是通过<strong>阻塞式系统调用</strong>的方式从内核缓冲区读取数据的。具体到代码：</p>
<ol>
<li><strong>关键点分析</strong>：<br>
• <code>inputStream.read(bytes)</code> 是一个<strong>阻塞调用</strong>，它会一直等待，直到内核缓冲区中有数据到达（或连接关闭）。<br>
• 当客户端发送数据时，数据会先被内核接收并存入socket的接收缓冲区，然后内核会唤醒被阻塞的<code>read()</code>系统调用，将数据从内核缓冲区复制到用户空间（即你的<code>bytes</code>数组）。</li>
<li><strong>详细流程</strong>：<br>
• <strong>数据到达</strong>：客户端发送的数据通过TCP协议栈到达服务器的网卡，内核将数据存入该socket对应的接收缓冲区。<br>
• <strong>唤醒进程</strong>：内核会通知（唤醒）正在阻塞等待<code>read()</code>的线程，此时<code>read()</code>会返回可读的字节数（<code>read &gt; 0</code>）。<br>
• <strong>数据拷贝</strong>：<code>read()</code>内部会触发系统调用（如Linux的<code>recv()</code>），将数据从内核缓冲区复制到Java进程的<code>bytes</code>数组中。</li>
<li><strong>BIO的特点</strong>：<br>
• 每个连接需要一个独立线程处理，<code>read()</code>会阻塞线程直到数据就绪。<br>
• 内核缓冲区的存在使得即使进程没有及时调用<code>read()</code>，数据也不会丢失（缓冲区未满时）。</li>
</ol>
<p><strong><code>serverSocket.accept()</code> 的行为</strong></p>
<ul>
<li><strong>作用</strong>：监听指定的端口（这里是6666），等待客户端发起TCP连接请求。</li>
<li><strong>阻塞性</strong>：这是一个<strong>阻塞调用</strong>，如果没有客户端连接，线程会一直卡在这里，直到有新的连接到达。</li>
<li>连接建立：当客户端（如Socket或telnet）发起连接时，操作系统内核会完成TCP三次握手，然后将这个新连接交给accept()方法。
<ul>
<li>此时，<code>accept()</code>会返回一个新的<code>Socket</code>对象（即代码中的<code>socket</code>），代表与客户端的独立连接。</li>
<li><strong>注意</strong>：此时连接已建立（TCP握手完成），但客户端可能还没有发送任何数据。</li>
</ul>
</li>
</ul>
<p><strong><code>inputStream.read()</code> 的行为</strong></p>
<ul>
<li><strong>作用</strong>：从已建立的连接中读取客户端发送的数据。</li>
<li>阻塞性：这也是一个阻塞调用，如果客户端没有发送数据，线程会卡在read()方法，直到：
<ol>
<li>客户端发送数据 → 数据到达内核缓冲区 → <code>read()</code>返回读取的字节数（<code>read &gt; 0</code>）。</li>
<li>客户端关闭连接 → <code>read()</code>返回<code>-1</code>（表示EOF）。</li>
<li>发生异常（如连接重置）。</li>
</ol>
</li>
</ul>
<p>主线程监听是否有连接请求，接收连接后将任务交由线程池中线程处理</p>
<p>任务线程负责对连接进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">newCachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//我们重写</span></span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">&quot;read....&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, read));<span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NIO">NIO</h3>
<img src="/2025/03/28/Netty/chapter02_02.png" class="" title="img">
<img src="/2025/03/28/Netty/chapter03_01.png" class="" title="img">
<p>特性</p>
<ol>
<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>
<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>
<li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li>
<li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li>
<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>
<li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li>
<li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>
</ol>
<h4 id="Selector">Selector</h4>
<p>概述</p>
<ol>
<li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li>
<li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li>
</ol>
<p>机制</p>
<ul>
<li><strong>底层依赖操作系统的 I/O 多路复用</strong>（如 Linux 的 <code>epoll</code>、Windows 的 <code>IOCP</code>、macOS 的 <code>kqueue</code>）。
<ul>
<li>当调用 <code>selector.select()</code> 时，JVM 会通过操作系统提供的机制<strong>阻塞等待</strong>，直到至少一个 Channel 有就绪事件（如可读、可写、连接完成等），而不是主动轮询所有 Channel。</li>
<li>这种阻塞是高效的，因为操作系统内核会直接通知哪些 Channel 就绪，避免了用户态的无谓循环。</li>
</ul>
</li>
<li><strong>返回就绪事件后</strong>，Selector 会通过 <code>selectedKeys()</code> 返回一个集合，开发者需要<strong>手动遍历处理这些事件</strong>（这一步是用户态的轮询）。</li>
</ul>
<p><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</p>
<p>SelectionKey</p>
<p>SelectionKey 表示 Selector 和网络通道的注册关系，共四种：</p>
<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
<img src="/2025/03/28/Netty/chapter03_15.png" class="" title="img">
<ol>
<li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li>
<li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li>
<li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li>
<li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li>
<li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li>
<li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li>
<li>可以通过得到的 <code>channel</code>，完成业务处理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端：单线程Reactor，所有操作（I/O + 业务处理）均在Reactor线程完成。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="comment">// 服务端用于监听客户端连接的通道，它不直接与客户端通信，而是接收客户端的连接请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//将该 listenChannel 注册到 selector，监听事件：有新的网络连接可以接收</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();  <span class="comment">// 线程阻塞在 select 方法</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">//有事件处理</span></span><br><span class="line">                    <span class="comment">// 遍历得到 selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//取出 selectionkey</span></span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="comment">//监听到 accept</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">//建立连接</span></span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> listenChannel.accept();</span><br><span class="line">                            <span class="comment">// sc实例直接与客户端通信，用于读取客户端发送的数据或向客户端转发消息</span></span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到 seletor，监听事件：客户端发送的数据</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;<span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">// 处理读(专门写方法..)</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的 key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到 channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建 buffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">//  数据从内核态拷贝到用户态堆内存</span></span><br><span class="line">            <span class="comment">//根据 count 的值做处理</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form客户端:&quot;</span> + msg);</span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key 取出对应的 SocketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">dest</span> <span class="operator">=</span> (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将 msg 存储到 buffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将 buffer 的数据写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">groupChatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;<span class="comment">//服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;<span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器,完成初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//将 channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到 username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//得到一个 Buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove(); <span class="comment">//删除当前的 selectionKey,防止重复操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动客户端</span></span><br><span class="line">        <span class="type">GroupChatClient</span> <span class="variable">chatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>();</span><br><span class="line">        <span class="comment">//启动一个线程,每个 3 秒，读取从服务器发送的数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Channel">Channel</h4>
<ol>
<li>NIO 的通道类似于流，但有些区别如下：
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
</li>
<li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li>
<li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li>
<li>常用的 <code>Channel</code> 类有: <strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong> 。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li>
<li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li>
</ol>
<blockquote>
<p>双向性体现：FileInputStream 和 FileOutputStream 为两个不同的类，FileChannel 为一个类，可实现read和write</p>
<p>实际使用的时候还是需要从FileInputStream 和 FileOutputStream 获取 FileChannel</p>
</blockquote>
<p>从Stream获取Channel</p>
<p>Buffer 的双向读写体现</p>
<ul>
<li><strong>读取阶段</strong>：<code>fileChannel01.read(byteBuffer)</code> 将数据从通道写入 Buffer（此时 Buffer 处于写模式）</li>
<li><strong>写入阶段</strong>：<code>fileChannel02.write(byteBuffer)</code> 将数据从 Buffer 读取到通道（需要先调用 <code>flip()</code> 切换为读模式）</li>
</ul>
<p>关键点在于同一个 <code>ByteBuffer</code> 对象先被用于接收数据（写操作），然后被翻转后用于提供数据（读操作），这体现了 Buffer 的双向性。</p>
<h4 id="Buffer">Buffer</h4>
<img src="/2025/03/28/Netty/chapter03_05.png" class="" title="img">
<p><code>byteBuffer.flip()</code></p>
<ol>
<li><strong>模式切换</strong>：将缓冲区从写模式切换到读模式</li>
<li>重置指针：
<ul>
<li>将 <code>limit</code> 设置为当前 <code>position</code> 值（即写入的最后一个位置）</li>
<li>将 <code>position</code> 重置为 0（准备从头开始读取）</li>
<li><code>mark</code> 被丢弃（如果之前设置了）</li>
</ul>
</li>
</ol>
<p><code>byteBuffer.clear()</code></p>
<p>将缓冲区从读模式切换为写模式，并重置</p>
<p><strong>关键方法对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">position</th>
<th style="text-align:center">limit</th>
<th style="text-align:center">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allocate</td>
<td style="text-align:center">创建新缓冲区</td>
<td style="text-align:center">0</td>
<td style="text-align:center">= capacity</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">put()</td>
<td style="text-align:center">写入数据</td>
<td style="text-align:center">增加</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">可能清除</td>
</tr>
<tr>
<td style="text-align:center">flip()</td>
<td style="text-align:center">写→读切换</td>
<td style="text-align:center">0</td>
<td style="text-align:center">=原position</td>
<td style="text-align:center">清除</td>
</tr>
<tr>
<td style="text-align:center">get()</td>
<td style="text-align:center">读取数据</td>
<td style="text-align:center">增加</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">可能清除</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">读→写切换(重置)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">= capacity</td>
<td style="text-align:center">清除</td>
</tr>
<tr>
<td style="text-align:center">rewind()</td>
<td style="text-align:center">重新读取(不改变limit)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">清除</td>
</tr>
<tr>
<td style="text-align:center">compact()</td>
<td style="text-align:center">压缩缓冲区(保留未读数据)</td>
<td style="text-align:center">=剩余数据数</td>
<td style="text-align:center">= capacity</td>
<td style="text-align:center">清除</td>
</tr>
</tbody>
</table>
<h3 id="NIO与零拷贝">NIO与零拷贝</h3>
<p>零拷贝是从操作系统的角度来说的</p>
<p>普通方式</p>
<img src="/2025/03/28/Netty/chapter03_17.png" class="" title="img">
<p>mmap</p>
<p><strong>mmap 的核心机制是通过修改页表，将进程用户态地址空间的一页和内核态地址空间的一页映射到同一个物理内存块（页缓存）来实现的</strong></p>
<p>仍需要一次从kernel buffer复制到socket buffer的过程</p>
<img src="/2025/03/28/Netty/chapter03_18.png" class="" title="img">
<p>sendFile</p>
<p><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</p>
<img src="/2025/03/28/Netty/chapter03_19.png" class="" title="img">
<p>sendFile优化</p>
<p><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</p>
<img src="/2025/03/28/Netty/chapter03_20.png" class="" title="img">
<h3 id="AIO">AIO</h3>
<h2 id="Netty">Netty</h2>
<h3 id="线程模型">线程模型</h3>
<p>传统阻塞 I/O 模型，蓝框线程，黄框对象，白框方法</p>
<img src="/2025/03/28/Netty/chapter05_01.png" class="" title="img">
<p>Reactor 模式，蓝框线程，黄框对象，白框方法</p>
<img src="/2025/03/28/Netty/chapter05_03.png" class="" title="img">
<ul>
<li>
<p><strong>单线程Reactor</strong>：</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_04.png" alt="img"></p>
<ul>
<li><strong>所有操作</strong>（I/O + 业务处理）均在Reactor线程完成。</li>
<li>缺点：业务处理阻塞事件循环（如数据库查询）。</li>
<li>示例：Redis的单线程模型。</li>
</ul>
</li>
<li>
<p><strong>多线程Reactor</strong>：</p>
<img src="/2025/03/28/Netty/chapter05_05.png" class="" title="img">
<ul>
<li><strong>主线程仅处理I/O</strong>（接收连接、读写数据），<strong>业务逻辑交给线程池</strong>。</li>
<li>子线程处理完成后，通常通过回调或队列通知Reactor线程继续I/O操作。</li>
<li>示例：Netty的默认模式、Java NIO的常见实践。</li>
</ul>
</li>
<li>
<p><strong>多Reactor线程</strong>：</p>
<img src="/2025/03/28/Netty/chapter05_06.png" class="" title="img">
<ul>
<li><strong>主Reactor</strong>负责接收连接，<strong>子Reactor线程</strong>（多个）负责已连接套接字的I/O和业务。</li>
<li>示例：Netty的<code>NioEventLoopGroup</code>、Linux下的<code>SO_REUSEPORT</code></li>
</ul>
</li>
</ul>
<h3 id="Netty线程模型">Netty线程模型</h3>
<p>蓝框线程，黄框对象，白框方法</p>
<img src="/2025/03/28/Netty/D693697CEDCDC16AC09A5CF4747129CE.png" class="" title="D693697CEDCDC16AC09A5CF4747129CE">
<p><code>NioEventLoopGroup</code> 可以看作是一个 <strong>线程池</strong>，但它不仅仅是普通的线程池，而是专门为 Netty 的异步 I/O 模型优化的 <strong>事件循环组</strong>。它的主要特点：</p>
<ul>
<li><strong>包含多个 <code>NioEventLoop</code>（事件循环）</strong>：
<ul>
<li>每个 <code>NioEventLoop</code> 是一个独立的线程，负责处理 I/O 事件、任务队列和定时任务。</li>
<li>默认情况下，<code>NioEventLoopGroup</code> 的线程数 = <code>CPU 核心数 × 2</code>（但可以手动指定）。</li>
</ul>
</li>
<li><strong>职责</strong>：
<ul>
<li><strong>BossGroup</strong>（用于服务端）：负责监听和接受新连接（<code>ServerSocketChannel</code>）。</li>
<li><strong>WorkerGroup</strong>（用于服务端/客户端）：负责处理已建立连接的 I/O 读写（<code>SocketChannel</code>）。</li>
</ul>
</li>
</ul>
<p>每个 <code>NioEventLoop</code> 是一个 <strong>单线程的事件循环</strong>，它负责：</p>
<ol>
<li><strong>监听 I/O 事件</strong>（如 <code>OP_ACCEPT</code>、<code>OP_READ</code>、<code>OP_WRITE</code>），为图中的 <code>selector.select()</code> <code>processSelectedKeys()</code>，<code>processSelectedKeys()</code> 根据 <code>selectedKeys</code> 的不同，触发 <code>ChannelPipeline</code> 中的不同方法</li>
<li><strong>执行任务队列中的任务</strong>（如用户提交的 <code>Runnable</code>），为图中的 <code>runAllTasks()</code></li>
<li><strong>处理定时任务</strong>（如 <code>schedule()</code> 提交的延迟任务），为图中的 <code>runAllTasks()</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventLoop Thread</span><br><span class="line">├── selector.select()          // 轮询 I/O 事件</span><br><span class="line">├── processSelectedKeys()      // 处理 I/O 事件（如读、写、连接接受等）,触发处理器链</span><br><span class="line">│   ├── channelRead()          // 例如处理读事件</span><br><span class="line">│   ├── channelActive()        // 例如处理连接事件</span><br><span class="line">│   ├── handlerAdded()</span><br><span class="line">│   └── handlerRemoved()</span><br><span class="line">└── runAllTasks()              // 执行用户提交的任务（Runnable）</span><br></pre></td></tr></table></figure>
<p>Handler</p>
<ul>
<li><code>handler()</code>：用于处理<strong>服务端Channel本身</strong>的事件（这里是NioServerSocketChannel）</li>
<li><code>childHandler()</code>：用于处理<strong>被接受的客户端连接</strong>（这里是SocketChannel）</li>
</ul>
<p><code>processSelectedKeys()</code> 方法</p>
<p><strong>作用</strong>：</p>
<ul>
<li>处理 <strong>I/O 事件</strong>（如读、写、连接接受等），触发 <strong>ChannelPipeline 中的处理器链</strong>。</li>
<li>当Selector检测到Channel有就绪的I/O事件时，<code>NioEventLoop</code>会调用此方法处理这些事件。</li>
</ul>
<p><strong>与处理器链的关系</strong>：</p>
<ul>
<li>对于每个就绪的Channel事件（如 OP_READ），Netty会调用该Channel的 ChannelPipeline 中的处理器链。
<ul>
<li>例如：数据读取 → 触发<code>ChannelInboundHandler.channelRead()</code>；</li>
<li>连接建立 → 触发<code>ChannelInboundHandler.channelActive()</code>。</li>
</ul>
</li>
<li><strong>空闲检测</strong>（如<code>IdleStateHandler</code>）也是通过<code>processSelectedKeys()</code>触发的，它会检查Channel的读写空闲状态，并触发<code>IdleStateEvent</code>事件。</li>
</ul>
<p><code>runAllTasks()</code> 方法</p>
<p><strong>作用</strong>：</p>
<ul>
<li>执行 <strong>非I/O的异步任务</strong>（如用户提交的<code>Runnable</code>、定时任务、ChannelFuture的回调等）。</li>
<li>这些任务可能是：
<ul>
<li>用户通过<code>eventLoop.execute(task)</code>提交的任务。</li>
<li>Netty内部任务（如Channel关闭后的清理、写刷新等）。</li>
<li>定时任务（如<code>schedule()</code>提交的延迟任务）。</li>
</ul>
</li>
</ul>
<p><strong>与 <code>processSelectedKeys()</code> 的关系</strong>：</p>
<ul>
<li>NioEventLoop 是单线程的，<code>runAllTasks()</code> 和 <code>processSelectedKeys()</code> 两者交替执行，但Netty会<strong>优先保证I/O处理</strong>，限制任务执行时间（默认不超过<code>ioRatio</code>比例）。</li>
</ul>
<p>流程：</p>
<ol>
<li>bossGroup的NioEventLoop接收新连接，创建SocketChannel</li>
<li>将该SocketChannel注册到workerGroup的一个NioEventLoop的Selector上</li>
<li>当该NioEventLoop处理I/O事件(<code>processSelectedKeys()</code>方法)时，会调用pipeline中的处理器链</li>
</ol>
<p>案例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 定义线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); <span class="comment">// 接收连接</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">// 处理I/O</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 配置服务端</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>) <span class="comment">// 连接队列大小</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">// BossGroup的Handler</span></span><br><span class="line">                    .childHandler(</span><br><span class="line">                <span class="comment">// Channel注册到EventLoop后	触发ChannelInitializer.initChannel()</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">// 3. 添加编解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            <span class="comment">// 4. 空闲检测（5秒无读触发）</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">                            <span class="comment">// 5. 自定义处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 方法执行完毕ChannelInitializer自动从Pipeline中移除，仅保留添加的处理器</span></span><br><span class="line">            <span class="comment">// 6. 绑定端口</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server started on port 8080&quot;</span>);</span><br><span class="line">            <span class="comment">// 7. 关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义服务端处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received: &quot;</span> + msg);</span><br><span class="line">        <span class="comment">// 异步任务示例</span></span><br><span class="line">        ctx.channel().eventLoop().execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Async task processed&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        ctx.writeAndFlush(<span class="string">&quot;Response: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理空闲事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Channel idle, closing...&quot;</span>);</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Netty模块">Netty模块</h3>
<h4 id="ChannelFuture">ChannelFuture</h4>
<p>ChannelFuture直接继承自<code>Future&lt;V&gt;</code>接口</p>
<ul>
<li><code>addListener(GenericFutureListener)</code> - 添加监听器</li>
<li><code>channel()</code> - 获取关联的Channel</li>
<li><code>sync()</code> - 等待操作完成，如果失败则抛出异常</li>
<li><code>await()</code> - 等待操作完成，不抛出异常</li>
</ul>
<h4 id="Channel-2">Channel</h4>
<p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p>
<p>Channel的所有行为都会触发事件，由<code>ChannelPipeline</code>中的处理器链处理：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>事件类型</strong></th>
<th style="text-align:center"><strong>触发场景</strong></th>
<th style="text-align:center"><strong>对应方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>channelRegistered</code></td>
<td style="text-align:center">Channel注册到EventLoop时</td>
<td style="text-align:center"><code>handlerAdded()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>channelActive</code></td>
<td style="text-align:center">Channel连接建立/绑定完成</td>
<td style="text-align:center"><code>channelActive()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>channelRead</code></td>
<td style="text-align:center">数据可读时</td>
<td style="text-align:center"><code>channelRead()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>channelInactive</code></td>
<td style="text-align:center">Channel断开连接</td>
<td style="text-align:center"><code>channelInactive()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>exceptionCaught</code></td>
<td style="text-align:center">发生异常时</td>
<td style="text-align:center"><code>exceptionCaught()</code></td>
</tr>
</tbody>
</table>
<p><strong>内存管理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接内存分配（零拷贝优化）</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">directBuf</span> <span class="operator">=</span> channel.alloc().directBuffer();</span><br></pre></td></tr></table></figure>
<ul>
<li>Channel内置<code>ByteBufAllocator</code>，支持堆内/堆外内存分配。</li>
</ul>
<h4 id="ChannelPipeline">ChannelPipeline</h4>
<p>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应</p>
<img src="/2025/03/28/Netty/chapter06_03.png" class="" title="img">
<p><strong>如何触发 ChannelPipeline？</strong></p>
<p>不同事件类型会触发 <code>ChannelPipeline</code> 中的不同方法：</p>
<p><strong>ACCEPT 事件</strong>（服务端）</p>
<ul>
<li>
<p>调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">processSelectedKeys() </span><br><span class="line">  → NioMessageUnsafe.read() </span><br><span class="line">    → ServerSocketChannel.accept() </span><br><span class="line">    → pipeline.fireChannelRead() <span class="comment">// 触发ChannelRead事件</span></span><br><span class="line">      → ServerBootstrapAcceptor.channelRead() <span class="comment">// 默认处理器</span></span><br><span class="line">        → 初始化客户端Channel并注册到WorkerGroup</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Pipeline 触发点：</p>
<ul>
<li><code>fireChannelRead()</code>：通知处理器有新连接接入</li>
<li><strong>不直接触发业务处理器</strong>，而是通过 <code>ServerBootstrapAcceptor</code> 处理连接</li>
</ul>
</li>
</ul>
<p><strong>READ 事件</strong>（客户端）</p>
<ul>
<li>
<p>调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">processSelectedKeys() </span><br><span class="line">  → NioByteUnsafe.read() </span><br><span class="line">    → SocketChannel.read(ByteBuf) </span><br><span class="line">    → pipeline.fireChannelRead(ByteBuf) <span class="comment">// 触发数据读取事件</span></span><br><span class="line">      → StringDecoder.channelRead()    <span class="comment">// 解码器处理</span></span><br><span class="line">      → MyHandler.channelRead()        <span class="comment">// 业务处理器</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Pipeline 触发点：</p>
<ul>
<li><code>fireChannelRead()</code>：将数据传递给第一个 <code>ChannelInboundHandler</code></li>
<li>数据会依次通过所有入站处理器（如解码器、业务逻辑）</li>
</ul>
</li>
</ul>
<p><strong>WRITE 事件</strong></p>
<ul>
<li>
<p>调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">processSelectedKeys() </span><br><span class="line">  → AbstractChannel$AbstractUnsafe.forceFlush()</span><br><span class="line">    → pipeline.fireChannelWritabilityChanged() <span class="comment">// 触发可写状态变化</span></span><br><span class="line">    → outboundBuffer.removeBytes(writtenBytes) <span class="comment">// 更新写指针</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Pipeline 触发点：</p>
<ul>
<li><code>fireChannelWritabilityChanged()</code>：通知处理器写状态变化</li>
<li>通常用于流量控制（如停止写入避免OOM）</li>
</ul>
</li>
</ul>
<hr>
<p><strong>关键结论</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>事件类型</strong></th>
<th style="text-align:center"><strong>是否触发 Pipeline</strong></th>
<th style="text-align:center"><strong>触发的处理器方法</strong></th>
<th style="text-align:center"><strong>典型处理器</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACCEPT</td>
<td style="text-align:center">是（但仅限服务端特殊处理器）</td>
<td style="text-align:center"><code>channelRead()</code></td>
<td style="text-align:center"><code>ServerBootstrapAcceptor</code></td>
</tr>
<tr>
<td style="text-align:center">READ</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>channelRead()</code></td>
<td style="text-align:center"><code>StringDecoder</code>/<code>MyHandler</code></td>
</tr>
<tr>
<td style="text-align:center">WRITE</td>
<td style="text-align:center">是（仅触发写状态变更）</td>
<td style="text-align:center"><code>channelWritabilityChanged()</code></td>
<td style="text-align:center">流量控制处理器</td>
</tr>
<tr>
<td style="text-align:center">CONNECT</td>
<td style="text-align:center">是（客户端连接完成时）</td>
<td style="text-align:center"><code>channelActive()</code></td>
<td style="text-align:center">日志处理器/初始化处理器</td>
</tr>
</tbody>
</table>
<h4 id="ChannelHandler">ChannelHandler</h4>
<p>适配器类在<strong>接口（Handler）和用户实现类</strong>之间架设了一层缓冲，将“必须实现所有方法”的严格接口适配为“按需实现”的灵活方式。</p>
<img src="/2025/03/28/Netty/chapter06_01.png" class="" title="img">
<p>通过继承 <code>ChannelInboundHandlerAdapter</code>重写相应方法实现业务逻辑</p>
<img src="/2025/03/28/Netty/chapter06_02.png" class="" title="img">
<h3 id="Netty零拷贝">Netty零拷贝</h3>
<ol>
<li><strong>直接封装 JDK Channel</strong>：避免抽象层带来的性能损耗。</li>
<li><strong>强制使用 Direct Buffer</strong>：减少内核态到用户态的内存拷贝。</li>
<li><strong>文件传输零拷贝</strong>：利用 <code>sendfile</code> 系统调用。</li>
<li><strong>内存池化技术</strong>：重用已分配的堆外内存。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java-Design-pattern/" rel="tag"># Java, Design pattern</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/03/19/LLM-Rela/" rel="prev" title="LLM&Rela">
      <i class="fa fa-chevron-left"></i> LLM&Rela
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/04/02/Paper-Reading-Record/" rel="next" title="Paper-Reading-Record">
      Paper-Reading-Record <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">Netty&amp;Rela</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Proactor-Reactor"><span class="nav-text">Proactor &amp; Reactor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Proactor"><span class="nav-text">Proactor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor"><span class="nav-text">Reactor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Diff"><span class="nav-text">Diff</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-IO"><span class="nav-text">Java IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO"><span class="nav-text">BIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO"><span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Selector"><span class="nav-text">Selector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel"><span class="nav-text">Channel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffer"><span class="nav-text">Buffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-text">NIO与零拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AIO"><span class="nav-text">AIO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty"><span class="nav-text">Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">Netty线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty%E6%A8%A1%E5%9D%97"><span class="nav-text">Netty模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelFuture"><span class="nav-text">ChannelFuture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel-2"><span class="nav-text">Channel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelPipeline"><span class="nav-text">ChannelPipeline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelHandler"><span class="nav-text">ChannelHandler</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-text">Netty零拷贝</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="marigo1d"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">marigo1d</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/marigo1d" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;marigo1d" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">marigo1d</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">435k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">13:11</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
