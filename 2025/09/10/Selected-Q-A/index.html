<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marigo1d.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="面试问题精选">
<meta property="og:type" content="article">
<meta property="og:title" content="Selected Q&amp;A">
<meta property="og:url" content="https://marigo1d.github.io/2025/09/10/Selected-Q-A/index.html">
<meta property="og:site_name" content="Marigold">
<meta property="og:description" content="面试问题精选">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://marigo1d.github.io/2025/09/10/Selected-Q-A/2a3c22e2ac6d0a8990f04e4920760b57.png">
<meta property="article:published_time" content="2025-09-10T02:12:25.000Z">
<meta property="article:modified_time" content="2025-09-17T02:31:51.873Z">
<meta property="article:author" content="marigo1d">
<meta property="article:tag" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://marigo1d.github.io/2025/09/10/Selected-Q-A/2a3c22e2ac6d0a8990f04e4920760b57.png">

<link rel="canonical" href="https://marigo1d.github.io/2025/09/10/Selected-Q-A/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Selected Q&A | Marigold</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Marigold</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Salt, Pepper and Birds~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://marigo1d.github.io/2025/09/10/Selected-Q-A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="marigo1d">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marigold">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Selected Q&A
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-10 10:12:25" itemprop="dateCreated datePublished" datetime="2025-09-10T10:12:25+08:00">2025-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-17 10:31:51" itemprop="dateModified" datetime="2025-09-17T10:31:51+08:00">2025-09-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/default/" itemprop="url" rel="index"><span itemprop="name">default</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>42 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>面试问题精选</p>
<span id="more"></span>
<h1>Selected Q&amp;A</h1>
<h2 id="Java-基础">Java 基础</h2>
<p><code>hashCode()</code> &amp; <code>equals()</code></p>
<p><strong><code>equals()</code> 方法详解</strong></p>
<p><code>equals()</code> 方法用于比较两个对象是否“相等”。</p>
<p><strong><code>Object</code> 类中的默认实现:</strong><br>
在 <code>Object</code> 类中，<code>equals()</code> 方法的默认实现是比较两个对象的内存地址，等同于 <code>==</code> 运算符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object 类的默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着，除非一个类重写（Override）了 <code>equals()</code> 方法，否则只有当两个引用指向同一个内存地址的对象时，<code>equals()</code> 才会返回 <code>true</code>。</p>
<p>对于 <code>==</code> 符号：</p>
<p><strong>对于基本数据类型（如 int, char, boolean 等）</strong></p>
<p><code>==</code>直接比较它们的<strong>值</strong>是否相等。</p>
<p><strong>对于对象（引用类型）</strong></p>
<p><code>==</code>比较的是两个对象的<strong>内存地址</strong>（即是否为同一个对象），而不是对象的内容。如果要比较对象的内容是否相等，需要使用 <code>equals()</code>方法。</p>
<br>
<p><strong><code>hashCode()</code> 方法详解</strong></p>
<p><code>hashCode()</code> 方法返回一个对象的哈希码（一个 <code>int</code> 类型的整数）。</p>
<p>当一个类没有重写 hashCode() 方法时，它会继承自 java.lang.Object 类的默认实现。Object 类中的 hashCode() 方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这里的 native 关键字是关键。它意味着该方法的实现并非由 Java 代码编写，而是由 Java 虚拟机 (JVM) 使用本地语言（通常是 C++）实现的。这也直接导致了 hashCode() 的默认行为是<strong>依赖于具体的 JVM 实现</strong>的，并没有一个全平台统一的算法。</p>
<p><strong>现代 JVM (以 OpenJDK/HotSpot 为例) 的实现策略</strong></p>
<p>为了解决内存地址变化的问题，并提供高效的哈希码生成，现代 JVM 采用了更为复杂的策略。虽然具体实现可能随版本变化，但通常有以下几种生成方式，首次调用对象的 hashCode() 时，JVM 会选择一种策略生成一个值，然后<strong>将这个值缓存（存储）在对象头（Object Header）的特定区域（称为 “Mark Word”）中</strong>。这样，后续对该对象 hashCode() 的调用就可以直接返回这个缓存的值，从而保证了其在对象生命周期内的一致性。</p>
<p>hashCode 的生成策略可能包括：</p>
<ol>
<li><strong>随机数生成：</strong> 在某些版本的 OpenJDK 中（例如 6 和 7），默认的哈希码是基于一个随机数生成器产生的。</li>
<li><strong>与线程状态相关的数：</strong> 在 OpenJDK 8 及之后的一些版本中，生成的哈希码可能与当前线程的状态有关。这是一种利用线程本地信息来生成不同哈希码的方式。</li>
<li><strong>内存地址（作为一次性输入）：</strong> 某些 JVM 实现可能在首次计算哈希码时使用对象的内存地址作为输入，但计算出结果后会将其缓存，即使对象地址后续发生变化，哈希码也不会变。</li>
<li><strong>固定值：</strong> 在极少数情况下或特定优化场景下，可能会返回一个固定的值。</li>
</ol>
<p><strong><code>hashCode()</code> 的作用:</strong><br>
当向一个哈希集合中添加一个对象时，集合会首先调用该对象的 <code>hashCode()</code> 方法来计算其哈希码。这个哈希码决定了对象在哈希表中的存储位置（即“桶”的位置）。</p>
<ul>
<li>如果多个对象的哈希码不同，它们会被存放在不同的桶中，查找时可以快速定位。</li>
<li>如果多个对象的哈希码相同（这种情况称为“哈希冲突”），它们会被存放在同一个桶中，通常以链表或红黑树的形式组织。 这时，集合会进一步调用 <code>equals()</code> 方法来精确地判断这两个对象是否真的相等。</li>
</ul>
<br>
<p><strong><code>equals()</code> 与 <code>hashCode()</code> 之间的契约</strong></p>
<p>这两个方法之间存在一个非常重要的契约，在重写它们时必须严格遵守：</p>
<ol>
<li><strong>如果两个对象通过 <code>equals()</code> 方法比较是相等的，那么它们的 <code>hashCode()</code> 方法必须返回相同的整数值。</strong></li>
<li><strong>如果两个对象通过 <code>equals()</code> 方法比较是不相等的，那么它们的 <code>hashCode()</code> 方法不被要求必须返回不同的整数值。但是，为了提高哈希表的性能，我们应该尽量让不相等的对象产生不同的哈希码。</strong></li>
</ol>
<p><strong>为什么必须遵守这个契约？</strong></p>
<p>这个契约是保证哈希集合（如 <code>HashMap</code>, <code>HashSet</code>）能够正常工作的关键。</p>
<p>设想一下，如果你违反了第一条规则：重写了 <code>equals()</code> 但没有重写 <code>hashCode()</code>。</p>
<ul>
<li>你创建了两个 <code>Person</code> 对象，<code>p1</code> 和 <code>p2</code>，它们的内容完全相同（例如，<code>id</code> 都是 “123”）。</li>
<li>根据你重写的 <code>equals()</code> 方法，<code>p1.equals(p2)</code> 会返回 <code>true</code>。</li>
<li>但是，因为你没有重写 <code>hashCode()</code>，它们会使用 <code>Object</code> 类的默认实现，该实现为每个不同的对象实例返回不同的哈希码。所以 <code>p1.hashCode()</code> 很可能不等于 <code>p2.hashCode()</code>。</li>
<li>现在，当你试图将 <code>p1</code> 和 <code>p2</code> 放入一个 <code>HashSet</code> 时，问题就出现了。<code>HashSet</code> 会认为它们是两个完全不同的对象，因为它们的哈希码不同，导致它们被存放在不同的位置。这违反了 <code>Set</code> 集合元素唯一的原则。</li>
</ul>
<br>
<h2 id="Java-反射">Java 反射</h2>
<p><strong>反射使用</strong></p>
<p>可以在运行时动态加载和操作类，实现高度可配置和可扩展的程序。许多框架（如 Spring, Hibernate, JUnit, MyBatis）的核心都基于反射。</p>
<ul>
<li>
<p><strong>Spring IOC</strong>：通过反射读取配置文件或注解，动态创建和管理 Bean。</p>
</li>
<li>
<p><strong>Hibernate/MyBatis</strong>：通过反射将数据库结果集映射到 Java 对象。</p>
</li>
<li>
<p><strong>JUnit</strong>：通过反射查找带有 <code>@Test</code> 注解的方法并执行它们。</p>
</li>
</ul>
<br>
<p><strong>反射性能差</strong></p>
<p><strong>运行时解析：失去编译时优化</strong></p>
<p>这是最根本的原因。</p>
<ul>
<li><strong>普通方法调用/字段访问（编译时绑定）：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.publicMethod(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 编译器明确知道要调用哪个方法，直接写入字节码</span></span><br><span class="line">p.name = <span class="string">&quot;Alice&quot;</span>;        <span class="comment">// 编译器明确知道要访问哪个字段，内存偏移量是固定的</span></span><br></pre></td></tr></table></figure>
<p>在编译期间（Compile-time），Java 编译器（javac）和 Just-In-Time (JIT) 编译器会进行大量优化：</p>
<ul>
<li><strong>内联（Inlining）</strong>：将短方法的方法体直接嵌入到调用处，避免方法调用的开销。</li>
<li><strong>方法链接</strong>：直接链接到目标方法的内存地址。</li>
<li><strong>字段偏移量计算</strong>：直接计算字段在对象内存中的固定偏移量。</li>
</ul>
<p><strong>反射调用/字段访问（运行时绑定）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method method = personClass.getMethod(&quot;publicMethod&quot;, String.class);</span><br><span class="line">method.invoke(p, &quot;Hello&quot;); // JVM 在运行时才知道要调用哪个方法</span><br><span class="line"></span><br><span class="line">Field field = personClass.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.set(p, &quot;Alice&quot;);     // JVM 在运行时才知道要访问哪个字段</span><br></pre></td></tr></table></figure>
<p>所有这些信息（方法名、参数类型、字段名等）都是在<strong>运行时（Run-time）</strong> 才被解析和确定的。JVM 无法在编译期进行上述的任何优化，必须执行一系列昂贵的查找和验证步骤。</p>
<p><strong>繁琐的检查与验证过程</strong></p>
<p>每次使用 <code>Method.invoke()</code> 或 <code>Field.set()</code> 时，JVM 都需要执行以下操作：</p>
<ul>
<li><strong>权限检查</strong>：检查当前调用上下文是否有权访问该方法或字段（尤其是对于 <code>private</code> 成员，需要调用 <code>setAccessible(true)</code>，但这个调用本身也有开销）。</li>
<li><strong>参数验证</strong>：检查传入的参数数量、类型是否与目标方法或字段匹配。</li>
<li><strong>类型转换</strong>：必要时需要进行参数的装箱（Boxing）和拆箱（Unboxing），因为 <code>invoke</code> 和 <code>set</code> 只接受 <code>Object</code>。这会产生额外的对象创建开销。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 反射需要装箱：基本类型 int 被包装成 Integer Object</span><br><span class="line">Method ageSetMethod = ... // 获取setAge(int age)方法</span><br><span class="line">ageSetMethod.invoke(p, 30); // 这里的 30 会被自动装箱成 Integer(30)</span><br></pre></td></tr></table></figure>
<p><strong>阻碍现代 JIT 编译器的深度优化</strong></p>
<p>现代高性能的 JVM（如 HotSpot）严重依赖 JIT 编译器。JIT 会监控代码的运行（“热点代码”），并将其编译成本地机器码，进行激进优化。</p>
<p>反射调用是<strong>动态的</strong>和<strong>不可预测的</strong>，这使得 JIT 编译器很难：</p>
<ul>
<li><strong>内联方法</strong>：因为无法在编译时确定实际要调用的方法。</li>
<li><strong>进行逃逸分析</strong>：难以确定反射创建的对象或传入的参数的生命周期。</li>
<li><strong>优化循环</strong>：如果循环体内包含反射调用，整个循环都可能无法被有效优化。</li>
</ul>
<p>反射调用就像告诉 JVM：“嘿，我现在要调用一个方法，但我不会告诉你具体是哪个，你自己在运行时去找吧。” 这迫使 JVM 使用一种更通用、更慢的路径来执行操作。</p>
<p><strong>性能差距的量级</strong></p>
<p>在<strong>早期</strong>的 JVM 版本中，反射调用的速度可能比直接调用<strong>慢几十甚至上百倍</strong>。</p>
<p>随着 JVM 的不断进化（尤其是现代 JDK 8+），这个差距已经<strong>显著缩小</strong>。JVM 为反射调用引入了一些优化，例如：</p>
<ul>
<li><strong>膨胀（Inflation）机制</strong>：最初的几次反射调用使用纯 Java 代码（慢）。当某个反射调用成为“热点”后，JVM 会为其生成一个专用的本地机器码（Native Method Accessor），后续的调用就会快很多。</li>
<li><strong>缓存</strong>：<code>Method</code>, <code>Field</code>, <code>Constructor</code> 对象是可缓存的。一旦获取，就不需要再次进行昂贵的类查找。</li>
</ul>
<p><strong>但是，即使有这些优化，反射调用仍然比直接调用慢数倍。</strong> 在需要极致性能的场景（例如，在循环中调用数百万次），这种开销依然是不可忽视的。</p>
<hr>
<p><strong>如何缓解反射的性能问题？</strong></p>
<ol>
<li><strong>避免在性能关键循环中使用反射</strong>：这是黄金法则。如果一段代码需要每秒执行百万次，请想尽办法避免在其中使用反射。</li>
<li><strong>缓存反射对象</strong>：<code>Class</code>, <code>Method</code>, <code>Field</code>, <code>Constructor</code> 等对象是 immutable（不可变）的，获取它们的开销很大。<strong>一定要将它们缓存起来重复使用</strong>，而不是在每次调用时都重新查找。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 错误示范：每次调用都查找方法，极其低效</span><br><span class="line">for (int i = 0; i &lt; 1_000_000; i++) &#123;</span><br><span class="line">    Method m = clz.getMethod(&quot;methodName&quot;);</span><br><span class="line">    m.invoke(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确示范：缓存方法对象</span><br><span class="line">Method m = clz.getMethod(&quot;methodName&quot;); // 在循环外查找并缓存</span><br><span class="line">for (int i = 0; i &lt; 1_000_000; i++) &#123;</span><br><span class="line">    m.invoke(target); // 只调用 invoke</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>使用</strong> <code>setAccessible(true)</code> <strong>并缓存其效果</strong>：访问私有成员时，调用 <code>setAccessible(true)</code> 会绕过运行时访问检查，这会带来一定的性能提升。这个效果是持久的，只需要设置一次即可。</li>
<li><strong>考虑使用方法句柄（MethodHandle, JDK7+）</strong>：<code>java.lang.invoke.MethodHandle</code> 提供了另一种更现代、更轻量级的反射机制。在某些情况下，它可能比传统反射性能更好，并且更适合 JIT 优化。</li>
<li><strong>终极方案：字节码操作库（如 ASM, CGLib, Byte Buddy）或代码生成</strong>：对于极端性能要求的场景，可以在程序启动时或编译时，通过这些库动态生成所需的直接调用代码类，从而完全避免运行时的反射开销。Spring 等框架大量使用这种技术。</li>
</ol>
<h2 id="Java-代理">Java 代理</h2>
<p><strong>JDK 动态代理</strong> 是 Java 标准库 java.lang.reflect 包的一部分，无需引入任何第三方库。它的核心是 Proxy 类和 InvocationHandler 接口。JDK 动态代理的机制要求被代理的目标对象必须实现至少一个接口。代理类在运行时动态地被创建，它会实现与目标对象相同的接口，并将所有的方法调用转发给一个 InvocationHandler 实例进行处理。简而言之，JDK 动态代理是通过实现接口的方式来创建代理对象的。</p>
<p><strong>CGLIB (Code Generation Library)</strong></p>
<p><strong>字节码生成</strong>: CGLIB 是一个强大的代码生成库。 当你使用 CGLIB 创建一个代理对象时，它不会修改原始类的代码。相反，它会在运行时利用底层的字节码操作库 ASM 来动态地创建一个新的类。 这个新生成的类是原始类的子类，并重写了父类中非 final 的方法，从而实现方法拦截和功能增强。</p>
<p><strong>在内存中创建</strong>: 这个新类的定义，也就是它的字节码（.class 文件内容），是在内存中直接生成的，而不是写入到物理磁盘文件中。</p>
<p><strong>类加载</strong>: 生成字节码后，CGLIB 会通过 ClassLoader 将这些字节码加载到当前的 JVM 中。</p>
<p><strong>存入方法区</strong>: 一旦类被加载，JVM 会将这个新类的元数据信息存放到<strong>方法区</strong>。 这些元数据包括类的结构信息（字段、方法）、方法的字节码、运行时常量池等。 从这一刻起，这个由 CGLIB 动态生成的代理类就和普通从 .class 文件加载的类一样，可以被 JVM 正常实例化和使用了。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>JDK 动态代理</th>
<th>CGLIB 动态代理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>实现方式</strong></td>
<td>基于接口，运行时动态实现接口</td>
<td>基于继承，运行时动态生成子类</td>
</tr>
<tr>
<td><strong>核心API</strong></td>
<td>java.lang.reflect.Proxy, java.lang.reflect.InvocationHandler</td>
<td>net.sf.cglib.proxy.Enhancer, net.sf.cglib.proxy.MethodInterceptor</td>
</tr>
<tr>
<td><strong>依赖</strong></td>
<td>Java 标准库，无需额外依赖</td>
<td>需要引入第三方 CGLIB 库</td>
</tr>
<tr>
<td><strong>代理对象</strong></td>
<td>必须实现接口</td>
<td>无需实现接口，但不能是 final 类</td>
</tr>
</tbody>
</table>
<h2 id="Java-编译">Java 编译</h2>
<p>Java 编译器 <code>javac</code> 和 JIT（Just-In-Time）编译器</p>
<p><strong>核心摘要</strong></p>
<p>最根本的区别在于：<strong><code>javac</code> 是一个将 Java 源代码编译成字节码的 *静态编译器*，而 JIT 是 Java 虚拟机（JVM）内部的一个组件，它是一个在运行时将字节码编译成机器码的 *动态编译器*。</strong></p>
<p>它们不是非此即彼的选择，而是协同工作的两个阶段。</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left"><code>javac</code>（前端编译器）</th>
<th style="text-align:left">JIT（后端编译器，如 HotSpot 的 C1/C2）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>编译时机</strong></td>
<td style="text-align:left"><strong>编译时</strong>（开发期间）</td>
<td style="text-align:left"><strong>运行时</strong>（程序运行期间）</td>
</tr>
<tr>
<td style="text-align:left"><strong>输入</strong></td>
<td style="text-align:left"><code>.java</code> 源代码文件</td>
<td style="text-align:left"><code>.class</code> 字节码文件</td>
</tr>
<tr>
<td style="text-align:left"><strong>输出</strong></td>
<td style="text-align:left"><code>.class</code> 字节码文件（中间代码）</td>
<td style="text-align:left"><strong>本地机器码</strong>（Native Machine Code）</td>
</tr>
<tr>
<td style="text-align:left"><strong>编译次数</strong></td>
<td style="text-align:left">一次编译，多次运行</td>
<td style="text-align:left"><strong>多次编译</strong>（对热点代码进行反复优化编译）</td>
</tr>
<tr>
<td style="text-align:left"><strong>目标平台</strong></td>
<td style="text-align:left">平台无关的字节码（一次编译，到处运行）</td>
<td style="text-align:left"><strong>平台相关</strong>的机器码（依赖特定的 CPU 和操作系统）</td>
</tr>
<tr>
<td style="text-align:left"><strong>优化类型</strong></td>
<td style="text-align:left">基本优化（语法检查、常量折叠等）</td>
<td style="text-align:left"><strong>深度优化</strong>（基于运行时信息的激进优化，如内联、逃逸分析、锁消除等）</td>
</tr>
<tr>
<td style="text-align:left"><strong>角色</strong></td>
<td style="text-align:left"><strong>翻译官</strong>：将人类可读的代码翻译成 JVM 可读的字节码</td>
<td style="text-align:left"><strong>性能引擎</strong>：在运行时将字节码翻译成机器码，并持续优化性能</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>详细解释</strong></p>
<p><strong><code>javac</code> - 静态编译器</strong></p>
<ul>
<li><strong>作用</strong>：<code>javac</code> 是 JDK 中自带的前端编译器。它的任务非常明确：检查 Java 源代码的语法、语义是否正确，然后将其编译成一种中间形式——<strong>字节码</strong>。</li>
<li><strong>输出（字节码）</strong>：字节码不是任何真实 CPU 的指令集，它是为 JVM 量身定做的虚拟指令。这种设计是实现 Java “<strong>一次编写，到处运行</strong>”（Write Once, Run Anywhere - WORA）理念的基石。字节码文件（.class）可以在任何安装了对应版本 JVM 的操作系统上运行。</li>
<li><strong>优化</strong>：<code>javac</code> 所做的优化非常有限，主要是一些编译期就能确定的操作，例如将 <code>static final</code> 常量直接替换成字面量、语法糖（如泛型擦除、自动拆装箱）的处理等。它不会进行任何基于程序运行行为的优化。</li>
</ul>
<p><strong>过程</strong>： <code>YourSource.java</code> --(<code>javac</code>)–&gt; <code>YourSource.class</code> (字节码)</p>
<p><strong>JIT (Just-In-Time) - 动态编译器</strong></p>
<ul>
<li><strong>作用</strong>：JIT 编译器是 JVM 执行引擎的核心部分。当 JVM 加载并运行一个 Java 程序时，它最初会使用<strong>解释器</strong>（Interpreter）来逐条读取字节码并翻译成机器码执行。解释执行的速度相对较慢。</li>
<li><strong>工作原理</strong>：
<ol>
<li><strong>解释执行</strong>：程序开始运行时，所有代码首先被解释执行。</li>
<li><strong>热点探测</strong>：JVM 会持续监控方法的调用次数和循环体的循环次数等指标。那些被频繁执行的代码（称为“<strong>热点代码</strong>” - Hot Spot）会被识别出来。</li>
<li><strong>即时编译</strong>：JIT 编译器会将这些热点代码<strong>动态编译</strong>成与当前本地硬件平台相关的、高度优化的<strong>机器码</strong>。</li>
<li><strong>缓存与执行</strong>：编译好的机器码会被缓存起来。下次再执行到这段代码时，JVM 会直接调用缓存中的机器码，而不是再次解释执行，从而极大地提升程序的运行效率。</li>
</ol>
</li>
<li><strong>分层编译</strong>：现代 JVM（如 HotSpot）通常采用分层编译策略来平衡启动速度和峰值性能：
<ul>
<li><strong>C1 编译器（客户端编译器）</strong>：编译速度快，但优化程度较低。适用于对启动速度敏感的应用（如桌面GUI程序）。</li>
<li><strong>C2 编译器（服务器编译器）</strong>：编译速度慢，但会进行大量激进优化，生成代码质量极高。适用于对峰值性能要求高的长期运行的服务端应用。</li>
<li><strong>分层编译（Tiered Compilation）</strong>：JDK 7 及以后版本的默认策略。代码可能先被 C1 编译，如果之后发现它非常“热”，再被 C2 重新编译进行深度优化。</li>
</ul>
</li>
</ul>
<br>
<h2 id="Java-锁">Java 锁</h2>
<p><strong>乐观锁</strong></p>
<p><strong>实现方式：</strong><br>
乐观锁主要通过两种方式实现：</p>
<p><strong>CAS (Compare-and-Swap) 算法</strong></p>
<p><code>AtomicInteger </code>类 <code>getAndIncrement</code> 方法</p>
<p>核心：在循环中反复获取内存中的某个值，获取后进行CAS操作，对比该内存中的值是否与刚才获取到的值一致，若一致则修改并退出循环，若不一致则循环继续；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">VALUE</span></span><br><span class="line">    <span class="operator">=</span> U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset); </span><br><span class="line">        <span class="comment">//  这个方法会以 volatile 的读语义，从指定的对象 o 的指定内存偏移量 offset 处，读取一个 int 值。换句话说，它保证了读取到的 v 是此刻主内存中的最新值。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="comment">// 这是比较并交换（Compare-And-Swap）操作。这是一个原子操作，通常由 CPU 指令直接支持。它的工作流程如下：比较: 比较位于 o 对象 offset 偏移量处的当前内存值，是否与我们刚刚读取到的值 v 相等。交换: 如果相等: 说明从我们读取 v 到现在，没有其他线程修改过这个值。那么，就将该内存位置的值更新为新值 v + delta，并返回 true。如果不相等: 说明在我们准备修改值的期间，有其他线程已经抢先修改了它。那么，更新操作失败，不改变内存中的值，并返回 false</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>版本号机制</strong>：在数据表中增加一个版本号字段。每次读取数据时，将版本号一同读出。当更新数据时，会比较当前数据库中的版本号与之前读取到的版本号是否一致。如果一致，则执行更新并将版本号加一；如果不一致，则表示数据已被其他线程修改，本次更新失败。</p>
<br>
<p><strong>悲观锁</strong></p>
<p><strong>实现方式：</strong><br>
Java 中典型的悲观锁实现包括：</p>
<p><strong><code>synchronized</code> 关键字</strong></p>
<p><strong>通过对象头的 Mark Word 记录锁状态，并随着线程竞争的激烈程度，经历从偏向锁、轻量级锁到重量级锁的膨胀过程</strong>。</p>
<p><strong>同步代码块与同步方法</strong></p>
<p>synchronized 主要有两种使用方式：同步代码块和同步方法。它们在字节码层面的实现略有不同：</p>
<ul>
<li><strong>同步代码块</strong>：JVM 使用 monitorenter 和 monitorexit 这两个字节码指令来实现。当线程执行到 monitorenter 指令时，会尝试获取对象的监视器锁。如果获取成功，锁计数器加一；如果获取失败，则线程将阻塞等待。当线程执行完同步代码块后，会执行 monitorexit 指令，锁计数器减一。当计数器归零时，锁被释放。</li>
<li><strong>同步方法</strong>：对于同步方法，JVM 会在方法的元数据中设置一个 ACC_SYNCHRONIZED 访问标志。当一个线程调用该方法时，JVM 会检查这个标志。如果标志存在，该线程必须先成功获取对象的监视器锁，才能执行方法体。方法执行完毕后（无论是正常返回还是抛出异常），JVM 会自动释放该锁。</li>
</ul>
<p><strong>Java 对象头与 Mark Word</strong></p>
<p>synchronized 的锁信息存储在 Java 对象头（Header）中。在 HotSpot 虚拟机中，对象头由两部分组成：</p>
<ul>
<li><strong>Klass Pointer（类型指针）</strong>：指向该对象所属类的元数据。</li>
<li><strong>Mark Word（标记字段）</strong>：用于存储对象自身的运行时数据，如哈希码、GC 分代年龄以及锁信息。</li>
</ul>
<p>Mark Word 的结构在不同锁状态下是动态变化的，它会根据对象的锁状态复用自己的存储空间，以在极小的空间内存储尽可能多的信息。</p>
<p><strong>锁的四种状态与膨胀过程</strong></p>
<p>为了在不同竞争情况下都能有较好的性能，synchronized 的锁会经历一个从无锁到偏向锁，再到轻量级锁，最终到重量级锁的膨胀过程。</p>
<p><strong>偏向锁 (Biased Locking)</strong></p>
<p><strong>引入目的</strong>：在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得。偏向锁的目的是消除在这种无竞争情况下的同步原语，进一步提高程序性能。</p>
<p><strong>工作原理</strong>：<br>
当一个线程首次获取锁时，JVM 会将对象头中的锁标志位设置为“01”，偏向模式设置为“1”，并记录下获取该锁的线程 ID。当该线程再次进入同步块时，只需简单检查一下 Mark Word 中记录的线程 ID 是否是当前线程的 ID，如果是，则无需再进行任何同步操作，直接执行同步代码。</p>
<p><strong>锁撤销</strong>：当有其他线程尝试获取该偏向锁时，偏向模式才会结束。持有偏向锁的线程会被挂起，JVM 会撤销偏向锁，并根据竞争情况将其升级为轻量级锁或重量级锁。</p>
<p><strong>轻量级锁 (Lightweight Locking)</strong></p>
<p><strong>引入目的</strong>：在线程交替执行同步块，但几乎没有实际竞争的情况下，避免重量级锁的性能开销。</p>
<p><strong>工作原理</strong>：<br>
在代码进入同步块时，如果同步对象处于无锁状态，JVM 会在当前线程的栈帧中创建一个名为“锁记录”（Lock Record）的空间，用于拷贝对象当前的 Mark Word（Displaced Mark Word）。然后，JVM 会尝试使用 CAS（Compare-And-Swap）操作将对象头中的 Mark Word 更新为指向锁记录的指针。如果更新成功，当前线程就获得了锁。</p>
<p>如果 CAS 操作失败，说明有其他线程正在竞争该锁。此时，JVM 会检查对象头的 Mark Word 是否指向当前线程的栈帧，如果是，则说明是锁重入，可以直接进入同步块。否则，说明存在锁竞争，轻量级锁会膨胀为重量级锁。</p>
<p><strong>重量级锁 (Heavyweight Locking)</strong></p>
<p><strong>引入目的</strong>：应对激烈的线程竞争情况。</p>
<p><strong>工作原理</strong>：<br>
当轻量级锁膨胀为重量级锁后，Mark Word 的锁标志位会变为“10”，并且其内容会变成一个指向重量级锁（即监视器 Monitor）的指针。这个 Monitor 对象在底层是由 C++ 实现的 ObjectMonitor。</p>
<p>ObjectMonitor 内部维护了几个关键的数据结构：</p>
<ul>
<li>_owner：指向持有该 Monitor 的线程。</li>
<li>_EntryList：存放处于阻塞状态，等待获取锁的线程队列。</li>
<li>_WaitSet：存放调用了 wait() 方法而被阻塞的线程队列。</li>
</ul>
<p>当一个线程尝试获取重量级锁时，如果 _owner 为空，则该线程会成为锁的持有者。如果 _owner 不为空，则该线程会被放入 _EntryList 队列中，并进入阻塞状态，等待被唤醒。重量级锁的获取和释放都涉及到线程的上下文切换和操作系统的互斥量（Mutex Lock），因此开销较大。</p>
<br>
<p><strong><code>ReentrantLock</code></strong>：<code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包下的一个类</p>
<br>
<p><strong>ReentrantLock 实现</strong></p>
<p><code>ReentrantLock</code> 的实现核心依赖于 <strong>AQS (AbstractQueuedSynchronizer)</strong> 框架。</p>
<p><code>ReentrantLock</code> 内部有两个关键的内部类：<code>FairSync</code>（公平锁）和 <code>NonfairSync</code>（非公平锁），它们都继承自 <code>Sync</code>，而 <code>Sync</code> 又继承自 AQS。</p>
<ul>
<li><strong>公平锁 (FairSync)</strong></li>
<li><strong>非公平锁 (NonfairSync)</strong> default</li>
</ul>
<p><code>ReentrantLock</code> 的加锁（<code>lock()</code>）和解锁（<code>unlock()</code>）操作，本质上是调用内部 <code>Sync</code> 对象的 <code>acquire()</code> 和 <code>release()</code> 方法，这两个方法则会调用 AQS 提供的模板方法。</p>
<p><strong>获取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock .lock()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sync.lock()</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS .aquire(int arg)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        acquire(<span class="literal">null</span>, arg, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">acquire</span><span class="params">(Node node, <span class="type">int</span> arg, <span class="type">boolean</span> shared,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> interruptible, <span class="type">boolean</span> timed, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">byte</span> <span class="variable">spins</span> <span class="operator">=</span> <span class="number">0</span>, postSpins = <span class="number">0</span>;   <span class="comment">// retries upon unpark of first thread</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>, first = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>;                <span class="comment">// predecessor of node when enqueued</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Repeatedly:</span></span><br><span class="line"><span class="comment">         *  Check if node now first</span></span><br><span class="line"><span class="comment">         *    if so, ensure head stable, else ensure valid predecessor</span></span><br><span class="line"><span class="comment">         *  if node is first or not yet enqueued, try acquiring</span></span><br><span class="line"><span class="comment">         *  else if node not yet created, create it</span></span><br><span class="line"><span class="comment">         *  else if not yet enqueued, try once to enqueue</span></span><br><span class="line"><span class="comment">         *  else if woken from park, retry (up to postSpins times)</span></span><br><span class="line"><span class="comment">         *  else if WAITING status not set, set and retry</span></span><br><span class="line"><span class="comment">         *  else park and clear WAITING status, and check cancellation</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="literal">null</span>) ? <span class="literal">null</span> : node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !(first = (head == pred))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cleanQueue();           <span class="comment">// predecessor cancelled</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">                Thread.onSpinWait();    <span class="comment">// ensure serialization</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first || pred == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> acquired;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (shared)</span><br><span class="line">                    acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    acquired = tryAcquire(arg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                cancelAcquire(node, interrupted, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="literal">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="literal">null</span>;</span><br><span class="line">                    node.waiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;                 <span class="comment">// allocate; retry before enqueue</span></span><br><span class="line">            <span class="keyword">if</span> (shared)</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">SharedNode</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">ExclusiveNode</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;          <span class="comment">// try to enqueue</span></span><br><span class="line">            node.waiter = current;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            node.setPrevRelaxed(t);         <span class="comment">// avoid unnecessary fence</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                tryInitializeHead();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node))</span><br><span class="line">                node.setPrevRelaxed(<span class="literal">null</span>);  <span class="comment">// back out</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">            --spins;                        <span class="comment">// reduce unfairness on rewaits</span></span><br><span class="line">            Thread.onSpinWait();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">            node.status = WAITING;          <span class="comment">// enable signal and recheck</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> nanos;</span><br><span class="line">            spins = postSpins = (<span class="type">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!timed)</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            node.clearStatus();</span><br><span class="line">            <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cancelAcquire(node, interrupted, interruptible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">//判断同步状态是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; !hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">//如果不需要排队，则直接cas操作更新同步状态为1</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//设置占用锁的线程为当前线程</span></span><br><span class="line">			 setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="comment">//返回true，表示上锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上情况都不是，则返回false，表示上锁失败。上锁失败根据AQS的框架设计，会入队排队</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>释放</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用AQS中的release()方法</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是AQS框架定义的release()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//当前锁是不是没有被线程持有,返回true表示该锁没有被任何线程持有</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">//获取头结点h</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//判断头结点是否为null并且waitStatus不是初始化节点状态，解除线程挂起状态</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">//减少可重入的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">//如果当前线程不是持有锁的线程，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//状态为0，表示持有线程被全部释放，设置为true</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p><strong>AQS (AbstractQueuedSynchronizer)</strong></p>
<p>AQS - Node</p>
<p>prev，next 实现 CLH 队列</p>
<p>nextWaiter 实现 Condition 队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"><span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱结点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next; <span class="comment">// 后继结点</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread; <span class="comment">// 结点对应的线程</span></span><br><span class="line">Node nextWaiter; <span class="comment">// 等待队列里下一个等待条件的结点</span></span><br></pre></td></tr></table></figure>
<p>![image](file://D:/github/blog/source/_posts/Java/java-thread-x-juc-aqs-1.png?lastModify=1757486309)</p>
<p>资源独占</p>
<p>总体思路：</p>
<ul>
<li><code>tryAcquire()</code> 尝试直接去获取资源，如果成功则直接返回。</li>
<li>如果失败则调用 <code>addWaiter()</code> 方法把当前线程包装成Node(状态为EXCLUSIVE，标记为独占模式)插入到CLH队列末尾。</li>
<li>然后 <code>acquireQueued()</code> 方法使线程阻塞在等待队列中获取资源，一直获取到资源后才返回，如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断 <code>selfInterrupt()</code>，将中断补上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2025/09/10/Selected-Q-A/2a3c22e2ac6d0a8990f04e4920760b57.png" class="" title="format,webp">
<h2 id="Java-容器">Java 容器</h2>
<p><strong>HashMap 负载因子</strong></p>
<ol>
<li>当 HashMap 中的元素数量（size）超过 <code>capacity * loadFactor</code>时触发扩容</li>
</ol>
<ul>
<li>默认负载因子(loadFactor)是 0.75</li>
<li>默认初始容量(capacity)是 16</li>
<li>因此默认情况下，当 size &gt; 12 (16×0.75) 时会触发第一次扩容</li>
</ul>
<ol start="2">
<li><strong>链表长度过长</strong>（JDK 8+）：当某个桶(bucket)中的链表长度超过 8，且当前容量小于 64 时，会优先扩容而不是树化</li>
</ol>
<br>
<p><strong>扩容过程</strong></p>
<ol>
<li><strong>计算新容量</strong>：新容量 = 旧容量 × 2（总是扩容为原来的 2 倍）</li>
<li><strong>重新计算阈值</strong>：新阈值 = 新容量 × 负载因子</li>
<li><strong>创建新数组</strong>：创建一个新的 Node 数组</li>
<li><strong>数据迁移</strong>（rehash）：
<ul>
<li>遍历旧数组中的每个桶</li>
<li>对于每个非空桶，重新计算元素在新数组中的位置</li>
<li>将元素迁移到新数组</li>
</ul>
</li>
</ol>
<p><strong>JDK 8 的优化</strong></p>
<p>在 JDK 8 中，HashMap 的扩容过程做了以下优化：</p>
<ol>
<li><strong>高位参与运算</strong>：元素在新表中的位置要么是原位置，要么是原位置+旧容量
<ul>
<li>通过 <code>(e.hash &amp; oldCap) == 0</code>判断</li>
<li>这样避免了重新计算 hash，提高了效率</li>
</ul>
</li>
<li><strong>链表保持顺序</strong>：扩容时链表元素会保持原有顺序（头插法改为尾插法）</li>
</ol>
<br>
<p><strong>ConcurrentHashMap</strong></p>
<p>分段锁</p>
<ul>
<li>将整个哈希表分成多个 Segment（默认为16个）</li>
<li>每个 Segment 是一个独立的 ReentrantLock</li>
<li>每个 Segment 相当于一个小的 HashMap</li>
</ul>
<p>CAS + synchronized</p>
<ol>
<li><strong>细粒度锁</strong>：
<ul>
<li>不再使用 Segment，而是直接使用 Node 数组</li>
<li>锁粒度细化到单个桶（bucket）级别</li>
<li>使用 synchronized 锁定单个桶</li>
</ul>
</li>
<li><strong>CAS 操作</strong>：
<ul>
<li>对无竞争的情况使用 CAS 操作（如计数、空桶插入）</li>
<li>只有在哈希冲突时才使用 synchronized</li>
</ul>
</li>
</ol>
<br>
<p>头插入 &amp; 尾插入</p>
<p><strong>头插法改为尾插法的主要目的是解决多线程扩容时的死循环问题</strong></p>
<p>在 Java 7 及更早版本中，HashMap 在解决哈希冲突时采用的是链地址法，即把哈希值相同的键值对以链表的形式存储起来。当有新的元素需要插入时，它会被放置在链表的头部。这种方式在单线程环境下通常效率更高，因为新插入的元素被访问的可能性被认为更大。然而，在多线程环境下，当多个线程同时对 HashMap 进行 put 操作并触发扩容时，头插法就会暴露其致命缺陷。</p>
<p>HashMap 的扩容是一个重新计算元素位置并将其放入新哈-希表的过程。问题的关键在于，扩容时会涉及到链表的反转。在并发场景下，多个线程同时对同一个链表进行反转操作，就可能导致链表中的节点指向关系发生错乱，形成一个闭环，即循环链表。</p>
<p><strong>举例详解循环链表的产生过程：</strong></p>
<p>假设有两个线程（线程 A 和线程 B）同时对一个 HashMap 进行 put 操作，并且这两个操作都触发了扩容。我们关注其中一个桶（bucket）的扩容过程，该桶中已经存在两个元素，例如 [A, B]（A 在前，B 在后）。</p>
<ol>
<li><strong>初始状态：</strong> 线程 A 和线程 B 都准备开始对这个桶中的链表进行转移。</li>
<li><strong>线程 A 执行一部分后挂起：</strong> 假设线程 A 执行了一部分扩容逻辑，它将 A 节点转移到了新的哈希表中，并准备处理 B 节点。此时，在线程 A 的视角里，新的链表可能是 [A]，它接下来要处理的节点是 B。然后，线程 A 的时间片用完被挂起。</li>
<li><strong>线程 B 完成扩容：</strong> 线程 B 此时获得 CPU 时间片，它完整地执行了整个扩容过程。由于头插法的特性，它会将原来的 [A, B] 链表反转为 [B, A] 并放入新的哈希表中。此时，在全局视角下，链表的实际指向关系是 B -&gt; A，且 A.next 为 null。</li>
<li><strong>线程 A 继续执行：</strong> 线程 A 重新被唤醒，它并不知道 HashMap 的内部结构已经被线程 B 修改了。它从自己挂起时的状态继续执行，即处理 B 节点。根据头插法的逻辑，它会将 B 节点插入到新链表的头部。接下来，它处理 A 节点，并再次使用头插法，将 A 节点也插入到头部。</li>
<li><strong>循环产生：</strong> 在线程 A 的操作中，它会将 A 的 next 指针指向 B。但由于此前线程 B 的操作已经将 B 的 next 指针指向了 A，这就形成了一个致命的循环：A.next -&gt; B 且 B.next -&gt; A。</li>
</ol>
<p>一旦形成循环链表，后续对该 HashMap 的 get 操作如果落到了这个桶上，就会陷入无限循环，导致 CPU 占用率飙升。</p>
<br>
<h2 id="Java-垃圾回收">Java 垃圾回收</h2>
<p>类型：</p>
<ul>
<li>引用计数法</li>
<li>可达性分析</li>
</ul>
<p>算法：</p>
<ul>
<li>标记-整理</li>
<li>标记-清除</li>
<li>复制</li>
<li>三色标记</li>
</ul>
<br>
<p>实现</p>
<p>| <strong>ParNew</strong> | 新生代 | 复制 | <strong>多线程</strong>版的 Serial，与 CMS 配合工作<br>
| <strong>CMS</strong>                | 老年代   | <strong>标记-清除</strong> | <strong>并发低停顿</strong>，<strong>追求最短回收停顿时间</strong><br>
| <strong>G1 (Garbage-First)</strong> | <strong>全区</strong> | <strong>标记-整理</strong> | <strong>分区</strong>算法，<strong>可预测的停顿时间</strong>，兼顾吞吐和低延迟</p>
<br>
<h2 id="Mysql-索引">Mysql 索引</h2>
<p><strong>索引构造原则</strong></p>
<ol>
<li>最左前缀原则</li>
<li>高选择性列</li>
<li>查询导向</li>
</ol>
<br>
<p>对于场景 <code>select a,b from table where c = c' order by d</code></p>
<p><strong>推荐创建复合索引：<code>(c, d)</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table ADD INDEX idx_c_d (c, d);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>WHERE条件优先</strong>：将WHERE子句中的条件列<code>c</code>放在索引的第一位，可以快速定位到<code>c = c'</code>的所有记录</p>
</li>
<li>
<p><strong>排序优化</strong>：索引的第二列包含ORDER BY的列<code>d</code>，这样数据库可以：</p>
<ul>
<li>直接使用索引的有序性来避免排序操作（避免<code>filesort</code>）</li>
<li>实现&quot;索引排序&quot;，直接从索引中按<code>d</code>的顺序读取数据</li>
</ul>
</li>
</ul>
<br>
<p><strong>覆盖索引</strong>是指一个索引包含了查询所需的所有字段，使得查询可以直接从索引中获取数据，而<strong>无需回表</strong>（不需要再去访问数据行）。</p>
<br>
<h2 id="Mysql-查询">Mysql 查询</h2>
<p>慢查询分析</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">优化目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>type</strong></td>
<td style="text-align:left">访问类型</td>
<td style="text-align:left">最好达到 <code>const</code>/<code>eq_ref</code>&gt; <code>ref</code>&gt; <code>range</code>&gt; <code>index</code>&gt; <code>ALL</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>possible_keys</strong></td>
<td style="text-align:left">可能使用的索引</td>
<td style="text-align:left">列出可供选择的索引</td>
</tr>
<tr>
<td style="text-align:left"><strong>key</strong></td>
<td style="text-align:left">实际使用的索引</td>
<td style="text-align:left">确保使用了合适的索引</td>
</tr>
<tr>
<td style="text-align:left"><strong>rows</strong></td>
<td style="text-align:left">预估扫描行数</td>
<td style="text-align:left">值越小越好</td>
</tr>
<tr>
<td style="text-align:left"><strong>Extra</strong></td>
<td style="text-align:left">额外信息</td>
<td style="text-align:left">避免出现 <code>Using filesort</code>、<code>Using temporary</code></td>
</tr>
</tbody>
</table>
<p><code>type</code> <strong>字段的常见值（性能从优到劣）：</strong></p>
<ul>
<li><code>const</code>：通过主键或唯一索引一次就找到。</li>
<li><code>eq_ref</code>：在连接查询（JOIN）中，后一张表是通过主键或唯一索引进行关联的；对于前一张表的每一行，后一张表只有唯一的一行与之匹配（使用 JOIN 时，驱动表直接返回结果；对于驱动表返回的每一行，被驱动表均只有一行与之对应（仅查询一次））。</li>
<li><code>ref</code>：查询条件使用了普通索引，而不是唯一索引或主键。这意味着查询可能会返回多行匹配的数据。</li>
<li><code>range</code>：使用索引进行范围查询。</li>
<li><code>index</code>：全索引扫描。</li>
<li><code>ALL</code>：全表扫描（<strong>需要避免</strong>）。</li>
</ul>
<p><code>Extra</code> <strong>字段的危险信号：</strong></p>
<ul>
<li><code>Using filesort</code>：需要额外的排序操作（考虑为 <code>ORDER BY</code> 字段加索引）。</li>
<li><code>Using temporary</code>：需要创建临时表（常见于 <code>GROUP BY</code>、<code>ORDER BY</code> 子句）。</li>
<li><code>Using join buffer</code>：在连接查询中，如果被驱动表（后连接的表）的连接字段上没有索引，MySQL会使用连接缓冲区来批量处理连接。这表示连接操作无法有效利用索引。</li>
</ul>
<br>
<p><strong>常见优化手段与实战举例</strong></p>
<p><strong>索引优化（最有效的手段）</strong></p>
<p>(1) 避免索引失效</p>
<p><strong>失效场景举例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构: CREATE TABLE users (id INT, name VARCHAR(10), age INT, INDEX idx_name_age (name, age));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 最左前缀原则：复合索引必须先使用左边的列</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>; <span class="comment">-- ❌ 无法使用 idx_name_age 索引</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">-- ✅ 可以使用索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 对索引列进行计算或函数操作</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(create_time) <span class="operator">=</span> <span class="number">2023</span>; <span class="comment">-- ❌ 索引失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> create_time <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span>; <span class="comment">-- ✅</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 使用 LIKE 以通配符开头</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%lice%&#x27;</span>; <span class="comment">-- ❌ 全表扫描</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;Alice%&#x27;</span>; <span class="comment">-- ✅ 索引范围扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 字符串索引未使用引号（发生类型转换）</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="number">123</span>; <span class="comment">-- ❌ 类型转换，索引失效</span></span><br></pre></td></tr></table></figure>
<p>(2) 建立合适的索引</p>
<ul>
<li><strong>为</strong> <code>WHERE</code><strong>、</strong><code>ORDER BY</code><strong>、</strong><code>GROUP BY</code><strong>、</strong><code>JOIN ON</code> <strong>子句中的字段建立索引</strong>。</li>
<li><strong>使用覆盖索引</strong>：索引包含所有查询字段，避免回表。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设有索引 idx_name_age (name, age)</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">-- ✅ 覆盖索引，性能极佳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">-- ❌ 需要回表查询其他字段</span></span><br></pre></td></tr></table></figure>
<p><strong>SQL语句优化</strong></p>
<p>(1) 避免 <code>SELECT *</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ❌ 不推荐</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 推荐：只取需要的字段</span></span><br><span class="line"><span class="keyword">SELECT</span> order_id, amount, status <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>(2) 优化分页查询（大偏移量问题）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ❌ 糟糕的分页（偏移量越大越慢）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 优化方案1：使用子查询或游标（记录上次查询的最大ID）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 优化方案2：使用覆盖索引先定位ID，再回表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">20</span>) <span class="keyword">AS</span> tmp </span><br><span class="line"><span class="keyword">ON</span> products.id <span class="operator">=</span> tmp.id;</span><br></pre></td></tr></table></figure>
<p>(3) 优化 <code>OR</code> 条件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ❌ OR 条件可能导致索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 优化为 UNION ALL（确保两个查询都能用索引）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><strong>表结构设计优化</strong></p>
<p>(1) 选择合适的数据类型</p>
<ul>
<li>用 <code>INT</code> 而非 <code>VARCHAR</code> 存储数字。</li>
<li>用 <code>DATETIME</code> 而非 <code>VARCHAR</code> 存储时间。</li>
<li>避免使用 <code>TEXT</code>/<code>BLOB</code> 作为常用查询条件。</li>
</ul>
<p>(2) 范式与反范式的权衡</p>
<ul>
<li><strong>范式化</strong>：减少数据冗余，但需要多表关联。</li>
<li><strong>反范式化</strong>：适当冗余数据，避免复杂关联，以空间换时间。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 反范式化举例：在订单表冗余用户姓名</span></span><br><span class="line"><span class="comment">-- orders 表结构: order_id, user_id, user_name, amount...</span></span><br><span class="line"><span class="keyword">SELECT</span> order_id, user_name, amount <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span>; <span class="comment">-- 无需关联用户表</span></span><br></pre></td></tr></table></figure>
<p><strong>数据库架构优化</strong></p>
<p>(1) 读写分离</p>
<ul>
<li>主库负责写操作，多个从库负责读操作。</li>
<li>通过程序或中间件（如MyCat、ShardingSphere）实现流量分发。</li>
</ul>
<p>(2) 分库分表</p>
<ul>
<li><strong>水平分表</strong>：按某个字段（如用户ID）将数据分散到多个表。</li>
<li><strong>垂直分表</strong>：将不常用的大字段拆分到扩展表。</li>
</ul>
<br>
<h2 id="Mysql-单表量级">Mysql 单表量级</h2>
<p>MySQL InnoDB 引擎使用 <strong>B+树</strong> 结构来存储索引和数据（对于聚簇索引，叶子节点直接包含行数据）。</p>
<p><strong>B+树的基础概念</strong></p>
<ul>
<li><strong>扇出（Fan-out）</strong>：一个节点能拥有的子节点数量。</li>
<li><strong>深度（Depth）</strong>：从根节点到叶子节点需要经过的层级数。</li>
</ul>
<p>B+树的查询效率取决于它的深度。每深入一层，就需要多一次磁盘I/O（如果该层节点不在内存中）。</p>
<p><strong>千万级数据如何影响B+树深度？</strong></p>
<p>我们来做一个简单的计算：</p>
<ul>
<li>
<p><strong>假设条件</strong>：</p>
</li>
<li>
<ul>
<li>页大小（Page Size）：16KB（MySQL默认）。</li>
<li>主键字段类型：<code>BIGINT</code>（8字节）。</li>
<li>每个索引条目（指针）额外占用约 6 字节。</li>
<li>因此，<strong>一个非叶子节点大约可以存储</strong> <code>16KB / (8B + 6B) ≈ 1170</code> <strong>个键值和指针</strong>。</li>
<li><strong>一个叶子节点</strong>：假设一行数据大小为 <strong>1KB</strong>，那么一个叶子节点大约可以存储 <code>16KB / 1KB = 16</code> 行数据。</li>
</ul>
</li>
<li>
<p><strong>计算不同深度B+树能存储的最大行数</strong>：</p>
</li>
<li>
<ul>
<li><strong>深度 = 2</strong>： <code>1170（根节点指针） * 16（每个叶子节点的行数） ≈ 18,720</code> 行。</li>
<li><strong>深度 = 3</strong>： <code>1170 * 1170 * 16 ≈ 21,902,400</code> 行（约 <strong>2200万</strong>）。</li>
<li><strong>深度 = 4</strong>： <code>1170 * 1170 * 1170 * 16 ≈ 25,621,000,000</code> 行（约 <strong>256亿</strong>）。</li>
</ul>
</li>
<li>
<p><strong>结论</strong>：</p>
</li>
<li>
<ul>
<li>当数据量在 <strong>千万级以下</strong> 时，B+树深度通常为 **2~**<strong>3层</strong>。这意味着通过主键查询最多只需要 **2~**<strong>3次磁盘I/O</strong>，速度极快。</li>
<li>当数据量增长到 <strong>千万级以上</strong>（如超过2200万），B+树深度很可能从 <strong>3层变为4层</strong>。</li>
</ul>
</li>
<li>
<ol start="3">
<li>深度增加的后果</li>
</ol>
</li>
<li>
<p><strong>每次查询需要多一次磁盘I/O</strong>。对于主键查询，从 <strong>3次I/O</strong> 变为 <strong>4次I/O</strong>，性能损耗可能达到 <strong>30%</strong>。</p>
</li>
<li>
<p>更重要的是，对于<strong>范围查询</strong>、<strong>全表扫描</strong>（即使只是统计行数<code>COUNT(*)</code>）和<strong>复杂的联合查询</strong>，需要遍历的叶子节点数量从“千万级”变成了“亿级”，性能下降是指数级的，从毫秒级可能直接恶化到秒级甚至分钟级。</p>
</li>
</ul>
<br>
<h2 id="Mysql-事务隔离级别">Mysql 事务隔离级别</h2>
<p>MySQL支持四种标准的事务隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>READ UNCOMMITTED</strong> (读未提交)</td>
<td>✅ 可能</td>
<td>✅ 可能</td>
<td>✅ 可能</td>
<td>性能最高，一致性最差</td>
</tr>
<tr>
<td><strong>READ COMMITTED</strong> (读已提交)</td>
<td>❌ 不可能</td>
<td>✅ 可能</td>
<td>✅ 可能</td>
<td>Oracle默认级别</td>
</tr>
<tr>
<td><strong>REPEATABLE READ</strong> (可重复读)</td>
<td>❌ 不可能</td>
<td>❌ 不可能</td>
<td>✅ 可能</td>
<td>MySQL默认级别</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong> (串行化)</td>
<td>❌ 不可能</td>
<td>❌ 不可能</td>
<td>❌ 不可能</td>
<td>性能最低，一致性最强</td>
</tr>
</tbody>
</table>
<p><strong>什么是幻读？</strong></p>
<p><strong>幻读</strong>是指在一个事务内，连续执行两次相同的查询，第二次查询看到了第一次查询没有看到的行，这些&quot;幻影行&quot;通常是由其他事务插入的新数据。</p>
<p>与不可重复读的区别：</p>
<ul>
<li>不可重复读：针对<strong>已存在行</strong>的修改（UPDATE/DELETE）</li>
<li>幻读：针对<strong>新增行</strong>的插入（INSERT）</li>
</ul>
<p>三、幻读的典型场景</p>
<p><strong>场景示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 会话A</span><br><span class="line">START TRANSACTION;</span><br><span class="line">SELECT * FROM users WHERE age &gt; 20; </span><br><span class="line">-- 返回3条记录</span><br><span class="line"></span><br><span class="line">-- 会话B</span><br><span class="line">INSERT INTO users(name, age) VALUES(&#x27;新用户&#x27;, 25);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 会话A再次执行相同查询</span><br><span class="line">SELECT * FROM users WHERE age &gt; 20;</span><br><span class="line">-- 返回4条记录，出现了&quot;幻影行&quot;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p><strong>MySQL如何解决幻读？</strong></p>
<p>REPEATABLE READ级别下的幻读问题</p>
<p><strong>MySQL的InnoDB引擎在REPEATABLE READ级别下实际上通过MVCC+Next-Key Lock解决了大部分幻读问题</strong>，这与SQL标准有所不同。</p>
<p><strong>解决机制：</strong></p>
<ul>
<li><strong>MVCC (多版本并发控制)</strong>：通过创建数据快照保证读取一致性</li>
<li><strong>Next-Key Lock</strong>：结合记录锁(Record Lock)和间隙锁(Gap Lock)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 对全表加锁，因为name字段无索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(name) <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="comment">-- 被阻塞，因为会话A持有全表锁</span></span><br></pre></td></tr></table></figure>
<br>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- age字段有索引</span></span><br><span class="line"><span class="comment">-- 会话A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 锁定age=25的记录及(20,25),(25,30)的间隙</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(age) <span class="keyword">VALUES</span>(<span class="number">22</span>); <span class="comment">-- 被阻塞(如果22在锁定间隙内)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(age) <span class="keyword">VALUES</span>(<span class="number">30</span>);  <span class="comment">-- 成功(不在锁定间隙内)</span></span><br></pre></td></tr></table></figure>
<br>
<h2 id="Mysql-锁">Mysql 锁</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM FOR UPDATE</span><br><span class="line">UPDATE </span><br><span class="line">DELETE</span><br></pre></td></tr></table></figure>
<p>MySQL UPDATE 和 DELETE 操作的加锁示例</p>
<p>基本环境准备</p>
<p>首先创建一个测试表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT,</span><br><span class="line">    department VARCHAR(50),</span><br><span class="line">    salary DECIMAL(10,2),</span><br><span class="line">    INDEX idx_department (department),</span><br><span class="line">    INDEX idx_age (age)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO employees VALUES</span><br><span class="line">(1, &#x27;张三&#x27;, 30, &#x27;技术部&#x27;, 8000),</span><br><span class="line">(2, &#x27;李四&#x27;, 35, &#x27;销售部&#x27;, 9000),</span><br><span class="line">(3, &#x27;王五&#x27;, 28, &#x27;技术部&#x27;, 7500),</span><br><span class="line">(4, &#x27;赵六&#x27;, 40, &#x27;人事部&#x27;, 8500),</span><br><span class="line">(5, &#x27;钱七&#x27;, 32, &#x27;销售部&#x27;, 9500);</span><br></pre></td></tr></table></figure>
<p>示例1：使用主键的UPDATE（行级锁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE employees SET salary = salary + 500 WHERE id = 3;</span><br><span class="line">-- 只锁定id=3这一行</span><br><span class="line"></span><br><span class="line">-- 会话2（同时执行）</span><br><span class="line">UPDATE employees SET salary = salary + 500 WHERE id = 4;</span><br><span class="line">-- 可以正常执行，因为锁定的是不同行</span><br></pre></td></tr></table></figure>
<p>示例2：使用普通索引的UPDATE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE employees SET salary = salary + 500 WHERE department = &#x27;技术部&#x27;;</span><br><span class="line">-- 锁定department索引中&#x27;技术部&#x27;对应的行(id=1和id=3)</span><br><span class="line"></span><br><span class="line">-- 会话2（同时执行）</span><br><span class="line">UPDATE employees SET salary = salary + 500 WHERE id = 2;</span><br><span class="line">-- 可以正常执行，因为不涉及被锁定的行</span><br><span class="line"></span><br><span class="line">-- 会话3（同时执行）</span><br><span class="line">UPDATE employees SET salary = salary + 500 WHERE department = &#x27;销售部&#x27;;</span><br><span class="line">-- 也可以执行，因为锁定的是不同的索引范围</span><br></pre></td></tr></table></figure>
<p>示例3：无索引条件的UPDATE（接近全表锁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE employees SET salary = salary + 500 WHERE age &gt; 30;</span><br><span class="line">-- 因为没有使用age索引(即使有索引，可能优化器选择全表扫描)</span><br><span class="line">-- 会锁定所有age&gt;30的行(实际会锁定扫描到的所有行)</span><br><span class="line"></span><br><span class="line">-- 会话2（同时执行）</span><br><span class="line">UPDATE employees SET salary = salary + 500 WHERE id = 1;</span><br><span class="line">-- 可能被阻塞，因为会话1可能已经扫描并锁定了id=1的行</span><br></pre></td></tr></table></figure>
<p>示例4：DELETE操作与UPDATE类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">BEGIN;</span><br><span class="line">DELETE FROM employees WHERE department = &#x27;销售部&#x27;;</span><br><span class="line">-- 锁定department索引中&#x27;销售部&#x27;对应的行(id=2和id=5)</span><br><span class="line"></span><br><span class="line">-- 会话2（同时执行）</span><br><span class="line">UPDATE employees SET salary = salary + 500 WHERE id = 3;</span><br><span class="line">-- 可以正常执行</span><br><span class="line"></span><br><span class="line">-- 会话3（同时执行）</span><br><span class="line">DELETE FROM employees WHERE id = 2;</span><br><span class="line">-- 会被阻塞，因为id=2的行已被锁定</span><br></pre></td></tr></table></figure>
<p>示例5：无WHERE条件的UPDATE/DELETE（全表锁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE employees SET salary = salary + 500;</span><br><span class="line">-- 锁定全表所有行</span><br><span class="line"></span><br><span class="line">-- 会话2（同时执行任何修改操作）</span><br><span class="line">UPDATE employees SET name = &#x27;测试&#x27; WHERE id = 1;</span><br><span class="line">-- 会被阻塞，直到会话1提交</span><br></pre></td></tr></table></figure>
<p>示例6：大事务导致的锁升级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE employees SET salary = salary + 500 WHERE age &gt; 20;</span><br><span class="line">-- 如果影响的行数超过阈值(由innodb_lock_wait_timeout等参数决定)</span><br><span class="line">-- 可能从行锁升级为表锁</span><br><span class="line"></span><br><span class="line">-- 会话2（同时执行）</span><br><span class="line">INSERT INTO employees VALUES (6, &#x27;孙八&#x27;, 29, &#x27;市场部&#x27;, 7000);</span><br><span class="line">-- 可能被阻塞，因为表可能被锁定</span><br></pre></td></tr></table></figure>
<p>关键结论</p>
<ol>
<li><strong>最佳情况</strong>：使用主键或唯一索引，只锁定目标行</li>
<li><strong>次优情况</strong>：使用普通索引，锁定索引范围内的行</li>
<li><strong>最差情况</strong>：无索引条件或无WHERE条件，可能锁定全表或大部分表</li>
<li><strong>锁升级</strong>：大事务可能导致行锁升级为表锁</li>
</ol>
<p>实际锁行为还受事务隔离级别、索引选择、MySQL版本等因素影响。</p>
<br>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/default/" rel="tag"># default</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/07/27/MQ-in-evolutionary/" rel="prev" title="MQ_in_evolutionary">
      <i class="fa fa-chevron-left"></i> MQ_in_evolutionary
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">Selected Q&amp;A</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="nav-text">Java 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%8F%8D%E5%B0%84"><span class="nav-text">Java 反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%BB%A3%E7%90%86"><span class="nav-text">Java 代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E7%BC%96%E8%AF%91"><span class="nav-text">Java 编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E9%94%81"><span class="nav-text">Java 锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%AE%B9%E5%99%A8"><span class="nav-text">Java 容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">Java 垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-%E7%B4%A2%E5%BC%95"><span class="nav-text">Mysql 索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-%E6%9F%A5%E8%AF%A2"><span class="nav-text">Mysql 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-%E5%8D%95%E8%A1%A8%E9%87%8F%E7%BA%A7"><span class="nav-text">Mysql 单表量级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">Mysql 事务隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-%E9%94%81"><span class="nav-text">Mysql 锁</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="marigo1d"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">marigo1d</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/marigo1d" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;marigo1d" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">marigo1d</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">553k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">16:46</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
