<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marigo1d.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="面试问题精选">
<meta property="og:type" content="article">
<meta property="og:title" content="Selected Q&amp;A">
<meta property="og:url" content="https://marigo1d.github.io/2025/09/10/Selected-Q-A/index.html">
<meta property="og:site_name" content="Marigold">
<meta property="og:description" content="面试问题精选">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-09-10T02:12:25.000Z">
<meta property="article:modified_time" content="2025-09-10T03:27:02.759Z">
<meta property="article:author" content="marigo1d">
<meta property="article:tag" content="default">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://marigo1d.github.io/2025/09/10/Selected-Q-A/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Selected Q&A | Marigold</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Marigold</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Salt, Pepper and Birds~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://marigo1d.github.io/2025/09/10/Selected-Q-A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="marigo1d">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marigold">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Selected Q&A
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-09-10 10:12:25 / Modified: 11:27:02" itemprop="dateCreated datePublished" datetime="2025-09-10T10:12:25+08:00">2025-09-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/default/" itemprop="url" rel="index"><span itemprop="name">default</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>23 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>面试问题精选</p>
<span id="more"></span>
<h1>Selected Q&amp;A</h1>
<h2 id="Java-基础">Java 基础</h2>
<p><code>hashCode()</code> &amp; <code>equals()</code></p>
<p><strong><code>equals()</code> 方法详解</strong></p>
<p><code>equals()</code> 方法用于比较两个对象是否“相等”。</p>
<p><strong><code>Object</code> 类中的默认实现:</strong><br>
在 <code>Object</code> 类中，<code>equals()</code> 方法的默认实现是比较两个对象的内存地址，等同于 <code>==</code> 运算符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object 类的默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着，除非一个类重写（Override）了 <code>equals()</code> 方法，否则只有当两个引用指向同一个内存地址的对象时，<code>equals()</code> 才会返回 <code>true</code>。</p>
<p>对于 <code>==</code> 符号：</p>
<p><strong>对于基本数据类型（如 int, char, boolean 等）</strong></p>
<p><code>==</code>直接比较它们的<strong>值</strong>是否相等。</p>
<p><strong>对于对象（引用类型）</strong></p>
<p><code>==</code>比较的是两个对象的<strong>内存地址</strong>（即是否为同一个对象），而不是对象的内容。如果要比较对象的内容是否相等，需要使用 <code>equals()</code>方法。</p>
<br>
<p><strong><code>hashCode()</code> 方法详解</strong></p>
<p><code>hashCode()</code> 方法返回一个对象的哈希码（一个 <code>int</code> 类型的整数）。</p>
<p>当一个类没有重写 hashCode() 方法时，它会继承自 java.lang.Object 类的默认实现。Object 类中的 hashCode() 方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这里的 native 关键字是关键。它意味着该方法的实现并非由 Java 代码编写，而是由 Java 虚拟机 (JVM) 使用本地语言（通常是 C++）实现的。这也直接导致了 hashCode() 的默认行为是<strong>依赖于具体的 JVM 实现</strong>的，并没有一个全平台统一的算法。</p>
<p><strong>现代 JVM (以 OpenJDK/HotSpot 为例) 的实现策略</strong></p>
<p>为了解决内存地址变化的问题，并提供高效的哈希码生成，现代 JVM 采用了更为复杂的策略。虽然具体实现可能随版本变化，但通常有以下几种生成方式，首次调用对象的 hashCode() 时，JVM 会选择一种策略生成一个值，然后<strong>将这个值缓存（存储）在对象头（Object Header）的特定区域（称为 “Mark Word”）中</strong>。这样，后续对该对象 hashCode() 的调用就可以直接返回这个缓存的值，从而保证了其在对象生命周期内的一致性。</p>
<p>hashCode 的生成策略可能包括：</p>
<ol>
<li><strong>随机数生成：</strong> 在某些版本的 OpenJDK 中（例如 6 和 7），默认的哈希码是基于一个随机数生成器产生的。</li>
<li><strong>与线程状态相关的数：</strong> 在 OpenJDK 8 及之后的一些版本中，生成的哈希码可能与当前线程的状态有关。这是一种利用线程本地信息来生成不同哈希码的方式。</li>
<li><strong>内存地址（作为一次性输入）：</strong> 某些 JVM 实现可能在首次计算哈希码时使用对象的内存地址作为输入，但计算出结果后会将其缓存，即使对象地址后续发生变化，哈希码也不会变。</li>
<li><strong>固定值：</strong> 在极少数情况下或特定优化场景下，可能会返回一个固定的值。</li>
</ol>
<p><strong><code>hashCode()</code> 的作用:</strong><br>
当向一个哈希集合中添加一个对象时，集合会首先调用该对象的 <code>hashCode()</code> 方法来计算其哈希码。这个哈希码决定了对象在哈希表中的存储位置（即“桶”的位置）。</p>
<ul>
<li>如果多个对象的哈希码不同，它们会被存放在不同的桶中，查找时可以快速定位。</li>
<li>如果多个对象的哈希码相同（这种情况称为“哈希冲突”），它们会被存放在同一个桶中，通常以链表或红黑树的形式组织。 这时，集合会进一步调用 <code>equals()</code> 方法来精确地判断这两个对象是否真的相等。</li>
</ul>
<br>
<p><strong><code>equals()</code> 与 <code>hashCode()</code> 之间的契约</strong></p>
<p>这两个方法之间存在一个非常重要的契约，在重写它们时必须严格遵守：</p>
<ol>
<li><strong>如果两个对象通过 <code>equals()</code> 方法比较是相等的，那么它们的 <code>hashCode()</code> 方法必须返回相同的整数值。</strong></li>
<li><strong>如果两个对象通过 <code>equals()</code> 方法比较是不相等的，那么它们的 <code>hashCode()</code> 方法不被要求必须返回不同的整数值。但是，为了提高哈希表的性能，我们应该尽量让不相等的对象产生不同的哈希码。</strong></li>
</ol>
<p><strong>为什么必须遵守这个契约？</strong></p>
<p>这个契约是保证哈希集合（如 <code>HashMap</code>, <code>HashSet</code>）能够正常工作的关键。</p>
<p>设想一下，如果你违反了第一条规则：重写了 <code>equals()</code> 但没有重写 <code>hashCode()</code>。</p>
<ul>
<li>你创建了两个 <code>Person</code> 对象，<code>p1</code> 和 <code>p2</code>，它们的内容完全相同（例如，<code>id</code> 都是 “123”）。</li>
<li>根据你重写的 <code>equals()</code> 方法，<code>p1.equals(p2)</code> 会返回 <code>true</code>。</li>
<li>但是，因为你没有重写 <code>hashCode()</code>，它们会使用 <code>Object</code> 类的默认实现，该实现为每个不同的对象实例返回不同的哈希码。所以 <code>p1.hashCode()</code> 很可能不等于 <code>p2.hashCode()</code>。</li>
<li>现在，当你试图将 <code>p1</code> 和 <code>p2</code> 放入一个 <code>HashSet</code> 时，问题就出现了。<code>HashSet</code> 会认为它们是两个完全不同的对象，因为它们的哈希码不同，导致它们被存放在不同的位置。这违反了 <code>Set</code> 集合元素唯一的原则。</li>
</ul>
<br>
<h2 id="Java-反射">Java 反射</h2>
<p><strong>反射使用</strong></p>
<p>可以在运行时动态加载和操作类，实现高度可配置和可扩展的程序。许多框架（如 Spring, Hibernate, JUnit, MyBatis）的核心都基于反射。</p>
<ul>
<li>
<p><strong>Spring IOC</strong>：通过反射读取配置文件或注解，动态创建和管理 Bean。</p>
</li>
<li>
<p><strong>Hibernate/MyBatis</strong>：通过反射将数据库结果集映射到 Java 对象。</p>
</li>
<li>
<p><strong>JUnit</strong>：通过反射查找带有 <code>@Test</code> 注解的方法并执行它们。</p>
</li>
</ul>
<br>
<p><strong>反射性能差</strong></p>
<p><strong>运行时解析：失去编译时优化</strong></p>
<p>这是最根本的原因。</p>
<ul>
<li><strong>普通方法调用/字段访问（编译时绑定）：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.publicMethod(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 编译器明确知道要调用哪个方法，直接写入字节码</span></span><br><span class="line">p.name = <span class="string">&quot;Alice&quot;</span>;        <span class="comment">// 编译器明确知道要访问哪个字段，内存偏移量是固定的</span></span><br></pre></td></tr></table></figure>
<p>在编译期间（Compile-time），Java 编译器（javac）和 Just-In-Time (JIT) 编译器会进行大量优化：</p>
<ul>
<li><strong>内联（Inlining）</strong>：将短方法的方法体直接嵌入到调用处，避免方法调用的开销。</li>
<li><strong>方法链接</strong>：直接链接到目标方法的内存地址。</li>
<li><strong>字段偏移量计算</strong>：直接计算字段在对象内存中的固定偏移量。</li>
</ul>
<p><strong>反射调用/字段访问（运行时绑定）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method method = personClass.getMethod(&quot;publicMethod&quot;, String.class);</span><br><span class="line">method.invoke(p, &quot;Hello&quot;); // JVM 在运行时才知道要调用哪个方法</span><br><span class="line"></span><br><span class="line">Field field = personClass.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.set(p, &quot;Alice&quot;);     // JVM 在运行时才知道要访问哪个字段</span><br></pre></td></tr></table></figure>
<p>所有这些信息（方法名、参数类型、字段名等）都是在<strong>运行时（Run-time）</strong> 才被解析和确定的。JVM 无法在编译期进行上述的任何优化，必须执行一系列昂贵的查找和验证步骤。</p>
<p><strong>繁琐的检查与验证过程</strong></p>
<p>每次使用 <code>Method.invoke()</code> 或 <code>Field.set()</code> 时，JVM 都需要执行以下操作：</p>
<ul>
<li><strong>权限检查</strong>：检查当前调用上下文是否有权访问该方法或字段（尤其是对于 <code>private</code> 成员，需要调用 <code>setAccessible(true)</code>，但这个调用本身也有开销）。</li>
<li><strong>参数验证</strong>：检查传入的参数数量、类型是否与目标方法或字段匹配。</li>
<li><strong>类型转换</strong>：必要时需要进行参数的装箱（Boxing）和拆箱（Unboxing），因为 <code>invoke</code> 和 <code>set</code> 只接受 <code>Object</code>。这会产生额外的对象创建开销。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 反射需要装箱：基本类型 int 被包装成 Integer Object</span><br><span class="line">Method ageSetMethod = ... // 获取setAge(int age)方法</span><br><span class="line">ageSetMethod.invoke(p, 30); // 这里的 30 会被自动装箱成 Integer(30)</span><br></pre></td></tr></table></figure>
<p><strong>阻碍现代 JIT 编译器的深度优化</strong></p>
<p>现代高性能的 JVM（如 HotSpot）严重依赖 JIT 编译器。JIT 会监控代码的运行（“热点代码”），并将其编译成本地机器码，进行激进优化。</p>
<p>反射调用是<strong>动态的</strong>和<strong>不可预测的</strong>，这使得 JIT 编译器很难：</p>
<ul>
<li><strong>内联方法</strong>：因为无法在编译时确定实际要调用的方法。</li>
<li><strong>进行逃逸分析</strong>：难以确定反射创建的对象或传入的参数的生命周期。</li>
<li><strong>优化循环</strong>：如果循环体内包含反射调用，整个循环都可能无法被有效优化。</li>
</ul>
<p>反射调用就像告诉 JVM：“嘿，我现在要调用一个方法，但我不会告诉你具体是哪个，你自己在运行时去找吧。” 这迫使 JVM 使用一种更通用、更慢的路径来执行操作。</p>
<p><strong>性能差距的量级</strong></p>
<p>在<strong>早期</strong>的 JVM 版本中，反射调用的速度可能比直接调用<strong>慢几十甚至上百倍</strong>。</p>
<p>随着 JVM 的不断进化（尤其是现代 JDK 8+），这个差距已经<strong>显著缩小</strong>。JVM 为反射调用引入了一些优化，例如：</p>
<ul>
<li><strong>膨胀（Inflation）机制</strong>：最初的几次反射调用使用纯 Java 代码（慢）。当某个反射调用成为“热点”后，JVM 会为其生成一个专用的本地机器码（Native Method Accessor），后续的调用就会快很多。</li>
<li><strong>缓存</strong>：<code>Method</code>, <code>Field</code>, <code>Constructor</code> 对象是可缓存的。一旦获取，就不需要再次进行昂贵的类查找。</li>
</ul>
<p><strong>但是，即使有这些优化，反射调用仍然比直接调用慢数倍。</strong> 在需要极致性能的场景（例如，在循环中调用数百万次），这种开销依然是不可忽视的。</p>
<hr>
<p><strong>如何缓解反射的性能问题？</strong></p>
<ol>
<li><strong>避免在性能关键循环中使用反射</strong>：这是黄金法则。如果一段代码需要每秒执行百万次，请想尽办法避免在其中使用反射。</li>
<li><strong>缓存反射对象</strong>：<code>Class</code>, <code>Method</code>, <code>Field</code>, <code>Constructor</code> 等对象是 immutable（不可变）的，获取它们的开销很大。<strong>一定要将它们缓存起来重复使用</strong>，而不是在每次调用时都重新查找。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 错误示范：每次调用都查找方法，极其低效</span><br><span class="line">for (int i = 0; i &lt; 1_000_000; i++) &#123;</span><br><span class="line">    Method m = clz.getMethod(&quot;methodName&quot;);</span><br><span class="line">    m.invoke(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确示范：缓存方法对象</span><br><span class="line">Method m = clz.getMethod(&quot;methodName&quot;); // 在循环外查找并缓存</span><br><span class="line">for (int i = 0; i &lt; 1_000_000; i++) &#123;</span><br><span class="line">    m.invoke(target); // 只调用 invoke</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>使用</strong> <code>setAccessible(true)</code> <strong>并缓存其效果</strong>：访问私有成员时，调用 <code>setAccessible(true)</code> 会绕过运行时访问检查，这会带来一定的性能提升。这个效果是持久的，只需要设置一次即可。</li>
<li><strong>考虑使用方法句柄（MethodHandle, JDK7+）</strong>：<code>java.lang.invoke.MethodHandle</code> 提供了另一种更现代、更轻量级的反射机制。在某些情况下，它可能比传统反射性能更好，并且更适合 JIT 优化。</li>
<li><strong>终极方案：字节码操作库（如 ASM, CGLib, Byte Buddy）或代码生成</strong>：对于极端性能要求的场景，可以在程序启动时或编译时，通过这些库动态生成所需的直接调用代码类，从而完全避免运行时的反射开销。Spring 等框架大量使用这种技术。</li>
</ol>
<h2 id="Java-代理">Java 代理</h2>
<p>静态代理</p>
<p>JDK 动态代理 和 CGLIB 动态代理对比？</p>
<h2 id="Java-编译">Java 编译</h2>
<p>Java 编译器 <code>javac</code> 和 JIT（Just-In-Time）编译器</p>
<p><strong>核心摘要</strong></p>
<p>最根本的区别在于：<strong><code>javac</code> 是一个将 Java 源代码编译成字节码的 *静态编译器*，而 JIT 是 Java 虚拟机（JVM）内部的一个组件，它是一个在运行时将字节码编译成机器码的 *动态编译器*。</strong></p>
<p>它们不是非此即彼的选择，而是协同工作的两个阶段。</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left"><code>javac</code>（前端编译器）</th>
<th style="text-align:left">JIT（后端编译器，如 HotSpot 的 C1/C2）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>编译时机</strong></td>
<td style="text-align:left"><strong>编译时</strong>（开发期间）</td>
<td style="text-align:left"><strong>运行时</strong>（程序运行期间）</td>
</tr>
<tr>
<td style="text-align:left"><strong>输入</strong></td>
<td style="text-align:left"><code>.java</code> 源代码文件</td>
<td style="text-align:left"><code>.class</code> 字节码文件</td>
</tr>
<tr>
<td style="text-align:left"><strong>输出</strong></td>
<td style="text-align:left"><code>.class</code> 字节码文件（中间代码）</td>
<td style="text-align:left"><strong>本地机器码</strong>（Native Machine Code）</td>
</tr>
<tr>
<td style="text-align:left"><strong>编译次数</strong></td>
<td style="text-align:left">一次编译，多次运行</td>
<td style="text-align:left"><strong>多次编译</strong>（对热点代码进行反复优化编译）</td>
</tr>
<tr>
<td style="text-align:left"><strong>目标平台</strong></td>
<td style="text-align:left">平台无关的字节码（一次编译，到处运行）</td>
<td style="text-align:left"><strong>平台相关</strong>的机器码（依赖特定的 CPU 和操作系统）</td>
</tr>
<tr>
<td style="text-align:left"><strong>优化类型</strong></td>
<td style="text-align:left">基本优化（语法检查、常量折叠等）</td>
<td style="text-align:left"><strong>深度优化</strong>（基于运行时信息的激进优化，如内联、逃逸分析、锁消除等）</td>
</tr>
<tr>
<td style="text-align:left"><strong>角色</strong></td>
<td style="text-align:left"><strong>翻译官</strong>：将人类可读的代码翻译成 JVM 可读的字节码</td>
<td style="text-align:left"><strong>性能引擎</strong>：在运行时将字节码翻译成机器码，并持续优化性能</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>详细解释</strong></p>
<p><strong><code>javac</code> - 静态编译器</strong></p>
<ul>
<li><strong>作用</strong>：<code>javac</code> 是 JDK 中自带的前端编译器。它的任务非常明确：检查 Java 源代码的语法、语义是否正确，然后将其编译成一种中间形式——<strong>字节码</strong>。</li>
<li><strong>输出（字节码）</strong>：字节码不是任何真实 CPU 的指令集，它是为 JVM 量身定做的虚拟指令。这种设计是实现 Java “<strong>一次编写，到处运行</strong>”（Write Once, Run Anywhere - WORA）理念的基石。字节码文件（.class）可以在任何安装了对应版本 JVM 的操作系统上运行。</li>
<li><strong>优化</strong>：<code>javac</code> 所做的优化非常有限，主要是一些编译期就能确定的操作，例如将 <code>static final</code> 常量直接替换成字面量、语法糖（如泛型擦除、自动拆装箱）的处理等。它不会进行任何基于程序运行行为的优化。</li>
</ul>
<p><strong>过程</strong>： <code>YourSource.java</code> --(<code>javac</code>)–&gt; <code>YourSource.class</code> (字节码)</p>
<p><strong>JIT (Just-In-Time) - 动态编译器</strong></p>
<ul>
<li><strong>作用</strong>：JIT 编译器是 JVM 执行引擎的核心部分。当 JVM 加载并运行一个 Java 程序时，它最初会使用<strong>解释器</strong>（Interpreter）来逐条读取字节码并翻译成机器码执行。解释执行的速度相对较慢。</li>
<li><strong>工作原理</strong>：
<ol>
<li><strong>解释执行</strong>：程序开始运行时，所有代码首先被解释执行。</li>
<li><strong>热点探测</strong>：JVM 会持续监控方法的调用次数和循环体的循环次数等指标。那些被频繁执行的代码（称为“<strong>热点代码</strong>” - Hot Spot）会被识别出来。</li>
<li><strong>即时编译</strong>：JIT 编译器会将这些热点代码<strong>动态编译</strong>成与当前本地硬件平台相关的、高度优化的<strong>机器码</strong>。</li>
<li><strong>缓存与执行</strong>：编译好的机器码会被缓存起来。下次再执行到这段代码时，JVM 会直接调用缓存中的机器码，而不是再次解释执行，从而极大地提升程序的运行效率。</li>
</ol>
</li>
<li><strong>分层编译</strong>：现代 JVM（如 HotSpot）通常采用分层编译策略来平衡启动速度和峰值性能：
<ul>
<li><strong>C1 编译器（客户端编译器）</strong>：编译速度快，但优化程度较低。适用于对启动速度敏感的应用（如桌面GUI程序）。</li>
<li><strong>C2 编译器（服务器编译器）</strong>：编译速度慢，但会进行大量激进优化，生成代码质量极高。适用于对峰值性能要求高的长期运行的服务端应用。</li>
<li><strong>分层编译（Tiered Compilation）</strong>：JDK 7 及以后版本的默认策略。代码可能先被 C1 编译，如果之后发现它非常“热”，再被 C2 重新编译进行深度优化。</li>
</ul>
</li>
</ul>
<br>
<h2 id="Java-锁">Java 锁</h2>
<p><strong>乐观锁</strong></p>
<p>乐观锁是一种并发控制的思想，它总是假设最好的情况，即认为共享资源在被访问时不会出现并发冲突。 因此，它不会在操作前对资源加锁，而是在数据提交更新时才进行冲突检测。如果检测到冲突（即数据在当前线程读取后被其他线程修改过），则操作失败并通常会进行重试。</p>
<p><strong>实现方式：</strong><br>
乐观锁主要通过两种方式实现：</p>
<ul>
<li><strong>CAS (Compare-and-Swap) 算法</strong>：CAS 是一种硬件级别的原子操作，它包含三个操作数——内存位置（V）、预期原值（A）和新值（B）。 当且仅当内存位置 V 的值与预期原值 A 相同时，处理器才会原子性地将该位置的值更新为新值 B。Java 中的 <code>java.util.concurrent.atomic</code> 包下的原子类（如 <code>AtomicInteger</code>）就是基于 CAS 实现的。</li>
<li><strong>版本号机制</strong>：在数据表中增加一个版本号字段。每次读取数据时，将版本号一同读出。当更新数据时，会比较当前数据库中的版本号与之前读取到的版本号是否一致。如果一致，则执行更新并将版本号加一；如果不一致，则表示数据已被其他线程修改，本次更新失败。</li>
</ul>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点</strong>：在并发冲突不激烈（读多写少）的场景下，由于避免了加锁和线程阻塞所带来的性能开销，乐观锁可以提供比悲观锁更好的性能。</li>
<li><strong>缺点</strong>：在写操作频繁、冲突激烈的场景下，会导致大量的失败和重试，反而会降低性能，并可能导致 CPU 使用率飙升。 此外，CAS 机制存在“ABA问题”，即一个值从 A 变成 B 又变回 A，CAS 检查时会误认为它没有被修改过。</li>
</ul>
<p><strong>悲观锁</strong></p>
<p>与乐观锁相反，悲观锁总是假设最坏的情况，认为共享资源在每次被访问时都会发生冲突。 因此，它会在线程访问共享资源之前先获取锁，以确保在同一时刻只有一个线程能够操作该资源。当一个线程持有锁时，其他任何试图访问该资源的线程都将被阻塞，直到锁被释放。</p>
<p><strong>实现方式：</strong><br>
Java 中典型的悲观锁实现包括：</p>
<ul>
<li><strong><code>synchronized</code> 关键字</strong>：这是 Java 中最基本的互斥同步手段，它可以修饰方法或代码块，确保被修饰的部分在同一时间只能被一个线程执行。</li>
<li><strong><code>ReentrantLock</code></strong>：<code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包下的一个类，它提供了比 <code>synchronized</code> 更强大和灵活的锁机制。</li>
</ul>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点</strong>：悲观锁的实现简单，并且在写操作频繁、并发冲突激烈的场景下，其性能开销是固定的，能够有效避免因频繁重试带来的性能问题。</li>
<li><strong>缺点</strong>：在高并发场景下，激烈的锁竞争会导致线程频繁阻塞和唤醒，这涉及到上下文切换，会带来显著的性能开销。此外，如果使用不当，还可能引发死锁问题。</li>
</ul>
<p><strong>ReentrantLock 实现</strong></p>
<p><code>ReentrantLock</code> 是一个可重入的互斥锁，功能上与 <code>synchronized</code> 相似，但提供了更高的灵活性。 &quot;可重入&quot;意味着已经持有该锁的线程可以再次成功获取该锁而不会被阻塞。 <code>ReentrantLock</code> 的实现核心依赖于 <strong>AQS (AbstractQueuedSynchronizer)</strong> 框架。</p>
<p><code>ReentrantLock</code> 内部有两个关键的内部类：<code>FairSync</code>（公平锁）和 <code>NonfairSync</code>（非公平锁），它们都继承自 <code>Sync</code>，而 <code>Sync</code> 又继承自 AQS。</p>
<ul>
<li><strong>公平锁 (FairSync)</strong>：遵循先到先得的原则。等待时间最长的线程将优先获得锁。这种方式可以避免线程饥饿，但由于需要维护队列顺序，吞吐量通常低于非公平锁。</li>
<li><strong>非公平锁 (NonfairSync)</strong>：允许新请求锁的线程“插队”，即直接尝试获取锁，而不管等待队列中是否有其他线程。如果获取成功，则无需进入队列等待。这种方式可能导致某些线程长时间无法获取锁（饥饿），但能减少线程挂起和恢复的次数，因此拥有更高的吞吐量。<code>ReentrantLock</code> 默认使用非公平锁。</li>
</ul>
<p><code>ReentrantLock</code> 的加锁（<code>lock()</code>）和解锁（<code>unlock()</code>）操作，本质上是调用内部 <code>Sync</code> 对象的 <code>acquire()</code> 和 <code>release()</code> 方法，这两个方法则会调用 AQS 提供的模板方法。</p>
<p><strong>AQS (AbstractQueuedSynchronizer)</strong></p>
<p>AQS（抽象队列同步器）是 Java 并发包中构建锁和同步器的核心框架。 它是一个抽象类，为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（如信号量、事件等）提供了一个通用框架。 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等都是基于 AQS 实现的。</p>
<p>AQS 的核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态。如果资源被占用，那么 AQS 会通过一套线程阻塞等待以及被唤醒时锁分配的机制来管理这些线程。</p>
<p>其内部主要维护了两个核心部分：</p>
<ol>
<li><strong>state (同步状态)</strong>：一个 <code>volatile</code> 的 <code>int</code> 变量，用于表示同步状态。例如，在 <code>ReentrantLock</code> 中，<code>state</code> 表示锁的持有次数（用于实现可重入）或表示锁是否被占用。AQS 提供了 <code>getState()</code>、<code>setState()</code> 和 <code>compareAndSetState()</code> 这三个原子操作来安全地读写 <code>state</code> 值。</li>
<li><strong>CLH 锁队列的变体</strong>：一个基于双向链表实现的 FIFO 队列，用于存放等待获取锁的线程。 当一个线程尝试获取锁失败后，会被封装成一个节点（<code>Node</code>）加入到这个队列的尾部，并进入阻塞状态。当持有锁的线程释放锁时，会唤醒队列头部的节点，使其再次尝试获取锁。</li>
</ol>
<p>AQS 定义了两种资源共享方式：</p>
<ul>
<li><strong>独占式 (Exclusive)</strong>：只有一个线程能执行，如 <code>ReentrantLock</code>。</li>
<li><strong>共享式 (Shared)</strong>：多个线程可同时执行，如 <code>Semaphore</code> 和 <code>CountDownLatch</code>。</li>
</ul>
<p>通过继承 AQS 并重写其指定的模板方法（如 <code>tryAcquire</code>、<code>tryRelease</code>、<code>tryAcquireShared</code>、<code>tryReleaseShared</code>），开发者可以相对轻松地构建出自定义的同步器，而无需关心线程排队、阻塞和唤醒等底层细节。</p>
<h2 id="Java-容器">Java 容器</h2>
<p>hashmap put get 负载因子</p>
<p>put时间复杂度</p>
<p>hashmap实现</p>
<p>链表 to 红黑树</p>
<p>红黑树</p>
<p>hashmap &amp; concurrenthashmap</p>
<p>分段锁  CAS + synchronized</p>
<p>头插入 &amp; 尾插入</p>
<p><strong>头插法改为尾插法的主要目的是解决多线程扩容时的死循环问题</strong></p>
<h2 id="Mysql-查询">Mysql 查询</h2>
<p>慢查询分析</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">优化目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>type</strong></td>
<td style="text-align:left">访问类型</td>
<td style="text-align:left">最好达到 <code>const</code>/<code>eq_ref</code>&gt; <code>ref</code>&gt; <code>range</code>&gt; <code>index</code>&gt; <code>ALL</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>possible_keys</strong></td>
<td style="text-align:left">可能使用的索引</td>
<td style="text-align:left">列出可供选择的索引</td>
</tr>
<tr>
<td style="text-align:left"><strong>key</strong></td>
<td style="text-align:left">实际使用的索引</td>
<td style="text-align:left">确保使用了合适的索引</td>
</tr>
<tr>
<td style="text-align:left"><strong>rows</strong></td>
<td style="text-align:left">预估扫描行数</td>
<td style="text-align:left">值越小越好</td>
</tr>
<tr>
<td style="text-align:left"><strong>Extra</strong></td>
<td style="text-align:left">额外信息</td>
<td style="text-align:left">避免出现 <code>Using filesort</code>、<code>Using temporary</code></td>
</tr>
</tbody>
</table>
<p><code>type</code> <strong>字段的常见值（性能从优到劣）：</strong></p>
<ul>
<li><code>const</code>：通过主键或唯一索引一次就找到。</li>
<li><code>eq_ref</code>：联表查询时，使用主键或唯一索引关联。</li>
<li><code>ref</code>：使用普通索引查询。</li>
<li><code>range</code>：使用索引进行范围查询。</li>
<li><code>index</code>：全索引扫描。</li>
<li><code>ALL</code>：全表扫描（<strong>需要避免</strong>）。</li>
</ul>
<p><code>Extra</code> <strong>字段的危险信号：</strong></p>
<ul>
<li><code>Using filesort</code>：需要额外的排序操作（考虑为 <code>ORDER BY</code> 字段加索引）。</li>
<li><code>Using temporary</code>：需要创建临时表（常见于 <code>GROUP BY</code>、<code>ORDER BY</code> 子句）。</li>
<li><code>Using join buffer</code>：联表查询时无法使用索引，需要连接缓冲区。</li>
</ul>
<br>
<p><strong>常见优化手段与实战举例</strong></p>
<p><strong>索引优化（最有效的手段）</strong></p>
<p>(1) 避免索引失效</p>
<p><strong>失效场景举例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构: CREATE TABLE users (id INT, name VARCHAR(10), age INT, INDEX idx_name_age (name, age));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 最左前缀原则：复合索引必须先使用左边的列</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>; <span class="comment">-- ❌ 无法使用 idx_name_age 索引</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">-- ✅ 可以使用索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 对索引列进行计算或函数操作</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(create_time) <span class="operator">=</span> <span class="number">2023</span>; <span class="comment">-- ❌ 索引失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> create_time <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span>; <span class="comment">-- ✅</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 使用 LIKE 以通配符开头</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%lice%&#x27;</span>; <span class="comment">-- ❌ 全表扫描</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;Alice%&#x27;</span>; <span class="comment">-- ✅ 索引范围扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 字符串索引未使用引号（发生类型转换）</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="number">123</span>; <span class="comment">-- ❌ 类型转换，索引失效</span></span><br></pre></td></tr></table></figure>
<p>(2) 建立合适的索引</p>
<ul>
<li><strong>为</strong> <code>WHERE</code><strong>、</strong><code>ORDER BY</code><strong>、</strong><code>GROUP BY</code><strong>、</strong><code>JOIN ON</code> <strong>子句中的字段建立索引</strong>。</li>
<li><strong>使用覆盖索引</strong>：索引包含所有查询字段，避免回表。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设有索引 idx_name_age (name, age)</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">-- ✅ 覆盖索引，性能极佳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">-- ❌ 需要回表查询其他字段</span></span><br></pre></td></tr></table></figure>
<p><strong>SQL语句优化</strong></p>
<p>(1) 避免 <code>SELECT *</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ❌ 不推荐</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 推荐：只取需要的字段</span></span><br><span class="line"><span class="keyword">SELECT</span> order_id, amount, status <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>(2) 优化分页查询（大偏移量问题）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ❌ 糟糕的分页（偏移量越大越慢）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 优化方案1：使用子查询或游标（记录上次查询的最大ID）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 优化方案2：使用覆盖索引先定位ID，再回表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">20</span>) <span class="keyword">AS</span> tmp </span><br><span class="line"><span class="keyword">ON</span> products.id <span class="operator">=</span> tmp.id;</span><br></pre></td></tr></table></figure>
<p>(3) 优化 <code>OR</code> 条件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ❌ OR 条件可能导致索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 优化为 UNION ALL（确保两个查询都能用索引）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><strong>表结构设计优化</strong></p>
<p>(1) 选择合适的数据类型</p>
<ul>
<li>用 <code>INT</code> 而非 <code>VARCHAR</code> 存储数字。</li>
<li>用 <code>DATETIME</code> 而非 <code>VARCHAR</code> 存储时间。</li>
<li>避免使用 <code>TEXT</code>/<code>BLOB</code> 作为常用查询条件。</li>
</ul>
<p>(2) 范式与反范式的权衡</p>
<ul>
<li><strong>范式化</strong>：减少数据冗余，但需要多表关联。</li>
<li><strong>反范式化</strong>：适当冗余数据，避免复杂关联，以空间换时间。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 反范式化举例：在订单表冗余用户姓名</span></span><br><span class="line"><span class="comment">-- orders 表结构: order_id, user_id, user_name, amount...</span></span><br><span class="line"><span class="keyword">SELECT</span> order_id, user_name, amount <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span>; <span class="comment">-- 无需关联用户表</span></span><br></pre></td></tr></table></figure>
<p><strong>数据库架构优化</strong></p>
<p>(1) 读写分离</p>
<ul>
<li>主库负责写操作，多个从库负责读操作。</li>
<li>通过程序或中间件（如MyCat、ShardingSphere）实现流量分发。</li>
</ul>
<p>(2) 分库分表</p>
<ul>
<li><strong>水平分表</strong>：按某个字段（如用户ID）将数据分散到多个表。</li>
<li><strong>垂直分表</strong>：将不常用的大字段拆分到扩展表。</li>
</ul>
<br>
<h2 id="Mysql-单表量级">Mysql 单表量级</h2>
<p>MySQL InnoDB 引擎使用 <strong>B+树</strong> 结构来存储索引和数据（对于聚簇索引，叶子节点直接包含行数据）。</p>
<p><strong>B+树的基础概念</strong></p>
<ul>
<li><strong>扇出（Fan-out）</strong>：一个节点能拥有的子节点数量。</li>
<li><strong>深度（Depth）</strong>：从根节点到叶子节点需要经过的层级数。</li>
</ul>
<p>B+树的查询效率取决于它的深度。每深入一层，就需要多一次磁盘I/O（如果该层节点不在内存中）。</p>
<p><strong>千万级数据如何影响B+树深度？</strong></p>
<p>我们来做一个简单的计算：</p>
<ul>
<li>
<p><strong>假设条件</strong>：</p>
</li>
<li>
<ul>
<li>页大小（Page Size）：16KB（MySQL默认）。</li>
<li>主键字段类型：<code>BIGINT</code>（8字节）。</li>
<li>每个索引条目（指针）额外占用约 6 字节。</li>
<li>因此，<strong>一个非叶子节点大约可以存储</strong> <code>16KB / (8B + 6B) ≈ 1170</code> <strong>个键值和指针</strong>。</li>
<li><strong>一个叶子节点</strong>：假设一行数据大小为 <strong>1KB</strong>，那么一个叶子节点大约可以存储 <code>16KB / 1KB = 16</code> 行数据。</li>
</ul>
</li>
<li>
<p><strong>计算不同深度B+树能存储的最大行数</strong>：</p>
</li>
<li>
<ul>
<li><strong>深度 = 2</strong>： <code>1170（根节点指针） * 16（每个叶子节点的行数） ≈ 18,720</code> 行。</li>
<li><strong>深度 = 3</strong>： <code>1170 * 1170 * 16 ≈ 21,902,400</code> 行（约 <strong>2200万</strong>）。</li>
<li><strong>深度 = 4</strong>： <code>1170 * 1170 * 1170 * 16 ≈ 25,621,000,000</code> 行（约 <strong>256亿</strong>）。</li>
</ul>
</li>
<li>
<p><strong>结论</strong>：</p>
</li>
<li>
<ul>
<li>当数据量在 <strong>千万级以下</strong> 时，B+树深度通常为 **2~**<strong>3层</strong>。这意味着通过主键查询最多只需要 **2~**<strong>3次磁盘I/O</strong>，速度极快。</li>
<li>当数据量增长到 <strong>千万级以上</strong>（如超过2200万），B+树深度很可能从 <strong>3层变为4层</strong>。</li>
</ul>
</li>
<li>
<ol start="3">
<li>深度增加的后果</li>
</ol>
</li>
<li>
<p><strong>每次查询需要多一次磁盘I/O</strong>。对于主键查询，从 <strong>3次I/O</strong> 变为 <strong>4次I/O</strong>，性能损耗可能达到 <strong>30%</strong>。</p>
</li>
<li>
<p>更重要的是，对于<strong>范围查询</strong>、<strong>全表扫描</strong>（即使只是统计行数<code>COUNT(*)</code>）和<strong>复杂的联合查询</strong>，需要遍历的叶子节点数量从“千万级”变成了“亿级”，性能下降是指数级的，从毫秒级可能直接恶化到秒级甚至分钟级。</p>
</li>
</ul>
<br>
<h2 id="Mysql-事务隔离级别">Mysql 事务隔离级别</h2>
<p>MySQL支持四种标准的事务隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>READ UNCOMMITTED</strong> (读未提交)</td>
<td>✅ 可能</td>
<td>✅ 可能</td>
<td>✅ 可能</td>
<td>性能最高，一致性最差</td>
</tr>
<tr>
<td><strong>READ COMMITTED</strong> (读已提交)</td>
<td>❌ 不可能</td>
<td>✅ 可能</td>
<td>✅ 可能</td>
<td>Oracle默认级别</td>
</tr>
<tr>
<td><strong>REPEATABLE READ</strong> (可重复读)</td>
<td>❌ 不可能</td>
<td>❌ 不可能</td>
<td>✅ 可能</td>
<td>MySQL默认级别</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong> (串行化)</td>
<td>❌ 不可能</td>
<td>❌ 不可能</td>
<td>❌ 不可能</td>
<td>性能最低，一致性最强</td>
</tr>
</tbody>
</table>
<p><strong>什么是幻读？</strong></p>
<p><strong>幻读</strong>是指在一个事务内，连续执行两次相同的查询，第二次查询看到了第一次查询没有看到的行，这些&quot;幻影行&quot;通常是由其他事务插入的新数据。</p>
<p>与不可重复读的区别：</p>
<ul>
<li>不可重复读：针对<strong>已存在行</strong>的修改（UPDATE/DELETE）</li>
<li>幻读：针对<strong>新增行</strong>的插入（INSERT）</li>
</ul>
<p>三、幻读的典型场景</p>
<p><strong>场景示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 会话A</span><br><span class="line">START TRANSACTION;</span><br><span class="line">SELECT * FROM users WHERE age &gt; 20; </span><br><span class="line">-- 返回3条记录</span><br><span class="line"></span><br><span class="line">-- 会话B</span><br><span class="line">INSERT INTO users(name, age) VALUES(&#x27;新用户&#x27;, 25);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 会话A再次执行相同查询</span><br><span class="line">SELECT * FROM users WHERE age &gt; 20;</span><br><span class="line">-- 返回4条记录，出现了&quot;幻影行&quot;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p><strong>MySQL如何解决幻读？</strong></p>
<p>REPEATABLE READ级别下的幻读问题</p>
<p><strong>MySQL的InnoDB引擎在REPEATABLE READ级别下实际上通过MVCC+Next-Key Lock解决了大部分幻读问题</strong>，这与SQL标准有所不同。</p>
<p><strong>解决机制：</strong></p>
<ul>
<li><strong>MVCC (多版本并发控制)</strong>：通过创建数据快照保证读取一致性</li>
<li><strong>Next-Key Lock</strong>：结合记录锁(Record Lock)和间隙锁(Gap Lock)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 对全表加锁，因为name字段无索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(name) <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="comment">-- 被阻塞，因为会话A持有全表锁</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- age字段有索引</span></span><br><span class="line"><span class="comment">-- 会话A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 锁定age=25的记录及(20,25),(25,30)的间隙</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(age) <span class="keyword">VALUES</span>(<span class="number">22</span>); <span class="comment">-- 被阻塞(如果22在锁定间隙内)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(age) <span class="keyword">VALUES</span>(<span class="number">30</span>);  <span class="comment">-- 成功(不在锁定间隙内)</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/default/" rel="tag"># default</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/07/27/MQ-in-evolutionary/" rel="prev" title="MQ_in_evolutionary">
      <i class="fa fa-chevron-left"></i> MQ_in_evolutionary
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">Selected Q&amp;A</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="nav-text">Java 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%8F%8D%E5%B0%84"><span class="nav-text">Java 反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%BB%A3%E7%90%86"><span class="nav-text">Java 代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E7%BC%96%E8%AF%91"><span class="nav-text">Java 编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E9%94%81"><span class="nav-text">Java 锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%AE%B9%E5%99%A8"><span class="nav-text">Java 容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-%E6%9F%A5%E8%AF%A2"><span class="nav-text">Mysql 查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-%E5%8D%95%E8%A1%A8%E9%87%8F%E7%BA%A7"><span class="nav-text">Mysql 单表量级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">Mysql 事务隔离级别</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="marigo1d"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">marigo1d</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/marigo1d" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;marigo1d" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">marigo1d</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">542k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">16:26</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
